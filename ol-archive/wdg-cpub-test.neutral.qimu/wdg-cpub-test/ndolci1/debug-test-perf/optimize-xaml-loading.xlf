<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci1\debug-test-perf\optimize-xaml-loading.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3fa7c0e3360635282968078432798793de8da191</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Optimize your XAML markup</source>
          <target state="new">Optimize your XAML markup</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Parsing XAML markup to construct objects in memory is time-consuming for a complex UI.</source>
          <target state="new">Parsing XAML markup to construct objects in memory is time-consuming for a complex UI.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Here are some things you can do to improve XAML markup parse and load time and memory efficiency for your app.</source>
          <target state="new">Here are some things you can do to improve XAML markup parse and load time and memory efficiency for your app.</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Optimize your XAML markup</source>
          <target state="new">Optimize your XAML markup</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Parsing XAML markup to construct objects in memory is time-consuming for a complex UI.</source>
          <target state="new">Parsing XAML markup to construct objects in memory is time-consuming for a complex UI.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Here are some things you can do to improve XAML markup parse and load time and memory efficiency for your app.</source>
          <target state="new">Here are some things you can do to improve XAML markup parse and load time and memory efficiency for your app.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>At app startup, limit the XAML markup that is loaded to only what you need for your initial UI.</source>
          <target state="new">At app startup, limit the XAML markup that is loaded to only what you need for your initial UI.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Examine the markup in your initial page and confirm it contains nothing that it doesn't need.</source>
          <target state="new">Examine the markup in your initial page and confirm it contains nothing that it doesn't need.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If a page references a user control or a resource defined in a different file, then the framework parses that file, too.</source>
          <target state="new">If a page references a user control or a resource defined in a different file, then the framework parses that file, too.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In this example, because InitialPage.xaml uses one resource from ExampleResourceDictionary.xaml, the whole of ExampleResourceDictionary.xaml must be parsed at startup.</source>
          <target state="new">In this example, because InitialPage.xaml uses one resource from ExampleResourceDictionary.xaml, the whole of ExampleResourceDictionary.xaml must be parsed at startup.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>InitialPage.xaml.</source>
          <target state="new">InitialPage.xaml.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>ExampleResourceDictionary.xaml.</source>
          <target state="new">ExampleResourceDictionary.xaml.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If you use a resource on many pages throughout your app, then storing it in App.xaml is a good practice, and avoids duplication.</source>
          <target state="new">If you use a resource on many pages throughout your app, then storing it in App.xaml is a good practice, and avoids duplication.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>But App.xaml is parsed at app startup so any resource that is used in only one page (unless that page is the initial page) should be put into the page's local resources.</source>
          <target state="new">But App.xaml is parsed at app startup so any resource that is used in only one page (unless that page is the initial page) should be put into the page's local resources.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This counter-example shows App.xaml containing resources that are used by only one page (that's not the initial page).</source>
          <target state="new">This counter-example shows App.xaml containing resources that are used by only one page (that's not the initial page).</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This needlessly increases app startup time.</source>
          <target state="new">This needlessly increases app startup time.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>InitialPage.xaml.</source>
          <target state="new">InitialPage.xaml.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>SecondPage.xaml.</source>
          <target state="new">SecondPage.xaml.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>App.xaml</source>
          <target state="new">App.xaml</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The way to make the above counter-example more efficient is to move <ph id="ph1">`SecondPageTextBrush`</ph> into SecondPage.xaml and to move <ph id="ph2">`ThirdPageTextBrush`</ph> into ThirdPage.xaml.</source>
          <target state="new">The way to make the above counter-example more efficient is to move <ph id="ph1">`SecondPageTextBrush`</ph> into SecondPage.xaml and to move <ph id="ph2">`ThirdPageTextBrush`</ph> into ThirdPage.xaml.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>can remain in App.xaml because application resources must be parsed at app startup in any case.</source>
          <target state="new">can remain in App.xaml because application resources must be parsed at app startup in any case.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Minimize element count</source>
          <target state="new">Minimize element count</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Although the XAML platform is capable of displaying large numbers of elements, you can make your app lay out and render faster by using the fewest number of elements to achieve the visuals you want.</source>
          <target state="new">Although the XAML platform is capable of displaying large numbers of elements, you can make your app lay out and render faster by using the fewest number of elements to achieve the visuals you want.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Layout panels have a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Background<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR227512)</ept> property so there's no need to put a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Rectangle<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR243371)</ept> in front of a Panel just to color it.</source>
          <target state="new">Layout panels have a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Background<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR227512)</ept> property so there's no need to put a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Rectangle<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR243371)</ept> in front of a Panel just to color it.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Inefficient.</source>
          <target state="new">Inefficient.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Efficient.</source>
          <target state="new">Efficient.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you reuse the same vector-based element enough times, it becomes more efficient to use an <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Image<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242752)</ept> element instead.</source>
          <target state="new">If you reuse the same vector-based element enough times, it becomes more efficient to use an <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Image<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242752)</ept> element instead.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Vector-based elements can be more expensive because the CPU must create each individual element separately.</source>
          <target state="new">Vector-based elements can be more expensive because the CPU must create each individual element separately.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The image file needs to be decoded only once.</source>
          <target state="new">The image file needs to be decoded only once.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Consolidate multiple brushes that look the same into one resource</source>
          <target state="new">Consolidate multiple brushes that look the same into one resource</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The XAML platform tries to cache commonly-used objects so that they can be reused as often as possible.</source>
          <target state="new">The XAML platform tries to cache commonly-used objects so that they can be reused as often as possible.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>But XAML cannot easily tell if a brush declared in one piece of markup is the same as a brush declared in another.</source>
          <target state="new">But XAML cannot easily tell if a brush declared in one piece of markup is the same as a brush declared in another.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The example here uses <bpt id="p1">[</bpt><bpt id="p2">**</bpt>SolidColorBrush<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242962)</ept> to demonstrate, but the case is more likely and more important with <bpt id="p3">[</bpt><bpt id="p4">**</bpt>GradientBrush<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR210068)</ept>.</source>
          <target state="new">The example here uses <bpt id="p1">[</bpt><bpt id="p2">**</bpt>SolidColorBrush<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242962)</ept> to demonstrate, but the case is more likely and more important with <bpt id="p3">[</bpt><bpt id="p4">**</bpt>GradientBrush<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR210068)</ept>.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Inefficient.</source>
          <target state="new">Inefficient.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Also check for brushes that use predefined colors: <ph id="ph1">`"Orange"`</ph> and <ph id="ph2">`"#FFFFA500"`</ph> are the same color.</source>
          <target state="new">Also check for brushes that use predefined colors: <ph id="ph1">`"Orange"`</ph> and <ph id="ph2">`"#FFFFA500"`</ph> are the same color.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>To fix the duplication, define the brush as a resource.</source>
          <target state="new">To fix the duplication, define the brush as a resource.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If controls in other pages use the same brush, move it to App.xaml.</source>
          <target state="new">If controls in other pages use the same brush, move it to App.xaml.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Efficient.</source>
          <target state="new">Efficient.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Minimize overdrawing</source>
          <target state="new">Minimize overdrawing</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Overdrawing is where more than one object is drawn in the same screen pixels.</source>
          <target state="new">Overdrawing is where more than one object is drawn in the same screen pixels.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Note that there is sometimes a trade-off between this guidance and the desire to minimize element count.</source>
          <target state="new">Note that there is sometimes a trade-off between this guidance and the desire to minimize element count.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If an element isn't visible because it's transparent or hidden behind other elements, and it's not contributing to layout, then delete it.</source>
          <target state="new">If an element isn't visible because it's transparent or hidden behind other elements, and it's not contributing to layout, then delete it.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>If the element is not visible in the initial visual state but it is visible in other visual states then set <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Visibility<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR208992)</ept> to <bpt id="p3">**</bpt>Collapsed<ept id="p3">**</ept> on the element itself and change the value to <bpt id="p4">**</bpt>Visible<ept id="p4">**</ept> in the appropriate states.</source>
          <target state="new">If the element is not visible in the initial visual state but it is visible in other visual states then set <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Visibility<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR208992)</ept> to <bpt id="p3">**</bpt>Collapsed<ept id="p3">**</ept> on the element itself and change the value to <bpt id="p4">**</bpt>Visible<ept id="p4">**</ept> in the appropriate states.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>There will be exceptions to this heuristic: in general, the value a property has in the major of visual states is best set locally on the element.</source>
          <target state="new">There will be exceptions to this heuristic: in general, the value a property has in the major of visual states is best set locally on the element.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Use a composite element instead of layering multiple elements to create an effect.</source>
          <target state="new">Use a composite element instead of layering multiple elements to create an effect.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>In this example, the result is a two-toned shape where the top half is black (from the background of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Grid<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept>) and the bottom half is gray (from the semi-transparent white <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Rectangle<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR243371)</ept> alpha-blended over the black background of the <bpt id="p5">**</bpt>Grid<ept id="p5">**</ept>).</source>
          <target state="new">In this example, the result is a two-toned shape where the top half is black (from the background of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Grid<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept>) and the bottom half is gray (from the semi-transparent white <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Rectangle<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR243371)</ept> alpha-blended over the black background of the <bpt id="p5">**</bpt>Grid<ept id="p5">**</ept>).</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Here, 150% of the pixels necessary to achieve the result are being filled.</source>
          <target state="new">Here, 150% of the pixels necessary to achieve the result are being filled.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Inefficient.</source>
          <target state="new">Inefficient.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Efficient.</source>
          <target state="new">Efficient.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>A layout panel can have two purposes: to color an area, and to lay out child elements.</source>
          <target state="new">A layout panel can have two purposes: to color an area, and to lay out child elements.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If an element further back in z-order is already coloring an area then a layout panel in front does not need to paint that area: instead it can just focus on laying out its children.</source>
          <target state="new">If an element further back in z-order is already coloring an area then a layout panel in front does not need to paint that area: instead it can just focus on laying out its children.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Here's an example.</source>
          <target state="new">Here's an example.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Inefficient.</source>
          <target state="new">Inefficient.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Efficient.</source>
          <target state="new">Efficient.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Grid<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept> has to be hit-testable then set a background value of transparent on it.</source>
          <target state="new">If the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Grid<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept> has to be hit-testable then set a background value of transparent on it.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Use a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Border<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR209253)</ept> element to draw a border around an object.</source>
          <target state="new">Use a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Border<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR209253)</ept> element to draw a border around an object.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In this example, a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Grid<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept> is used as a makeshift border around a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>TextBox<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR209683)</ept>.</source>
          <target state="new">In this example, a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Grid<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept> is used as a makeshift border around a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>TextBox<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR209683)</ept>.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>But all the pixels in the center cell are overdrawn.</source>
          <target state="new">But all the pixels in the center cell are overdrawn.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Inefficient.</source>
          <target state="new">Inefficient.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Efficient.</source>
          <target state="new">Efficient.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Be aware of margins.</source>
          <target state="new">Be aware of margins.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Two neighboring elements will overlap (possibly accidentally) if negative margins extend into another’s render bounds and cause overdrawing.</source>
          <target state="new">Two neighboring elements will overlap (possibly accidentally) if negative margins extend into another’s render bounds and cause overdrawing.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DebugSettings.IsOverdrawHeatMapEnabled<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/Hh701823)</ept> as a visual diagnostic.</source>
          <target state="new">Use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DebugSettings.IsOverdrawHeatMapEnabled<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/Hh701823)</ept> as a visual diagnostic.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>You may find objects being drawn that you weren't aware were in the scene.</source>
          <target state="new">You may find objects being drawn that you weren't aware were in the scene.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Cache static content</source>
          <target state="new">Cache static content</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Another source of overdrawing is a shape made from many overlapping elements.</source>
          <target state="new">Another source of overdrawing is a shape made from many overlapping elements.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>If you set <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CacheMode<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR228084)</ept> to <bpt id="p3">**</bpt>BitmapCache<ept id="p3">**</ept> on the <bpt id="p4">[</bpt><bpt id="p5">**</bpt>UIElement<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/BR208911)</ept> that contains the composite shape then the platform renders the element to a bitmap once and then uses that bitmap each frame instead of overdrawing.</source>
          <target state="new">If you set <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CacheMode<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR228084)</ept> to <bpt id="p3">**</bpt>BitmapCache<ept id="p3">**</ept> on the <bpt id="p4">[</bpt><bpt id="p5">**</bpt>UIElement<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/BR208911)</ept> that contains the composite shape then the platform renders the element to a bitmap once and then uses that bitmap each frame instead of overdrawing.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Inefficient.</source>
          <target state="new">Inefficient.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Venn diagram with three solid circles</source>
          <target state="new">Venn diagram with three solid circles</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The image above is the result, but here's a map of the overdrawn regions.</source>
          <target state="new">The image above is the result, but here's a map of the overdrawn regions.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Darker red indicates higher amounts of overdraw.</source>
          <target state="new">Darker red indicates higher amounts of overdraw.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Venn diagram that shows overlapping areas</source>
          <target state="new">Venn diagram that shows overlapping areas</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Efficient.</source>
          <target state="new">Efficient.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Note the use of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CacheMode<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR228084)</ept>.</source>
          <target state="new">Note the use of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CacheMode<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR228084)</ept>.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Don't use this technique if any of the sub-shapes animate because the bitmap cache will likely need to be regenerated every frame, defeating the purpose.</source>
          <target state="new">Don't use this technique if any of the sub-shapes animate because the bitmap cache will likely need to be regenerated every frame, defeating the purpose.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>ResourceDictionaries</source>
          <target state="new">ResourceDictionaries</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>ResourceDictionaries are generally used to store your resources at a somewhat global level.</source>
          <target state="new">ResourceDictionaries are generally used to store your resources at a somewhat global level.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Resources that your app wants to reference in multiple places.</source>
          <target state="new">Resources that your app wants to reference in multiple places.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For example, styles, brushes, templates, and so on.</source>
          <target state="new">For example, styles, brushes, templates, and so on.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>In general, we have optimized ResourceDictionaries to not instantiate resources unless they're asked for.</source>
          <target state="new">In general, we have optimized ResourceDictionaries to not instantiate resources unless they're asked for.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>But there are few places where you need to be a little careful.</source>
          <target state="new">But there are few places where you need to be a little careful.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Resource with x:Name<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Resource with x:Name<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Any resource with x:Name will not benefit from the platform optimization, but instead it will be instantiated as soon as the ResourceDictionary is created.</source>
          <target state="new">Any resource with x:Name will not benefit from the platform optimization, but instead it will be instantiated as soon as the ResourceDictionary is created.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>This happens because x:Name tells the platform that your app needs field access to this resource, so the platform needs to create something to create a reference to.</source>
          <target state="new">This happens because x:Name tells the platform that your app needs field access to this resource, so the platform needs to create something to create a reference to.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ResourceDictionaries in a UserControl<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>ResourceDictionaries in a UserControl<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>ResourceDictionaries defined inside of a UserControl carry a penalty.</source>
          <target state="new">ResourceDictionaries defined inside of a UserControl carry a penalty.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The platform will create a copy of such a ResourceDictionary for every instance of the UserControl.</source>
          <target state="new">The platform will create a copy of such a ResourceDictionary for every instance of the UserControl.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>If you have a UserControl that is used a lot, then move the ResourceDictionary out of the UserControl and put it the page level.</source>
          <target state="new">If you have a UserControl that is used a lot, then move the ResourceDictionary out of the UserControl and put it the page level.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Use XBF2</source>
          <target state="new">Use XBF2</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>XBF2 is a binary representation of XAML markup that avoids all text-parsing costs at runtime.</source>
          <target state="new">XBF2 is a binary representation of XAML markup that avoids all text-parsing costs at runtime.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>It also optimizes your binary for load and tree creation, and allows "fast-path" for XAML types to improve heap and object creation costs, for example VSM, ResourceDictionary, Styles, and so on.</source>
          <target state="new">It also optimizes your binary for load and tree creation, and allows "fast-path" for XAML types to improve heap and object creation costs, for example VSM, ResourceDictionary, Styles, and so on.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It is completely memory-mapped so there is no heap footprint for loading and reading a XAML Page.</source>
          <target state="new">It is completely memory-mapped so there is no heap footprint for loading and reading a XAML Page.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>In addition, it reduces the disk footprint of stored XAML pages in an appx.</source>
          <target state="new">In addition, it reduces the disk footprint of stored XAML pages in an appx.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>XBF2 is a more compact representation and it can reduce disk footprint of comparative XAML/XBF1 files by up to 50%.</source>
          <target state="new">XBF2 is a more compact representation and it can reduce disk footprint of comparative XAML/XBF1 files by up to 50%.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>For example, the built-in Photos app saw around a 60% reduction after conversion to XBF2 dropping from around ~1mb of XBF1 assets to ~400kb of XBF2 assets.</source>
          <target state="new">For example, the built-in Photos app saw around a 60% reduction after conversion to XBF2 dropping from around ~1mb of XBF1 assets to ~400kb of XBF2 assets.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>We have also seen apps benefit anywhere from 15 to 20% in CPU and 10 to 15% in Win32 heap.</source>
          <target state="new">We have also seen apps benefit anywhere from 15 to 20% in CPU and 10 to 15% in Win32 heap.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>XAML built-in controls and dictionaries that the framework provides are already fully XBF2-enabled.</source>
          <target state="new">XAML built-in controls and dictionaries that the framework provides are already fully XBF2-enabled.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>For your own app, ensure that your project file declares TargetPlatformVersion 8.2 or later.</source>
          <target state="new">For your own app, ensure that your project file declares TargetPlatformVersion 8.2 or later.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>To check whether you have XBF2, open your app in a binary editor; the 12th and 13th bytes are 00 02 if you have XBF2.</source>
          <target state="new">To check whether you have XBF2, open your app in a binary editor; the 12th and 13th bytes are 00 02 if you have XBF2.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>