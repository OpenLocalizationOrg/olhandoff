<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\applying-textures-to-primitives.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">665b61816d3e69dac7341852f156e1f42b0a5e99</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Apply textures to primitives</source>
          <target state="new">Apply textures to primitives</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Here, we load raw texture data and apply that data to a 3D primitive by using the cube that we created in Using depth and effects on primitives.</source>
          <target state="new">Here, we load raw texture data and apply that data to a 3D primitive by using the cube that we created in Using depth and effects on primitives.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Apply textures to primitives</source>
          <target state="new">Apply textures to primitives</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Here, we load raw texture data and apply that data to a 3D primitive by using the cube that we created in <bpt id="p1">[</bpt>Using depth and effects on primitives<ept id="p1">](using-depth-and-effects-on-primitives.md)</ept>.</source>
          <target state="new">Here, we load raw texture data and apply that data to a 3D primitive by using the cube that we created in <bpt id="p1">[</bpt>Using depth and effects on primitives<ept id="p1">](using-depth-and-effects-on-primitives.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>We also introduce a simple dot-product lighting model, where the cube surfaces are lighter or darker based on their distance and angle relative to a light source.</source>
          <target state="new">We also introduce a simple dot-product lighting model, where the cube surfaces are lighter or darker based on their distance and angle relative to a light source.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Objective:<ept id="p1">**</ept> To apply textures to primitives.</source>
          <target state="new"><bpt id="p1">**</bpt>Objective:<ept id="p1">**</ept> To apply textures to primitives.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="new">Prerequisites</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>We assume that you are familiar with C++.</source>
          <target state="new">We assume that you are familiar with C++.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You also need basic experience with graphics programming concepts.</source>
          <target state="new">You also need basic experience with graphics programming concepts.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>We also assume that you went through <bpt id="p1">[</bpt>Quickstart: setting up DirectX resources and displaying an image<ept id="p1">](setting-up-directx-resources.md)</ept>, <bpt id="p2">[</bpt>Creating shaders and drawing primitives<ept id="p2">](creating-shaders-and-drawing-primitives.md)</ept>, and <bpt id="p3">[</bpt>Using depth and effects on primitives<ept id="p3">](using-depth-and-effects-on-primitives.md)</ept>.</source>
          <target state="new">We also assume that you went through <bpt id="p1">[</bpt>Quickstart: setting up DirectX resources and displaying an image<ept id="p1">](setting-up-directx-resources.md)</ept>, <bpt id="p2">[</bpt>Creating shaders and drawing primitives<ept id="p2">](creating-shaders-and-drawing-primitives.md)</ept>, and <bpt id="p3">[</bpt>Using depth and effects on primitives<ept id="p3">](using-depth-and-effects-on-primitives.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Time to complete:<ept id="p1">**</ept> 20 minutes.</source>
          <target state="new"><bpt id="p1">**</bpt>Time to complete:<ept id="p1">**</ept> 20 minutes.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="new">Instructions</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>1. Defining variables for a textured cube</source>
          <target state="new">1. Defining variables for a textured cube</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>First, we need to define the <bpt id="p1">**</bpt>BasicVertex<ept id="p1">**</ept> and <bpt id="p2">**</bpt>ConstantBuffer<ept id="p2">**</ept> structures for the textured cube.</source>
          <target state="new">First, we need to define the <bpt id="p1">**</bpt>BasicVertex<ept id="p1">**</ept> and <bpt id="p2">**</bpt>ConstantBuffer<ept id="p2">**</ept> structures for the textured cube.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>These structures specify the vertex positions, orientations, and textures for the cube and how the cube will be viewed.</source>
          <target state="new">These structures specify the vertex positions, orientations, and textures for the cube and how the cube will be viewed.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Otherwise, we declare variables similarly to the previous tutorial, <bpt id="p1">[</bpt>Using depth and effects on primitives<ept id="p1">](using-depth-and-effects-on-primitives.md)</ept>.</source>
          <target state="new">Otherwise, we declare variables similarly to the previous tutorial, <bpt id="p1">[</bpt>Using depth and effects on primitives<ept id="p1">](using-depth-and-effects-on-primitives.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>2. Creating vertex and pixel shaders with surface and texture elements</source>
          <target state="new">2. Creating vertex and pixel shaders with surface and texture elements</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Here, we create more complex vertex and pixel shaders than in the previous tutorial, <bpt id="p1">[</bpt>Using depth and effects on primitives<ept id="p1">](using-depth-and-effects-on-primitives.md)</ept>.</source>
          <target state="new">Here, we create more complex vertex and pixel shaders than in the previous tutorial, <bpt id="p1">[</bpt>Using depth and effects on primitives<ept id="p1">](using-depth-and-effects-on-primitives.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This app's vertex shader transforms each vertex position into projection space and passes the vertex texture coordinate through to the pixel shader.</source>
          <target state="new">This app's vertex shader transforms each vertex position into projection space and passes the vertex texture coordinate through to the pixel shader.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>The app's array of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>INPUT<ph id="ph2">\_</ph>ELEMENT<ph id="ph3">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structures that describe the layout of the vertex shader code has three layout elements: one element defines the vertex position, another element defines the surface normal vector (the direction that the surface normally faces), and the third element defines the texture coordinates.</source>
          <target state="new">The app's array of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>INPUT<ph id="ph2">\_</ph>ELEMENT<ph id="ph3">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structures that describe the layout of the vertex shader code has three layout elements: one element defines the vertex position, another element defines the surface normal vector (the direction that the surface normally faces), and the third element defines the texture coordinates.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>We create vertex, index, and constant buffers that define an orbiting textured cube.</source>
          <target state="new">We create vertex, index, and constant buffers that define an orbiting textured cube.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>To define an orbiting textured cube</source>
          <target state="new">To define an orbiting textured cube</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>First, we define the cube.</source>
          <target state="new">First, we define the cube.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Each vertex is assigned a position, a surface normal vector, and texture coordinates.</source>
          <target state="new">Each vertex is assigned a position, a surface normal vector, and texture coordinates.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>We use multiple vertices for each corner to allow different normal vectors and texture coordinates to be defined for each face.</source>
          <target state="new">We use multiple vertices for each corner to allow different normal vectors and texture coordinates to be defined for each face.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Next, we describe the vertex and index buffers (<bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>BUFFER<ph id="ph2">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11<ph id="ph3">\_</ph>SUBRESOURCE<ph id="ph4">\_</ph>DATA<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept>) using the cube definition.</source>
          <target state="new">Next, we describe the vertex and index buffers (<bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>BUFFER<ph id="ph2">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11<ph id="ph3">\_</ph>SUBRESOURCE<ph id="ph4">\_</ph>DATA<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept>) using the cube definition.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>We call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> once for each buffer.</source>
          <target state="new">We call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> once for each buffer.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Next, we create a constant buffer (<bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>BUFFER<ph id="ph2">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept>) for passing model, view, and projection matrices to the vertex shader.</source>
          <target state="new">Next, we create a constant buffer (<bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>BUFFER<ph id="ph2">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept>) for passing model, view, and projection matrices to the vertex shader.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>We can later use the constant buffer to rotate the cube and apply a perspective projection to it.</source>
          <target state="new">We can later use the constant buffer to rotate the cube and apply a perspective projection to it.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>We call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> to create the constant buffer.</source>
          <target state="new">We call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> to create the constant buffer.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Finally, we specify the view transform that corresponds to a camera position of X = 0, Y = 1, Z = 2.</source>
          <target state="new">Finally, we specify the view transform that corresponds to a camera position of X = 0, Y = 1, Z = 2.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>3. Creating textures and samplers</source>
          <target state="new">3. Creating textures and samplers</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Here, we apply texture data to a cube rather than applying colors as in the previous tutorial, <bpt id="p1">[</bpt>Using depth and effects on primitives<ept id="p1">](using-depth-and-effects-on-primitives.md)</ept>.</source>
          <target state="new">Here, we apply texture data to a cube rather than applying colors as in the previous tutorial, <bpt id="p1">[</bpt>Using depth and effects on primitives<ept id="p1">](using-depth-and-effects-on-primitives.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>We use raw texture data to create textures.</source>
          <target state="new">We use raw texture data to create textures.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>To create textures and samplers</source>
          <target state="new">To create textures and samplers</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>First, we read raw texture data from the texturedata.bin file on disk.</source>
          <target state="new">First, we read raw texture data from the texturedata.bin file on disk.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Next, we construct a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>SUBRESOURCE<ph id="ph2">\_</ph>DATA<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure that references that raw texture data.</source>
          <target state="new">Next, we construct a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>SUBRESOURCE<ph id="ph2">\_</ph>DATA<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure that references that raw texture data.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Then, we populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>TEXTURE2D<ph id="ph2">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476253)</ept> structure to describe the texture.</source>
          <target state="new">Then, we populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>TEXTURE2D<ph id="ph2">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476253)</ept> structure to describe the texture.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>We then pass the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>SUBRESOURCE<ph id="ph2">\_</ph>DATA<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> and <bpt id="p3">**</bpt>D3D11<ph id="ph3">\_</ph>TEXTURE2D<ph id="ph4">\_</ph>DESC<ept id="p3">**</ept> structures in a call to <bpt id="p4">[</bpt><bpt id="p5">**</bpt>ID3D11Device::CreateTexture2D<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/desktop/ff476521)</ept> to create the texture.</source>
          <target state="new">We then pass the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>SUBRESOURCE<ph id="ph2">\_</ph>DATA<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> and <bpt id="p3">**</bpt>D3D11<ph id="ph3">\_</ph>TEXTURE2D<ph id="ph4">\_</ph>DESC<ept id="p3">**</ept> structures in a call to <bpt id="p4">[</bpt><bpt id="p5">**</bpt>ID3D11Device::CreateTexture2D<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/desktop/ff476521)</ept> to create the texture.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Next, we create a shader-resource view of the texture so shaders can use the texture.</source>
          <target state="new">Next, we create a shader-resource view of the texture so shaders can use the texture.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>To create the shader-resource view, we populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>SHADER<ph id="ph2">\_</ph>RESOURCE<ph id="ph3">\_</ph>VIEW<ph id="ph4">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476211)</ept> to describe the shader-resource view and pass the shader-resource view description and the texture to <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11Device::CreateShaderResourceView<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476519)</ept>.</source>
          <target state="new">To create the shader-resource view, we populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>SHADER<ph id="ph2">\_</ph>RESOURCE<ph id="ph3">\_</ph>VIEW<ph id="ph4">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476211)</ept> to describe the shader-resource view and pass the shader-resource view description and the texture to <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11Device::CreateShaderResourceView<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476519)</ept>.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>In general, you match the view description with the texture description.</source>
          <target state="new">In general, you match the view description with the texture description.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Next, we create sampler state for the texture.</source>
          <target state="new">Next, we create sampler state for the texture.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This sampler state uses the relevant texture data to define how the color for a particular texture coordinate is determined.</source>
          <target state="new">This sampler state uses the relevant texture data to define how the color for a particular texture coordinate is determined.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>We populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>SAMPLER<ph id="ph2">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476207)</ept> structure to describe the sampler state.</source>
          <target state="new">We populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>SAMPLER<ph id="ph2">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476207)</ept> structure to describe the sampler state.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>We then pass the <bpt id="p1">**</bpt>D3D11<ph id="ph1">\_</ph>SAMPLER<ph id="ph2">\_</ph>DESC<ept id="p1">**</ept> structure in a call to <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ID3D11Device::CreateSamplerState<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/ff476518)</ept> to create the sampler state.</source>
          <target state="new">We then pass the <bpt id="p1">**</bpt>D3D11<ph id="ph1">\_</ph>SAMPLER<ph id="ph2">\_</ph>DESC<ept id="p1">**</ept> structure in a call to <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ID3D11Device::CreateSamplerState<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/ff476518)</ept> to create the sampler state.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Finally, we declare a <bpt id="p1">*</bpt>degree<ept id="p1">*</ept> variable that we will use to animate the cube by rotating it every frame.</source>
          <target state="new">Finally, we declare a <bpt id="p1">*</bpt>degree<ept id="p1">*</ept> variable that we will use to animate the cube by rotating it every frame.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>4. Rotating and drawing the textured cube and presenting the rendered image</source>
          <target state="new">4. Rotating and drawing the textured cube and presenting the rendered image</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>As in the previous tutorials, we enter an endless loop to continually render and display the scene.</source>
          <target state="new">As in the previous tutorials, we enter an endless loop to continually render and display the scene.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>We call the <bpt id="p1">**</bpt>rotationY<ept id="p1">**</ept> inline function (BasicMath.h) with a rotation amount to set values that will rotate the cube’s model matrix around the Y axis.</source>
          <target state="new">We call the <bpt id="p1">**</bpt>rotationY<ept id="p1">**</ept> inline function (BasicMath.h) with a rotation amount to set values that will rotate the cube’s model matrix around the Y axis.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>We then call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::UpdateSubresource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</ept> to update the constant buffer and rotate the cube model.</source>
          <target state="new">We then call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::UpdateSubresource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</ept> to update the constant buffer and rotate the cube model.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::OMSetRenderTargets<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept> to specify the render target and the depth-stencil view.</source>
          <target state="new">Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::OMSetRenderTargets<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept> to specify the render target and the depth-stencil view.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>We call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::ClearRenderTargetView<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476388)</ept> to clear the render target to a solid blue color and call <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::ClearDepthStencilView<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476387)</ept> to clear the depth buffer.</source>
          <target state="new">We call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::ClearRenderTargetView<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476388)</ept> to clear the render target to a solid blue color and call <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::ClearDepthStencilView<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476387)</ept> to clear the depth buffer.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In the endless loop, we also draw the textured cube on the blue surface.</source>
          <target state="new">In the endless loop, we also draw the textured cube on the blue surface.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>To draw the textured cube</source>
          <target state="new">To draw the textured cube</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>First, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::IASetInputLayout<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</ept> to describe how vertex buffer data is streamed into the input-assembler stage.</source>
          <target state="new">First, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::IASetInputLayout<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</ept> to describe how vertex buffer data is streamed into the input-assembler stage.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::IASetVertexBuffers<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::IASetIndexBuffer<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476453)</ept> to bind the vertex and index buffers to the input-assembler stage.</source>
          <target state="new">Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::IASetVertexBuffers<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::IASetIndexBuffer<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476453)</ept> to bind the vertex and index buffers to the input-assembler stage.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::IASetPrimitiveTopology<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476455)</ept> with the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11<ph id="ph1">\_</ph>PRIMITIVE<ph id="ph2">\_</ph>TOPOLOGY<ph id="ph3">\_</ph>TRIANGLESTRIP<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476189#D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP)</ept> value to specify for the input-assembler stage to interpret the vertex data as a triangle strip.</source>
          <target state="new">Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::IASetPrimitiveTopology<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476455)</ept> with the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11<ph id="ph1">\_</ph>PRIMITIVE<ph id="ph2">\_</ph>TOPOLOGY<ph id="ph3">\_</ph>TRIANGLESTRIP<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476189#D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP)</ept> value to specify for the input-assembler stage to interpret the vertex data as a triangle strip.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::VSSetShader<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> to initialize the vertex shader stage with the vertex shader code and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::PSSetShader<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> to initialize the pixel shader stage with the pixel shader code.</source>
          <target state="new">Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::VSSetShader<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> to initialize the vertex shader stage with the vertex shader code and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::PSSetShader<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> to initialize the pixel shader stage with the pixel shader code.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::VSSetConstantBuffers<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476491)</ept> to set the constant buffer that is used by the vertex shader pipeline stage.</source>
          <target state="new">Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::VSSetConstantBuffers<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476491)</ept> to set the constant buffer that is used by the vertex shader pipeline stage.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>PSSetShaderResources<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476473)</ept> to bind the shader-resource view of the texture to the pixel shader pipeline stage.</source>
          <target state="new">Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>PSSetShaderResources<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476473)</ept> to bind the shader-resource view of the texture to the pixel shader pipeline stage.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>PSSetSamplers<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476471)</ept> to set the sampler state to the pixel shader pipeline stage.</source>
          <target state="new">Next, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>PSSetSamplers<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476471)</ept> to set the sampler state to the pixel shader pipeline stage.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Finally, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</ept> to draw the cube and submit it to the rendering pipeline.</source>
          <target state="new">Finally, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</ept> to draw the cube and submit it to the rendering pipeline.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>As in the previous tutorials, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain::Present<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb174576)</ept> to present the rendered image to the window.</source>
          <target state="new">As in the previous tutorials, we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain::Present<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb174576)</ept> to present the rendered image to the window.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="new">Summary</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>We loaded raw texture data and applied that data to a 3D primitive.</source>
          <target state="new">We loaded raw texture data and applied that data to a 3D primitive.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>