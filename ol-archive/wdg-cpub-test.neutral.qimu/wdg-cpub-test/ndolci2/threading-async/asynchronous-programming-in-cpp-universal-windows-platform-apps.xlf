<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\threading-async\asynchronous-programming-in-cpp-universal-windows-platform-apps.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8e580d7698bd61babf3c2c1a068d9abc166f5e7f</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the task class defined in the concurrency namespace in ppltasks.h.</source>
          <target state="new">This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the task class defined in the concurrency namespace in ppltasks.h.</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Asynchronous programming in C++</source>
          <target state="new">Asynchronous programming in C++</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Asynchronous programming in C++</source>
          <target state="new">Asynchronous programming in C++</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the <ph id="ph1">`task`</ph> class that's defined in the <ph id="ph2">`concurrency`</ph> namespace in ppltasks.h.</source>
          <target state="new">This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the <ph id="ph1">`task`</ph> class that's defined in the <ph id="ph2">`concurrency`</ph> namespace in ppltasks.h.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Universal Windows Platform (UWP) asynchronous types</source>
          <target state="new">Universal Windows Platform (UWP) asynchronous types</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The Universal Windows Platform (UWP) features a well-defined model for calling asynchronous methods and provides the types that you need to consume such methods.</source>
          <target state="new">The Universal Windows Platform (UWP) features a well-defined model for calling asynchronous methods and provides the types that you need to consume such methods.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>If you are not familiar with the UWP asynchronous model, read <bpt id="p1">[</bpt>Asynchronous Programming<ept id="p1">]</ept><bpt id="p2">[</bpt>AsyncProgramming<ept id="p2">]</ept> before you read the rest of this article.</source>
          <target state="new">If you are not familiar with the UWP asynchronous model, read <bpt id="p1">[</bpt>Asynchronous Programming<ept id="p1">]</ept><bpt id="p2">[</bpt>AsyncProgramming<ept id="p2">]</ept> before you read the rest of this article.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Although you can consume the asynchronous UWP APIs directly in C++, the preferred approach is to use the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task class<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>task-class<ept id="p3">]</ept> and its related types and functions, which are contained in the <bpt id="p4">[</bpt><bpt id="p5">**</bpt>concurrency<ept id="p5">**</ept><ept id="p4">]</ept><bpt id="p6">[</bpt>concurrencyNamespace<ept id="p6">]</ept> namespace and defined in <ph id="ph1">`&lt;ppltasks.h&gt;`</ph>.</source>
          <target state="new">Although you can consume the asynchronous UWP APIs directly in C++, the preferred approach is to use the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task class<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>task-class<ept id="p3">]</ept> and its related types and functions, which are contained in the <bpt id="p4">[</bpt><bpt id="p5">**</bpt>concurrency<ept id="p5">**</ept><ept id="p4">]</ept><bpt id="p6">[</bpt>concurrencyNamespace<ept id="p6">]</ept> namespace and defined in <ph id="ph1">`&lt;ppltasks.h&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>concurrency::task<ept id="p1">**</ept> is a general-purpose type, but when the <bpt id="p2">**</bpt>/ZW<ept id="p2">**</ept> compiler switch—which is required for Universal Windows Platform (UWP) apps and components—is used, the task class encapsulates the UWP asynchronous types so that it's easier to:</source>
          <target state="new">The <bpt id="p1">**</bpt>concurrency::task<ept id="p1">**</ept> is a general-purpose type, but when the <bpt id="p2">**</bpt>/ZW<ept id="p2">**</ept> compiler switch—which is required for Universal Windows Platform (UWP) apps and components—is used, the task class encapsulates the UWP asynchronous types so that it's easier to:</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>chain multiple asynchronous and synchronous operations together</source>
          <target state="new">chain multiple asynchronous and synchronous operations together</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>handle exceptions in task chains</source>
          <target state="new">handle exceptions in task chains</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>perform cancellation in task chains</source>
          <target state="new">perform cancellation in task chains</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>ensure that individual tasks run in the appropriate thread context or apartment</source>
          <target state="new">ensure that individual tasks run in the appropriate thread context or apartment</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This article provides basic guidance about how to use the <bpt id="p1">**</bpt>task<ept id="p1">**</ept> class with the UWP asynchronous APIs.</source>
          <target state="new">This article provides basic guidance about how to use the <bpt id="p1">**</bpt>task<ept id="p1">**</ept> class with the UWP asynchronous APIs.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>For more complete documentation about <bpt id="p1">**</bpt>task<ept id="p1">**</ept> and its related methods including <bpt id="p2">[</bpt><bpt id="p3">**</bpt>create<ph id="ph1">\_</ph>task<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>createTask<ept id="p4">]</ept>, see <bpt id="p5">[</bpt>Task Parallelism (Concurrency Runtime)<ept id="p5">]</ept><bpt id="p6">[</bpt>taskParallelism<ept id="p6">]</ept>.</source>
          <target state="new">For more complete documentation about <bpt id="p1">**</bpt>task<ept id="p1">**</ept> and its related methods including <bpt id="p2">[</bpt><bpt id="p3">**</bpt>create<ph id="ph1">\_</ph>task<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>createTask<ept id="p4">]</ept>, see <bpt id="p5">[</bpt>Task Parallelism (Concurrency Runtime)<ept id="p5">]</ept><bpt id="p6">[</bpt>taskParallelism<ept id="p6">]</ept>.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>For more information about how to create asynchronous public methods for consumption by JavaScript or other UWP-compatible languages, see <bpt id="p1">[</bpt>Creating Asynchronous Operations in C++ for Windows Runtime apps<ept id="p1">]</ept><bpt id="p2">[</bpt>createAsyncCpp<ept id="p2">]</ept>.</source>
          <target state="new">For more information about how to create asynchronous public methods for consumption by JavaScript or other UWP-compatible languages, see <bpt id="p1">[</bpt>Creating Asynchronous Operations in C++ for Windows Runtime apps<ept id="p1">]</ept><bpt id="p2">[</bpt>createAsyncCpp<ept id="p2">]</ept>.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Consuming an async operation by using a task</source>
          <target state="new">Consuming an async operation by using a task</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The following example shows how to use the task class to consume an <bpt id="p1">**</bpt>async<ept id="p1">**</ept> method that returns an <bpt id="p2">[</bpt><bpt id="p3">**</bpt>IAsyncOperation<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>IAsyncOperation<ept id="p4">]</ept> interface and whose operation produces a value.</source>
          <target state="new">The following example shows how to use the task class to consume an <bpt id="p1">**</bpt>async<ept id="p1">**</ept> method that returns an <bpt id="p2">[</bpt><bpt id="p3">**</bpt>IAsyncOperation<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>IAsyncOperation<ept id="p4">]</ept> interface and whose operation produces a value.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Here are the basic steps:</source>
          <target state="new">Here are the basic steps:</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Call the <ph id="ph1">`create_task`</ph> method and pass it the <bpt id="p1">**</bpt>IAsyncOperation^<ept id="p1">**</ept> object.</source>
          <target state="new">Call the <ph id="ph1">`create_task`</ph> method and pass it the <bpt id="p1">**</bpt>IAsyncOperation^<ept id="p1">**</ept> object.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Call the member function <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::then<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskThen<ept id="p3">]</ept> on the task and supply a lambda that will be invoked when the asynchronous operation completes.</source>
          <target state="new">Call the member function <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::then<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskThen<ept id="p3">]</ept> on the task and supply a lambda that will be invoked when the asynchronous operation completes.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The task that's created and returned by the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::then<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskThen<ept id="p3">]</ept> function is known as a <bpt id="p4">*</bpt>continuation<ept id="p4">*</ept>.</source>
          <target state="new">The task that's created and returned by the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::then<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskThen<ept id="p3">]</ept> function is known as a <bpt id="p4">*</bpt>continuation<ept id="p4">*</ept>.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The input argument (in this case) to the user-provided lambda is the result that the task operation produces when it completes.</source>
          <target state="new">The input argument (in this case) to the user-provided lambda is the result that the task operation produces when it completes.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>It's the same value that would be retrieved by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAsyncOperation::GetResults<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br206600)</ept> if you were using the <bpt id="p3">**</bpt>IAsyncOperation<ept id="p3">**</ept> interface directly.</source>
          <target state="new">It's the same value that would be retrieved by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAsyncOperation::GetResults<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br206600)</ept> if you were using the <bpt id="p3">**</bpt>IAsyncOperation<ept id="p3">**</ept> interface directly.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::then<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskThen<ept id="p3">]</ept> method returns immediately, and its delegate doesn't run until the asynchronous work completes successfully.</source>
          <target state="new">The <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::then<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskThen<ept id="p3">]</ept> method returns immediately, and its delegate doesn't run until the asynchronous work completes successfully.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>In this example, if the asynchronous operation causes an exception to be thrown, or ends in the canceled state as a result of a cancellation request, the continuation will never execute.</source>
          <target state="new">In this example, if the asynchronous operation causes an exception to be thrown, or ends in the canceled state as a result of a cancellation request, the continuation will never execute.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Later, we’ll describe how to write continuations that execute even if the previous task was cancelled or failed.</source>
          <target state="new">Later, we’ll describe how to write continuations that execute even if the previous task was cancelled or failed.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Although you declare the task variable on the local stack, it manages its lifetime so that it is not deleted until all of its operations complete and all references to it go out of scope, even if the method returns before the operations complete.</source>
          <target state="new">Although you declare the task variable on the local stack, it manages its lifetime so that it is not deleted until all of its operations complete and all references to it go out of scope, even if the method returns before the operations complete.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Creating a chain of tasks</source>
          <target state="new">Creating a chain of tasks</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In asynchronous programming, it's common to define a sequence of operations, also known as <bpt id="p1">*</bpt>task chains<ept id="p1">*</ept>, in which each continuation executes only when the previous one completes.</source>
          <target state="new">In asynchronous programming, it's common to define a sequence of operations, also known as <bpt id="p1">*</bpt>task chains<ept id="p1">*</ept>, in which each continuation executes only when the previous one completes.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In some cases, the previous (or <bpt id="p1">*</bpt>antecedent<ept id="p1">*</ept>) task produces a value that the continuation accepts as input.</source>
          <target state="new">In some cases, the previous (or <bpt id="p1">*</bpt>antecedent<ept id="p1">*</ept>) task produces a value that the continuation accepts as input.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::then<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskThen<ept id="p3">]</ept> method, you can create task chains in an intuitive and straightforward manner; the method returns a <bpt id="p4">**</bpt>task<ph id="ph1">&lt;T&gt;</ph><ept id="p4">**</ept> where <bpt id="p5">**</bpt>T<ept id="p5">**</ept> is the return type of the lambda function.</source>
          <target state="new">By using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::then<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskThen<ept id="p3">]</ept> method, you can create task chains in an intuitive and straightforward manner; the method returns a <bpt id="p4">**</bpt>task<ph id="ph1">&lt;T&gt;</ph><ept id="p4">**</ept> where <bpt id="p5">**</bpt>T<ept id="p5">**</ept> is the return type of the lambda function.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>You can compose multiple continuations into a task chain:</source>
          <target state="new">You can compose multiple continuations into a task chain:</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Task chains are especially useful when a continuation creates a new asynchronous operation; such a task is known as an asynchronous task.</source>
          <target state="new">Task chains are especially useful when a continuation creates a new asynchronous operation; such a task is known as an asynchronous task.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The following example illustrates a task chain that has two continuations.</source>
          <target state="new">The following example illustrates a task chain that has two continuations.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The initial task acquires the handle to an existing file, and when that operation completes, the first continuation starts up a new asynchronous operation to delete the file.</source>
          <target state="new">The initial task acquires the handle to an existing file, and when that operation completes, the first continuation starts up a new asynchronous operation to delete the file.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>When that operation completes, the second continuation runs, and outputs a confirmation message.</source>
          <target state="new">When that operation completes, the second continuation runs, and outputs a confirmation message.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The previous example illustrates four important points:</source>
          <target state="new">The previous example illustrates four important points:</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The first continuation converts the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAsyncAction^<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>IAsyncAction<ept id="p3">]</ept> object to a <bpt id="p4">**</bpt>task<ph id="ph1">&lt;void&gt;</ph><ept id="p4">**</ept> and returns the <bpt id="p5">**</bpt>task<ept id="p5">**</ept>.</source>
          <target state="new">The first continuation converts the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAsyncAction^<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>IAsyncAction<ept id="p3">]</ept> object to a <bpt id="p4">**</bpt>task<ph id="ph1">&lt;void&gt;</ph><ept id="p4">**</ept> and returns the <bpt id="p5">**</bpt>task<ept id="p5">**</ept>.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The second continuation performs no error handling, and therefore takes <bpt id="p1">**</bpt>void<ept id="p1">**</ept> and not <bpt id="p2">**</bpt>task<ph id="ph1">&lt;void&gt;</ph><ept id="p2">**</ept> as input.</source>
          <target state="new">The second continuation performs no error handling, and therefore takes <bpt id="p1">**</bpt>void<ept id="p1">**</ept> and not <bpt id="p2">**</bpt>task<ph id="ph1">&lt;void&gt;</ph><ept id="p2">**</ept> as input.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>It is a value-based continuation.</source>
          <target state="new">It is a value-based continuation.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The second continuation doesn't execute until the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DeleteAsync<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>deleteAsync<ept id="p3">]</ept> operation completes.</source>
          <target state="new">The second continuation doesn't execute until the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DeleteAsync<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>deleteAsync<ept id="p3">]</ept> operation completes.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Because the second continuation is value-based, if the operation that was started by the call to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DeleteAsync<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>deleteAsync<ept id="p3">]</ept> throws an exception, the second continuation doesn't execute at all.</source>
          <target state="new">Because the second continuation is value-based, if the operation that was started by the call to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DeleteAsync<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>deleteAsync<ept id="p3">]</ept> throws an exception, the second continuation doesn't execute at all.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Creating a task chain is just one of the ways to use the <bpt id="p2">**</bpt>task<ept id="p2">**</ept> class to compose asynchronous operations.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Creating a task chain is just one of the ways to use the <bpt id="p2">**</bpt>task<ept id="p2">**</ept> class to compose asynchronous operations.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You can also compose operations by using join and choice operators <bpt id="p1">**</bpt><ph id="ph1">&amp;&amp;</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">||</ph><ept id="p2">**</ept>.</source>
          <target state="new">You can also compose operations by using join and choice operators <bpt id="p1">**</bpt><ph id="ph1">&amp;&amp;</ph><ept id="p1">**</ept> and <bpt id="p2">**</bpt><ph id="ph2">||</ph><ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Task Parallelism (Concurrency Runtime)<ept id="p1">]</ept><bpt id="p2">[</bpt>taskParallelism<ept id="p2">]</ept>.</source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>Task Parallelism (Concurrency Runtime)<ept id="p1">]</ept><bpt id="p2">[</bpt>taskParallelism<ept id="p2">]</ept>.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Lambda function return types and task return types</source>
          <target state="new">Lambda function return types and task return types</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In a task continuation, the return type of the lambda function is wrapped in a <bpt id="p1">**</bpt>task<ept id="p1">**</ept> object.</source>
          <target state="new">In a task continuation, the return type of the lambda function is wrapped in a <bpt id="p1">**</bpt>task<ept id="p1">**</ept> object.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>If the lambda returns a <bpt id="p1">**</bpt>double<ept id="p1">**</ept>, then the type of the continuation task is <bpt id="p2">**</bpt>task<ph id="ph1">&lt;double&gt;</ph><ept id="p2">**</ept>.</source>
          <target state="new">If the lambda returns a <bpt id="p1">**</bpt>double<ept id="p1">**</ept>, then the type of the continuation task is <bpt id="p2">**</bpt>task<ph id="ph1">&lt;double&gt;</ph><ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>However, the task object is designed so that it doesn't produce needlessly nested return types.</source>
          <target state="new">However, the task object is designed so that it doesn't produce needlessly nested return types.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If a lambda returns an <bpt id="p1">**</bpt>IAsyncOperation&lt;SyndicationFeed^&gt;^<ept id="p1">**</ept>, the continuation returns a <bpt id="p2">**</bpt>task&lt;SyndicationFeed^&gt;<ept id="p2">**</ept>, not a <bpt id="p3">**</bpt>task&lt;task&lt;SyndicationFeed^&gt;&gt;<ept id="p3">**</ept> or <bpt id="p4">**</bpt>task&lt;IAsyncOperation&lt;SyndicationFeed^&gt;^&gt;^<ept id="p4">**</ept>.</source>
          <target state="new">If a lambda returns an <bpt id="p1">**</bpt>IAsyncOperation&lt;SyndicationFeed^&gt;^<ept id="p1">**</ept>, the continuation returns a <bpt id="p2">**</bpt>task&lt;SyndicationFeed^&gt;<ept id="p2">**</ept>, not a <bpt id="p3">**</bpt>task&lt;task&lt;SyndicationFeed^&gt;&gt;<ept id="p3">**</ept> or <bpt id="p4">**</bpt>task&lt;IAsyncOperation&lt;SyndicationFeed^&gt;^&gt;^<ept id="p4">**</ept>.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This process is known as <bpt id="p1">*</bpt>asynchronous unwrapping<ept id="p1">*</ept> and it also ensures that the asynchronous operation inside the continuation completes before the next continuation is invoked.</source>
          <target state="new">This process is known as <bpt id="p1">*</bpt>asynchronous unwrapping<ept id="p1">*</ept> and it also ensures that the asynchronous operation inside the continuation completes before the next continuation is invoked.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In the previous example, notice that the task returns a <bpt id="p1">**</bpt>task<ph id="ph1">&lt;void&gt;</ph><ept id="p1">**</ept> even though its lambda returned an <bpt id="p2">[</bpt><bpt id="p3">**</bpt>IAsyncInfo<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>IAsyncInfo<ept id="p4">]</ept> object.</source>
          <target state="new">In the previous example, notice that the task returns a <bpt id="p1">**</bpt>task<ph id="ph1">&lt;void&gt;</ph><ept id="p1">**</ept> even though its lambda returned an <bpt id="p2">[</bpt><bpt id="p3">**</bpt>IAsyncInfo<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>IAsyncInfo<ept id="p4">]</ept> object.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The following table summarizes the type conversions that occur between a lambda function and the enclosing task:</source>
          <target state="new">The following table summarizes the type conversions that occur between a lambda function and the enclosing task:</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>lambda return type</source>
          <target state="new">lambda return type</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>return type</source>
          <target state="new">return type</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>TResult</source>
          <target state="new">TResult</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>task</source>
          <target state="new">task</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>IAsyncOperation</source>
          <target state="new">IAsyncOperation</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>task</source>
          <target state="new">task</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>IAsyncOperationWithProgress&lt;TResult, TProgress&gt;^</source>
          <target state="new">IAsyncOperationWithProgress&lt;TResult, TProgress&gt;^</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>task</source>
          <target state="new">task</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>IAsyncAction^</source>
          <target state="new">IAsyncAction^</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>task</source>
          <target state="new">task</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>IAsyncActionWithProgress</source>
          <target state="new">IAsyncActionWithProgress</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>task</source>
          <target state="new">task</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>task</source>
          <target state="new">task</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>task</source>
          <target state="new">task</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Canceling tasks</source>
          <target state="new">Canceling tasks</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>It is often a good idea to give the user the option to cancel an asynchronous operation.</source>
          <target state="new">It is often a good idea to give the user the option to cancel an asynchronous operation.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>And in some cases you might have to cancel an operation programmatically from outside the task chain.</source>
          <target state="new">And in some cases you might have to cancel an operation programmatically from outside the task chain.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Although each <ph id="ph1">\*</ph><bpt id="p1">**</bpt>Async<ept id="p1">**</ept> return type has a <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Cancel<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>IAsyncInfoCancel<ept id="p4">]</ept> method that it inherits from <bpt id="p5">[</bpt><bpt id="p6">**</bpt>IAsyncInfo<ept id="p6">**</ept><ept id="p5">]</ept><bpt id="p7">[</bpt>IAsyncInfo<ept id="p7">]</ept>, it's awkward to expose it to outside methods.</source>
          <target state="new">Although each <ph id="ph1">\*</ph><bpt id="p1">**</bpt>Async<ept id="p1">**</ept> return type has a <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Cancel<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>IAsyncInfoCancel<ept id="p4">]</ept> method that it inherits from <bpt id="p5">[</bpt><bpt id="p6">**</bpt>IAsyncInfo<ept id="p6">**</ept><ept id="p5">]</ept><bpt id="p7">[</bpt>IAsyncInfo<ept id="p7">]</ept>, it's awkward to expose it to outside methods.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The preferred way to support cancellation in a task chain is to use a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>cancellation<ph id="ph1">\_</ph>token<ph id="ph2">\_</ph>source<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749985.aspx)</ept> to create a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>cancellation<ph id="ph3">\_</ph>token<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749975.aspx)</ept>, and then pass the token to the constructor of the initial task.</source>
          <target state="new">The preferred way to support cancellation in a task chain is to use a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>cancellation<ph id="ph1">\_</ph>token<ph id="ph2">\_</ph>source<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749985.aspx)</ept> to create a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>cancellation<ph id="ph3">\_</ph>token<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749975.aspx)</ept>, and then pass the token to the constructor of the initial task.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>If an asynchronous task is created with a cancellation token, and <bpt id="p1">[</bpt><bpt id="p2">**</bpt>cancellation<ph id="ph1">\_</ph>token<ph id="ph2">\_</ph>source::cancel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750076.aspx)</ept> is called, the task automatically calls <bpt id="p3">**</bpt>Cancel<ept id="p3">**</ept> on the <bpt id="p4">**</bpt>IAsync<ph id="ph3">\*</ph><ept id="p4">**</ept> operation and passes the cancellation request down its continuation chain.</source>
          <target state="new">If an asynchronous task is created with a cancellation token, and <bpt id="p1">[</bpt><bpt id="p2">**</bpt>cancellation<ph id="ph1">\_</ph>token<ph id="ph2">\_</ph>source::cancel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750076.aspx)</ept> is called, the task automatically calls <bpt id="p3">**</bpt>Cancel<ept id="p3">**</ept> on the <bpt id="p4">**</bpt>IAsync<ph id="ph3">\*</ph><ept id="p4">**</ept> operation and passes the cancellation request down its continuation chain.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The following pseudocode demonstrates the basic approach.</source>
          <target state="new">The following pseudocode demonstrates the basic approach.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>When a task is canceled, a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>canceled<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskCanceled<ept id="p3">]</ept> exception is propagated down the task chain.</source>
          <target state="new">When a task is canceled, a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>canceled<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskCanceled<ept id="p3">]</ept> exception is propagated down the task chain.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Value-based continuations will simply not execute, but task-based continuations will cause the exception to be thrown when <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::get<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskGet<ept id="p3">]</ept> is called.</source>
          <target state="new">Value-based continuations will simply not execute, but task-based continuations will cause the exception to be thrown when <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::get<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskGet<ept id="p3">]</ept> is called.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>If you have an error-handling continuation, make sure that it catches the <bpt id="p1">**</bpt>task<ph id="ph1">\_</ph>canceled<ept id="p1">**</ept> exception explicitly.</source>
          <target state="new">If you have an error-handling continuation, make sure that it catches the <bpt id="p1">**</bpt>task<ph id="ph1">\_</ph>canceled<ept id="p1">**</ept> exception explicitly.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>(This exception is not derived from <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Platform::Exception<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh755825.aspx)</ept>.)</source>
          <target state="new">(This exception is not derived from <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Platform::Exception<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh755825.aspx)</ept>.)</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Cancellation is cooperative.</source>
          <target state="new">Cancellation is cooperative.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If your continuation does some long-running work beyond just invoking a UWP method, then it is your responsibility to check the state of the cancellation token periodically and stop execution if it is canceled.</source>
          <target state="new">If your continuation does some long-running work beyond just invoking a UWP method, then it is your responsibility to check the state of the cancellation token periodically and stop execution if it is canceled.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>After you clean up all resources that were allocated in the continuation, call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>cancel<ph id="ph1">\_</ph>current<ph id="ph2">\_</ph>task<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749945.aspx)</ept> to cancel that task and propagate the cancellation down to any value-based continuations that follow it.</source>
          <target state="new">After you clean up all resources that were allocated in the continuation, call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>cancel<ph id="ph1">\_</ph>current<ph id="ph2">\_</ph>task<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749945.aspx)</ept> to cancel that task and propagate the cancellation down to any value-based continuations that follow it.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Here's another example: you can create a task chain that represents the result of a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FileSavePicker<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR207871)</ept> operation.</source>
          <target state="new">Here's another example: you can create a task chain that represents the result of a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FileSavePicker<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR207871)</ept> operation.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>If the user chooses the <bpt id="p1">**</bpt>Cancel<ept id="p1">**</ept> button, the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>IAsyncInfo::Cancel<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>IAsyncInfoCancel<ept id="p4">]</ept> method is not called.</source>
          <target state="new">If the user chooses the <bpt id="p1">**</bpt>Cancel<ept id="p1">**</ept> button, the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>IAsyncInfo::Cancel<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>IAsyncInfoCancel<ept id="p4">]</ept> method is not called.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Instead, the operation succeeds but returns <bpt id="p1">**</bpt>nullptr<ept id="p1">**</ept>.</source>
          <target state="new">Instead, the operation succeeds but returns <bpt id="p1">**</bpt>nullptr<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The continuation can test the input parameter and call <bpt id="p1">**</bpt>cancel<ph id="ph1">\_</ph>current<ph id="ph2">\_</ph>task<ept id="p1">**</ept> if the input is <bpt id="p2">**</bpt>nullptr<ept id="p2">**</ept>.</source>
          <target state="new">The continuation can test the input parameter and call <bpt id="p1">**</bpt>cancel<ph id="ph1">\_</ph>current<ph id="ph2">\_</ph>task<ept id="p1">**</ept> if the input is <bpt id="p2">**</bpt>nullptr<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For more information, see <bpt id="p1">[</bpt>Cancellation in the PPL<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd984117.aspx)</ept></source>
          <target state="new">For more information, see <bpt id="p1">[</bpt>Cancellation in the PPL<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd984117.aspx)</ept></target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Handling errors in a task chain</source>
          <target state="new">Handling errors in a task chain</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>If you want a continuation to execute even if the antecedent was canceled or threw an exception, then make the continuation a task-based continuation by specifying the input to its lambda function as a <bpt id="p1">**</bpt>task<ph id="ph1">&lt;TResult&gt;</ph><ept id="p1">**</ept> or <bpt id="p2">**</bpt>task<ph id="ph2">&lt;void&gt;</ph><ept id="p2">**</ept> if the lambda of the antecedent task returns an <bpt id="p3">[</bpt><bpt id="p4">**</bpt>IAsyncAction^<ept id="p4">**</ept><ept id="p3">]</ept><bpt id="p5">[</bpt>IAsyncAction<ept id="p5">]</ept>.</source>
          <target state="new">If you want a continuation to execute even if the antecedent was canceled or threw an exception, then make the continuation a task-based continuation by specifying the input to its lambda function as a <bpt id="p1">**</bpt>task<ph id="ph1">&lt;TResult&gt;</ph><ept id="p1">**</ept> or <bpt id="p2">**</bpt>task<ph id="ph2">&lt;void&gt;</ph><ept id="p2">**</ept> if the lambda of the antecedent task returns an <bpt id="p3">[</bpt><bpt id="p4">**</bpt>IAsyncAction^<ept id="p4">**</ept><ept id="p3">]</ept><bpt id="p5">[</bpt>IAsyncAction<ept id="p5">]</ept>.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>To handle errors and cancellation in a task chain, you don't have to make every continuation task-based or enclose every operation that might throw within a <ph id="ph1">`try…catch`</ph> block.</source>
          <target state="new">To handle errors and cancellation in a task chain, you don't have to make every continuation task-based or enclose every operation that might throw within a <ph id="ph1">`try…catch`</ph> block.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Instead, you can add a task-based continuation at the end of the chain and handle all errors there.</source>
          <target state="new">Instead, you can add a task-based continuation at the end of the chain and handle all errors there.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Any exception—this includes a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>canceled<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskCanceled<ept id="p3">]</ept> exception—will propagate down the task chain and bypass any value-based continuations, so that you can handle it in the error-handling task-based continuation.</source>
          <target state="new">Any exception—this includes a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>canceled<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskCanceled<ept id="p3">]</ept> exception—will propagate down the task chain and bypass any value-based continuations, so that you can handle it in the error-handling task-based continuation.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>We can rewrite the previous example to use an error-handling task-based continuation:</source>
          <target state="new">We can rewrite the previous example to use an error-handling task-based continuation:</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>In a task-based continuation, we call the member function <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::get<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskGet<ept id="p3">]</ept> to get the results of the task.</source>
          <target state="new">In a task-based continuation, we call the member function <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::get<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskGet<ept id="p3">]</ept> to get the results of the task.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>We still have to call <bpt id="p1">**</bpt>task::get<ept id="p1">**</ept> even if the operation was an <bpt id="p2">[</bpt><bpt id="p3">**</bpt>IAsyncAction<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>IAsyncAction<ept id="p4">]</ept> that produces no result because <bpt id="p5">**</bpt>task::get<ept id="p5">**</ept> also gets any exceptions that have been transported down to the task.</source>
          <target state="new">We still have to call <bpt id="p1">**</bpt>task::get<ept id="p1">**</ept> even if the operation was an <bpt id="p2">[</bpt><bpt id="p3">**</bpt>IAsyncAction<ept id="p3">**</ept><ept id="p2">]</ept><bpt id="p4">[</bpt>IAsyncAction<ept id="p4">]</ept> that produces no result because <bpt id="p5">**</bpt>task::get<ept id="p5">**</ept> also gets any exceptions that have been transported down to the task.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>If the input task is storing an exception, it is thrown at the call to <bpt id="p1">**</bpt>task::get<ept id="p1">**</ept>.</source>
          <target state="new">If the input task is storing an exception, it is thrown at the call to <bpt id="p1">**</bpt>task::get<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>If you don't call <bpt id="p1">**</bpt>task::get<ept id="p1">**</ept>, or don't use a task-based continuation at the end of the chain, or don't catch the exception type that was thrown, then an <bpt id="p2">**</bpt>unobserved<ph id="ph1">\_</ph>task<ph id="ph2">\_</ph>exception<ept id="p2">**</ept> is thrown when all references to the task have been deleted.</source>
          <target state="new">If you don't call <bpt id="p1">**</bpt>task::get<ept id="p1">**</ept>, or don't use a task-based continuation at the end of the chain, or don't catch the exception type that was thrown, then an <bpt id="p2">**</bpt>unobserved<ph id="ph1">\_</ph>task<ph id="ph2">\_</ph>exception<ept id="p2">**</ept> is thrown when all references to the task have been deleted.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Only catch the exceptions that you can handle.</source>
          <target state="new">Only catch the exceptions that you can handle.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If your app encounters an error that you can't recover from, it's better to let the app crash than to let it continue to run in an unknown state.</source>
          <target state="new">If your app encounters an error that you can't recover from, it's better to let the app crash than to let it continue to run in an unknown state.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Also, in general, don't attempt to catch the <bpt id="p1">**</bpt>unobserved<ph id="ph1">\_</ph>task<ph id="ph2">\_</ph>exception<ept id="p1">**</ept> itself.</source>
          <target state="new">Also, in general, don't attempt to catch the <bpt id="p1">**</bpt>unobserved<ph id="ph1">\_</ph>task<ph id="ph2">\_</ph>exception<ept id="p1">**</ept> itself.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>This exception is mainly intended for diagnostic purposes.</source>
          <target state="new">This exception is mainly intended for diagnostic purposes.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>When <bpt id="p1">**</bpt>unobserved<ph id="ph1">\_</ph>task<ph id="ph2">\_</ph>exception<ept id="p1">**</ept> is thrown, it usually indicates a bug in the code.</source>
          <target state="new">When <bpt id="p1">**</bpt>unobserved<ph id="ph1">\_</ph>task<ph id="ph2">\_</ph>exception<ept id="p1">**</ept> is thrown, it usually indicates a bug in the code.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Often the cause is either an exception that should be handled, or an unrecoverable exception that's caused by some other error in the code.</source>
          <target state="new">Often the cause is either an exception that should be handled, or an unrecoverable exception that's caused by some other error in the code.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Managing the thread context</source>
          <target state="new">Managing the thread context</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The UI of a UWP app runs in a single-threaded apartment (STA).</source>
          <target state="new">The UI of a UWP app runs in a single-threaded apartment (STA).</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>A task whose lambda returns either an <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAsyncAction<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>IAsyncAction<ept id="p3">]</ept> or <bpt id="p4">[</bpt><bpt id="p5">**</bpt>IAsyncOperation<ept id="p5">**</ept><ept id="p4">]</ept><bpt id="p6">[</bpt>IAsyncOperation<ept id="p6">]</ept> is apartment-aware.</source>
          <target state="new">A task whose lambda returns either an <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAsyncAction<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>IAsyncAction<ept id="p3">]</ept> or <bpt id="p4">[</bpt><bpt id="p5">**</bpt>IAsyncOperation<ept id="p5">**</ept><ept id="p4">]</ept><bpt id="p6">[</bpt>IAsyncOperation<ept id="p6">]</ept> is apartment-aware.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If the task is created in the STA, then all of its continuations will run also run in it by default, unless you specify otherwise.</source>
          <target state="new">If the task is created in the STA, then all of its continuations will run also run in it by default, unless you specify otherwise.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>In other words, the entire task chain inherits apartment-awareness from the parent task.</source>
          <target state="new">In other words, the entire task chain inherits apartment-awareness from the parent task.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>This behavior helps simplify interactions with UI controls, which can only be accessed from the STA.</source>
          <target state="new">This behavior helps simplify interactions with UI controls, which can only be accessed from the STA.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>For example, in a UWP app, in the member function of any class that represents a XAML page, you can populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ListBox<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242868)</ept> control from within a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>task::then<ept id="p4">**</ept><ept id="p3">]</ept><bpt id="p5">[</bpt>taskThen<ept id="p5">]</ept> method without having to use the <bpt id="p6">[</bpt><bpt id="p7">**</bpt>Dispatcher<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/BR208211)</ept> object.</source>
          <target state="new">For example, in a UWP app, in the member function of any class that represents a XAML page, you can populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ListBox<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR242868)</ept> control from within a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>task::then<ept id="p4">**</ept><ept id="p3">]</ept><bpt id="p5">[</bpt>taskThen<ept id="p5">]</ept> method without having to use the <bpt id="p6">[</bpt><bpt id="p7">**</bpt>Dispatcher<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/BR208211)</ept> object.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If a task doesn't return an <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAsyncAction<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>IAsyncAction<ept id="p3">]</ept> or <bpt id="p4">[</bpt><bpt id="p5">**</bpt>IAsyncOperation<ept id="p5">**</ept><ept id="p4">]</ept><bpt id="p6">[</bpt>IAsyncOperation<ept id="p6">]</ept>, then it's not apartment-aware and, by default, its continuations are run on the first available background thread.</source>
          <target state="new">If a task doesn't return an <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAsyncAction<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>IAsyncAction<ept id="p3">]</ept> or <bpt id="p4">[</bpt><bpt id="p5">**</bpt>IAsyncOperation<ept id="p5">**</ept><ept id="p4">]</ept><bpt id="p6">[</bpt>IAsyncOperation<ept id="p6">]</ept>, then it's not apartment-aware and, by default, its continuations are run on the first available background thread.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>You can override the default thread context for either kind of task by using the overload of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::then<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskThen<ept id="p3">]</ept> that takes a <bpt id="p4">[</bpt><bpt id="p5">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749968.aspx)</ept>.</source>
          <target state="new">You can override the default thread context for either kind of task by using the overload of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task::then<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>taskThen<ept id="p3">]</ept> that takes a <bpt id="p4">[</bpt><bpt id="p5">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749968.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>For example, in some cases, it might be desirable to schedule the continuation of an apartment-aware task on a background thread.</source>
          <target state="new">For example, in some cases, it might be desirable to schedule the continuation of an apartment-aware task on a background thread.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>In such a case, you can pass <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context::use<ph id="ph3">\_</ph>arbitrary<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>useArbitrary<ept id="p3">]</ept> to schedule the task’s work on the next available thread in a multi-threaded apartment.</source>
          <target state="new">In such a case, you can pass <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context::use<ph id="ph3">\_</ph>arbitrary<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>useArbitrary<ept id="p3">]</ept> to schedule the task’s work on the next available thread in a multi-threaded apartment.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>This can improve the performance of the continuation because its work doesn't have to be synchronized with other work that's happening on the UI thread.</source>
          <target state="new">This can improve the performance of the continuation because its work doesn't have to be synchronized with other work that's happening on the UI thread.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The following example demonstrates when it's useful to specify the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context::use<ph id="ph3">\_</ph>arbitrary<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>useArbitrary<ept id="p3">]</ept> option, and it also shows how the default continuation context is useful for synchronizing concurrent operations on non-thread-safe collections.</source>
          <target state="new">The following example demonstrates when it's useful to specify the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context::use<ph id="ph3">\_</ph>arbitrary<ept id="p2">**</ept><ept id="p1">]</ept><bpt id="p3">[</bpt>useArbitrary<ept id="p3">]</ept> option, and it also shows how the default continuation context is useful for synchronizing concurrent operations on non-thread-safe collections.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>In this code, we loop through a list of URLs for RSS feeds, and for each URL, we start up an async operation to retrieve the feed data.</source>
          <target state="new">In this code, we loop through a list of URLs for RSS feeds, and for each URL, we start up an async operation to retrieve the feed data.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>We can’t control the order in which the feeds are retrieved, and we don't really care.</source>
          <target state="new">We can’t control the order in which the feeds are retrieved, and we don't really care.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>When each <bpt id="p1">[</bpt><bpt id="p2">**</bpt>RetrieveFeedAsync<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR210642)</ept> operation completes, the first continuation accepts the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>SyndicationFeed^<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR243485)</ept> object and uses it to initialize an app-defined <ph id="ph1">`FeedData^`</ph> object.</source>
          <target state="new">When each <bpt id="p1">[</bpt><bpt id="p2">**</bpt>RetrieveFeedAsync<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR210642)</ept> operation completes, the first continuation accepts the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>SyndicationFeed^<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR243485)</ept> object and uses it to initialize an app-defined <ph id="ph1">`FeedData^`</ph> object.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Because each of these operations is independent from the others, we can potentially speed things up by specifying the <bpt id="p1">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context::use<ph id="ph3">\_</ph>arbitrary<ept id="p1">**</ept> continuation context.</source>
          <target state="new">Because each of these operations is independent from the others, we can potentially speed things up by specifying the <bpt id="p1">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context::use<ph id="ph3">\_</ph>arbitrary<ept id="p1">**</ept> continuation context.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>However, after each <ph id="ph1">`FeedData`</ph> object is initialized, we have to add it to a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Vector<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh441570.aspx)</ept>, which is not a thread-safe collection.</source>
          <target state="new">However, after each <ph id="ph1">`FeedData`</ph> object is initialized, we have to add it to a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Vector<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh441570.aspx)</ept>, which is not a thread-safe collection.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Therefore, we create a continuation and specify <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context::use<ph id="ph3">\_</ph>current<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx)</ept> to ensure that all the calls to <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Append<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR206632)</ept> occur in the same Application Single-Threaded Apartment (ASTA) context.</source>
          <target state="new">Therefore, we create a continuation and specify <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context::use<ph id="ph3">\_</ph>current<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx)</ept> to ensure that all the calls to <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Append<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR206632)</ept> occur in the same Application Single-Threaded Apartment (ASTA) context.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Because <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context::use<ph id="ph3">\_</ph>default<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx)</ept> is the default context, we don’t have to specify it explicitly, but we do so here for the sake of clarity.</source>
          <target state="new">Because <bpt id="p1">[</bpt><bpt id="p2">**</bpt>task<ph id="ph1">\_</ph>continuation<ph id="ph2">\_</ph>context::use<ph id="ph3">\_</ph>default<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx)</ept> is the default context, we don’t have to specify it explicitly, but we do so here for the sake of clarity.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Nested tasks, which are new tasks that are created inside a continuation, don't inherit apartment-awareness of the initial task.</source>
          <target state="new">Nested tasks, which are new tasks that are created inside a continuation, don't inherit apartment-awareness of the initial task.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Handing progress updates</source>
          <target state="new">Handing progress updates</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Methods that support <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAsyncOperationWithProgress<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR206594)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>IAsyncActionWithProgress<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR206580withprogress_1)</ept> provide progress updates periodically while the operation is in progress, before it completes.</source>
          <target state="new">Methods that support <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IAsyncOperationWithProgress<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR206594)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>IAsyncActionWithProgress<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR206580withprogress_1)</ept> provide progress updates periodically while the operation is in progress, before it completes.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Progress reporting is independent from the notion of tasks and continuations.</source>
          <target state="new">Progress reporting is independent from the notion of tasks and continuations.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>You just supply the delegate for the object’s <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Progress<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br206594)</ept> property.</source>
          <target state="new">You just supply the delegate for the object’s <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Progress<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br206594)</ept> property.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>A typical use of the delegate is to update a progress bar in the UI.</source>
          <target state="new">A typical use of the delegate is to update a progress bar in the UI.</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Creating Asynchronous Operations in C++ for Windows Store apps<ept id="p1">]</ept><bpt id="p2">[</bpt>createAsyncCpp<ept id="p2">]</ept></source>
          <target state="new"><bpt id="p1">[</bpt>Creating Asynchronous Operations in C++ for Windows Store apps<ept id="p1">]</ept><bpt id="p2">[</bpt>createAsyncCpp<ept id="p2">]</ept></target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Visual C++ Language Reference</source>
          <target state="new">Visual C++ Language Reference</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Asynchronous Programming<ept id="p1">]</ept><bpt id="p2">[</bpt>AsyncProgramming<ept id="p2">]</ept></source>
          <target state="new"><bpt id="p1">[</bpt>Asynchronous Programming<ept id="p1">]</ept><bpt id="p2">[</bpt>AsyncProgramming<ept id="p2">]</ept></target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Task Parallelism (Concurrency Runtime)<ept id="p1">]</ept><bpt id="p2">[</bpt>taskParallelism<ept id="p2">]</ept></source>
          <target state="new"><bpt id="p1">[</bpt>Task Parallelism (Concurrency Runtime)<ept id="p1">]</ept><bpt id="p2">[</bpt>taskParallelism<ept id="p2">]</ept></target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>task class<ept id="p1">]</ept><bpt id="p2">[</bpt>task-class<ept id="p2">]</ept></source>
          <target state="new"><bpt id="p1">[</bpt>task class<ept id="p1">]</ept><bpt id="p2">[</bpt>task-class<ept id="p2">]</ept></target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>AsyncProgramming<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh464924.aspx&gt;</ept><bpt id="p2"> "</bpt>AsyncProgramming<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>AsyncProgramming<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh464924.aspx&gt;</ept><bpt id="p2"> "</bpt>AsyncProgramming<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>concurrencyNamespace<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd492819.aspx&gt;</ept><bpt id="p2"> "</bpt>Concurrency Namespace<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>concurrencyNamespace<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd492819.aspx&gt;</ept><bpt id="p2"> "</bpt>Concurrency Namespace<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>createTask<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh913025.aspx&gt;</ept><bpt id="p2"> "</bpt>CreateTask<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>createTask<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh913025.aspx&gt;</ept><bpt id="p2"> "</bpt>CreateTask<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>createAsyncCpp<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750082.aspx&gt;</ept><bpt id="p2"> "</bpt>CreateAsync<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>createAsyncCpp<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750082.aspx&gt;</ept><bpt id="p2"> "</bpt>CreateAsync<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>deleteAsync<ept id="p1">]: &lt;https://msdn.microsoft.com/library/windows/apps/BR227199&gt;</ept><bpt id="p2"> "</bpt>DeleteAsync<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>deleteAsync<ept id="p1">]: &lt;https://msdn.microsoft.com/library/windows/apps/BR227199&gt;</ept><bpt id="p2"> "</bpt>DeleteAsync<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IAsyncAction<ept id="p1">]: &lt;https://msdn.microsoft.com/library/windows/apps/BR206580&gt;</ept><bpt id="p2"> "</bpt>IAsyncAction<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>IAsyncAction<ept id="p1">]: &lt;https://msdn.microsoft.com/library/windows/apps/BR206580&gt;</ept><bpt id="p2"> "</bpt>IAsyncAction<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IAsyncOperation<ept id="p1">]: &lt;https://msdn.microsoft.com/library/windows/apps/BR206598&gt;</ept><bpt id="p2"> "</bpt>IAsyncOperation<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>IAsyncOperation<ept id="p1">]: &lt;https://msdn.microsoft.com/library/windows/apps/BR206598&gt;</ept><bpt id="p2"> "</bpt>IAsyncOperation<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IAsyncInfo<ept id="p1">]: &lt;https://msdn.microsoft.com/library/windows/apps/BR206587&gt;</ept><bpt id="p2"> "</bpt>IAsyncInfo<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>IAsyncInfo<ept id="p1">]: &lt;https://msdn.microsoft.com/library/windows/apps/BR206587&gt;</ept><bpt id="p2"> "</bpt>IAsyncInfo<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>IAsyncInfoCancel<ept id="p1">]: &lt;https://msdn.microsoft.com/library/windows/apps/windows.foundation.iasyncinfo.cancel&gt;</ept><bpt id="p2"> "</bpt>IAsyncInfoCancel<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>IAsyncInfoCancel<ept id="p1">]: &lt;https://msdn.microsoft.com/library/windows/apps/windows.foundation.iasyncinfo.cancel&gt;</ept><bpt id="p2"> "</bpt>IAsyncInfoCancel<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>taskCanceled<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750106.aspx&gt;</ept><bpt id="p2"> "</bpt>TaskCancelled<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>taskCanceled<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750106.aspx&gt;</ept><bpt id="p2"> "</bpt>TaskCancelled<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>task-class<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750113.aspx&gt;</ept><bpt id="p2"> "</bpt>Task Class<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>task-class<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750113.aspx&gt;</ept><bpt id="p2"> "</bpt>Task Class<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>taskGet<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750017.aspx&gt;</ept><bpt id="p2"> "</bpt>TaskGet<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>taskGet<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750017.aspx&gt;</ept><bpt id="p2"> "</bpt>TaskGet<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>taskParallelism<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd492427.aspx&gt;</ept><bpt id="p2"> "</bpt>Task Parallelism<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>taskParallelism<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd492427.aspx&gt;</ept><bpt id="p2"> "</bpt>Task Parallelism<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>taskThen<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750044.aspx&gt;</ept><bpt id="p2"> "</bpt>TaskThen<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>taskThen<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750044.aspx&gt;</ept><bpt id="p2"> "</bpt>TaskThen<ept id="p2">"</ept></target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>useArbitrary<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750036.aspx&gt;</ept><bpt id="p2"> "</bpt>UseArbitrary<ept id="p2">"</ept></source>
          <target state="new"><bpt id="p1">[</bpt>useArbitrary<ept id="p1">]: &lt;https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750036.aspx&gt;</ept><bpt id="p2"> "</bpt>UseArbitrary<ept id="p2">"</ept></target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>