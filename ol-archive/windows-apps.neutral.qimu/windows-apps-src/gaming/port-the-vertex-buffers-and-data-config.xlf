<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="zh-cn" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">windows-apps-src\gaming\port-the-vertex-buffers-and-data-config.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">9692b33303099f9d1193b93ab458a19a5d95abe3</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-781aacf</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>Port the vertex buffers and data</source>
          <target>Port the vertex buffers and data</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.</source>
          <target>In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>Port the vertex buffers and data</source>
          <target>Port the vertex buffers and data</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>Updated for UWP apps on Windows 10.</source>
          <target>Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="105">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></source>
          <target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>Important APIs</source>
          <target>Important APIs</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>ID3DDevice::CreateBuffer</source>
          <target>ID3DDevice::CreateBuffer</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source>ID3DDeviceContext::IASetVertexBuffers</source>
          <target>ID3DDeviceContext::IASetVertexBuffers</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source>ID3D11DeviceContext::IASetIndexBuffer</source>
          <target>ID3D11DeviceContext::IASetIndexBuffer</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.</source>
          <target>In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source>At this point, let's examine the hardcoded model for the cube mesh we are using.</source>
          <target>At this point, let's examine the hardcoded model for the cube mesh we are using.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source>Both representations have the vertices organized as a triangle list (as opposed to a strip or other more efficient triangle layout).</source>
          <target>Both representations have the vertices organized as a triangle list (as opposed to a strip or other more efficient triangle layout).</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source>All vertices in both representations also have associated indices and color values.</source>
          <target>All vertices in both representations also have associated indices and color values.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source>Much of the Direct3D code in this topic refers to variables and objects defined in the Direct3D project.</source>
          <target>Much of the Direct3D code in this topic refers to variables and objects defined in the Direct3D project.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source>Here's the cube for processing by OpenGL ES 2.0.</source>
          <target>Here's the cube for processing by OpenGL ES 2.0.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source>In the sample implementation, each vertex is 7 float values: 3 position coordinates followed by 4 RGBA color values.</source>
          <target>In the sample implementation, each vertex is 7 float values: 3 position coordinates followed by 4 RGBA color values.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source>And here's the same cube for processing by Direct3D 11.</source>
          <target>And here's the same cube for processing by Direct3D 11.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source>Reviewing this code, you notice that the cube in the OpenGL ES 2.0 code is represented in a right-hand coordinate system, whereas the cube in the Direct3D-specific code is represented in a left-hand coordinate system.</source>
          <target>Reviewing this code, you notice that the cube in the OpenGL ES 2.0 code is represented in a right-hand coordinate system, whereas the cube in the Direct3D-specific code is represented in a left-hand coordinate system.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source>When importing your own mesh data, you must reverse the z-axis coordinates for your model and change the indices for each mesh accordingly to traverse the triangles according to the change in the coordinate system.</source>
          <target>When importing your own mesh data, you must reverse the z-axis coordinates for your model and change the indices for each mesh accordingly to traverse the triangles according to the change in the coordinate system.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source>Assuming that we have successfully moved the cube mesh from the right-handed OpenGL ES 2.0 coordinate system to the left-handed Direct3D one, let's see how to load the cube data for processing in both models.</source>
          <target>Assuming that we have successfully moved the cube mesh from the right-handed OpenGL ES 2.0 coordinate system to the left-handed Direct3D one, let's see how to load the cube data for processing in both models.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>Instructions</source>
          <target>Instructions</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>Step 1: Create an input layout</source>
          <target>Step 1: Create an input layout</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>In OpenGL ES 2.0, your vertex data is supplied as attributes that will be supplied to and read by the shader objects.</source>
          <target>In OpenGL ES 2.0, your vertex data is supplied as attributes that will be supplied to and read by the shader objects.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>You typically provide a string that contains the attribute name used in the shader's GLSL to the shader program object, and get a memory location back that you can supply to the shader.</source>
          <target>You typically provide a string that contains the attribute name used in the shader's GLSL to the shader program object, and get a memory location back that you can supply to the shader.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>In this example, a vertex buffer object contains a list of custom Vertex structures, defined and formatted as follows:</source>
          <target>In this example, a vertex buffer object contains a list of custom Vertex structures, defined and formatted as follows:</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source>OpenGL ES 2.0: Configure the attributes that contain the per-vertex information.</source>
          <target>OpenGL ES 2.0: Configure the attributes that contain the per-vertex information.</target>
        </segment>
      </unit>
      <unit id="127">
        <originalData>
          <data id="id1">\_</data>
          <data id="id2">\_</data>
          <data id="id3">\_</data>
        </originalData>
        <segment state="initial">
          <source>In OpenGL ES 2.0, input layouts are implicit; you take a general purpose GL<ph dataRef="id1" id="ph1" />ELEMENT<ph dataRef="id2" id="ph2" />ARRAY<ph dataRef="id3" id="ph3" />BUFFER and supply the stride and offset such that the vertex shader can interpret the data after uploading it.</source>
          <target>In OpenGL ES 2.0, input layouts are implicit; you take a general purpose GL<ph dataRef="id1" id="ph1" />ELEMENT<ph dataRef="id2" id="ph2" />ARRAY<ph dataRef="id3" id="ph3" />BUFFER and supply the stride and offset such that the vertex shader can interpret the data after uploading it.</target>
        </segment>
      </unit>
      <unit id="128">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>You inform the shader before rendering which attributes map to which portions of each block of vertex data with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">glVertexAttribPointer</pc>.</source>
          <target>You inform the shader before rendering which attributes map to which portions of each block of vertex data with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">glVertexAttribPointer</pc>.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source>In Direct3D, you must provide an input layout to describe the structure of the vertex data in the vertex buffer when you create the buffer, instead of before you draw the geometry.</source>
          <target>In Direct3D, you must provide an input layout to describe the structure of the vertex data in the vertex buffer when you create the buffer, instead of before you draw the geometry.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source>To do this, you use an input layout which corresponds to layout of the data for our individual vertices in memory.</source>
          <target>To do this, you use an input layout which corresponds to layout of the data for our individual vertices in memory.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>It is very important to specify this accurately!</source>
          <target>It is very important to specify this accurately!</target>
        </segment>
      </unit>
      <unit id="132">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">\_</data>
          <data id="id6">\_</data>
          <data id="id7">\_</data>
        </originalData>
        <segment state="initial">
          <source>Here, you create an input description as an array of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11<ph dataRef="id5" id="ph1" />INPUT<ph dataRef="id6" id="ph2" />ELEMENT<ph dataRef="id7" id="ph3" />DESC</pc></pc> structures.</source>
          <target>Here, you create an input description as an array of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11<ph dataRef="id5" id="ph1" />INPUT<ph dataRef="id6" id="ph2" />ELEMENT<ph dataRef="id7" id="ph3" />DESC</pc></pc> structures.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>Direct3D: Define an input layout description.</source>
          <target>Direct3D: Define an input layout description.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>This input description defines a vertex as a pair of 2 3-coordinate vectors: one 3D vector to store the position of the vertex in model coordinates, and another 3D vector to store the RGB color value associated with the vertex.</source>
          <target>This input description defines a vertex as a pair of 2 3-coordinate vectors: one 3D vector to store the position of the vertex in model coordinates, and another 3D vector to store the RGB color value associated with the vertex.</target>
        </segment>
      </unit>
      <unit id="135">
        <originalData>
          <data id="id1">`XMFLOAT3(X.Xf, X.Xf, X.Xf)`</data>
        </originalData>
        <segment state="initial">
          <source>In this case, you use 3x32 bit floating point format, elements of which we represent in code as <ph dataRef="id1" id="ph1" />.</source>
          <target>In this case, you use 3x32 bit floating point format, elements of which we represent in code as <ph dataRef="id1" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="136">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ee415574)</data>
        </originalData>
        <segment state="initial">
          <source>You should use types from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXMath</pc> library whenever you are handling data that will be used by a shader, as it ensure the proper packing and alignment of that data.</source>
          <target>You should use types from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DirectXMath</pc> library whenever you are handling data that will be used by a shader, as it ensure the proper packing and alignment of that data.</target>
        </segment>
      </unit>
      <unit id="137">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ee419475)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ee419608)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/desktop/ee419621)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source>(For example, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XMFLOAT3</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">XMFLOAT4</pc></pc> for vector data, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">XMFLOAT4X4</pc></pc> for matrices.)</source>
          <target>(For example, use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XMFLOAT3</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">XMFLOAT4</pc></pc> for vector data, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">XMFLOAT4X4</pc></pc> for matrices.)</target>
        </segment>
      </unit>
      <unit id="138">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">\_</data>
        </originalData>
        <segment state="initial">
          <source>For a list of all the possible format types, refer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI<ph dataRef="id5" id="ph1" />FORMAT</pc></pc>.</source>
          <target>For a list of all the possible format types, refer to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DXGI<ph dataRef="id5" id="ph1" />FORMAT</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source>With the per-vertex input layout defined, you create the layout object.</source>
          <target>With the per-vertex input layout defined, you create the layout object.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">[</data>
          <data id="id7">](https://msdn.microsoft.com/library/windows/desktop/ff476575)</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
        </originalData>
        <segment state="initial">
          <source>In the following code, you write it to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m<ph dataRef="id3" id="ph1" />inputLayout</pc>, a variable of type <pc dataRefEnd="id5" dataRefStart="id4" id="p2">ComPtr</pc> (which points to an object of type <pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">ID3D11InputLayout</pc></pc>).</source>
          <target>In the following code, you write it to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">m<ph dataRef="id3" id="ph1" />inputLayout</pc>, a variable of type <pc dataRefEnd="id5" dataRefStart="id4" id="p2">ComPtr</pc> (which points to an object of type <pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">ID3D11InputLayout</pc></pc>).</target>
        </segment>
      </unit>
      <unit id="141">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](port-the-shader-config.md)</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">fileData</pc> contains the compiled vertex shader object from the previous step, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Port the shaders</pc>.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">fileData</pc> contains the compiled vertex shader object from the previous step, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Port the shaders</pc>.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source>Direct3D: Create the input layout used by the vertex buffer.</source>
          <target>Direct3D: Create the input layout used by the vertex buffer.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source>We've defined the input layout.</source>
          <target>We've defined the input layout.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>Now, let's create a buffer that uses this layout and load it with the cube mesh data.</source>
          <target>Now, let's create a buffer that uses this layout and load it with the cube mesh data.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source>Step 2: Create and load the vertex buffer(s)</source>
          <target>Step 2: Create and load the vertex buffer(s)</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source>In OpenGL ES 2.0, you create a pair of buffers, one for the position data and one for the color data.</source>
          <target>In OpenGL ES 2.0, you create a pair of buffers, one for the position data and one for the color data.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source>(You could also create a struct that contains both and a single buffer.) You bind each buffer and write position and color data into them.</source>
          <target>(You could also create a struct that contains both and a single buffer.) You bind each buffer and write position and color data into them.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source>Later, during your render function, bind the buffers again and provide the shader with the format of the data in the buffer so it can correctly interpret it.</source>
          <target>Later, during your render function, bind the buffers again and provide the shader with the format of the data in the buffer so it can correctly interpret it.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>OpenGL ES 2.0: Bind the vertex buffers</source>
          <target>OpenGL ES 2.0: Bind the vertex buffers</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">\_</data>
          <data id="id6">\_</data>
        </originalData>
        <segment state="initial">
          <source>In Direct3D, shader-accessible buffers are represented as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11<ph dataRef="id5" id="ph1" />SUBRESOURCE<ph dataRef="id6" id="ph2" />DATA</pc></pc> structures.</source>
          <target>In Direct3D, shader-accessible buffers are represented as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">D3D11<ph dataRef="id5" id="ph1" />SUBRESOURCE<ph dataRef="id6" id="ph2" />DATA</pc></pc> structures.</target>
        </segment>
      </unit>
      <unit id="151">
        <originalData>
          <data id="id1">\_</data>
          <data id="id2">\_</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source>To bind the location of this buffer to shader object, you need to create a CD3D11<ph dataRef="id1" id="ph1" />BUFFER<ph dataRef="id2" id="ph2" />DESC structure for each buffer with <pc dataRefEnd="id4" dataRefStart="id3" id="p1"><pc dataRefEnd="id6" dataRefStart="id5" id="p2">ID3DDevice::CreateBuffer</pc></pc>, and then set the buffer of the Direct3D device context by calling a set method specific to the buffer type, such as <pc dataRefEnd="id8" dataRefStart="id7" id="p3"><pc dataRefEnd="id10" dataRefStart="id9" id="p4">ID3DDeviceContext::IASetVertexBuffers</pc></pc>.</source>
          <target>To bind the location of this buffer to shader object, you need to create a CD3D11<ph dataRef="id1" id="ph1" />BUFFER<ph dataRef="id2" id="ph2" />DESC structure for each buffer with <pc dataRefEnd="id4" dataRefStart="id3" id="p1"><pc dataRefEnd="id6" dataRefStart="id5" id="p2">ID3DDevice::CreateBuffer</pc></pc>, and then set the buffer of the Direct3D device context by calling a set method specific to the buffer type, such as <pc dataRefEnd="id8" dataRefStart="id7" id="p3"><pc dataRefEnd="id10" dataRefStart="id9" id="p4">ID3DDeviceContext::IASetVertexBuffers</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>When you set the buffer, you must set the stride (the size of the data element for an individual vertex) as well the offset (where the vertex data array actually starts) from the beginning of the buffer.</source>
          <target>When you set the buffer, you must set the stride (the size of the data element for an individual vertex) as well the offset (where the vertex data array actually starts) from the beginning of the buffer.</target>
        </segment>
      </unit>
      <unit id="153">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">\_</data>
          <data id="id10">\_</data>
        </originalData>
        <segment state="initial">
          <source>Notice that we assign the pointer to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">vertexIndices</pc> array to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">pSysMem</pc> field of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">D3D11<ph dataRef="id9" id="ph1" />SUBRESOURCE<ph dataRef="id10" id="ph2" />DATA</pc></pc> structure.</source>
          <target>Notice that we assign the pointer to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">vertexIndices</pc> array to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">pSysMem</pc> field of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">D3D11<ph dataRef="id9" id="ph1" />SUBRESOURCE<ph dataRef="id10" id="ph2" />DATA</pc></pc> structure.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>If this isn't correct, your mesh will be corrupt or empty!</source>
          <target>If this isn't correct, your mesh will be corrupt or empty!</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>Direct3D: Create and set the vertex buffer</source>
          <target>Direct3D: Create and set the vertex buffer</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source>Step 3: Create and load the index buffer</source>
          <target>Step 3: Create and load the index buffer</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source>Index buffers are an efficient way to allow the vertex shader to look up individual vertices.</source>
          <target>Index buffers are an efficient way to allow the vertex shader to look up individual vertices.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>Although they are not required, we use them in this sample renderer.</source>
          <target>Although they are not required, we use them in this sample renderer.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>As with vertex buffers in OpenGL ES 2.0, an index buffer is created and bound as a general purpose buffer and the vertex indices you created earlier are copied into it.</source>
          <target>As with vertex buffers in OpenGL ES 2.0, an index buffer is created and bound as a general purpose buffer and the vertex indices you created earlier are copied into it.</target>
        </segment>
      </unit>
      <unit id="160">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>When you're ready to draw, you bind both the vertex and the index buffer again, and call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">glDrawElements</pc>.</source>
          <target>When you're ready to draw, you bind both the vertex and the index buffer again, and call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">glDrawElements</pc>.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source>OpenGL ES 2.0: Send the index order to the draw call.</source>
          <target>OpenGL ES 2.0: Send the index order to the draw call.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source>With Direct3D, it's a bit very similar process, albeit a bit more didactic.</source>
          <target>With Direct3D, it's a bit very similar process, albeit a bit more didactic.</target>
        </segment>
      </unit>
      <unit id="163">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Supply the index buffer as a Direct3D subresource to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc> you created when you configured Direct3D.</source>
          <target>Supply the index buffer as a Direct3D subresource to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc> you created when you configured Direct3D.</target>
        </segment>
      </unit>
      <unit id="164">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/bb173588)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>You do this by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::IASetIndexBuffer</pc></pc> with the configured subresource for the index array, as follows.</source>
          <target>You do this by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::IASetIndexBuffer</pc></pc> with the configured subresource for the index array, as follows.</target>
        </segment>
      </unit>
      <unit id="165">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">\_</data>
          <data id="id10">\_</data>
        </originalData>
        <segment state="initial">
          <source>(Again, notice that you assign the pointer to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cubeIndices</pc> array to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">pSysMem</pc> field of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">D3D11<ph dataRef="id9" id="ph1" />SUBRESOURCE<ph dataRef="id10" id="ph2" />DATA</pc></pc> structure.)</source>
          <target>(Again, notice that you assign the pointer to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cubeIndices</pc> array to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">pSysMem</pc> field of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">D3D11<ph dataRef="id9" id="ph1" />SUBRESOURCE<ph dataRef="id10" id="ph2" />DATA</pc></pc> structure.)</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source>Direct3D: Create the index buffer.</source>
          <target>Direct3D: Create the index buffer.</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476407)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source>Later, you will draw the triangles with a call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::DrawIndexed</pc></pc> (or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext::Draw</pc></pc> for unindexed vertices), as follows.</source>
          <target>Later, you will draw the triangles with a call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext::DrawIndexed</pc></pc> (or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext::Draw</pc></pc> for unindexed vertices), as follows.</target>
        </segment>
      </unit>
      <unit id="168">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](draw-to-the-screen.md)</data>
        </originalData>
        <segment state="initial">
          <source>(For more details, jump ahead to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Draw to the screen</pc>.)</source>
          <target>(For more details, jump ahead to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Draw to the screen</pc>.)</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>Direct3D: Draw the indexed vertices.</source>
          <target>Direct3D: Draw the indexed vertices.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source>Previous step</source>
          <target>Previous step</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source>Port the shader objects</source>
          <target>Port the shader objects</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source>Next step</source>
          <target>Next step</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source>Port the GLSL</source>
          <target>Port the GLSL</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source>Remarks</source>
          <target>Remarks</target>
        </segment>
      </unit>
      <unit id="175">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>When structuring your Direct3D, separate the code that calls methods on <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device</pc></pc> into a method that is called whenever the device resources need to be recreated.</source>
          <target>When structuring your Direct3D, separate the code that calls methods on <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device</pc></pc> into a method that is called whenever the device resources need to be recreated.</target>
        </segment>
      </unit>
      <unit id="176">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>(In the Direct3D project template, this code is in the renderer object's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResource</pc> methods.</source>
          <target>(In the Direct3D project template, this code is in the renderer object's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResource</pc> methods.</target>
        </segment>
      </unit>
      <unit id="177">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>The code that updates the device context (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc>), on the other hand, is placed in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Render</pc> method, since this is where you actually construct the shader stages and bind the data.</source>
          <target>The code that updates the device context (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext</pc></pc>), on the other hand, is placed in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Render</pc> method, since this is where you actually construct the shader stages and bind the data.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source>Related topics</source>
          <target>Related topics</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</source>
          <target>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source>Port the shader objects</source>
          <target>Port the shader objects</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source>Port the vertex buffers and data</source>
          <target>Port the vertex buffers and data</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source>Port the GLSL</source>
          <target>Port the GLSL</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>