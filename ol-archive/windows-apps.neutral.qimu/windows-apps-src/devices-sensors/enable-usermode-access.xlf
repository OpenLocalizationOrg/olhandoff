<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="zh-cn" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">windows-apps-src\devices-sensors\enable-usermode-access.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">eedabee593400ff0260b6d3468ac922285a034f8</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-781aacf</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>Enable usermode access on Windows 10 IoT Core</source>
          <target>Enable usermode access on Windows 10 IoT Core</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>This tutorial describes how to enable usermode access to GPIO, I2C, SPI, and UART on Windows 10 IoT Core.</source>
          <target>This tutorial describes how to enable usermode access to GPIO, I2C, SPI, and UART on Windows 10 IoT Core.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>Enable usermode access on Windows 10 IoT Core</source>
          <target>Enable usermode access on Windows 10 IoT Core</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>Updated for UWP apps on Windows 10.</source>
          <target>Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="105">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></source>
          <target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>Windows 10 IoT Core contains new APIs for accessing GPIO, I2C, SPI, and UART directly from usermode.</source>
          <target>Windows 10 IoT Core contains new APIs for accessing GPIO, I2C, SPI, and UART directly from usermode.</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>Development boards like Raspberry Pi 2 expose a subset of these connections which enable users to extend a base compute module with custom circuitry to address a particular application.</source>
          <target>Development boards like Raspberry Pi 2 expose a subset of these connections which enable users to extend a base compute module with custom circuitry to address a particular application.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source>These low level buses are usually shared with other critical onboard functions, with only a subset of GPIO pins and buses exposed on headers.</source>
          <target>These low level buses are usually shared with other critical onboard functions, with only a subset of GPIO pins and buses exposed on headers.</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source>To preserve system stability, it is necessary to specify which pins and buses are safe for modification by usermode applications.</source>
          <target>To preserve system stability, it is necessary to specify which pins and buses are safe for modification by usermode applications.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>This document describes how to specify this configuration in ACPI and provides tools to validate that the configuration was specified correctly.</source>
          <target>This document describes how to specify this configuration in ACPI and provides tools to validate that the configuration was specified correctly.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source>The audience for this document is UEFI and ACPI developers.</source>
          <target>The audience for this document is UEFI and ACPI developers.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source>Some familiarity with ACPI, ASL authoring, and SpbCx/GpioClx is assumed.</source>
          <target>Some familiarity with ACPI, ASL authoring, and SpbCx/GpioClx is assumed.</target>
        </segment>
      </unit>
      <unit id="113">
        <originalData>
          <data id="id1">`GpioClx`</data>
          <data id="id2">`SpbCx`</data>
        </originalData>
        <segment state="initial">
          <source>Usermode access to low level buses on Windows is plumbed through the existing <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> frameworks.</source>
          <target>Usermode access to low level buses on Windows is plumbed through the existing <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> frameworks.</target>
        </segment>
      </unit>
      <unit id="114">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">`GpioClx`</data>
          <data id="id4">`SpbCx`</data>
        </originalData>
        <segment state="initial">
          <source>A new driver called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RhProxy</pc>, only available on Windows 10 IoT Core, exposes <ph dataRef="id3" id="ph1" /> and <ph dataRef="id4" id="ph2" /> resources to usermode.</source>
          <target>A new driver called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RhProxy</pc>, only available on Windows 10 IoT Core, exposes <ph dataRef="id3" id="ph1" /> and <ph dataRef="id4" id="ph2" /> resources to usermode.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source>To enable the APIs, a device node for rhproxy must be declared in your ACPI tables with each of the GPIO and SPB resources that should be exposed to usermode.</source>
          <target>To enable the APIs, a device node for rhproxy must be declared in your ACPI tables with each of the GPIO and SPB resources that should be exposed to usermode.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source>This document walks through authoring and verifying the ASL.</source>
          <target>This document walks through authoring and verifying the ASL.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source>ASL by example</source>
          <target>ASL by example</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source>Let’s walk through the rhproxy device node declaration on Raspberry Pi 2.</source>
          <target>Let’s walk through the rhproxy device node declaration on Raspberry Pi 2.</target>
        </segment>
      </unit>
      <unit id="119">
        <originalData>
          <data id="id1">\\</data>
        </originalData>
        <segment state="initial">
          <source>First, create the ACPI device declaration in the <ph dataRef="id1" id="ph1" />_SB scope.</source>
          <target>First, create the ACPI device declaration in the <ph dataRef="id1" id="ph1" />_SB scope.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source>_HID – Hardware Id.</source>
          <target>_HID – Hardware Id.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>Set this to a vendor-specific hardware ID.</source>
          <target>Set this to a vendor-specific hardware ID.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>_CID – Compatible Id.</source>
          <target>_CID – Compatible Id.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>Must be “MSFT8000”.</source>
          <target>Must be “MSFT8000”.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>_UID – Unique Id.</source>
          <target>_UID – Unique Id.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>Set to 1.</source>
          <target>Set to 1.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source>Next we declare each of the GPIO and SPB resources that should be exposed to usermode.</source>
          <target>Next we declare each of the GPIO and SPB resources that should be exposed to usermode.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source>The order in which resources are declared is important because resource indexes are used to associate properties with resources.</source>
          <target>The order in which resources are declared is important because resource indexes are used to associate properties with resources.</target>
        </segment>
      </unit>
      <unit id="128">
        <originalData>
          <data id="id1">`GetDefaultAsync()`</data>
          <data id="id2">[</data>
          <data id="id3">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.devices.i2c.i2ccontroller.aspx)</data>
          <data id="id4">[</data>
          <data id="id5">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.devices.spi.spicontroller.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>If there are multiple I2C or SPI busses exposed, the first declared bus is considered the ‘default’ bus for that type, and will be the instance returned by the <ph dataRef="id1" id="ph1" /> methods of <pc dataRefEnd="id3" dataRefStart="id2" id="p1">Windows.Devices.I2c.I2cController</pc> and <pc dataRefEnd="id5" dataRefStart="id4" id="p2">Windows.Devices.Spi.SpiController</pc>.</source>
          <target>If there are multiple I2C or SPI busses exposed, the first declared bus is considered the ‘default’ bus for that type, and will be the instance returned by the <ph dataRef="id1" id="ph1" /> methods of <pc dataRefEnd="id3" dataRefStart="id2" id="p1">Windows.Devices.I2c.I2cController</pc> and <pc dataRefEnd="id5" dataRefStart="id4" id="p2">Windows.Devices.Spi.SpiController</pc>.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source>SPI</source>
          <target>SPI</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source>Raspberry Pi has two exposed SPI buses.</source>
          <target>Raspberry Pi has two exposed SPI buses.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>SPI0 has two hardware chip select lines and SPI1 has one hardware chip select line.</source>
          <target>SPI0 has two hardware chip select lines and SPI1 has one hardware chip select line.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>One SPISerialBus() resource declaration is required for each chip select line for each bus.</source>
          <target>One SPISerialBus() resource declaration is required for each chip select line for each bus.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>The following two SPISerialBus resource declarations are for the two chip select lines on SPI0.</source>
          <target>The following two SPISerialBus resource declarations are for the two chip select lines on SPI0.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>The DeviceSelection field contains a unique value which the driver interprets as a hardware chip select line identifier.</source>
          <target>The DeviceSelection field contains a unique value which the driver interprets as a hardware chip select line identifier.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source>The exact value that you put in the DeviceSelection field depends on how your driver interprets this field of the ACPI connection descriptor.</source>
          <target>The exact value that you put in the DeviceSelection field depends on how your driver interprets this field of the ACPI connection descriptor.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source>How does software know that these two resources should be associated with the same bus?</source>
          <target>How does software know that these two resources should be associated with the same bus?</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>The mapping between bus friendly name and resource index is specified in the DSD:</source>
          <target>The mapping between bus friendly name and resource index is specified in the DSD:</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source>This creates a bus named “SPI0” with two chip select lines – resource indexes 0 and 1.</source>
          <target>This creates a bus named “SPI0” with two chip select lines – resource indexes 0 and 1.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source>Several more properties are required to declare the capabilities of the SPI bus.</source>
          <target>Several more properties are required to declare the capabilities of the SPI bus.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MinClockInHz</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MaxClockInHz</pc> properties specify the minimum and maximum clock speeds that are supported by the controller.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MinClockInHz</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MaxClockInHz</pc> properties specify the minimum and maximum clock speeds that are supported by the controller.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source>The API will prevent users from specifying values outside this range.</source>
          <target>The API will prevent users from specifying values outside this range.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source>The clock speed is passed to your SPB driver in the _SPE field of the connection descriptor (ACPI section 6.4.3.8.2.2).</source>
          <target>The clock speed is passed to your SPB driver in the _SPE field of the connection descriptor (ACPI section 6.4.3.8.2.2).</target>
        </segment>
      </unit>
      <unit id="143">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SupportedDataBitLengths</pc> property lists the data bit lengths supported by the controller.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SupportedDataBitLengths</pc> property lists the data bit lengths supported by the controller.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>Multiple values can be specified in a comma-separated list.</source>
          <target>Multiple values can be specified in a comma-separated list.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source>The API will prevent users from specifying values outside this list.</source>
          <target>The API will prevent users from specifying values outside this list.</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source>The data bit length is passed to your SPB driver in the _LEN field of the connection descriptor (ACPI section 6.4.3.8.2.2).</source>
          <target>The data bit length is passed to your SPB driver in the _LEN field of the connection descriptor (ACPI section 6.4.3.8.2.2).</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source>You can think of these resource declarations as “templates.”</source>
          <target>You can think of these resource declarations as “templates.”</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source>Some of the fields are fixed at system boot while others are specified dynamically at runtime.</source>
          <target>Some of the fields are fixed at system boot while others are specified dynamically at runtime.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>The following fields of the SPISerialBus descriptor are fixed:</source>
          <target>The following fields of the SPISerialBus descriptor are fixed:</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source>DeviceSelection</source>
          <target>DeviceSelection</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source>DeviceSelectionPolarity</source>
          <target>DeviceSelectionPolarity</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>WireMode</source>
          <target>WireMode</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source>SlaveMode</source>
          <target>SlaveMode</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>ResourceSource</source>
          <target>ResourceSource</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>The following fields are placeholders for values specified by the user at runtime:</source>
          <target>The following fields are placeholders for values specified by the user at runtime:</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source>DataBitLength</source>
          <target>DataBitLength</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source>ConnectionSpeed</source>
          <target>ConnectionSpeed</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>ClockPolarity</source>
          <target>ClockPolarity</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>ClockPhase</source>
          <target>ClockPhase</target>
        </segment>
      </unit>
      <unit id="160">
        <originalData>
          <data id="id1">`SPISerialBus()`</data>
        </originalData>
        <segment state="initial">
          <source>Since SPI1 contains only a single chip select line, a single <ph dataRef="id1" id="ph1" /> resource is declared:</source>
          <target>Since SPI1 contains only a single chip select line, a single <ph dataRef="id1" id="ph1" /> resource is declared:</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source>The accompanying friendly name declaration – which is required – is specified in the DSD and refers to the index of this resource declaration.</source>
          <target>The accompanying friendly name declaration – which is required – is specified in the DSD and refers to the index of this resource declaration.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source>This creates a bus named “SPI1” and associates it with resource index 2.</source>
          <target>This creates a bus named “SPI1” and associates it with resource index 2.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source>SPI Driver Requirements</source>
          <target>SPI Driver Requirements</target>
        </segment>
      </unit>
      <unit id="164">
        <originalData>
          <data id="id1">`SpbCx`</data>
        </originalData>
        <segment state="initial">
          <source>Must use <ph dataRef="id1" id="ph1" /> or be SpbCx-compatible</source>
          <target>Must use <ph dataRef="id1" id="ph1" /> or be SpbCx-compatible</target>
        </segment>
      </unit>
      <unit id="165">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/dn919873.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>Must have passed the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MITT SPI Tests</pc></source>
          <target>Must have passed the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MITT SPI Tests</pc></target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source>Must support 4Mhz clock speed</source>
          <target>Must support 4Mhz clock speed</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source>Must support 8-bit data length</source>
          <target>Must support 8-bit data length</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source>Must support all SPI Modes: 0, 1, 2, 3</source>
          <target>Must support all SPI Modes: 0, 1, 2, 3</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>I2C</source>
          <target>I2C</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source>Next, we declare the I2C resources.</source>
          <target>Next, we declare the I2C resources.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source>Raspberry Pi exposes a single I2C bus on pins 3 and 5.</source>
          <target>Raspberry Pi exposes a single I2C bus on pins 3 and 5.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source>The accompanying friendly name declaration – which is required – is specified in the DSD:</source>
          <target>The accompanying friendly name declaration – which is required – is specified in the DSD:</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source>This declares an I2C bus with friendly name “I2C1” that refers to resource index 3, which is the index of the I2CSerialBus() resource that we declared above.</source>
          <target>This declares an I2C bus with friendly name “I2C1” that refers to resource index 3, which is the index of the I2CSerialBus() resource that we declared above.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source>The following fields of the I2CSerialBus() descriptor are fixed:</source>
          <target>The following fields of the I2CSerialBus() descriptor are fixed:</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source>SlaveMode</source>
          <target>SlaveMode</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source>ResourceSource</source>
          <target>ResourceSource</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source>The following fields are placeholders for values specified by the user at runtime.</source>
          <target>The following fields are placeholders for values specified by the user at runtime.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source>SlaveAddress</source>
          <target>SlaveAddress</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source>ConnectionSpeed</source>
          <target>ConnectionSpeed</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source>AddressingMode</source>
          <target>AddressingMode</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source>I2C Driver Requirements</source>
          <target>I2C Driver Requirements</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source>Must use SpbCx or be SpbCx-compatible</source>
          <target>Must use SpbCx or be SpbCx-compatible</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/dn919852.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>Must have passed the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MITT I2C Tests</pc></source>
          <target>Must have passed the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MITT I2C Tests</pc></target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source>Must support 7-bit addressing</source>
          <target>Must support 7-bit addressing</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source>Must support 100kHz clock speed</source>
          <target>Must support 100kHz clock speed</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source>Must support 400kHz clock speed</source>
          <target>Must support 400kHz clock speed</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source>GPIO</source>
          <target>GPIO</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source>Next, we declare all the GPIO pins that are exposed to usermode.</source>
          <target>Next, we declare all the GPIO pins that are exposed to usermode.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source>We offer the following guidance in deciding which pins to expose:</source>
          <target>We offer the following guidance in deciding which pins to expose:</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source>Declare all pins on exposed headers.</source>
          <target>Declare all pins on exposed headers.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source>Declare pins that are connected to useful onboard functions like buttons and LEDs.</source>
          <target>Declare pins that are connected to useful onboard functions like buttons and LEDs.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source>Do not declare pins that are reserved for system functions or are not connected to anything.</source>
          <target>Do not declare pins that are reserved for system functions or are not connected to anything.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source>The following block of ASL declares two pins – GPIO4 and GPIO5.</source>
          <target>The following block of ASL declares two pins – GPIO4 and GPIO5.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source>The other pins are not shown here for brevity.</source>
          <target>The other pins are not shown here for brevity.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source>Appendix C contains a sample powershell script which can be used to generate the GPIO resources.</source>
          <target>Appendix C contains a sample powershell script which can be used to generate the GPIO resources.</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source>The following requirements must be observed when declaring GPIO pins:</source>
          <target>The following requirements must be observed when declaring GPIO pins:</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source>Only memory mapped GPIO controllers are supported.</source>
          <target>Only memory mapped GPIO controllers are supported.</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source>GPIO controllers interfaced over I2C/SPI are not supported.</source>
          <target>GPIO controllers interfaced over I2C/SPI are not supported.</target>
        </segment>
      </unit>
      <unit id="199">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/hh439449.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/hardware/hh439358.aspx)</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/hardware/hh439399.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>The controller driver is a memory mapped controller if it sets the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MemoryMappedController</pc> flag in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CLIENT_CONTROLLER_BASIC_INFORMATION</pc> structure in response to the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CLIENT_QueryControllerBasicInformation</pc> callback.</source>
          <target>The controller driver is a memory mapped controller if it sets the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MemoryMappedController</pc> flag in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CLIENT_CONTROLLER_BASIC_INFORMATION</pc> structure in response to the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CLIENT_QueryControllerBasicInformation</pc> callback.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source>Each pin requires both a GpioIO and a GpioInt resource.</source>
          <target>Each pin requires both a GpioIO and a GpioInt resource.</target>
        </segment>
      </unit>
      <unit id="201">
        <segment state="initial">
          <source>The GpioInt resource must immediately follow the GpioIO resource and must refer to the same pin number.</source>
          <target>The GpioInt resource must immediately follow the GpioIO resource and must refer to the same pin number.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source>GPIO resources must be ordered by increasing pin number.</source>
          <target>GPIO resources must be ordered by increasing pin number.</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source>Each GpioIO and GpioInt resource must contain exactly one pin number in the pin list.</source>
          <target>Each GpioIO and GpioInt resource must contain exactly one pin number in the pin list.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source>The ShareType field of both descriptors must be Shared</source>
          <target>The ShareType field of both descriptors must be Shared</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source>The EdgeLevel field of the GpioInt descriptor must be Edge</source>
          <target>The EdgeLevel field of the GpioInt descriptor must be Edge</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source>The ActiveLevel field of the GpioInt descriptor must be ActiveBoth</source>
          <target>The ActiveLevel field of the GpioInt descriptor must be ActiveBoth</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source>The PinConfig field</source>
          <target>The PinConfig field</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source>Must be the same in both the GpioIO and GpioInt descriptors</source>
          <target>Must be the same in both the GpioIO and GpioInt descriptors</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source>Must be one of PullUp, PullDown, or PullNone.</source>
          <target>Must be one of PullUp, PullDown, or PullNone.</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source>It cannot be PullDefault.</source>
          <target>It cannot be PullDefault.</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source>The pull configuration must match the power-on state of the pin.</source>
          <target>The pull configuration must match the power-on state of the pin.</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source>Putting the pin in the specified pull mode from power-on state must not change the state of the pin.</source>
          <target>Putting the pin in the specified pull mode from power-on state must not change the state of the pin.</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source>For example, if the datasheet specifies that the pin comes up with a pull up, specify PinConfig as PullUp.</source>
          <target>For example, if the datasheet specifies that the pin comes up with a pull up, specify PinConfig as PullUp.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source>Firmware, UEFI, and driver initialization code should not change the state of a pin from its power-on state during boot.</source>
          <target>Firmware, UEFI, and driver initialization code should not change the state of a pin from its power-on state during boot.</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source>Only the user knows what’s attached to a pin and therefore which state transitions are safe.</source>
          <target>Only the user knows what’s attached to a pin and therefore which state transitions are safe.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source>The power-on state of each pin must be documented so that users can design hardware that correctly interfaces with a pin.</source>
          <target>The power-on state of each pin must be documented so that users can design hardware that correctly interfaces with a pin.</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source>A pin must not change state unexpectedly during boot.</source>
          <target>A pin must not change state unexpectedly during boot.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source>If an exposed pin has multiple alternate functions, it is the responsibility of firmware to initialize the pin in the correct mux configuration for subsequent use by the OS.</source>
          <target>If an exposed pin has multiple alternate functions, it is the responsibility of firmware to initialize the pin in the correct mux configuration for subsequent use by the OS.</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source>Dynamically changing the function of a pin (“muxing”) is not currently supported on Windows.</source>
          <target>Dynamically changing the function of a pin (“muxing”) is not currently supported on Windows.</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source>Supported Drive Modes</source>
          <target>Supported Drive Modes</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source>If your GPIO controller supports built-in pull up and pull down resistors in addition to high impedance input and CMOS output, you must specify this with the optional SupportedDriveModes property.</source>
          <target>If your GPIO controller supports built-in pull up and pull down resistors in addition to high impedance input and CMOS output, you must specify this with the optional SupportedDriveModes property.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source>The SupportedDriveModes property indicates which drive modes are supported by the GPIO controller.</source>
          <target>The SupportedDriveModes property indicates which drive modes are supported by the GPIO controller.</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source>In the example above, all of the following drive modes are supported.</source>
          <target>In the example above, all of the following drive modes are supported.</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source>The property is a bitmask of the following values:</source>
          <target>The property is a bitmask of the following values:</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source>Flag Value</source>
          <target>Flag Value</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source>Drive Mode</source>
          <target>Drive Mode</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source>0x1</source>
          <target>0x1</target>
        </segment>
      </unit>
      <unit id="229">
        <segment state="initial">
          <source>InputHighImpedance</source>
          <target>InputHighImpedance</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source>The pin supports high impedance input, which corresponds to the “PullNone” value in ACPI.</source>
          <target>The pin supports high impedance input, which corresponds to the “PullNone” value in ACPI.</target>
        </segment>
      </unit>
      <unit id="231">
        <segment state="initial">
          <source>0x2</source>
          <target>0x2</target>
        </segment>
      </unit>
      <unit id="232">
        <segment state="initial">
          <source>InputPullUp</source>
          <target>InputPullUp</target>
        </segment>
      </unit>
      <unit id="233">
        <segment state="initial">
          <source>The pin supports a built-in pull-up resistor, which corresponds to the “PullUp” value in ACPI.</source>
          <target>The pin supports a built-in pull-up resistor, which corresponds to the “PullUp” value in ACPI.</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source>0x4</source>
          <target>0x4</target>
        </segment>
      </unit>
      <unit id="235">
        <segment state="initial">
          <source>InputPullDown</source>
          <target>InputPullDown</target>
        </segment>
      </unit>
      <unit id="236">
        <segment state="initial">
          <source>The pin supports a built-in pull-down resistor, which corresponds to the “PullDown” value in ACPI.</source>
          <target>The pin supports a built-in pull-down resistor, which corresponds to the “PullDown” value in ACPI.</target>
        </segment>
      </unit>
      <unit id="237">
        <segment state="initial">
          <source>0x8</source>
          <target>0x8</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source>OutputCmos</source>
          <target>OutputCmos</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source>The pin supports generating both strong highs and strong lows (as opposed to open drain).</source>
          <target>The pin supports generating both strong highs and strong lows (as opposed to open drain).</target>
        </segment>
      </unit>
      <unit id="240">
        <segment state="initial">
          <source>InputHighImpedance and OutputCmos are supported by almost all GPIO controllers.</source>
          <target>InputHighImpedance and OutputCmos are supported by almost all GPIO controllers.</target>
        </segment>
      </unit>
      <unit id="241">
        <segment state="initial">
          <source>If the SupportedDriveModes property is not specified, this is the default.</source>
          <target>If the SupportedDriveModes property is not specified, this is the default.</target>
        </segment>
      </unit>
      <unit id="242">
        <segment state="initial">
          <source>If a GPIO signal goes through a level shifter before reaching an exposed header, declare the drive modes supported by the SOC, even if the drive mode would not be observable on the external header.</source>
          <target>If a GPIO signal goes through a level shifter before reaching an exposed header, declare the drive modes supported by the SOC, even if the drive mode would not be observable on the external header.</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source>For example, if a pin goes through a bidirectional level shifter that makes a pin appear as open drain with resistive pull up, you will never observe a high impedance state on the exposed header even if the pin is configured as a high impedance input.</source>
          <target>For example, if a pin goes through a bidirectional level shifter that makes a pin appear as open drain with resistive pull up, you will never observe a high impedance state on the exposed header even if the pin is configured as a high impedance input.</target>
        </segment>
      </unit>
      <unit id="244">
        <segment state="initial">
          <source>You should still declare that the pin supports high impedance input.</source>
          <target>You should still declare that the pin supports high impedance input.</target>
        </segment>
      </unit>
      <unit id="245">
        <segment state="initial">
          <source>Pin Numbering</source>
          <target>Pin Numbering</target>
        </segment>
      </unit>
      <unit id="246">
        <segment state="initial">
          <source>Windows supports two pin numbering schemes:</source>
          <target>Windows supports two pin numbering schemes:</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source>Sequential Pin Numbering – Users see numbers like 0, 1, 2 …</source>
          <target>Sequential Pin Numbering – Users see numbers like 0, 1, 2 …</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source>up to the number of exposed pins.</source>
          <target>up to the number of exposed pins.</target>
        </segment>
      </unit>
      <unit id="249">
        <segment state="initial">
          <source>0 is the first GpioIo resource declared in ASL, 1 is the second GpioIo resource declared in ASL, and so on.</source>
          <target>0 is the first GpioIo resource declared in ASL, 1 is the second GpioIo resource declared in ASL, and so on.</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source>Native Pin Numbering – Users see the pin numbers specified in GpioIo descriptors, e.g. 4, 5, 12, 13, …</source>
          <target>Native Pin Numbering – Users see the pin numbers specified in GpioIo descriptors, e.g. 4, 5, 12, 13, …</target>
        </segment>
      </unit>
      <unit id="251">
        <segment state="initial">
          <source>.</source>
          <target>.</target>
        </segment>
      </unit>
      <unit id="252">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UseDescriptorPinNumbers</pc> property tells Windows to use native pin numbering instead of sequential pin numbering.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UseDescriptorPinNumbers</pc> property tells Windows to use native pin numbering instead of sequential pin numbering.</target>
        </segment>
      </unit>
      <unit id="253">
        <segment state="initial">
          <source>If the UseDescriptorPinNumbers property is not specified or its value is zero, Windows will default to Sequential pin numbering.</source>
          <target>If the UseDescriptorPinNumbers property is not specified or its value is zero, Windows will default to Sequential pin numbering.</target>
        </segment>
      </unit>
      <unit id="254">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>If native pin numbering is used, you must also specify the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PinCount</pc> property.</source>
          <target>If native pin numbering is used, you must also specify the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PinCount</pc> property.</target>
        </segment>
      </unit>
      <unit id="255">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/hardware/hh439399.aspx)</data>
          <data id="id7">`GpioClx`</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PinCount</pc> property should match the value returned through the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">TotalPins</pc> property in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CLIENT_QueryControllerBasicInformation</pc> callback of the <ph dataRef="id7" id="ph1" /> driver.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PinCount</pc> property should match the value returned through the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">TotalPins</pc> property in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">CLIENT_QueryControllerBasicInformation</pc> callback of the <ph dataRef="id7" id="ph1" /> driver.</target>
        </segment>
      </unit>
      <unit id="256">
        <segment state="initial">
          <source>Choose the numbering scheme that is most compatible with existing published documentation for your board.</source>
          <target>Choose the numbering scheme that is most compatible with existing published documentation for your board.</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source>For example, Raspberry Pi uses native pin numbering because many existing pinout diagrams use the BCM2835 pin numbers.</source>
          <target>For example, Raspberry Pi uses native pin numbering because many existing pinout diagrams use the BCM2835 pin numbers.</target>
        </segment>
      </unit>
      <unit id="258">
        <segment state="initial">
          <source>MinnowBoardMax uses sequential pin numbering because there are few existing pinout diagrams, and sequential pin numbering simplifies the developer experience because only 10 pins are exposed out of more than 200 pins.</source>
          <target>MinnowBoardMax uses sequential pin numbering because there are few existing pinout diagrams, and sequential pin numbering simplifies the developer experience because only 10 pins are exposed out of more than 200 pins.</target>
        </segment>
      </unit>
      <unit id="259">
        <segment state="initial">
          <source>The decision to use sequential or native pin numbering should aim to reduce developer confusion.</source>
          <target>The decision to use sequential or native pin numbering should aim to reduce developer confusion.</target>
        </segment>
      </unit>
      <unit id="260">
        <segment state="initial">
          <source>GPIO Driver Requirements</source>
          <target>GPIO Driver Requirements</target>
        </segment>
      </unit>
      <unit id="261">
        <segment state="initial">
          <source>Must use</source>
          <target>Must use</target>
        </segment>
      </unit>
      <unit id="262">
        <segment state="initial">
          <source>Must be on-SOC memory mapped</source>
          <target>Must be on-SOC memory mapped</target>
        </segment>
      </unit>
      <unit id="263">
        <segment state="initial">
          <source>Must use emulated ActiveBoth interrupt handling</source>
          <target>Must use emulated ActiveBoth interrupt handling</target>
        </segment>
      </unit>
      <unit id="264">
        <segment state="initial">
          <source>UART</source>
          <target>UART</target>
        </segment>
      </unit>
      <unit id="265">
        <segment state="initial">
          <source>UART is not supported on Raspberry Pi at the time of writing, so the following UART declaration is from MinnowBoardMax.</source>
          <target>UART is not supported on Raspberry Pi at the time of writing, so the following UART declaration is from MinnowBoardMax.</target>
        </segment>
      </unit>
      <unit id="266">
        <segment state="initial">
          <source>Only the ResourceSource field is fixed while all other fields are placeholders for values specified at runtime by the user.</source>
          <target>Only the ResourceSource field is fixed while all other fields are placeholders for values specified at runtime by the user.</target>
        </segment>
      </unit>
      <unit id="267">
        <segment state="initial">
          <source>The accompanying friendly name declaration is:</source>
          <target>The accompanying friendly name declaration is:</target>
        </segment>
      </unit>
      <unit id="268">
        <segment state="initial">
          <source>This assigns the friendly name “UART2” to the controller, which is the identifier users will use to access the bus from usermode.</source>
          <target>This assigns the friendly name “UART2” to the controller, which is the identifier users will use to access the bus from usermode.</target>
        </segment>
      </unit>
      <unit id="269">
        <segment state="initial">
          <source>Runtime Pin Muxing</source>
          <target>Runtime Pin Muxing</target>
        </segment>
      </unit>
      <unit id="270">
        <segment state="initial">
          <source>Pin muxing is the ability to use the same physical pin for different functions.</source>
          <target>Pin muxing is the ability to use the same physical pin for different functions.</target>
        </segment>
      </unit>
      <unit id="271">
        <segment state="initial">
          <source>Several different on-chip peripherals, such as an I2C controller, SPI controller, and GPIO controller, might be routed to the same physical pin on a SOC.</source>
          <target>Several different on-chip peripherals, such as an I2C controller, SPI controller, and GPIO controller, might be routed to the same physical pin on a SOC.</target>
        </segment>
      </unit>
      <unit id="272">
        <segment state="initial">
          <source>The mux block controls which function is active on the pin at any given time.</source>
          <target>The mux block controls which function is active on the pin at any given time.</target>
        </segment>
      </unit>
      <unit id="273">
        <segment state="initial">
          <source>Traditionally, firmware is responsible for establishing function assignments at boot, and this assignment remains static through the boot session.</source>
          <target>Traditionally, firmware is responsible for establishing function assignments at boot, and this assignment remains static through the boot session.</target>
        </segment>
      </unit>
      <unit id="274">
        <segment state="initial">
          <source>Runtime pin muxing adds the ability to reconfigure pin function assignments at runtime.</source>
          <target>Runtime pin muxing adds the ability to reconfigure pin function assignments at runtime.</target>
        </segment>
      </unit>
      <unit id="275">
        <segment state="initial">
          <source>Enabling users to choose a pin’s function at runtime speeds development by enabling users to quickly reconfigure a board’s pins, and enables hardware to support a broader range of applications than would a static configuration.</source>
          <target>Enabling users to choose a pin’s function at runtime speeds development by enabling users to quickly reconfigure a board’s pins, and enables hardware to support a broader range of applications than would a static configuration.</target>
        </segment>
      </unit>
      <unit id="276">
        <segment state="initial">
          <source>Users consume muxing support for GPIO, I2C, SPI, and UART without writing any additional code.</source>
          <target>Users consume muxing support for GPIO, I2C, SPI, and UART without writing any additional code.</target>
        </segment>
      </unit>
      <unit id="277">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/dn960157.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/windows.devices.i2c.i2cdevice.fromidasync)</data>
        </originalData>
        <segment state="initial">
          <source>When a user opens a GPIO or bus using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OpenPin()</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FromIdAsync()</pc>, the underlying physical pins are automatically muxed to the requested function.</source>
          <target>When a user opens a GPIO or bus using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OpenPin()</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FromIdAsync()</pc>, the underlying physical pins are automatically muxed to the requested function.</target>
        </segment>
      </unit>
      <unit id="278">
        <segment state="initial">
          <source>If the pins are already in use by a different function, the OpenPin() or FromIdAsync() call will fail.</source>
          <target>If the pins are already in use by a different function, the OpenPin() or FromIdAsync() call will fail.</target>
        </segment>
      </unit>
      <unit id="279">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.devices.gpio.gpiopin.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/windows.devices.i2c.i2cdevice.aspx)</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/windows.devices.spi.spidevice.aspx)</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/windows.devices.serialcommunication.serialdevice.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>When the user closes the device by disposing the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GpioPin</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">I2cDevice</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">SpiDevice</pc>, or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">SerialDevice</pc> object, the pins are released, allowing them to later be opened for a different function.</source>
          <target>When the user closes the device by disposing the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GpioPin</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">I2cDevice</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">SpiDevice</pc>, or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">SerialDevice</pc> object, the pins are released, allowing them to later be opened for a different function.</target>
        </segment>
      </unit>
      <unit id="280">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/hh439515.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/hardware/hh406203.aspx)</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/hardware/dn265349.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>Windows contains built-in support for pin muxing in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GpioClx</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SpbCx</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">SerCx</pc> frameworks.</source>
          <target>Windows contains built-in support for pin muxing in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GpioClx</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SpbCx</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">SerCx</pc> frameworks.</target>
        </segment>
      </unit>
      <unit id="281">
        <segment state="initial">
          <source>These frameworks work together to automatically switch a pin to the correct function when a GPIO pin or bus is accessed.</source>
          <target>These frameworks work together to automatically switch a pin to the correct function when a GPIO pin or bus is accessed.</target>
        </segment>
      </unit>
      <unit id="282">
        <segment state="initial">
          <source>Access to the pins is arbitrated to prevent conflicts among multiple clients.</source>
          <target>Access to the pins is arbitrated to prevent conflicts among multiple clients.</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source>In addition to this built-in support, the interfaces and protocols for pin muxing are general purpose and can be extended to support additional devices and scenarios.</source>
          <target>In addition to this built-in support, the interfaces and protocols for pin muxing are general purpose and can be extended to support additional devices and scenarios.</target>
        </segment>
      </unit>
      <unit id="284">
        <segment state="initial">
          <source>This document first describes the underlying interfaces and protocols involved in pin muxing, and then describes how to add support for pin muxing to GpioClx, SpbCx, and SerCx controller drivers.</source>
          <target>This document first describes the underlying interfaces and protocols involved in pin muxing, and then describes how to add support for pin muxing to GpioClx, SpbCx, and SerCx controller drivers.</target>
        </segment>
      </unit>
      <unit id="285">
        <segment state="initial">
          <source>Pin Muxing Architecture</source>
          <target>Pin Muxing Architecture</target>
        </segment>
      </unit>
      <unit id="286">
        <segment state="initial">
          <source>This section describes the underlying interfaces and protocols involved in pin muxing.</source>
          <target>This section describes the underlying interfaces and protocols involved in pin muxing.</target>
        </segment>
      </unit>
      <unit id="287">
        <segment state="initial">
          <source>Knowledge of the underlying protocols is not necessarily needed to support pin muxing with GpioClx/SpbCx/SerCx drivers.</source>
          <target>Knowledge of the underlying protocols is not necessarily needed to support pin muxing with GpioClx/SpbCx/SerCx drivers.</target>
        </segment>
      </unit>
      <unit id="288">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#supporting-muxing-support-in-GpioClx-client-drivers)</data>
          <data id="id3">[</data>
          <data id="id4">](#supporting-muxing-in-SpbCx-and-SerCx-controller-drivers)</data>
        </originalData>
        <segment state="initial">
          <source>For details on how to support pin muxing with GpioCls/SpbCx/SerCx drivers, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing pin muxing support in GpioClx client drivers</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Consuming muxing support in SpbCx and SerCx controller drivers</pc>.</source>
          <target>For details on how to support pin muxing with GpioCls/SpbCx/SerCx drivers, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing pin muxing support in GpioClx client drivers</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Consuming muxing support in SpbCx and SerCx controller drivers</pc>.</target>
        </segment>
      </unit>
      <unit id="289">
        <segment state="initial">
          <source>Pin muxing is accomplished by the cooperation of several components.</source>
          <target>Pin muxing is accomplished by the cooperation of several components.</target>
        </segment>
      </unit>
      <unit id="290">
        <segment state="initial">
          <source>Pin muxing servers – these are drivers that control the pin muxing control block.</source>
          <target>Pin muxing servers – these are drivers that control the pin muxing control block.</target>
        </segment>
      </unit>
      <unit id="291">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>Pin muxing servers receive pin muxing requests from clients via requests to reserve muxing resources (via <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CREATE</pc>) requests, and requests to switch a pin’s function (via <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc> requests).</source>
          <target>Pin muxing servers receive pin muxing requests from clients via requests to reserve muxing resources (via <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CREATE</pc>) requests, and requests to switch a pin’s function (via <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc> requests).</target>
        </segment>
      </unit>
      <unit id="292">
        <segment state="initial">
          <source>The pin muxing server is usually the GPIO driver, since the muxing block is sometimes part of the GPIO block.</source>
          <target>The pin muxing server is usually the GPIO driver, since the muxing block is sometimes part of the GPIO block.</target>
        </segment>
      </unit>
      <unit id="293">
        <segment state="initial">
          <source>Even if the muxing block is a separate peripheral, the GPIO driver is a logical place to put muxing functionality.</source>
          <target>Even if the muxing block is a separate peripheral, the GPIO driver is a logical place to put muxing functionality.</target>
        </segment>
      </unit>
      <unit id="294">
        <segment state="initial">
          <source>Pin muxing clients – these are drivers that consume pin muxing.</source>
          <target>Pin muxing clients – these are drivers that consume pin muxing.</target>
        </segment>
      </unit>
      <unit id="295">
        <segment state="initial">
          <source>Pin muxing clients receive pin muxing resources from ACPI firmware.</source>
          <target>Pin muxing clients receive pin muxing resources from ACPI firmware.</target>
        </segment>
      </unit>
      <unit id="296">
        <segment state="initial">
          <source>Pin muxing resources are a type of connection resource and are managed by the resource hub.</source>
          <target>Pin muxing resources are a type of connection resource and are managed by the resource hub.</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source>Pin muxing clients reserve pin muxing resources by opening a handle to the resource.</source>
          <target>Pin muxing clients reserve pin muxing resources by opening a handle to the resource.</target>
        </segment>
      </unit>
      <unit id="298">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>To effect a hardware change, clients must commit the configuration by sending an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc> request.</source>
          <target>To effect a hardware change, clients must commit the configuration by sending an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc> request.</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source>Clients release pin muxing resources by closing the handle, at which point muxing configuration is reverted to its default state.</source>
          <target>Clients release pin muxing resources by closing the handle, at which point muxing configuration is reverted to its default state.</target>
        </segment>
      </unit>
      <unit id="300">
        <originalData>
          <data id="id1">`MsftFunctionConfig()`</data>
        </originalData>
        <segment state="initial">
          <source>ACPI firmware – specifies muxing configuration with <ph dataRef="id1" id="ph1" /> resources.</source>
          <target>ACPI firmware – specifies muxing configuration with <ph dataRef="id1" id="ph1" /> resources.</target>
        </segment>
      </unit>
      <unit id="301">
        <segment state="initial">
          <source>MsftFunctionConfig resources express which pins, in which muxing configuration, are required by a client.</source>
          <target>MsftFunctionConfig resources express which pins, in which muxing configuration, are required by a client.</target>
        </segment>
      </unit>
      <unit id="302">
        <segment state="initial">
          <source>MsftFunctionConfig resources contain function number, pull configuration, and list of pin numbers.</source>
          <target>MsftFunctionConfig resources contain function number, pull configuration, and list of pin numbers.</target>
        </segment>
      </unit>
      <unit id="303">
        <segment state="initial">
          <source>MsftFunctionConfig resources are supplied to pin muxing clients as hardware resources, which are received by drivers in their PrepareHardware callback similarly to GPIO and SPB connection resources.</source>
          <target>MsftFunctionConfig resources are supplied to pin muxing clients as hardware resources, which are received by drivers in their PrepareHardware callback similarly to GPIO and SPB connection resources.</target>
        </segment>
      </unit>
      <unit id="304">
        <segment state="initial">
          <source>Clients receive a resource hub ID which can be used to open a handle to the resource.</source>
          <target>Clients receive a resource hub ID which can be used to open a handle to the resource.</target>
        </segment>
      </unit>
      <unit id="305">
        <originalData>
          <data id="id1">`/MsftInternal`</data>
          <data id="id2">`asl.exe`</data>
          <data id="id3">`MsftFunctionConfig()`</data>
        </originalData>
        <segment state="initial">
          <source>You must pass the <ph dataRef="id1" id="ph1" /> command line switch to <ph dataRef="id2" id="ph2" /> to compile ASL files containing <ph dataRef="id3" id="ph3" /> descriptors since these descriptors are currently under review by the ACPI working committee.</source>
          <target>You must pass the <ph dataRef="id1" id="ph1" /> command line switch to <ph dataRef="id2" id="ph2" /> to compile ASL files containing <ph dataRef="id3" id="ph3" /> descriptors since these descriptors are currently under review by the ACPI working committee.</target>
        </segment>
      </unit>
      <unit id="306">
        <segment state="initial">
          <source>For example:</source>
          <target>For example:</target>
        </segment>
      </unit>
      <unit id="307">
        <segment state="initial">
          <source>The sequence of operations involved in pin muxing is shown below.</source>
          <target>The sequence of operations involved in pin muxing is shown below.</target>
        </segment>
      </unit>
      <unit id="308">
        <segment state="initial">
          <source>Pin muxing client server interaction</source>
          <target>Pin muxing client server interaction</target>
        </segment>
      </unit>
      <unit id="309">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/ff540880.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>The client receives MsftFunctionConfig resources from ACPI firmware in its <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EvtDevicePrepareHardware()</pc> callback.</source>
          <target>The client receives MsftFunctionConfig resources from ACPI firmware in its <pc dataRefEnd="id2" dataRefStart="id1" id="p1">EvtDevicePrepareHardware()</pc> callback.</target>
        </segment>
      </unit>
      <unit id="310">
        <originalData>
          <data id="id1">`RESOURCE_HUB_CREATE_PATH_FROM_ID()`</data>
          <data id="id2">[</data>
          <data id="id3">](https://msdn.microsoft.com/library/windows/hardware/ff566424.aspx)</data>
          <data id="id4">[</data>
          <data id="id5">](https://msdn.microsoft.com/library/windows/hardware/ff549198.aspx)</data>
          <data id="id6">[</data>
          <data id="id7">](https://msdn.microsoft.com/library/windows/hardware/ff548634.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>The client uses the resource hub helper function <ph dataRef="id1" id="ph1" /> to create a path from the resource ID, then opens a handle to the path (using <pc dataRefEnd="id3" dataRefStart="id2" id="p1">ZwCreateFile()</pc>, <pc dataRefEnd="id5" dataRefStart="id4" id="p2">IoGetDeviceObjectPointer()</pc>, or <pc dataRefEnd="id7" dataRefStart="id6" id="p3">WdfIoTargetOpen()</pc>).</source>
          <target>The client uses the resource hub helper function <ph dataRef="id1" id="ph1" /> to create a path from the resource ID, then opens a handle to the path (using <pc dataRefEnd="id3" dataRefStart="id2" id="p1">ZwCreateFile()</pc>, <pc dataRefEnd="id5" dataRefStart="id4" id="p2">IoGetDeviceObjectPointer()</pc>, or <pc dataRefEnd="id7" dataRefStart="id6" id="p3">WdfIoTargetOpen()</pc>).</target>
        </segment>
      </unit>
      <unit id="311">
        <originalData>
          <data id="id1">`RESOURCE_HUB_ID_FROM_FILE_NAME()`</data>
        </originalData>
        <segment state="initial">
          <source>The server extracts the resource hub ID from the file path using resource hub helper functions <ph dataRef="id1" id="ph1" />, then queries the resource hub to get the resource descriptor.</source>
          <target>The server extracts the resource hub ID from the file path using resource hub helper functions <ph dataRef="id1" id="ph1" />, then queries the resource hub to get the resource descriptor.</target>
        </segment>
      </unit>
      <unit id="312">
        <segment state="initial">
          <source>The server performs sharing arbitration for each pin in the descriptor and completes the IRP_MJ_CREATE request.</source>
          <target>The server performs sharing arbitration for each pin in the descriptor and completes the IRP_MJ_CREATE request.</target>
        </segment>
      </unit>
      <unit id="313">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>The client issues an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc> request on the received handle.</source>
          <target>The client issues an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc> request on the received handle.</target>
        </segment>
      </unit>
      <unit id="314">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>In response to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc>, the server performs the hardware muxing operation by making the specified function active on each pin.</source>
          <target>In response to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc>, the server performs the hardware muxing operation by making the specified function active on each pin.</target>
        </segment>
      </unit>
      <unit id="315">
        <segment state="initial">
          <source>The client proceeds with operations that depend on the requested pin muxing configuration.</source>
          <target>The client proceeds with operations that depend on the requested pin muxing configuration.</target>
        </segment>
      </unit>
      <unit id="316">
        <segment state="initial">
          <source>When the client no longer requires the pins to be muxed, it closes the handle.</source>
          <target>When the client no longer requires the pins to be muxed, it closes the handle.</target>
        </segment>
      </unit>
      <unit id="317">
        <segment state="initial">
          <source>In response to the handle being closed, the server reverts the pins back to their initial state.</source>
          <target>In response to the handle being closed, the server reverts the pins back to their initial state.</target>
        </segment>
      </unit>
      <unit id="318">
        <segment state="initial">
          <source>Protocol description for pin muxing clients</source>
          <target>Protocol description for pin muxing clients</target>
        </segment>
      </unit>
      <unit id="319">
        <segment state="initial">
          <source>This section describes how a client consumes pin muxing functionality.</source>
          <target>This section describes how a client consumes pin muxing functionality.</target>
        </segment>
      </unit>
      <unit id="320">
        <originalData>
          <data id="id1">`SerCx`</data>
          <data id="id2">`SpbCx`</data>
        </originalData>
        <segment state="initial">
          <source>This does not apply to <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> controller drivers, since the frameworks implement this protocol on behalf of controller drivers.</source>
          <target>This does not apply to <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> controller drivers, since the frameworks implement this protocol on behalf of controller drivers.</target>
        </segment>
      </unit>
      <unit id="321">
        <segment state="initial">
          <source>Parsing resources</source>
          <target>Parsing resources</target>
        </segment>
      </unit>
      <unit id="322">
        <originalData>
          <data id="id1">`MsftFunctionConfig()`</data>
          <data id="id2">[</data>
          <data id="id3">](https://msdn.microsoft.com/library/windows/hardware/ff540880.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>A WDF driver receives <ph dataRef="id1" id="ph1" /> resources in its <pc dataRefEnd="id3" dataRefStart="id2" id="p1">EvtDevicePrepareHardware()</pc> routine.</source>
          <target>A WDF driver receives <ph dataRef="id1" id="ph1" /> resources in its <pc dataRefEnd="id3" dataRefStart="id2" id="p1">EvtDevicePrepareHardware()</pc> routine.</target>
        </segment>
      </unit>
      <unit id="323">
        <segment state="initial">
          <source>MsftFunctionConfig resources can be identified by the following fields:</source>
          <target>MsftFunctionConfig resources can be identified by the following fields:</target>
        </segment>
      </unit>
      <unit id="324">
        <originalData>
          <data id="id1">`EvtDevicePrepareHardware()`</data>
        </originalData>
        <segment state="initial">
          <source>An <ph dataRef="id1" id="ph1" /> routine might extract MsftFunctionConfig resources as follows:</source>
          <target>An <ph dataRef="id1" id="ph1" /> routine might extract MsftFunctionConfig resources as follows:</target>
        </segment>
      </unit>
      <unit id="325">
        <segment state="initial">
          <source>Reserving and committing resources</source>
          <target>Reserving and committing resources</target>
        </segment>
      </unit>
      <unit id="326">
        <segment state="initial">
          <source>When a client wants to mux pins, it reserves and commits the MsftFunctionConfig resource.</source>
          <target>When a client wants to mux pins, it reserves and commits the MsftFunctionConfig resource.</target>
        </segment>
      </unit>
      <unit id="327">
        <segment state="initial">
          <source>The following example shows how a client might reserve and commit MsftFunctionConfig resources.</source>
          <target>The following example shows how a client might reserve and commit MsftFunctionConfig resources.</target>
        </segment>
      </unit>
      <unit id="328">
        <segment state="initial">
          <source>The driver should store the WDFIOTARGET in one of its context areas so that it can be closed later.</source>
          <target>The driver should store the WDFIOTARGET in one of its context areas so that it can be closed later.</target>
        </segment>
      </unit>
      <unit id="329">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/ff548734.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/hardware/ff548586.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>When the driver is ready to release the muxing configuration, it should close the resource handle by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WdfObjectDelete()</pc>, or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">WdfIoTargetClose()</pc> if you intend to reuse the WDFIOTARGET.</source>
          <target>When the driver is ready to release the muxing configuration, it should close the resource handle by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WdfObjectDelete()</pc>, or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">WdfIoTargetClose()</pc> if you intend to reuse the WDFIOTARGET.</target>
        </segment>
      </unit>
      <unit id="330">
        <segment state="initial">
          <source>When the client closes its resource handle, the pins are muxed back to their initial state, and can now be acquired by a different client.</source>
          <target>When the client closes its resource handle, the pins are muxed back to their initial state, and can now be acquired by a different client.</target>
        </segment>
      </unit>
      <unit id="331">
        <segment state="initial">
          <source>Protocol description for pin muxing servers</source>
          <target>Protocol description for pin muxing servers</target>
        </segment>
      </unit>
      <unit id="332">
        <segment state="initial">
          <source>This section describes how a pin muxing server exposes its functionality to clients.</source>
          <target>This section describes how a pin muxing server exposes its functionality to clients.</target>
        </segment>
      </unit>
      <unit id="333">
        <originalData>
          <data id="id1">`GpioClx`</data>
        </originalData>
        <segment state="initial">
          <source>This does not apply to <ph dataRef="id1" id="ph1" /> miniport drivers, since the framework implements this protocol on behalf of client drivers.</source>
          <target>This does not apply to <ph dataRef="id1" id="ph1" /> miniport drivers, since the framework implements this protocol on behalf of client drivers.</target>
        </segment>
      </unit>
      <unit id="334">
        <originalData>
          <data id="id1">`GpioClx`</data>
          <data id="id2">[</data>
          <data id="id3">](#supporting-muxing-support-in-GpioClx-client-drivers)</data>
        </originalData>
        <segment state="initial">
          <source>For details on how to support pin muxing in <ph dataRef="id1" id="ph1" /> client drivers, see <pc dataRefEnd="id3" dataRefStart="id2" id="p1">Implementing muxing support in GpioClx Client Drivers</pc>.</source>
          <target>For details on how to support pin muxing in <ph dataRef="id1" id="ph1" /> client drivers, see <pc dataRefEnd="id3" dataRefStart="id2" id="p1">Implementing muxing support in GpioClx Client Drivers</pc>.</target>
        </segment>
      </unit>
      <unit id="335">
        <segment state="initial">
          <source>Handling IRP_MJ_CREATE requests</source>
          <target>Handling IRP_MJ_CREATE requests</target>
        </segment>
      </unit>
      <unit id="336">
        <segment state="initial">
          <source>Clients open a handle to a resource when they want to reserve a pin muxing resource.</source>
          <target>Clients open a handle to a resource when they want to reserve a pin muxing resource.</target>
        </segment>
      </unit>
      <unit id="337">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>A pin muxing server receives <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CREATE</pc> requests by way of a reparse operation from the resource hub.</source>
          <target>A pin muxing server receives <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CREATE</pc> requests by way of a reparse operation from the resource hub.</target>
        </segment>
      </unit>
      <unit id="338">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>The trailing path component of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CREATE</pc> request contains the resource hub ID, which is a 64-bit integer in hexadecimal format.</source>
          <target>The trailing path component of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CREATE</pc> request contains the resource hub ID, which is a 64-bit integer in hexadecimal format.</target>
        </segment>
      </unit>
      <unit id="339">
        <originalData>
          <data id="id1">`RESOURCE_HUB_ID_FROM_FILE_NAME()`</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">`MsftFunctionConfig()`</data>
        </originalData>
        <segment state="initial">
          <source>The server should extract the resource hub ID from the filename using <ph dataRef="id1" id="ph1" /> from reshub.h, and send <pc dataRefEnd="id3" dataRefStart="id2" id="p1">IOCTL_RH_QUERY_CONNECTION_PROPERTIES</pc> to the resource hub to obtain the <ph dataRef="id4" id="ph2" /> descriptor.</source>
          <target>The server should extract the resource hub ID from the filename using <ph dataRef="id1" id="ph1" /> from reshub.h, and send <pc dataRefEnd="id3" dataRefStart="id2" id="p1">IOCTL_RH_QUERY_CONNECTION_PROPERTIES</pc> to the resource hub to obtain the <ph dataRef="id4" id="ph2" /> descriptor.</target>
        </segment>
      </unit>
      <unit id="340">
        <segment state="initial">
          <source>The server should validate the descriptor and extract the sharing mode and pin list from the descriptor.</source>
          <target>The server should validate the descriptor and extract the sharing mode and pin list from the descriptor.</target>
        </segment>
      </unit>
      <unit id="341">
        <segment state="initial">
          <source>It should then perform sharing arbitration for the pins, and if successful, mark the pins as reserved before completing the request.</source>
          <target>It should then perform sharing arbitration for the pins, and if successful, mark the pins as reserved before completing the request.</target>
        </segment>
      </unit>
      <unit id="342">
        <segment state="initial">
          <source>Sharing arbitration succeeds overall if sharing arbitration succeeds for each pin in the pin list.</source>
          <target>Sharing arbitration succeeds overall if sharing arbitration succeeds for each pin in the pin list.</target>
        </segment>
      </unit>
      <unit id="343">
        <segment state="initial">
          <source>Each pin should be arbitrated as follows:</source>
          <target>Each pin should be arbitrated as follows:</target>
        </segment>
      </unit>
      <unit id="344">
        <segment state="initial">
          <source>If the pin is not already reserved, sharing arbitration succeeds.</source>
          <target>If the pin is not already reserved, sharing arbitration succeeds.</target>
        </segment>
      </unit>
      <unit id="345">
        <segment state="initial">
          <source>If the pin is already reserved as exclusive, sharing arbitration fails.</source>
          <target>If the pin is already reserved as exclusive, sharing arbitration fails.</target>
        </segment>
      </unit>
      <unit id="346">
        <segment state="initial">
          <source>If the pin is already reserved as shared,</source>
          <target>If the pin is already reserved as shared,</target>
        </segment>
      </unit>
      <unit id="347">
        <segment state="initial">
          <source>and the incoming request is shared, sharing arbitration succeeds.</source>
          <target>and the incoming request is shared, sharing arbitration succeeds.</target>
        </segment>
      </unit>
      <unit id="348">
        <segment state="initial">
          <source>and the incoming request is exclusive, sharing arbitration fails.</source>
          <target>and the incoming request is exclusive, sharing arbitration fails.</target>
        </segment>
      </unit>
      <unit id="349">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>If sharing arbitration fails, the request should be completed with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE</pc>.</source>
          <target>If sharing arbitration fails, the request should be completed with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE</pc>.</target>
        </segment>
      </unit>
      <unit id="350">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>If sharing arbitration succeeds, the request should completed with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">STATUS_SUCCESS</pc>.</source>
          <target>If sharing arbitration succeeds, the request should completed with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">STATUS_SUCCESS</pc>.</target>
        </segment>
      </unit>
      <unit id="351">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/ff548630.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>Note that the sharing mode of the incoming request should be taken from the MsftFunctionConfig descriptor, not <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IrpSp-&gt;Parameters.Create.ShareAccess</pc>.</source>
          <target>Note that the sharing mode of the incoming request should be taken from the MsftFunctionConfig descriptor, not <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IrpSp-&gt;Parameters.Create.ShareAccess</pc>.</target>
        </segment>
      </unit>
      <unit id="352">
        <segment state="initial">
          <source>Handling IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS requests</source>
          <target>Handling IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS requests</target>
        </segment>
      </unit>
      <unit id="353">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>After the client has successfully reserved a MsftFunctionConfig resource by opening a handle, it can send <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc> to request the server to perform the actual hardware muxing operation.</source>
          <target>After the client has successfully reserved a MsftFunctionConfig resource by opening a handle, it can send <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc> to request the server to perform the actual hardware muxing operation.</target>
        </segment>
      </unit>
      <unit id="354">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>When the server receives <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc>, for each pin in the pin list it should</source>
          <target>When the server receives <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc>, for each pin in the pin list it should</target>
        </segment>
      </unit>
      <unit id="355">
        <segment state="initial">
          <source>Set the pull mode specified in the PinConfiguration member of the PNP_FUNCTION_CONFIG_DESCRIPTOR structure into hardware.</source>
          <target>Set the pull mode specified in the PinConfiguration member of the PNP_FUNCTION_CONFIG_DESCRIPTOR structure into hardware.</target>
        </segment>
      </unit>
      <unit id="356">
        <segment state="initial">
          <source>Mux the pin to the function specified by the FunctionNumber member of the PNP_FUNCTION_CONFIG_DESCRIPTOR structure.</source>
          <target>Mux the pin to the function specified by the FunctionNumber member of the PNP_FUNCTION_CONFIG_DESCRIPTOR structure.</target>
        </segment>
      </unit>
      <unit id="357">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>The server should then complete the request with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">STATUS_SUCCESS</pc>.</source>
          <target>The server should then complete the request with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">STATUS_SUCCESS</pc>.</target>
        </segment>
      </unit>
      <unit id="358">
        <segment state="initial">
          <source>The meaning of FunctionNumber is defined by the server, and it is understood that the MsftFunctionConfig descriptor was authored with knowledge of how the server interprets this field.</source>
          <target>The meaning of FunctionNumber is defined by the server, and it is understood that the MsftFunctionConfig descriptor was authored with knowledge of how the server interprets this field.</target>
        </segment>
      </unit>
      <unit id="359">
        <segment state="initial">
          <source>Remember that when the handle is closed, the server will have to revert the pins to the configuration they were in when IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS was received, so the server may need to save the pins’ state before modifying them.</source>
          <target>Remember that when the handle is closed, the server will have to revert the pins to the configuration they were in when IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS was received, so the server may need to save the pins’ state before modifying them.</target>
        </segment>
      </unit>
      <unit id="360">
        <segment state="initial">
          <source>Handling IRP_MJ_CLOSE requests</source>
          <target>Handling IRP_MJ_CLOSE requests</target>
        </segment>
      </unit>
      <unit id="361">
        <segment state="initial">
          <source>When a client no longer requires a muxing resource, it closes its handle.</source>
          <target>When a client no longer requires a muxing resource, it closes its handle.</target>
        </segment>
      </unit>
      <unit id="362">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>When a server receives a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CLOSE</pc> request, it should revert the pins to the state they were in when <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc> was received.</source>
          <target>When a server receives a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CLOSE</pc> request, it should revert the pins to the state they were in when <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc> was received.</target>
        </segment>
      </unit>
      <unit id="363">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>If the client never sent a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc>, no action is necessary.</source>
          <target>If the client never sent a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS</pc>, no action is necessary.</target>
        </segment>
      </unit>
      <unit id="364">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>The server should then mark the pins as available with respect to sharing arbitration, and complete the request with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">STATUS_SUCCESS</pc>.</source>
          <target>The server should then mark the pins as available with respect to sharing arbitration, and complete the request with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">STATUS_SUCCESS</pc>.</target>
        </segment>
      </unit>
      <unit id="365">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>Be sure to properly synchronize <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CLOSE</pc> handling with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IRP_MJ_CREATE</pc> handling.</source>
          <target>Be sure to properly synchronize <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CLOSE</pc> handling with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IRP_MJ_CREATE</pc> handling.</target>
        </segment>
      </unit>
      <unit id="366">
        <segment state="initial">
          <source>Authoring guidelines for ACPI tables</source>
          <target>Authoring guidelines for ACPI tables</target>
        </segment>
      </unit>
      <unit id="367">
        <segment state="initial">
          <source>This section describes how to supply muxing resources to client drivers.</source>
          <target>This section describes how to supply muxing resources to client drivers.</target>
        </segment>
      </unit>
      <unit id="368">
        <originalData>
          <data id="id1">`MsftFunctionConfig()`</data>
        </originalData>
        <segment state="initial">
          <source>Note that you will need Microsoft ASL compiler build 14327 or later to compile tables containing <ph dataRef="id1" id="ph1" /> resources.</source>
          <target>Note that you will need Microsoft ASL compiler build 14327 or later to compile tables containing <ph dataRef="id1" id="ph1" /> resources.</target>
        </segment>
      </unit>
      <unit id="369">
        <segment state="initial">
          <source>resources are supplied to pin muxing clients as hardware resources.</source>
          <target>resources are supplied to pin muxing clients as hardware resources.</target>
        </segment>
      </unit>
      <unit id="370">
        <segment state="initial">
          <source>resources should be supplied to drivers that require pin muxing changes, which are typically SPB and serial controller drivers, but should not be supplied to SPB and serial peripheral drivers, since the controller driver handles muxing configuration.</source>
          <target>resources should be supplied to drivers that require pin muxing changes, which are typically SPB and serial controller drivers, but should not be supplied to SPB and serial peripheral drivers, since the controller driver handles muxing configuration.</target>
        </segment>
      </unit>
      <unit id="371">
        <originalData>
          <data id="id1">`MsftFunctionConfig()`</data>
        </originalData>
        <segment state="initial">
          <source>The <ph dataRef="id1" id="ph1" /> ACPI macro is defined as follows:</source>
          <target>The <ph dataRef="id1" id="ph1" /> ACPI macro is defined as follows:</target>
        </segment>
      </unit>
      <unit id="372">
        <segment state="initial">
          <source>Shared/Exclusive – If exclusive, this pin can be acquired by a single client at a time.</source>
          <target>Shared/Exclusive – If exclusive, this pin can be acquired by a single client at a time.</target>
        </segment>
      </unit>
      <unit id="373">
        <segment state="initial">
          <source>If shared, multiple shared clients can acquire the resource.</source>
          <target>If shared, multiple shared clients can acquire the resource.</target>
        </segment>
      </unit>
      <unit id="374">
        <segment state="initial">
          <source>Always set this to exclusive since allowing multiple uncoordinated clients to access a mutable resource can lead to data races and therefore unpredictable results.</source>
          <target>Always set this to exclusive since allowing multiple uncoordinated clients to access a mutable resource can lead to data races and therefore unpredictable results.</target>
        </segment>
      </unit>
      <unit id="375">
        <segment state="initial">
          <source>PinPullConfig – one of</source>
          <target>PinPullConfig – one of</target>
        </segment>
      </unit>
      <unit id="376">
        <segment state="initial">
          <source>PullDefault – use the SOC-defined power-on default pull configuration</source>
          <target>PullDefault – use the SOC-defined power-on default pull configuration</target>
        </segment>
      </unit>
      <unit id="377">
        <segment state="initial">
          <source>PullUp – enable pull-up resistor</source>
          <target>PullUp – enable pull-up resistor</target>
        </segment>
      </unit>
      <unit id="378">
        <segment state="initial">
          <source>PullDown – enable pull-down resistor</source>
          <target>PullDown – enable pull-down resistor</target>
        </segment>
      </unit>
      <unit id="379">
        <segment state="initial">
          <source>PullNone – disable all pull resistors</source>
          <target>PullNone – disable all pull resistors</target>
        </segment>
      </unit>
      <unit id="380">
        <segment state="initial">
          <source>FunctionNumber – the function number to program into the mux.</source>
          <target>FunctionNumber – the function number to program into the mux.</target>
        </segment>
      </unit>
      <unit id="381">
        <segment state="initial">
          <source>ResourceSource – The ACPI namespace path of the pin muxing server</source>
          <target>ResourceSource – The ACPI namespace path of the pin muxing server</target>
        </segment>
      </unit>
      <unit id="382">
        <segment state="initial">
          <source>ResourceSourceIndex – set this to 0</source>
          <target>ResourceSourceIndex – set this to 0</target>
        </segment>
      </unit>
      <unit id="383">
        <segment state="initial">
          <source>ResourceConsumer/ResourceProducer – set this to ResourceConsumer</source>
          <target>ResourceConsumer/ResourceProducer – set this to ResourceConsumer</target>
        </segment>
      </unit>
      <unit id="384">
        <segment state="initial">
          <source>VendorData – optional binary data whose meaning is defined by the pin muxing server.</source>
          <target>VendorData – optional binary data whose meaning is defined by the pin muxing server.</target>
        </segment>
      </unit>
      <unit id="385">
        <segment state="initial">
          <source>This should usually be left blank</source>
          <target>This should usually be left blank</target>
        </segment>
      </unit>
      <unit id="386">
        <segment state="initial">
          <source>Pin List – a comma separated list of pin numbers to which the configuration applies.</source>
          <target>Pin List – a comma separated list of pin numbers to which the configuration applies.</target>
        </segment>
      </unit>
      <unit id="387">
        <segment state="initial">
          <source>When the pin muxing server is a GpioClx driver, these are GPIO pin numbers and have the same meaning as pin numbers in a GpioIo descriptor.</source>
          <target>When the pin muxing server is a GpioClx driver, these are GPIO pin numbers and have the same meaning as pin numbers in a GpioIo descriptor.</target>
        </segment>
      </unit>
      <unit id="388">
        <segment state="initial">
          <source>The following example shows how one might supply a MsftFunctionConfig() resource to an I2C controller driver.</source>
          <target>The following example shows how one might supply a MsftFunctionConfig() resource to an I2C controller driver.</target>
        </segment>
      </unit>
      <unit id="389">
        <originalData>
          <data id="id1">`MsftFunctionConfig()`</data>
        </originalData>
        <segment state="initial">
          <source>In addition to the memory and interrupt resources typically required by a controller driver, a <ph dataRef="id1" id="ph1" /> resource is also specified.</source>
          <target>In addition to the memory and interrupt resources typically required by a controller driver, a <ph dataRef="id1" id="ph1" /> resource is also specified.</target>
        </segment>
      </unit>
      <unit id="390">
        <originalData>
          <data id="id1">\\</data>
        </originalData>
        <segment state="initial">
          <source>This resource enables the I2C controller driver to put pins 2 and 3 - managed by the device node at <ph dataRef="id1" id="ph1" />_SB.GPIO0 – in function 4 with pull-up resistor enabled.</source>
          <target>This resource enables the I2C controller driver to put pins 2 and 3 - managed by the device node at <ph dataRef="id1" id="ph1" />_SB.GPIO0 – in function 4 with pull-up resistor enabled.</target>
        </segment>
      </unit>
      <unit id="391">
        <segment state="initial">
          <source>Supporting muxing support in GpioClx client drivers</source>
          <target>Supporting muxing support in GpioClx client drivers</target>
        </segment>
      </unit>
      <unit id="392">
        <segment state="initial">
          <source>has built-in support for pin muxing.</source>
          <target>has built-in support for pin muxing.</target>
        </segment>
      </unit>
      <unit id="393">
        <segment state="initial">
          <source>GpioClx miniport drivers (also referred to as “GpioClx client drivers”), drive GPIO controller hardware.</source>
          <target>GpioClx miniport drivers (also referred to as “GpioClx client drivers”), drive GPIO controller hardware.</target>
        </segment>
      </unit>
      <unit id="394">
        <segment state="initial">
          <source>As of Windows 10 build 14327, GpioClx miniport drivers can add support for pin muxing by implementing two new DDIs:</source>
          <target>As of Windows 10 build 14327, GpioClx miniport drivers can add support for pin muxing by implementing two new DDIs:</target>
        </segment>
      </unit>
      <unit id="395">
        <originalData>
          <data id="id1">`GpioClx`</data>
        </originalData>
        <segment state="initial">
          <source>CLIENT_ConnectFunctionConfigPins – called by <ph dataRef="id1" id="ph1" /> to command the miniport driver to apply the specified muxing configuration.</source>
          <target>CLIENT_ConnectFunctionConfigPins – called by <ph dataRef="id1" id="ph1" /> to command the miniport driver to apply the specified muxing configuration.</target>
        </segment>
      </unit>
      <unit id="396">
        <originalData>
          <data id="id1">`GpioClx`</data>
        </originalData>
        <segment state="initial">
          <source>CLIENT_DisconnectFunctionConfigPins – called by <ph dataRef="id1" id="ph1" /> to command the miniport driver to revert the muxing configuration.</source>
          <target>CLIENT_DisconnectFunctionConfigPins – called by <ph dataRef="id1" id="ph1" /> to command the miniport driver to revert the muxing configuration.</target>
        </segment>
      </unit>
      <unit id="397">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/hh439464.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GpioClx Event Callback Functions</pc> for a description of these routines.</source>
          <target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GpioClx Event Callback Functions</pc> for a description of these routines.</target>
        </segment>
      </unit>
      <unit id="398">
        <segment state="initial">
          <source>In addition to these two new DDIs, existing DDIs should be audited for pin muxing compatibility:</source>
          <target>In addition to these two new DDIs, existing DDIs should be audited for pin muxing compatibility:</target>
        </segment>
      </unit>
      <unit id="399">
        <segment state="initial">
          <source>CLIENT_ConnectIoPins/CLIENT_ConnectInterrupt – CLIENT_ConnectIoPins is called by GpioClx to command the miniport driver to configure a set pins for GPIO input or output.</source>
          <target>CLIENT_ConnectIoPins/CLIENT_ConnectInterrupt – CLIENT_ConnectIoPins is called by GpioClx to command the miniport driver to configure a set pins for GPIO input or output.</target>
        </segment>
      </unit>
      <unit id="400">
        <segment state="initial">
          <source>GPIO is mutually exclusive with MsftFunctionConfig, meaning a pin will never be connected for GPIO and MsftFunctionConfig at the same time.</source>
          <target>GPIO is mutually exclusive with MsftFunctionConfig, meaning a pin will never be connected for GPIO and MsftFunctionConfig at the same time.</target>
        </segment>
      </unit>
      <unit id="401">
        <segment state="initial">
          <source>Since a pin’s default function is not required to be GPIO, a pin may not necessarily not be muxed to GPIO when ConnectIoPins is called.</source>
          <target>Since a pin’s default function is not required to be GPIO, a pin may not necessarily not be muxed to GPIO when ConnectIoPins is called.</target>
        </segment>
      </unit>
      <unit id="402">
        <segment state="initial">
          <source>ConnectIoPins is required to perform all operations necessary to make the pin ready for GPIO IO, including muxing operations.</source>
          <target>ConnectIoPins is required to perform all operations necessary to make the pin ready for GPIO IO, including muxing operations.</target>
        </segment>
      </unit>
      <unit id="403">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CLIENT_ConnectInterrupt</pc> should behave similarly, since interrupts can be thought of as a special case of GPIO input.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CLIENT_ConnectInterrupt</pc> should behave similarly, since interrupts can be thought of as a special case of GPIO input.</target>
        </segment>
      </unit>
      <unit id="404">
        <segment state="initial">
          <source>CLIENT_DisconnectIoPins/CLIENT_DisconnectInterrupt – These routine should return pins to the state they were in when CLIENT_ConnectIoPins/CLIENT_ConnectInterrupt was called, unless the PreserveConfiguration flag is specified.</source>
          <target>CLIENT_DisconnectIoPins/CLIENT_DisconnectInterrupt – These routine should return pins to the state they were in when CLIENT_ConnectIoPins/CLIENT_ConnectInterrupt was called, unless the PreserveConfiguration flag is specified.</target>
        </segment>
      </unit>
      <unit id="405">
        <segment state="initial">
          <source>In addition to reverting the direction of pins to their default state, the miniport should also revert each pin’s muxing state to the state it was in when the _Connect routine was called.</source>
          <target>In addition to reverting the direction of pins to their default state, the miniport should also revert each pin’s muxing state to the state it was in when the _Connect routine was called.</target>
        </segment>
      </unit>
      <unit id="406">
        <segment state="initial">
          <source>For example, assume that a pin’s default muxing configuration is UART, and the pin can also be used as GPIO.</source>
          <target>For example, assume that a pin’s default muxing configuration is UART, and the pin can also be used as GPIO.</target>
        </segment>
      </unit>
      <unit id="407">
        <segment state="initial">
          <source>When CLIENT_ConnectIoPins is called to connect the pin for GPIO, it should mux the pin to GPIO, and in CLIENT_DisconnectIoPins, it should mux the pin back to UART.</source>
          <target>When CLIENT_ConnectIoPins is called to connect the pin for GPIO, it should mux the pin to GPIO, and in CLIENT_DisconnectIoPins, it should mux the pin back to UART.</target>
        </segment>
      </unit>
      <unit id="408">
        <segment state="initial">
          <source>In general, the _Disconnect routines should undo operations done by the _Connect routines.</source>
          <target>In general, the _Disconnect routines should undo operations done by the _Connect routines.</target>
        </segment>
      </unit>
      <unit id="409">
        <segment state="initial">
          <source>Supporting muxing in SpbCx and SerCx controller drivers</source>
          <target>Supporting muxing in SpbCx and SerCx controller drivers</target>
        </segment>
      </unit>
      <unit id="410">
        <originalData>
          <data id="id1">`SpbCx`</data>
          <data id="id2">`SerCx`</data>
          <data id="id3">`SpbCx`</data>
          <data id="id4">`SerCx`</data>
        </originalData>
        <segment state="initial">
          <source>As of Windows 10 build 14327, the <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> frameworks contain built-in support for pin muxing that enables <ph dataRef="id3" id="ph3" /> and <ph dataRef="id4" id="ph4" /> controller drivers to be pin muxing clients without any code changes to the controller drivers themselves.</source>
          <target>As of Windows 10 build 14327, the <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> frameworks contain built-in support for pin muxing that enables <ph dataRef="id3" id="ph3" /> and <ph dataRef="id4" id="ph4" /> controller drivers to be pin muxing clients without any code changes to the controller drivers themselves.</target>
        </segment>
      </unit>
      <unit id="411">
        <segment state="initial">
          <source>By extension, any SpbCx/SerCx peripheral driver that connects to a muxing-enabled SpbCx/SerCx controller driver will trigger pin muxing activity.</source>
          <target>By extension, any SpbCx/SerCx peripheral driver that connects to a muxing-enabled SpbCx/SerCx controller driver will trigger pin muxing activity.</target>
        </segment>
      </unit>
      <unit id="412">
        <segment state="initial">
          <source>The following diagram shows the dependencies between each of these components.</source>
          <target>The following diagram shows the dependencies between each of these components.</target>
        </segment>
      </unit>
      <unit id="413">
        <segment state="initial">
          <source>As you can see, pin muxing introduces a dependency from SerCx and SpbCx controller drivers to the GPIO driver, which is usually responsible for muxing.</source>
          <target>As you can see, pin muxing introduces a dependency from SerCx and SpbCx controller drivers to the GPIO driver, which is usually responsible for muxing.</target>
        </segment>
      </unit>
      <unit id="414">
        <segment state="initial">
          <source>Pin muxing dependency</source>
          <target>Pin muxing dependency</target>
        </segment>
      </unit>
      <unit id="415">
        <originalData>
          <data id="id1">`SpbCx`</data>
          <data id="id2">`SerCx`</data>
          <data id="id3">`MsftFunctionConfig()`</data>
        </originalData>
        <segment state="initial">
          <source>At device initialization time, the <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> frameworks parse all <ph dataRef="id3" id="ph3" /> resources supplied as hardware resources to the device.</source>
          <target>At device initialization time, the <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> frameworks parse all <ph dataRef="id3" id="ph3" /> resources supplied as hardware resources to the device.</target>
        </segment>
      </unit>
      <unit id="416">
        <segment state="initial">
          <source>SpbCx/SerCx then acquire and release the pin muxing resources on demand.</source>
          <target>SpbCx/SerCx then acquire and release the pin muxing resources on demand.</target>
        </segment>
      </unit>
      <unit id="417">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/hardware/hh450818.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>applies pin muxing configuration in its <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CREATE</pc> handler, just before calling the client driver’s <pc dataRefEnd="id4" dataRefStart="id3" id="p2">EvtSpbTargetConnect()</pc> callback.</source>
          <target>applies pin muxing configuration in its <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CREATE</pc> handler, just before calling the client driver’s <pc dataRefEnd="id4" dataRefStart="id3" id="p2">EvtSpbTargetConnect()</pc> callback.</target>
        </segment>
      </unit>
      <unit id="418">
        <originalData>
          <data id="id1">`EvtSpbTargetConnect()`</data>
        </originalData>
        <segment state="initial">
          <source>If muxing configuration could not be applied, the controller driver’s <ph dataRef="id1" id="ph1" /> callback will not be called.</source>
          <target>If muxing configuration could not be applied, the controller driver’s <ph dataRef="id1" id="ph1" /> callback will not be called.</target>
        </segment>
      </unit>
      <unit id="419">
        <originalData>
          <data id="id1">`EvtSpbTargetConnect()`</data>
        </originalData>
        <segment state="initial">
          <source>Therefore, an SPB controller driver may assume that pins are muxed to the SPB function by the time <ph dataRef="id1" id="ph1" /> is called.</source>
          <target>Therefore, an SPB controller driver may assume that pins are muxed to the SPB function by the time <ph dataRef="id1" id="ph1" /> is called.</target>
        </segment>
      </unit>
      <unit id="420">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/hardware/hh450820.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>reverts pin muxing configuration in its <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CLOSE</pc> handler, just after invoking the controller driver’s <pc dataRefEnd="id4" dataRefStart="id3" id="p2">EvtSpbTargetDisconnect()</pc> callback.</source>
          <target>reverts pin muxing configuration in its <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IRP_MJ_CLOSE</pc> handler, just after invoking the controller driver’s <pc dataRefEnd="id4" dataRefStart="id3" id="p2">EvtSpbTargetDisconnect()</pc> callback.</target>
        </segment>
      </unit>
      <unit id="421">
        <segment state="initial">
          <source>The result is that pins are muxed to the SPB function whenever a peripheral driver opens a handle to the SPB controller driver, and are muxed away when the peripheral driver closes their handle.</source>
          <target>The result is that pins are muxed to the SPB function whenever a peripheral driver opens a handle to the SPB controller driver, and are muxed away when the peripheral driver closes their handle.</target>
        </segment>
      </unit>
      <unit id="422">
        <segment state="initial">
          <source>behaves similarly.</source>
          <target>behaves similarly.</target>
        </segment>
      </unit>
      <unit id="423">
        <originalData>
          <data id="id1">`MsftFunctionConfig()`</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">[</data>
          <data id="id5">](https://msdn.microsoft.com/library/windows/hardware/dn265209.aspx)</data>
          <data id="id6">[</data>
          <data id="id7">](https://msdn.microsoft.com/library/windows/hardware/dn265208.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>acquires all <ph dataRef="id1" id="ph1" /> resources in its <pc dataRefEnd="id3" dataRefStart="id2" id="p1">IRP_MJ_CREATE</pc> handler just before invoking the controller driver’s <pc dataRefEnd="id5" dataRefStart="id4" id="p2">EvtSerCx2FileOpen()</pc> callback, and releases all resources in its IRP_MJ_CLOSE handler, just after invoking the controller driver’s <pc dataRefEnd="id7" dataRefStart="id6" id="p3">EvtSerCx2FileClose</pc> callback.</source>
          <target>acquires all <ph dataRef="id1" id="ph1" /> resources in its <pc dataRefEnd="id3" dataRefStart="id2" id="p1">IRP_MJ_CREATE</pc> handler just before invoking the controller driver’s <pc dataRefEnd="id5" dataRefStart="id4" id="p2">EvtSerCx2FileOpen()</pc> callback, and releases all resources in its IRP_MJ_CLOSE handler, just after invoking the controller driver’s <pc dataRefEnd="id7" dataRefStart="id6" id="p3">EvtSerCx2FileClose</pc> callback.</target>
        </segment>
      </unit>
      <unit id="424">
        <originalData>
          <data id="id1">`SerCx`</data>
          <data id="id2">`SpbCx`</data>
        </originalData>
        <segment state="initial">
          <source>The implication of dynamic pin muxing for <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> controller drivers is that they must be able to tolerate pins being muxed away from SPB/UART function at certain times.</source>
          <target>The implication of dynamic pin muxing for <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> controller drivers is that they must be able to tolerate pins being muxed away from SPB/UART function at certain times.</target>
        </segment>
      </unit>
      <unit id="425">
        <originalData>
          <data id="id1">`EvtSpbTargetConnect()`</data>
          <data id="id2">`EvtSerCx2FileOpen()`</data>
        </originalData>
        <segment state="initial">
          <source>Controller drivers need to assume that pins will not be muxed until <ph dataRef="id1" id="ph1" /> or <ph dataRef="id2" id="ph2" /> is called.</source>
          <target>Controller drivers need to assume that pins will not be muxed until <ph dataRef="id1" id="ph1" /> or <ph dataRef="id2" id="ph2" /> is called.</target>
        </segment>
      </unit>
      <unit id="426">
        <segment state="initial">
          <source>Pins are not necessary muxed to SPB/UART function during the following callbacks.</source>
          <target>Pins are not necessary muxed to SPB/UART function during the following callbacks.</target>
        </segment>
      </unit>
      <unit id="427">
        <segment state="initial">
          <source>The following is not a complete list, but represents the most common PNP routines implemented by controller drivers.</source>
          <target>The following is not a complete list, but represents the most common PNP routines implemented by controller drivers.</target>
        </segment>
      </unit>
      <unit id="428">
        <segment state="initial">
          <source>DriverEntry</source>
          <target>DriverEntry</target>
        </segment>
      </unit>
      <unit id="429">
        <segment state="initial">
          <source>EvtDriverDeviceAdd</source>
          <target>EvtDriverDeviceAdd</target>
        </segment>
      </unit>
      <unit id="430">
        <segment state="initial">
          <source>EvtDevicePrepareHardware/EvtDeviceReleaseHardware</source>
          <target>EvtDevicePrepareHardware/EvtDeviceReleaseHardware</target>
        </segment>
      </unit>
      <unit id="431">
        <segment state="initial">
          <source>EvtDeviceD0Entry/EvtDeviceD0Exit</source>
          <target>EvtDeviceD0Entry/EvtDeviceD0Exit</target>
        </segment>
      </unit>
      <unit id="432">
        <segment state="initial">
          <source>Verification</source>
          <target>Verification</target>
        </segment>
      </unit>
      <unit id="433">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/hardware/dn930814.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>When you’ve finished authoring your ASL, you should run the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Hardware Lab Kit (HLK)</pc> tests to verify that all resources are exposed correctly and the underlying busses meet the functional contract of the API.</source>
          <target>When you’ve finished authoring your ASL, you should run the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Hardware Lab Kit (HLK)</pc> tests to verify that all resources are exposed correctly and the underlying busses meet the functional contract of the API.</target>
        </segment>
      </unit>
      <unit id="434">
        <segment state="initial">
          <source>The following sections describe how to load the rhproxy device node for testing without recompiling your firmware and how to run the HLK tests.</source>
          <target>The following sections describe how to load the rhproxy device node for testing without recompiling your firmware and how to run the HLK tests.</target>
        </segment>
      </unit>
      <unit id="435">
        <segment state="initial">
          <source>Compile and load ASL with ACPITABL.dat</source>
          <target>Compile and load ASL with ACPITABL.dat</target>
        </segment>
      </unit>
      <unit id="436">
        <segment state="initial">
          <source>The first step is to compile and load the ASL file onto your system under test.</source>
          <target>The first step is to compile and load the ASL file onto your system under test.</target>
        </segment>
      </unit>
      <unit id="437">
        <segment state="initial">
          <source>We recommend using ACPITABL.dat during development and validation as it does not require a full UEFI rebuild to test ASL changes.</source>
          <target>We recommend using ACPITABL.dat during development and validation as it does not require a full UEFI rebuild to test ASL changes.</target>
        </segment>
      </unit>
      <unit id="438">
        <segment state="initial">
          <source>Create a file named yourboard.asl and put the RHPX device node inside a DefinitionBlock:</source>
          <target>Create a file named yourboard.asl and put the RHPX device node inside a DefinitionBlock:</target>
        </segment>
      </unit>
      <unit id="439">
        <segment state="initial">
          <source>Download the WDK and get asl.exe</source>
          <target>Download the WDK and get asl.exe</target>
        </segment>
      </unit>
      <unit id="440">
        <segment state="initial">
          <source>Run the following command to generate ACPITABL.dat:</source>
          <target>Run the following command to generate ACPITABL.dat:</target>
        </segment>
      </unit>
      <unit id="441">
        <segment state="initial">
          <source>Copy the resulting ACPITABL.dat file to c:\windows\system32 on your system under test.</source>
          <target>Copy the resulting ACPITABL.dat file to c:\windows\system32 on your system under test.</target>
        </segment>
      </unit>
      <unit id="442">
        <segment state="initial">
          <source>Turn on testsigning on your system under test:</source>
          <target>Turn on testsigning on your system under test:</target>
        </segment>
      </unit>
      <unit id="443">
        <segment state="initial">
          <source>Reboot the system under test.</source>
          <target>Reboot the system under test.</target>
        </segment>
      </unit>
      <unit id="444">
        <segment state="initial">
          <source>The system will append the ACPI tables defined in ACPITABL.dat to the system firmware tables.</source>
          <target>The system will append the ACPI tables defined in ACPITABL.dat to the system firmware tables.</target>
        </segment>
      </unit>
      <unit id="445">
        <segment state="initial">
          <source>Verify that the RHPX device node was added to the system:</source>
          <target>Verify that the RHPX device node was added to the system:</target>
        </segment>
      </unit>
      <unit id="446">
        <segment state="initial">
          <source>The output of devcon should indicate that the device is present, although the driver may have failed to initialize if there are bugs in the ASL that need to be worked out.</source>
          <target>The output of devcon should indicate that the device is present, although the driver may have failed to initialize if there are bugs in the ASL that need to be worked out.</target>
        </segment>
      </unit>
      <unit id="447">
        <segment state="initial">
          <source>Run the HLK Tests</source>
          <target>Run the HLK Tests</target>
        </segment>
      </unit>
      <unit id="448">
        <segment state="initial">
          <source>When you select the rhproxy device node in HLK manager, the applicable tests will automatically be selected.</source>
          <target>When you select the rhproxy device node in HLK manager, the applicable tests will automatically be selected.</target>
        </segment>
      </unit>
      <unit id="449">
        <segment state="initial">
          <source>In the HLK manager, select “Resource Hub Proxy device”:</source>
          <target>In the HLK manager, select “Resource Hub Proxy device”:</target>
        </segment>
      </unit>
      <unit id="450">
        <segment state="initial">
          <source>HLK manager screenshot</source>
          <target>HLK manager screenshot</target>
        </segment>
      </unit>
      <unit id="451">
        <segment state="initial">
          <source>Then click the Tests tab, and select I2C WinRT, Gpio WinRT, and Spi WinRT tests.</source>
          <target>Then click the Tests tab, and select I2C WinRT, Gpio WinRT, and Spi WinRT tests.</target>
        </segment>
      </unit>
      <unit id="452">
        <segment state="initial">
          <source>HLK manager screenshot</source>
          <target>HLK manager screenshot</target>
        </segment>
      </unit>
      <unit id="453">
        <segment state="initial">
          <source>Click Run Selected.</source>
          <target>Click Run Selected.</target>
        </segment>
      </unit>
      <unit id="454">
        <segment state="initial">
          <source>Further documentation on each test is available by right clicking on the test and clicking “Test Description.”</source>
          <target>Further documentation on each test is available by right clicking on the test and clicking “Test Description.”</target>
        </segment>
      </unit>
      <unit id="455">
        <segment state="initial">
          <source>More testing resources</source>
          <target>More testing resources</target>
        </segment>
      </unit>
      <unit id="456">
        <segment state="initial">
          <source>Simple command line tools for Gpio, I2c, Spi, and Serial are available on the ms-iot github samples repository  (https://github.com/ms-iot/samples).</source>
          <target>Simple command line tools for Gpio, I2c, Spi, and Serial are available on the ms-iot github samples repository  (https://github.com/ms-iot/samples).</target>
        </segment>
      </unit>
      <unit id="457">
        <segment state="initial">
          <source>These tools can be helpful for manual debugging.</source>
          <target>These tools can be helpful for manual debugging.</target>
        </segment>
      </unit>
      <unit id="458">
        <segment state="initial">
          <source>Tool</source>
          <target>Tool</target>
        </segment>
      </unit>
      <unit id="459">
        <segment state="initial">
          <source>Link</source>
          <target>Link</target>
        </segment>
      </unit>
      <unit id="460">
        <segment state="initial">
          <source>GpioTestTool</source>
          <target>GpioTestTool</target>
        </segment>
      </unit>
      <unit id="461">
        <segment state="initial">
          <source>https://developer.microsoft.com/en-us/windows/iot/win10/samples/GPIOTestTool</source>
          <target>https://developer.microsoft.com/en-us/windows/iot/win10/samples/GPIOTestTool</target>
        </segment>
      </unit>
      <unit id="462">
        <segment state="initial">
          <source>I2cTestTool</source>
          <target>I2cTestTool</target>
        </segment>
      </unit>
      <unit id="463">
        <segment state="initial">
          <source>https://developer.microsoft.com/en-us/windows/iot/win10/samples/I2cTestTool</source>
          <target>https://developer.microsoft.com/en-us/windows/iot/win10/samples/I2cTestTool</target>
        </segment>
      </unit>
      <unit id="464">
        <segment state="initial">
          <source>SpiTestTool</source>
          <target>SpiTestTool</target>
        </segment>
      </unit>
      <unit id="465">
        <segment state="initial">
          <source>https://developer.microsoft.com/en-us/windows/iot/win10/samples/spitesttool</source>
          <target>https://developer.microsoft.com/en-us/windows/iot/win10/samples/spitesttool</target>
        </segment>
      </unit>
      <unit id="466">
        <segment state="initial">
          <source>MinComm (Serial)</source>
          <target>MinComm (Serial)</target>
        </segment>
      </unit>
      <unit id="467">
        <segment state="initial">
          <source>https://github.com/ms-iot/samples/tree/develop/MinComm</source>
          <target>https://github.com/ms-iot/samples/tree/develop/MinComm</target>
        </segment>
      </unit>
      <unit id="468">
        <segment state="initial">
          <source>Resources</source>
          <target>Resources</target>
        </segment>
      </unit>
      <unit id="469">
        <segment state="initial">
          <source>Destination</source>
          <target>Destination</target>
        </segment>
      </unit>
      <unit id="470">
        <segment state="initial">
          <source>Link</source>
          <target>Link</target>
        </segment>
      </unit>
      <unit id="471">
        <segment state="initial">
          <source>ACPI 5.0 specification</source>
          <target>ACPI 5.0 specification</target>
        </segment>
      </unit>
      <unit id="472">
        <segment state="initial">
          <source>http://acpi.info/spec.htm</source>
          <target>http://acpi.info/spec.htm</target>
        </segment>
      </unit>
      <unit id="473">
        <segment state="initial">
          <source>Asl.exe (Microsoft ASL Compiler)</source>
          <target>Asl.exe (Microsoft ASL Compiler)</target>
        </segment>
      </unit>
      <unit id="474">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/hardware/dn551195.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/hardware/dn551195.aspx</target>
        </segment>
      </unit>
      <unit id="475">
        <segment state="initial">
          <source>Windows.Devices.Gpio</source>
          <target>Windows.Devices.Gpio</target>
        </segment>
      </unit>
      <unit id="476">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/apps/windows.devices.gpio.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/apps/windows.devices.gpio.aspx</target>
        </segment>
      </unit>
      <unit id="477">
        <segment state="initial">
          <source>Windows.Devices.I2c</source>
          <target>Windows.Devices.I2c</target>
        </segment>
      </unit>
      <unit id="478">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/apps/windows.devices.i2c.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/apps/windows.devices.i2c.aspx</target>
        </segment>
      </unit>
      <unit id="479">
        <segment state="initial">
          <source>Windows.Devices.Spi</source>
          <target>Windows.Devices.Spi</target>
        </segment>
      </unit>
      <unit id="480">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/apps/windows.devices.spi.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/apps/windows.devices.spi.aspx</target>
        </segment>
      </unit>
      <unit id="481">
        <segment state="initial">
          <source>Windows.Devices.SerialCommunication</source>
          <target>Windows.Devices.SerialCommunication</target>
        </segment>
      </unit>
      <unit id="482">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/apps/windows.devices.serialcommunication.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/apps/windows.devices.serialcommunication.aspx</target>
        </segment>
      </unit>
      <unit id="483">
        <segment state="initial">
          <source>Test Authoring and Execution Framework (TAEF)</source>
          <target>Test Authoring and Execution Framework (TAEF)</target>
        </segment>
      </unit>
      <unit id="484">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/hardware/hh439725.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/hardware/hh439725.aspx</target>
        </segment>
      </unit>
      <unit id="485">
        <segment state="initial">
          <source>SpbCx</source>
          <target>SpbCx</target>
        </segment>
      </unit>
      <unit id="486">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/hardware/hh450906.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/hardware/hh450906.aspx</target>
        </segment>
      </unit>
      <unit id="487">
        <segment state="initial">
          <source>GpioClx</source>
          <target>GpioClx</target>
        </segment>
      </unit>
      <unit id="488">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/hardware/hh439508.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/hardware/hh439508.aspx</target>
        </segment>
      </unit>
      <unit id="489">
        <segment state="initial">
          <source>SerCx</source>
          <target>SerCx</target>
        </segment>
      </unit>
      <unit id="490">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/hardware/ff546939.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/hardware/ff546939.aspx</target>
        </segment>
      </unit>
      <unit id="491">
        <segment state="initial">
          <source>MITT I2C Tests</source>
          <target>MITT I2C Tests</target>
        </segment>
      </unit>
      <unit id="492">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/hardware/dn919852.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/hardware/dn919852.aspx</target>
        </segment>
      </unit>
      <unit id="493">
        <segment state="initial">
          <source>GpioTestTool</source>
          <target>GpioTestTool</target>
        </segment>
      </unit>
      <unit id="494">
        <segment state="initial">
          <source>https://developer.microsoft.com/en-us/windows/iot/win10/samples/GPIOTestTool</source>
          <target>https://developer.microsoft.com/en-us/windows/iot/win10/samples/GPIOTestTool</target>
        </segment>
      </unit>
      <unit id="495">
        <segment state="initial">
          <source>I2cTestTool</source>
          <target>I2cTestTool</target>
        </segment>
      </unit>
      <unit id="496">
        <segment state="initial">
          <source>https://developer.microsoft.com/en-us/windows/iot/win10/samples/I2cTestTool</source>
          <target>https://developer.microsoft.com/en-us/windows/iot/win10/samples/I2cTestTool</target>
        </segment>
      </unit>
      <unit id="497">
        <segment state="initial">
          <source>SpiTestTool</source>
          <target>SpiTestTool</target>
        </segment>
      </unit>
      <unit id="498">
        <segment state="initial">
          <source>https://developer.microsoft.com/en-us/windows/iot/win10/samples/spitesttool</source>
          <target>https://developer.microsoft.com/en-us/windows/iot/win10/samples/spitesttool</target>
        </segment>
      </unit>
      <unit id="499">
        <segment state="initial">
          <source>MinComm (Serial)</source>
          <target>MinComm (Serial)</target>
        </segment>
      </unit>
      <unit id="500">
        <segment state="initial">
          <source>https://github.com/ms-iot/samples/tree/develop/MinComm</source>
          <target>https://github.com/ms-iot/samples/tree/develop/MinComm</target>
        </segment>
      </unit>
      <unit id="501">
        <segment state="initial">
          <source>Hardware Lab Kit (HLK)</source>
          <target>Hardware Lab Kit (HLK)</target>
        </segment>
      </unit>
      <unit id="502">
        <segment state="initial">
          <source>https://msdn.microsoft.com/library/windows/hardware/dn930814.aspx</source>
          <target>https://msdn.microsoft.com/library/windows/hardware/dn930814.aspx</target>
        </segment>
      </unit>
      <unit id="503">
        <segment state="initial">
          <source>Apendix</source>
          <target>Apendix</target>
        </segment>
      </unit>
      <unit id="504">
        <segment state="initial">
          <source>Appendix A - Raspberry Pi ASL Listing</source>
          <target>Appendix A - Raspberry Pi ASL Listing</target>
        </segment>
      </unit>
      <unit id="505">
        <segment state="initial">
          <source>Header pinout: https://developer.microsoft.com/en-us/windows/iot/win10/samples/PinMappingsRPi2</source>
          <target>Header pinout: https://developer.microsoft.com/en-us/windows/iot/win10/samples/PinMappingsRPi2</target>
        </segment>
      </unit>
      <unit id="506">
        <segment state="initial">
          <source>Appendix B - MinnowBoardMax ASL Listing</source>
          <target>Appendix B - MinnowBoardMax ASL Listing</target>
        </segment>
      </unit>
      <unit id="507">
        <segment state="initial">
          <source>Header pinout: https://developer.microsoft.com/en-us/windows/iot/win10/samples/PinMappingsMBM</source>
          <target>Header pinout: https://developer.microsoft.com/en-us/windows/iot/win10/samples/PinMappingsMBM</target>
        </segment>
      </unit>
      <unit id="508">
        <segment state="initial">
          <source>Appendix C - Sample Powershell script to generate GPIO resources</source>
          <target>Appendix C - Sample Powershell script to generate GPIO resources</target>
        </segment>
      </unit>
      <unit id="509">
        <segment state="initial">
          <source>The following script can be used to generate the GPIO resource declarations for Raspberry Pi:</source>
          <target>The following script can be used to generate the GPIO resource declarations for Raspberry Pi:</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>