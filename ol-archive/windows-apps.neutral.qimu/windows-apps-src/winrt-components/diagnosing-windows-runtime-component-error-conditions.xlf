<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="zh-cn" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">windows-apps-src\winrt-components\diagnosing-windows-runtime-component-error-conditions.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">29199b7c94c4fecd173fb96f0d8fb43692d72464</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-781aacf</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>Diagnosing Windows Runtime Component error conditions</source>
          <target>Diagnosing Windows Runtime Component error conditions</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>This article provides additional information about restrictions on Windows Runtime Components written with managed code.</source>
          <target>This article provides additional information about restrictions on Windows Runtime Components written with managed code.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>Diagnosing Windows Runtime Component error conditions</source>
          <target>Diagnosing Windows Runtime Component error conditions</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>Updated for UWP apps on Windows 10.</source>
          <target>Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="105">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></source>
          <target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>This article provides additional information about restrictions on Windows Runtime Components written with managed code.</source>
          <target>This article provides additional information about restrictions on Windows Runtime Components written with managed code.</target>
        </segment>
      </unit>
      <unit id="107">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/hh925576.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](creating-windows-runtime-components-in-csharp-and-visual-basic.md)</data>
        </originalData>
        <segment state="initial">
          <source>It expands on the information that is provided in error messages from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Winmdexp.exe (Windows Runtime Metadata Export Tool)</pc>, and complements the information on restrictions that is provided in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Creating Windows Runtime Components in C# and Visual Basic</pc>.</source>
          <target>It expands on the information that is provided in error messages from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Winmdexp.exe (Windows Runtime Metadata Export Tool)</pc>, and complements the information on restrictions that is provided in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Creating Windows Runtime Components in C# and Visual Basic</pc>.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source>This article doesn’t cover all errors.</source>
          <target>This article doesn’t cover all errors.</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source>The errors discussed here are grouped by general category, and each category includes a table of associated error messages.</source>
          <target>The errors discussed here are grouped by general category, and each category includes a table of associated error messages.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>Search for message text (omitting specific values for placeholders) or for message number.</source>
          <target>Search for message text (omitting specific values for placeholders) or for message number.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source>If you don’t find the information you need here, please help us improve the documentation by using the feedback button at the end of this article.</source>
          <target>If you don’t find the information you need here, please help us improve the documentation by using the feedback button at the end of this article.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source>Include the error message.</source>
          <target>Include the error message.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source>Alternatively, you can file a bug at the Microsoft Connect website.</source>
          <target>Alternatively, you can file a bug at the Microsoft Connect website.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source>Error message for implementing async interface provides incorrect type</source>
          <target>Error message for implementing async interface provides incorrect type</target>
        </segment>
      </unit>
      <unit id="115">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/br205781.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/br205784.aspx)</data>
          <data id="id5">&amp;lt;</data>
          <data id="id6">&amp;gt;</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br206598.aspx)</data>
          <data id="id9">&amp;lt;</data>
          <data id="id10">&amp;gt;</data>
          <data id="id11">[</data>
          <data id="id12">](https://msdn.microsoft.com/library/windows/apps/br206594.aspx)</data>
          <data id="id13">&amp;lt;</data>
          <data id="id14">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>Managed Windows Runtime Components cannot implement the Universal Windows Platform (UWP) interfaces that represent asynchronous actions or operations (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncAction</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncActionWithProgress<ph dataRef="id5" id="ph1" />TProgress<ph dataRef="id6" id="ph2" /></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p3">IAsyncOperation<ph dataRef="id9" id="ph3" />TResult<ph dataRef="id10" id="ph4" /></pc>, or <pc dataRefEnd="id12" dataRefStart="id11" id="p4">IAsyncOperationWithProgress<ph dataRef="id13" id="ph5" />TResult, TProgress<ph dataRef="id14" id="ph6" /></pc>).</source>
          <target>Managed Windows Runtime Components cannot implement the Universal Windows Platform (UWP) interfaces that represent asynchronous actions or operations (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncAction</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncActionWithProgress<ph dataRef="id5" id="ph1" />TProgress<ph dataRef="id6" id="ph2" /></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p3">IAsyncOperation<ph dataRef="id9" id="ph3" />TResult<ph dataRef="id10" id="ph4" /></pc>, or <pc dataRefEnd="id12" dataRefStart="id11" id="p4">IAsyncOperationWithProgress<ph dataRef="id13" id="ph5" />TResult, TProgress<ph dataRef="id14" id="ph6" /></pc>).</target>
        </segment>
      </unit>
      <unit id="116">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/system.runtime.interopservices.windowsruntime.asyncinfo.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>Instead, the .NET Framework provides the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AsyncInfo</pc> class for generating async operations in Windows Runtime Components.</source>
          <target>Instead, the .NET Framework provides the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AsyncInfo</pc> class for generating async operations in Windows Runtime Components.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source>The error message that Winmdexp.exe displays when you try to implement an async interface incorrectly refers to this class by its former name, AsyncInfoFactory.</source>
          <target>The error message that Winmdexp.exe displays when you try to implement an async interface incorrectly refers to this class by its former name, AsyncInfoFactory.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source>The .NET Framework no longer includes the AsyncInfoFactory class.</source>
          <target>The .NET Framework no longer includes the AsyncInfoFactory class.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>WME1084</source>
          <target>WME1084</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>Type '{0}' implements Windows Runtime async interface '{1}'.</source>
          <target>Type '{0}' implements Windows Runtime async interface '{1}'.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>Windows Runtime types cannot implement async interfaces.</source>
          <target>Windows Runtime types cannot implement async interfaces.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>Please use the System.Runtime.InteropServices.WindowsRuntime.AsyncInfoFactory class to generate async operations for export to Windows Runtime.</source>
          <target>Please use the System.Runtime.InteropServices.WindowsRuntime.AsyncInfoFactory class to generate async operations for export to Windows Runtime.</target>
        </segment>
      </unit>
      <unit id="125">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc> The error messages that refer to the Windows Runtime use an old terminology.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc> The error messages that refer to the Windows Runtime use an old terminology.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source>This is now referred to as the Universal Windows Platform (UWP).</source>
          <target>This is now referred to as the Universal Windows Platform (UWP).</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source>For example, Windows Runtime types are now called UWP types.</source>
          <target>For example, Windows Runtime types are now called UWP types.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source>Missing references to mscorlib.dll or System.Runtime.dll</source>
          <target>Missing references to mscorlib.dll or System.Runtime.dll</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source>This issue occurs only when you use Winmdexp.exe from the command line.</source>
          <target>This issue occurs only when you use Winmdexp.exe from the command line.</target>
        </segment>
      </unit>
      <unit id="130">
        <originalData>
          <data id="id1">\\</data>
          <data id="id2">\\</data>
          <data id="id3">\\</data>
          <data id="id4">\\</data>
          <data id="id5">\\</data>
          <data id="id6">\\</data>
        </originalData>
        <segment state="initial">
          <source>We recommend that you use the /reference option to include references to both mscorlib.dll and System.Runtime.dll from the .NET Framework core reference assemblies, which are located in "%ProgramFiles(x86)%<ph dataRef="id1" id="ph1" />Reference Assemblies<ph dataRef="id2" id="ph2" />Microsoft<ph dataRef="id3" id="ph3" />Framework<ph dataRef="id4" id="ph4" />.NETCore<ph dataRef="id5" id="ph5" />v4.5" ("%ProgramFiles%<ph dataRef="id6" id="ph6" />..." on a 32-bit computer).</source>
          <target>We recommend that you use the /reference option to include references to both mscorlib.dll and System.Runtime.dll from the .NET Framework core reference assemblies, which are located in "%ProgramFiles(x86)%<ph dataRef="id1" id="ph1" />Reference Assemblies<ph dataRef="id2" id="ph2" />Microsoft<ph dataRef="id3" id="ph3" />Framework<ph dataRef="id4" id="ph4" />.NETCore<ph dataRef="id5" id="ph5" />v4.5" ("%ProgramFiles%<ph dataRef="id6" id="ph6" />..." on a 32-bit computer).</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>WME1009</source>
          <target>WME1009</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>No reference was made to mscorlib.dll.</source>
          <target>No reference was made to mscorlib.dll.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source>A reference to this metadata file is required in order to export correctly.</source>
          <target>A reference to this metadata file is required in order to export correctly.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source>WME1090</source>
          <target>WME1090</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>Could not determine the core reference assembly.</source>
          <target>Could not determine the core reference assembly.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source>Please make sure mscorlib.dll and System.Runtime.dll is referenced using the /reference switch.</source>
          <target>Please make sure mscorlib.dll and System.Runtime.dll is referenced using the /reference switch.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source>Operator overloading is not allowed</source>
          <target>Operator overloading is not allowed</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source>In a Windows Runtime Component written in managed code, you cannot expose overloaded operators on public types.</source>
          <target>In a Windows Runtime Component written in managed code, you cannot expose overloaded operators on public types.</target>
        </segment>
      </unit>
      <unit id="141">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">\_</data>
          <data id="id4">\_</data>
          <data id="id5">\_</data>
          <data id="id6">\_</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc> In the error message, the operator is identified by its metadata name, such as op<ph dataRef="id3" id="ph1" />Addition, op<ph dataRef="id4" id="ph2" />Multiply, op<ph dataRef="id5" id="ph3" />ExclusiveOr, op<ph dataRef="id6" id="ph4" />Implicit (implicit conversion), and so on.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc> In the error message, the operator is identified by its metadata name, such as op<ph dataRef="id3" id="ph1" />Addition, op<ph dataRef="id4" id="ph2" />Multiply, op<ph dataRef="id5" id="ph3" />ExclusiveOr, op<ph dataRef="id6" id="ph4" />Implicit (implicit conversion), and so on.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>WME1087</source>
          <target>WME1087</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source>'{0}' is an operator overload.</source>
          <target>'{0}' is an operator overload.</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source>Managed types cannot expose operator overloads in the Windows Runtime.</source>
          <target>Managed types cannot expose operator overloads in the Windows Runtime.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source>Constructors on a class have the same number of parameters</source>
          <target>Constructors on a class have the same number of parameters</target>
        </segment>
      </unit>
      <unit id="148">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>In the UWP, a class can have only one constructor with a given number of parameters; for example, you can't have one constructor that has a single parameter of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">String</pc> and another that has a single parameter of type <pc dataRefEnd="id4" dataRefStart="id3" id="p2">int</pc> (<pc dataRefEnd="id6" dataRefStart="id5" id="p3">Integer</pc> in Visual Basic).</source>
          <target>In the UWP, a class can have only one constructor with a given number of parameters; for example, you can't have one constructor that has a single parameter of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">String</pc> and another that has a single parameter of type <pc dataRefEnd="id4" dataRefStart="id3" id="p2">int</pc> (<pc dataRefEnd="id6" dataRefStart="id5" id="p3">Integer</pc> in Visual Basic).</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>The only workaround is to use a different number of parameters for each constructor.</source>
          <target>The only workaround is to use a different number of parameters for each constructor.</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>WME1099</source>
          <target>WME1099</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source>Type '{0}' has multiple constructors with '{1}' argument(s).</source>
          <target>Type '{0}' has multiple constructors with '{1}' argument(s).</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>Windows Runtime types cannot have multiple constructors with the same number of arguments.</source>
          <target>Windows Runtime types cannot have multiple constructors with the same number of arguments.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>Must specify a default for overloads that have the same number of parameters</source>
          <target>Must specify a default for overloads that have the same number of parameters</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source>In the UWP, overloaded methods can have the same number of parameters only if one overload is specified as the default overload.</source>
          <target>In the UWP, overloaded methods can have the same number of parameters only if one overload is specified as the default overload.</target>
        </segment>
      </unit>
      <unit id="157">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](creating-windows-runtime-components-in-csharp-and-visual-basic.md)</data>
        </originalData>
        <segment state="initial">
          <source>See "Overloaded Methods" in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating Windows Runtime Components in C# and Visual Basic</pc>.</source>
          <target>See "Overloaded Methods" in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating Windows Runtime Components in C# and Visual Basic</pc>.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source>WME1059</source>
          <target>WME1059</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source>Multiple {0}-parameter overloads of '{1}.{2}' are decorated with Windows.Foundation.Metadata.DefaultOverloadAttribute.</source>
          <target>Multiple {0}-parameter overloads of '{1}.{2}' are decorated with Windows.Foundation.Metadata.DefaultOverloadAttribute.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source>WME1085</source>
          <target>WME1085</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source>The {0}-parameter overloads of {1}.{2} must have exactly one method specified as the default overload by decorating it with Windows.Foundation.Metadata.DefaultOverloadAttribute.</source>
          <target>The {0}-parameter overloads of {1}.{2} must have exactly one method specified as the default overload by decorating it with Windows.Foundation.Metadata.DefaultOverloadAttribute.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source>Namespace errors and invalid names for the output file</source>
          <target>Namespace errors and invalid names for the output file</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source>In the Universal Windows Platform, all the public types in a Windows metadata (.winmd) file must be in a namespace that shares the .winmd file name, or in sub-namespaces of the file name.</source>
          <target>In the Universal Windows Platform, all the public types in a Windows metadata (.winmd) file must be in a namespace that shares the .winmd file name, or in sub-namespaces of the file name.</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source>For example, if your Visual Studio project is named A.B (that is, your Windows Runtime Component is A.B.winmd), it can contain public classes A.B.Class1 and A.B.C.Class2, but not A.Class3 (WME0006) or D.Class4 (WME1044).</source>
          <target>For example, if your Visual Studio project is named A.B (that is, your Windows Runtime Component is A.B.winmd), it can contain public classes A.B.Class1 and A.B.C.Class2, but not A.Class3 (WME0006) or D.Class4 (WME1044).</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  These restrictions apply only to public types, not to private types used in your implementation.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  These restrictions apply only to public types, not to private types used in your implementation.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source>In the case of A.Class3, you can either move Class3 to another namespace or change the name of the Windows Runtime Component to A.winmd.</source>
          <target>In the case of A.Class3, you can either move Class3 to another namespace or change the name of the Windows Runtime Component to A.winmd.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>Although WME0006 is a warning, you should treat it as an error.</source>
          <target>Although WME0006 is a warning, you should treat it as an error.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source>In the previous example, code that calls A.B.winmd will be unable to locate A.Class3.</source>
          <target>In the previous example, code that calls A.B.winmd will be unable to locate A.Class3.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source>In the case of D.Class4, no file name can contain both D.Class4 and classes in the A.B namespace, so changing the name of the Windows Runtime Component is not an option.</source>
          <target>In the case of D.Class4, no file name can contain both D.Class4 and classes in the A.B namespace, so changing the name of the Windows Runtime Component is not an option.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source>You can either move D.Class4 to another namespace, or put it in another Windows Runtime Component.</source>
          <target>You can either move D.Class4 to another namespace, or put it in another Windows Runtime Component.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source>The file system can't distinguish between uppercase and lowercase, so namespaces that differ by case are not allowed (WME1067).</source>
          <target>The file system can't distinguish between uppercase and lowercase, so namespaces that differ by case are not allowed (WME1067).</target>
        </segment>
      </unit>
      <unit id="174">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Your component must contain at least one <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public sealed</pc> type (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Public NotInheritable</pc> in Visual Basic).</source>
          <target>Your component must contain at least one <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public sealed</pc> type (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Public NotInheritable</pc> in Visual Basic).</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source>If not, you will get WME1042 or WME1043, depending on whether your component contains private types.</source>
          <target>If not, you will get WME1042 or WME1043, depending on whether your component contains private types.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source>A type in a Windows Runtime Component cannot have a name that is the same as a namespace (WME1068).</source>
          <target>A type in a Windows Runtime Component cannot have a name that is the same as a namespace (WME1068).</target>
        </segment>
      </unit>
      <unit id="177">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  If you call Winmdexp.exe directly and don't use the /out option to specify a name for your Windows Runtime Component, Winmdexp.exe tries to generate a name that includes all the namespaces in the component.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  If you call Winmdexp.exe directly and don't use the /out option to specify a name for your Windows Runtime Component, Winmdexp.exe tries to generate a name that includes all the namespaces in the component.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source>Renaming namespaces can change the name of your component.</source>
          <target>Renaming namespaces can change the name of your component.</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source>WME0006</source>
          <target>WME0006</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source>'{0}' is not a valid winmd file name for this assembly.</source>
          <target>'{0}' is not a valid winmd file name for this assembly.</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source>All types within a Windows Metadata file must exist in a sub namespace of the namespace that is implied by the file name.</source>
          <target>All types within a Windows Metadata file must exist in a sub namespace of the namespace that is implied by the file name.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source>Types that do not exist in such a sub namespace cannot be located at runtime.</source>
          <target>Types that do not exist in such a sub namespace cannot be located at runtime.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source>In this assembly, the smallest common namespace that could serve as a filename is '{1}'.</source>
          <target>In this assembly, the smallest common namespace that could serve as a filename is '{1}'.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source>WME1042</source>
          <target>WME1042</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source>Input module must contain at least one public type that is located inside a namespace.</source>
          <target>Input module must contain at least one public type that is located inside a namespace.</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source>WME1043</source>
          <target>WME1043</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source>Input module must contain at least one public type that is located inside a namespace.</source>
          <target>Input module must contain at least one public type that is located inside a namespace.</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source>The only types found inside namespaces are private.</source>
          <target>The only types found inside namespaces are private.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source>WME1044</source>
          <target>WME1044</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source>A public type has a namespace ('{1}') that shares no common prefix with other namespaces ('{0}').</source>
          <target>A public type has a namespace ('{1}') that shares no common prefix with other namespaces ('{0}').</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source>All types within a Windows Metadata file must exist in a sub namespace of the namespace that is implied by the file name.</source>
          <target>All types within a Windows Metadata file must exist in a sub namespace of the namespace that is implied by the file name.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source>WME1067</source>
          <target>WME1067</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source>Namespace names cannot differ only by case: '{0}', '{1}'.</source>
          <target>Namespace names cannot differ only by case: '{0}', '{1}'.</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source>WME1068</source>
          <target>WME1068</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source>Type '{0}' cannot have the same name as namespace '{1}'.</source>
          <target>Type '{0}' cannot have the same name as namespace '{1}'.</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source>Exporting types that aren't valid Universal Windows Platform types</source>
          <target>Exporting types that aren't valid Universal Windows Platform types</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source>The public interface of your component must expose only UWP types.</source>
          <target>The public interface of your component must expose only UWP types.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source>However, the .NET Framework provides mappings for a number of commonly used types that are slightly different in the .NET Framework and the UWP.</source>
          <target>However, the .NET Framework provides mappings for a number of commonly used types that are slightly different in the .NET Framework and the UWP.</target>
        </segment>
      </unit>
      <unit id="201">
        <segment state="initial">
          <source>This enables the .NET Framework developer to work with familiar types instead of learning new ones.</source>
          <target>This enables the .NET Framework developer to work with familiar types instead of learning new ones.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source>You can use these mapped .NET Framework types in the public interface of your component.</source>
          <target>You can use these mapped .NET Framework types in the public interface of your component.</target>
        </segment>
      </unit>
      <unit id="203">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](creating-windows-runtime-components-in-csharp-and-visual-basic.md)</data>
          <data id="id3">[</data>
          <data id="id4">](net-framework-mappings-of-windows-runtime-types.md)</data>
        </originalData>
        <segment state="initial">
          <source>See "Declaring types in Windows Runtime Components" and "Passing Universal Windows Platform types to managed code" in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating Windows Runtime Components in C# and Visual Basic</pc>, and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">.NET Framework mappings of Windows Runtime types</pc>.</source>
          <target>See "Declaring types in Windows Runtime Components" and "Passing Universal Windows Platform types to managed code" in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating Windows Runtime Components in C# and Visual Basic</pc>, and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">.NET Framework mappings of Windows Runtime types</pc>.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source>Many of these mappings are interfaces.</source>
          <target>Many of these mappings are interfaces.</target>
        </segment>
      </unit>
      <unit id="205">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/5y536ey6.aspx)</data>
          <data id="id3">&amp;lt;</data>
          <data id="id4">&amp;gt;</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br206631.aspx)</data>
          <data id="id7">&amp;lt;</data>
          <data id="id8">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IList<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /></pc> maps to the UWP interface <pc dataRefEnd="id6" dataRefStart="id5" id="p2">IVector<ph dataRef="id7" id="ph3" />T<ph dataRef="id8" id="ph4" /></pc>.</source>
          <target>For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IList<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" /></pc> maps to the UWP interface <pc dataRefEnd="id6" dataRefStart="id5" id="p2">IVector<ph dataRef="id7" id="ph3" />T<ph dataRef="id8" id="ph4" /></pc>.</target>
        </segment>
      </unit>
      <unit id="206">
        <originalData>
          <data id="id1">&amp;lt;</data>
          <data id="id2">&amp;gt;</data>
          <data id="id3">`List(Of String)`</data>
          <data id="id4">&amp;lt;</data>
          <data id="id5">&amp;gt;</data>
          <data id="id6">&amp;lt;</data>
          <data id="id7">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>If you use List<ph dataRef="id1" id="ph1" />string<ph dataRef="id2" id="ph2" /> (<ph dataRef="id3" id="ph3" /> in Visual Basic) instead of IList<ph dataRef="id4" id="ph4" />string<ph dataRef="id5" id="ph5" /> as a parameter type, Winmdexp.exe provides a list of alternatives that includes all the mapped interfaces implemented by List<ph dataRef="id6" id="ph6" />T<ph dataRef="id7" id="ph7" />.</source>
          <target>If you use List<ph dataRef="id1" id="ph1" />string<ph dataRef="id2" id="ph2" /> (<ph dataRef="id3" id="ph3" /> in Visual Basic) instead of IList<ph dataRef="id4" id="ph4" />string<ph dataRef="id5" id="ph5" /> as a parameter type, Winmdexp.exe provides a list of alternatives that includes all the mapped interfaces implemented by List<ph dataRef="id6" id="ph6" />T<ph dataRef="id7" id="ph7" />.</target>
        </segment>
      </unit>
      <unit id="207">
        <originalData>
          <data id="id1">&amp;lt;</data>
          <data id="id2">&amp;lt;</data>
          <data id="id3">&amp;gt;&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>If you use nested generic types, such as List<ph dataRef="id1" id="ph1" />Dictionary<ph dataRef="id2" id="ph2" />int, string<ph dataRef="id3" id="ph3" /> (List(Of Dictionary(Of Integer, String)) in Visual Basic), Winmdexp.exe offers choices for each level of nesting.</source>
          <target>If you use nested generic types, such as List<ph dataRef="id1" id="ph1" />Dictionary<ph dataRef="id2" id="ph2" />int, string<ph dataRef="id3" id="ph3" /> (List(Of Dictionary(Of Integer, String)) in Visual Basic), Winmdexp.exe offers choices for each level of nesting.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source>These lists can become quite long.</source>
          <target>These lists can become quite long.</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source>In general, the best choice is the interface that is closest to the type.</source>
          <target>In general, the best choice is the interface that is closest to the type.</target>
        </segment>
      </unit>
      <unit id="210">
        <originalData>
          <data id="id1">&amp;lt;</data>
          <data id="id2">&amp;gt;</data>
          <data id="id3">&amp;lt;</data>
          <data id="id4">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>For example, for Dictionary<ph dataRef="id1" id="ph1" />int, string<ph dataRef="id2" id="ph2" />, the best choice is most likely IDictionary<ph dataRef="id3" id="ph3" />int, string<ph dataRef="id4" id="ph4" />.</source>
          <target>For example, for Dictionary<ph dataRef="id1" id="ph1" />int, string<ph dataRef="id2" id="ph2" />, the best choice is most likely IDictionary<ph dataRef="id3" id="ph3" />int, string<ph dataRef="id4" id="ph4" />.</target>
        </segment>
      </unit>
      <unit id="211">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  JavaScript uses the interface that appears first in the list of interfaces that a managed type implements.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  JavaScript uses the interface that appears first in the list of interfaces that a managed type implements.</target>
        </segment>
      </unit>
      <unit id="212">
        <originalData>
          <data id="id1">&amp;lt;</data>
          <data id="id2">&amp;gt;</data>
          <data id="id3">&amp;lt;</data>
          <data id="id4">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>For example, if you return Dictionary<ph dataRef="id1" id="ph1" />int, string<ph dataRef="id2" id="ph2" /> to JavaScript code, it appears as IDictionary<ph dataRef="id3" id="ph3" />int, string<ph dataRef="id4" id="ph4" /> no matter which interface you specify as the return type.</source>
          <target>For example, if you return Dictionary<ph dataRef="id1" id="ph1" />int, string<ph dataRef="id2" id="ph2" /> to JavaScript code, it appears as IDictionary<ph dataRef="id3" id="ph3" />int, string<ph dataRef="id4" id="ph4" /> no matter which interface you specify as the return type.</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source>This means that if the first interface doesn't include a member that appears on later interfaces, that member isn't visible to JavaScript.</source>
          <target>This means that if the first interface doesn't include a member that appears on later interfaces, that member isn't visible to JavaScript.</target>
        </segment>
      </unit>
      <unit id="214">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/system.collections.ilist.aspx)</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/system.collections.ienumerable.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  Avoid using the non-generic <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IList</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">IEnumerable</pc> interfaces if your component will be used by JavaScript.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  Avoid using the non-generic <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IList</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">IEnumerable</pc> interfaces if your component will be used by JavaScript.</target>
        </segment>
      </unit>
      <unit id="215">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.interop.ibindablevector.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.interop.ibindableiterator.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>These interfaces map to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IBindableVector</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IBindableIterator</pc>, respectively.</source>
          <target>These interfaces map to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IBindableVector</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IBindableIterator</pc>, respectively.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source>They support binding for XAML controls, and are invisible to JavaScript.</source>
          <target>They support binding for XAML controls, and are invisible to JavaScript.</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source>JavaScript issues the run-time error "The function 'X' has an invalid signature and cannot be called."</source>
          <target>JavaScript issues the run-time error "The function 'X' has an invalid signature and cannot be called."</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source>WME1033</source>
          <target>WME1033</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source>Method '{0}' has parameter '{1}' of type '{2}'.</source>
          <target>Method '{0}' has parameter '{1}' of type '{2}'.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source>'{2}' is not a valid Windows Runtime parameter type.</source>
          <target>'{2}' is not a valid Windows Runtime parameter type.</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source>WME1038</source>
          <target>WME1038</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source>Method '{0}' has a parameter of type '{1}' in its signature.</source>
          <target>Method '{0}' has a parameter of type '{1}' in its signature.</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source>Although this type is not a valid Windows Runtime type, it implements interfaces that are valid Windows Runtime types.</source>
          <target>Although this type is not a valid Windows Runtime type, it implements interfaces that are valid Windows Runtime types.</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source>Consider changing the method signature to use one of the following types instead: '{2}'.</source>
          <target>Consider changing the method signature to use one of the following types instead: '{2}'.</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source>WME1039</source>
          <target>WME1039</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source>Method '{0}' has a parameter of type '{1}' in its signature.</source>
          <target>Method '{0}' has a parameter of type '{1}' in its signature.</target>
        </segment>
      </unit>
      <unit id="229">
        <segment state="initial">
          <source>Although this generic type is not a valid Windows Runtime type, the type or its generic parameters implement interfaces that are valid Windows Runtime types.</source>
          <target>Although this generic type is not a valid Windows Runtime type, the type or its generic parameters implement interfaces that are valid Windows Runtime types.</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source>{2}</source>
          <target>{2}</target>
        </segment>
      </unit>
      <unit id="231">
        <originalData>
          <data id="id1">
&gt; **</data>
          <data id="id2">**</data>
          <data id="id3">&amp;lt;</data>
          <data id="id4">&amp;gt;</data>
          <data id="id5">&amp;lt;</data>
          <data id="id6">&amp;gt;</data>
          <data id="id7">&amp;lt;</data>
          <data id="id8">&amp;gt;</data>
          <data id="id9">&amp;lt;</data>
          <data id="id10">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For {2}, Winmdexp.exe appends a list of alternatives, such as "Consider changing the type 'System.Collections.Generic.List<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" />' in the method signature to one of the following types instead: 'System.Collections.Generic.IList<ph dataRef="id5" id="ph3" />T<ph dataRef="id6" id="ph4" />, System.Collections.Generic.IReadOnlyList<ph dataRef="id7" id="ph5" />T<ph dataRef="id8" id="ph6" />, System.Collections.Generic.IEnumerable<ph dataRef="id9" id="ph7" />T<ph dataRef="id10" id="ph8" />'."</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For {2}, Winmdexp.exe appends a list of alternatives, such as "Consider changing the type 'System.Collections.Generic.List<ph dataRef="id3" id="ph1" />T<ph dataRef="id4" id="ph2" />' in the method signature to one of the following types instead: 'System.Collections.Generic.IList<ph dataRef="id5" id="ph3" />T<ph dataRef="id6" id="ph4" />, System.Collections.Generic.IReadOnlyList<ph dataRef="id7" id="ph5" />T<ph dataRef="id8" id="ph6" />, System.Collections.Generic.IEnumerable<ph dataRef="id9" id="ph7" />T<ph dataRef="id10" id="ph8" />'."</target>
        </segment>
      </unit>
      <unit id="232">
        <segment state="initial">
          <source>WME1040</source>
          <target>WME1040</target>
        </segment>
      </unit>
      <unit id="233">
        <segment state="initial">
          <source>Method '{0}' has a parameter of type '{1}' in its signature.</source>
          <target>Method '{0}' has a parameter of type '{1}' in its signature.</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source>Instead of using a managed Task type, use Windows.Foundation.IAsyncAction, Windows.Foundation.IAsyncOperation, or one of the other Windows Runtime async interfaces.</source>
          <target>Instead of using a managed Task type, use Windows.Foundation.IAsyncAction, Windows.Foundation.IAsyncOperation, or one of the other Windows Runtime async interfaces.</target>
        </segment>
      </unit>
      <unit id="235">
        <segment state="initial">
          <source>The standard .NET await pattern also applies to these interfaces.</source>
          <target>The standard .NET await pattern also applies to these interfaces.</target>
        </segment>
      </unit>
      <unit id="236">
        <segment state="initial">
          <source>Please see System.Runtime.InteropServices.WindowsRuntime.AsyncInfo for more information about converting managed task objects to Windows Runtime async interfaces.</source>
          <target>Please see System.Runtime.InteropServices.WindowsRuntime.AsyncInfo for more information about converting managed task objects to Windows Runtime async interfaces.</target>
        </segment>
      </unit>
      <unit id="237">
        <segment state="initial">
          <source>Structures that contain fields of disallowed types</source>
          <target>Structures that contain fields of disallowed types</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source>In the UWP, a structure can contain only fields, and only structures can contain fields.</source>
          <target>In the UWP, a structure can contain only fields, and only structures can contain fields.</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source>Those fields must be public.</source>
          <target>Those fields must be public.</target>
        </segment>
      </unit>
      <unit id="240">
        <segment state="initial">
          <source>Valid field types include enumerations, structures, and primitive types.</source>
          <target>Valid field types include enumerations, structures, and primitive types.</target>
        </segment>
      </unit>
      <unit id="241">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="242">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source>WME1060</source>
          <target>WME1060</target>
        </segment>
      </unit>
      <unit id="244">
        <segment state="initial">
          <source>Structure '{0}' has field '{1}' of type '{2}'.</source>
          <target>Structure '{0}' has field '{1}' of type '{2}'.</target>
        </segment>
      </unit>
      <unit id="245">
        <segment state="initial">
          <source>'{2}' is not a valid Windows Runtime field type.</source>
          <target>'{2}' is not a valid Windows Runtime field type.</target>
        </segment>
      </unit>
      <unit id="246">
        <segment state="initial">
          <source>Each field in a Windows Runtime structure can only be UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Boolean, String, Enum, or itself a structure.</source>
          <target>Each field in a Windows Runtime structure can only be UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Single, Double, Boolean, String, Enum, or itself a structure.</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source>Restrictions on arrays in member signatures</source>
          <target>Restrictions on arrays in member signatures</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source>In the UWP, arrays in member signatures must be one-dimensional with a lower bound of 0 (zero).</source>
          <target>In the UWP, arrays in member signatures must be one-dimensional with a lower bound of 0 (zero).</target>
        </segment>
      </unit>
      <unit id="249">
        <originalData>
          <data id="id1">`myArray[][]`</data>
          <data id="id2">`myArray()()`</data>
        </originalData>
        <segment state="initial">
          <source>Nested array types such as <ph dataRef="id1" id="ph1" /> (<ph dataRef="id2" id="ph2" /> in Visual Basic) are not allowed.</source>
          <target>Nested array types such as <ph dataRef="id1" id="ph1" /> (<ph dataRef="id2" id="ph2" /> in Visual Basic) are not allowed.</target>
        </segment>
      </unit>
      <unit id="250">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc> This restriction does not apply to arrays you use internally in your implementation.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc> This restriction does not apply to arrays you use internally in your implementation.</target>
        </segment>
      </unit>
      <unit id="251">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="252">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="253">
        <segment state="initial">
          <source>WME1034</source>
          <target>WME1034</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source>Method '{0}' has an array of type '{1}' with non-zero lower bound in its signature.</source>
          <target>Method '{0}' has an array of type '{1}' with non-zero lower bound in its signature.</target>
        </segment>
      </unit>
      <unit id="255">
        <segment state="initial">
          <source>Arrays in Windows Runtime method signatures must have a lower bound of zero.</source>
          <target>Arrays in Windows Runtime method signatures must have a lower bound of zero.</target>
        </segment>
      </unit>
      <unit id="256">
        <segment state="initial">
          <source>WME1035</source>
          <target>WME1035</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source>Method '{0}' has a multi-dimensional array of type '{1}' in its signature.</source>
          <target>Method '{0}' has a multi-dimensional array of type '{1}' in its signature.</target>
        </segment>
      </unit>
      <unit id="258">
        <segment state="initial">
          <source>Arrays in Windows Runtime method signatures must be one dimensional.</source>
          <target>Arrays in Windows Runtime method signatures must be one dimensional.</target>
        </segment>
      </unit>
      <unit id="259">
        <segment state="initial">
          <source>WME1036</source>
          <target>WME1036</target>
        </segment>
      </unit>
      <unit id="260">
        <segment state="initial">
          <source>Method '{0}' has a nested array of type '{1}' in its signature.</source>
          <target>Method '{0}' has a nested array of type '{1}' in its signature.</target>
        </segment>
      </unit>
      <unit id="261">
        <segment state="initial">
          <source>Arrays in Windows Runtime method signatures cannot be nested.</source>
          <target>Arrays in Windows Runtime method signatures cannot be nested.</target>
        </segment>
      </unit>
      <unit id="262">
        <segment state="initial">
          <source>Array parameters must specify whether array contents are readable or writable</source>
          <target>Array parameters must specify whether array contents are readable or writable</target>
        </segment>
      </unit>
      <unit id="263">
        <segment state="initial">
          <source>In the UWP, parameters must be read-only or write-only.</source>
          <target>In the UWP, parameters must be read-only or write-only.</target>
        </segment>
      </unit>
      <unit id="264">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/system.runtime.interopservices.outattribute.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>Parameters cannot be marked <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ref</pc> (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">ByRef</pc> without the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">OutAttribute</pc> attribute in Visual Basic).</source>
          <target>Parameters cannot be marked <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ref</pc> (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">ByRef</pc> without the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">OutAttribute</pc> attribute in Visual Basic).</target>
        </segment>
      </unit>
      <unit id="265">
        <segment state="initial">
          <source>This applies to the contents of arrays, so array parameters must indicate whether the array contents are read-only or write-only.</source>
          <target>This applies to the contents of arrays, so array parameters must indicate whether the array contents are read-only or write-only.</target>
        </segment>
      </unit>
      <unit id="266">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>The direction is clear for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">out</pc> parameters (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">ByRef</pc> parameter with the OutAttribute attribute in Visual Basic), but array parameters that are passed by value (ByVal in Visual Basic) must be marked.</source>
          <target>The direction is clear for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">out</pc> parameters (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">ByRef</pc> parameter with the OutAttribute attribute in Visual Basic), but array parameters that are passed by value (ByVal in Visual Basic) must be marked.</target>
        </segment>
      </unit>
      <unit id="267">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](passing-arrays-to-a-windows-runtime-component.md)</data>
        </originalData>
        <segment state="initial">
          <source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Passing arrays to a Windows Runtime Component</pc>.</source>
          <target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Passing arrays to a Windows Runtime Component</pc>.</target>
        </segment>
      </unit>
      <unit id="268">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="269">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="270">
        <segment state="initial">
          <source>WME1101</source>
          <target>WME1101</target>
        </segment>
      </unit>
      <unit id="271">
        <segment state="initial">
          <source>Method '{0}' has parameter '{1}' which is an array, and which has both {2} and {3}.</source>
          <target>Method '{0}' has parameter '{1}' which is an array, and which has both {2} and {3}.</target>
        </segment>
      </unit>
      <unit id="272">
        <segment state="initial">
          <source>In the Windows Runtime, the contents array parameters must be either readable or writable.</source>
          <target>In the Windows Runtime, the contents array parameters must be either readable or writable.</target>
        </segment>
      </unit>
      <unit id="273">
        <segment state="initial">
          <source>Please remove one of the attributes from '{1}'.</source>
          <target>Please remove one of the attributes from '{1}'.</target>
        </segment>
      </unit>
      <unit id="274">
        <segment state="initial">
          <source>WME1102</source>
          <target>WME1102</target>
        </segment>
      </unit>
      <unit id="275">
        <segment state="initial">
          <source>Method '{0}' has an output parameter '{1}' which is an array, but which has {2}.</source>
          <target>Method '{0}' has an output parameter '{1}' which is an array, but which has {2}.</target>
        </segment>
      </unit>
      <unit id="276">
        <segment state="initial">
          <source>In the Windows Runtime, the contents of output arrays are writable.</source>
          <target>In the Windows Runtime, the contents of output arrays are writable.</target>
        </segment>
      </unit>
      <unit id="277">
        <segment state="initial">
          <source>Please remove the attribute from '{1}'.</source>
          <target>Please remove the attribute from '{1}'.</target>
        </segment>
      </unit>
      <unit id="278">
        <segment state="initial">
          <source>WME1103</source>
          <target>WME1103</target>
        </segment>
      </unit>
      <unit id="279">
        <segment state="initial">
          <source>Method '{0}' has parameter '{1}' which is an array, and which has either a System.Runtime.InteropServices.InAttribute or a System.Runtime.InteropServices.OutAttribute.</source>
          <target>Method '{0}' has parameter '{1}' which is an array, and which has either a System.Runtime.InteropServices.InAttribute or a System.Runtime.InteropServices.OutAttribute.</target>
        </segment>
      </unit>
      <unit id="280">
        <segment state="initial">
          <source>In the Windows Runtime, array parameters must have either {2} or {3}.</source>
          <target>In the Windows Runtime, array parameters must have either {2} or {3}.</target>
        </segment>
      </unit>
      <unit id="281">
        <segment state="initial">
          <source>Please remove these attributes or replace them with the appropriate Windows Runtime attribute if necessary.</source>
          <target>Please remove these attributes or replace them with the appropriate Windows Runtime attribute if necessary.</target>
        </segment>
      </unit>
      <unit id="282">
        <segment state="initial">
          <source>WME1104</source>
          <target>WME1104</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source>Method '{0}' has parameter '{1}' which is not an array, and which has either a {2} or a {3}.</source>
          <target>Method '{0}' has parameter '{1}' which is not an array, and which has either a {2} or a {3}.</target>
        </segment>
      </unit>
      <unit id="284">
        <segment state="initial">
          <source>Windows Runtime does not support marking non-array parameters with {2} or {3}.</source>
          <target>Windows Runtime does not support marking non-array parameters with {2} or {3}.</target>
        </segment>
      </unit>
      <unit id="285">
        <segment state="initial">
          <source>WME1105</source>
          <target>WME1105</target>
        </segment>
      </unit>
      <unit id="286">
        <segment state="initial">
          <source>Method '{0}' has parameter '{1}' with a System.Runtime.InteropServices.InAttribute or System.Runtime.InteropServices.OutAttribute.</source>
          <target>Method '{0}' has parameter '{1}' with a System.Runtime.InteropServices.InAttribute or System.Runtime.InteropServices.OutAttribute.</target>
        </segment>
      </unit>
      <unit id="287">
        <segment state="initial">
          <source>Windows Runtime does not support marking parameters with System.Runtime.InteropServices.InAttribute or System.Runtime.InteropServices.OutAttribute.</source>
          <target>Windows Runtime does not support marking parameters with System.Runtime.InteropServices.InAttribute or System.Runtime.InteropServices.OutAttribute.</target>
        </segment>
      </unit>
      <unit id="288">
        <segment state="initial">
          <source>Please consider removing System.Runtime.InteropServices.InAttribute and replace System.Runtime.InteropServices.OutAttribute with 'out' modifier instead.</source>
          <target>Please consider removing System.Runtime.InteropServices.InAttribute and replace System.Runtime.InteropServices.OutAttribute with 'out' modifier instead.</target>
        </segment>
      </unit>
      <unit id="289">
        <segment state="initial">
          <source>Method '{0}' has parameter '{1}' with a System.Runtime.InteropServices.InAttribute or System.Runtime.InteropServices.OutAttribute.</source>
          <target>Method '{0}' has parameter '{1}' with a System.Runtime.InteropServices.InAttribute or System.Runtime.InteropServices.OutAttribute.</target>
        </segment>
      </unit>
      <unit id="290">
        <segment state="initial">
          <source>Windows Runtime only supports marking ByRef parameters with System.Runtime.InteropServices.OutAttribute, and does not support other usages of those attributes.</source>
          <target>Windows Runtime only supports marking ByRef parameters with System.Runtime.InteropServices.OutAttribute, and does not support other usages of those attributes.</target>
        </segment>
      </unit>
      <unit id="291">
        <segment state="initial">
          <source>WME1106</source>
          <target>WME1106</target>
        </segment>
      </unit>
      <unit id="292">
        <segment state="initial">
          <source>Method '{0}' has parameter '{1}' which is an array.</source>
          <target>Method '{0}' has parameter '{1}' which is an array.</target>
        </segment>
      </unit>
      <unit id="293">
        <segment state="initial">
          <source>In the Windows Runtime, the contents of array parameters must be either readable or writable.</source>
          <target>In the Windows Runtime, the contents of array parameters must be either readable or writable.</target>
        </segment>
      </unit>
      <unit id="294">
        <segment state="initial">
          <source>Please apply either {2} or {3} to '{1}'.</source>
          <target>Please apply either {2} or {3} to '{1}'.</target>
        </segment>
      </unit>
      <unit id="295">
        <segment state="initial">
          <source>Member with a parameter named "value"</source>
          <target>Member with a parameter named "value"</target>
        </segment>
      </unit>
      <unit id="296">
        <segment state="initial">
          <source>In the UWP, return values are considered to be output parameters, and the names of parameters must be unique.</source>
          <target>In the UWP, return values are considered to be output parameters, and the names of parameters must be unique.</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source>By default, Winmdexp.exe gives the return value the name "value".</source>
          <target>By default, Winmdexp.exe gives the return value the name "value".</target>
        </segment>
      </unit>
      <unit id="298">
        <segment state="initial">
          <source>If your method has a parameter named "value", you will get error WME1092.</source>
          <target>If your method has a parameter named "value", you will get error WME1092.</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source>There are two ways to correct this:</source>
          <target>There are two ways to correct this:</target>
        </segment>
      </unit>
      <unit id="300">
        <segment state="initial">
          <source>Give your parameter a name other than "value" (in property accessors, a name other than "returnValue").</source>
          <target>Give your parameter a name other than "value" (in property accessors, a name other than "returnValue").</target>
        </segment>
      </unit>
      <unit id="301">
        <segment state="initial">
          <source>Use the ReturnValueNameAttribute attribute to change the name of the return value, as shown here:</source>
          <target>Use the ReturnValueNameAttribute attribute to change the name of the return value, as shown here:</target>
        </segment>
      </unit>
      <unit id="302">
        <segment state="initial">
          <source>[!div class="tabbedCodeSnippets"]</source>
          <target>[!div class="tabbedCodeSnippets"]</target>
        </segment>
      </unit>
      <unit id="303">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you change the name of the return value, and the new name collides with the name of another parameter, you will get error WME1091.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you change the name of the return value, and the new name collides with the name of another parameter, you will get error WME1091.</target>
        </segment>
      </unit>
      <unit id="304">
        <segment state="initial">
          <source>JavaScript code can access the output parameters of a method by name, including the return value.</source>
          <target>JavaScript code can access the output parameters of a method by name, including the return value.</target>
        </segment>
      </unit>
      <unit id="305">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/system.runtime.interopservices.windowsruntime.returnvaluenameattribute.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>For an example, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReturnValueNameAttribute</pc> attribute.</source>
          <target>For an example, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ReturnValueNameAttribute</pc> attribute.</target>
        </segment>
      </unit>
      <unit id="306">
        <segment state="initial">
          <source>Error number</source>
          <target>Error number</target>
        </segment>
      </unit>
      <unit id="307">
        <segment state="initial">
          <source>Message Text</source>
          <target>Message Text</target>
        </segment>
      </unit>
      <unit id="308">
        <segment state="initial">
          <source>WME1091</source>
          <target>WME1091</target>
        </segment>
      </unit>
      <unit id="309">
        <originalData>
          <data id="id1">\{</data>
          <data id="id2">\{</data>
        </originalData>
        <segment state="initial">
          <source>The method '<ph dataRef="id1" id="ph1" />0}' has the return value named '<ph dataRef="id2" id="ph2" />1}' which is the same as a parameter name.</source>
          <target>The method '<ph dataRef="id1" id="ph1" />0}' has the return value named '<ph dataRef="id2" id="ph2" />1}' which is the same as a parameter name.</target>
        </segment>
      </unit>
      <unit id="310">
        <segment state="initial">
          <source>Windows Runtime method parameters and return value must have unique names.</source>
          <target>Windows Runtime method parameters and return value must have unique names.</target>
        </segment>
      </unit>
      <unit id="311">
        <segment state="initial">
          <source>WME1092</source>
          <target>WME1092</target>
        </segment>
      </unit>
      <unit id="312">
        <originalData>
          <data id="id1">\{</data>
          <data id="id2">\{</data>
        </originalData>
        <segment state="initial">
          <source>The method '<ph dataRef="id1" id="ph1" />0}' has a parameter named '<ph dataRef="id2" id="ph2" />1}' which is the same as the default return value name.</source>
          <target>The method '<ph dataRef="id1" id="ph1" />0}' has a parameter named '<ph dataRef="id2" id="ph2" />1}' which is the same as the default return value name.</target>
        </segment>
      </unit>
      <unit id="313">
        <segment state="initial">
          <source>Consider using another name for the parameter or use the System.Runtime.InteropServices.WindowsRuntime.ReturnValueNameAttribute to explicitly specify the name of the return value.</source>
          <target>Consider using another name for the parameter or use the System.Runtime.InteropServices.WindowsRuntime.ReturnValueNameAttribute to explicitly specify the name of the return value.</target>
        </segment>
      </unit>
      <unit id="314">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The default name is "returnValue" for property accessors and "value" for all other methods.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The default name is "returnValue" for property accessors and "value" for all other methods.</target>
        </segment>
      </unit>
      <unit id="315">
        <segment state="initial">
          <source>Related topics</source>
          <target>Related topics</target>
        </segment>
      </unit>
      <unit id="316">
        <segment state="initial">
          <source>Creating Windows Runtime Components in C# and Visual Basic</source>
          <target>Creating Windows Runtime Components in C# and Visual Basic</target>
        </segment>
      </unit>
      <unit id="317">
        <segment state="initial">
          <source>Winmdexp.exe (Windows Runtime Metadata Export Tool)</source>
          <target>Winmdexp.exe (Windows Runtime Metadata Export Tool)</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>