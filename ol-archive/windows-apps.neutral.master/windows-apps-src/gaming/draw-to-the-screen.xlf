<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="zh-cn" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">windows-apps-src\gaming\draw-to-the-screen.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">1b7431c20e25173a0aa3f8d6ee0d407be869d60a</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-781aacf</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>Draw to the screen</source>
          <target>Draw to the screen</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>Finally, we port the code that draws the spinning cube to the screen.</source>
          <target>Finally, we port the code that draws the spinning cube to the screen.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>Draw to the screen</source>
          <target>Draw to the screen</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>Updated for UWP apps on Windows 10.</source>
          <target>Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="105">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></source>
          <target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>Important APIs</source>
          <target>Important APIs</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>ID3D11Texture2D</source>
          <target>ID3D11Texture2D</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source>ID3D11RenderTargetView</source>
          <target>ID3D11RenderTargetView</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source>IDXGISwapChain1</source>
          <target>IDXGISwapChain1</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>Finally, we port the code that draws the spinning cube to the screen.</source>
          <target>Finally, we port the code that draws the spinning cube to the screen.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source>In OpenGL ES 2.0, your drawing context is defined as an EGLContext type, which contains the window and surface parameters as well the resources necessary for drawing to the render targets that will be used to compose the final image displayed to the window.</source>
          <target>In OpenGL ES 2.0, your drawing context is defined as an EGLContext type, which contains the window and surface parameters as well the resources necessary for drawing to the render targets that will be used to compose the final image displayed to the window.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source>You use this context to configure the graphics resources to correctly display the results of your shader pipeline on the display.</source>
          <target>You use this context to configure the graphics resources to correctly display the results of your shader pipeline on the display.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source>One of the primary resources is the "back buffer" (or "frame buffer object") that contains the final, composited render targets, ready for presentation to the display.</source>
          <target>One of the primary resources is the "back buffer" (or "frame buffer object") that contains the final, composited render targets, ready for presentation to the display.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source>With Direct3D, the process of configuring the graphics resources for drawing to the display is more didactic, and requires quite a few more APIs.</source>
          <target>With Direct3D, the process of configuring the graphics resources for drawing to the display is more didactic, and requires quite a few more APIs.</target>
        </segment>
      </unit>
      <unit id="115">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source>(A Microsoft Visual Studio Direct3D template can significantly simplify this process, though!) To obtain a context (called a Direct3D device context), you must first obtain an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device1</pc></pc> object, and use it to create and configure an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext1</pc></pc> object.</source>
          <target>(A Microsoft Visual Studio Direct3D template can significantly simplify this process, though!) To obtain a context (called a Direct3D device context), you must first obtain an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device1</pc></pc> object, and use it to create and configure an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11DeviceContext1</pc></pc> object.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source>These two objects are used in conjunction to configure the specific resources you need for drawing to the display.</source>
          <target>These two objects are used in conjunction to configure the specific resources you need for drawing to the display.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source>In short, the DXGI APIs contain primarily APIs for managing resources that directly pertain to the graphics adapter, and Direct3D contains the APIs that allow you to interface between the GPU and your main program running on the CPU.</source>
          <target>In short, the DXGI APIs contain primarily APIs for managing resources that directly pertain to the graphics adapter, and Direct3D contains the APIs that allow you to interface between the GPU and your main program running on the CPU.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source>For the purposes of comparison in this sample, here are the relevant types from each API:</source>
          <target>For the purposes of comparison in this sample, here are the relevant types from each API:</target>
        </segment>
      </unit>
      <unit id="119">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">
              <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device1</pc>
            </pc>: provides a virtual representation of the graphics device and its resources.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">
              <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11Device1</pc>
            </pc>: provides a virtual representation of the graphics device and its resources.</target>
        </segment>
      </unit>
      <unit id="120">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">
              <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1</pc>
            </pc>: provides the interface to configure buffers and issue rendering commands.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">
              <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1</pc>
            </pc>: provides the interface to configure buffers and issue rendering commands.</target>
        </segment>
      </unit>
      <unit id="121">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">
              <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1</pc>
            </pc>: the swap chain is analogous to the back buffer in OpenGL ES 2.0.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">
              <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1</pc>
            </pc>: the swap chain is analogous to the back buffer in OpenGL ES 2.0.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>It is the region of memory on the graphics adapter that contains the final rendered image(s) for display.</source>
          <target>It is the region of memory on the graphics adapter that contains the final rendered image(s) for display.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>It is called the "swap chain" because it has several buffers that can be written to and "swapped" to present the latest render to the screen.</source>
          <target>It is called the "swap chain" because it has several buffers that can be written to and "swapped" to present the latest render to the screen.</target>
        </segment>
      </unit>
      <unit id="124">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">
              <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc>
            </pc>: this contains the 2D bitmap buffer that the Direct3D device context draws into, and which is presented by the swap chain.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">
              <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11RenderTargetView</pc>
            </pc>: this contains the 2D bitmap buffer that the Direct3D device context draws into, and which is presented by the swap chain.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>As with OpenGL ES 2.0, you can have multiple render targets, some of which are not bound to the swap chain but are used for multi-pass shading techniques.</source>
          <target>As with OpenGL ES 2.0, you can have multiple render targets, some of which are not bound to the swap chain but are used for multi-pass shading techniques.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source>In the template, the renderer object contains the following fields:</source>
          <target>In the template, the renderer object contains the following fields:</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source>Direct3D 11: Device and device context declarations</source>
          <target>Direct3D 11: Device and device context declarations</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source>Here's how the back buffer is configured as a render target and provided to the swap chain.</source>
          <target>Here's how the back buffer is configured as a render target and provided to the swap chain.</target>
        </segment>
      </unit>
      <unit id="129">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff471343)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source>The Direct3D runtime implicitly creates an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISurface1</pc></pc> for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11Texture2D</pc></pc>, which represents the texture as a "back buffer" that the swap chain can use for display.</source>
          <target>The Direct3D runtime implicitly creates an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISurface1</pc></pc> for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ID3D11Texture2D</pc></pc>, which represents the texture as a "back buffer" that the swap chain can use for display.</target>
        </segment>
      </unit>
      <unit id="130">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>The initialization and configuration of the Direct3D device and device context, as well as the render targets, can be found in the custom <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResources</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateWindowSizeDependentResources</pc> methods in the Direct3D template.</source>
          <target>The initialization and configuration of the Direct3D device and device context, as well as the render targets, can be found in the custom <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDeviceResources</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateWindowSizeDependentResources</pc> methods in the Direct3D template.</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](moving-from-egl-to-dxgi.md)</data>
        </originalData>
        <segment state="initial">
          <source>For more info on Direct3D device context as it relates to EGL and the EGLContext type, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port EGL code to DXGI and Direct3D</pc>.</source>
          <target>For more info on Direct3D device context as it relates to EGL and the EGLContext type, read <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Port EGL code to DXGI and Direct3D</pc>.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>Instructions</source>
          <target>Instructions</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>Step 1: Rendering the scene and displaying it</source>
          <target>Step 1: Rendering the scene and displaying it</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>After updating the cube data (in this case, by rotating it slightly around the y axis), the Render method sets the viewport to the dimensions of he drawing context (an EGLContext).</source>
          <target>After updating the cube data (in this case, by rotating it slightly around the y axis), the Render method sets the viewport to the dimensions of he drawing context (an EGLContext).</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source>This context contains the color buffer that will be displayed to the window surface (an EGLSurface), using the configured display (EGLDisplay).</source>
          <target>This context contains the color buffer that will be displayed to the window surface (an EGLSurface), using the configured display (EGLDisplay).</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source>At this time, the example updates the vertex data attributes, re-binds the index buffer, draws the cube, and swaps in color buffer drawn by the shading pipeline to the display surface.</source>
          <target>At this time, the example updates the vertex data attributes, re-binds the index buffer, draws the cube, and swaps in color buffer drawn by the shading pipeline to the display surface.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>OpenGL ES 2.0: Rendering a frame for display</source>
          <target>OpenGL ES 2.0: Rendering a frame for display</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source>In Direct3D 11, the process is very similar.</source>
          <target>In Direct3D 11, the process is very similar.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source>(We're assuming that you're using the viewport and render target configuration from the Direct3D template.</source>
          <target>(We're assuming that you're using the viewport and render target configuration from the Direct3D template.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446790)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Update the constant buffers (the model-view-projection matrix, in this case) with calls to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::UpdateSubresource</pc></pc>.</source>
          <target>Update the constant buffers (the model-view-projection matrix, in this case) with calls to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::UpdateSubresource</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="141">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Set the vertex buffer with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::IASetVertexBuffers</pc></pc>.</source>
          <target>Set the vertex buffer with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::IASetVertexBuffers</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476453)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Set the index buffer with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::IASetIndexBuffer</pc></pc>.</source>
          <target>Set the index buffer with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::IASetIndexBuffer</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="143">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476455)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Set the specific triangle topology (a triangle list) with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::IASetPrimitiveTopology</pc></pc>.</source>
          <target>Set the specific triangle topology (a triangle list) with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::IASetPrimitiveTopology</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="144">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Set the input layout of the vertex buffer with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::IASetInputLayout</pc></pc>.</source>
          <target>Set the input layout of the vertex buffer with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::IASetInputLayout</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="145">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Bind the vertex shader with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::VSSetShader</pc></pc>.</source>
          <target>Bind the vertex shader with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::VSSetShader</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Bind the fragment shader with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::PSSetShader</pc></pc>.</source>
          <target>Bind the fragment shader with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::PSSetShader</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Send the indexed vertices through the shaders and output the color results to the render target buffer with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::DrawIndexed</pc></pc>.</source>
          <target>Send the indexed vertices through the shaders and output the color results to the render target buffer with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ID3D11DeviceContext1::DrawIndexed</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="148">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Display the render target buffer with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::Present1</pc></pc>.</source>
          <target>Display the render target buffer with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::Present1</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>Direct3D 11: Rendering a frame for display</source>
          <target>Direct3D 11: Rendering a frame for display</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Once <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::Present1</pc></pc> is called, your frame is output to the configured display.</source>
          <target>Once <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IDXGISwapChain1::Present1</pc></pc> is called, your frame is output to the configured display.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source>Previous step</source>
          <target>Previous step</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>Port the GLSL</source>
          <target>Port the GLSL</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source>Remarks</source>
          <target>Remarks</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>This example glosses over much of the complexity that goes into configuring device resources, especially for Universal Windows Platform (UWP) DirectX apps.</source>
          <target>This example glosses over much of the complexity that goes into configuring device resources, especially for Universal Windows Platform (UWP) DirectX apps.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>We suggest you review the full template code, especially the parts that perform the window and device resource setup and management.</source>
          <target>We suggest you review the full template code, especially the parts that perform the window and device resource setup and management.</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source>UWP apps have to support rotation events as well as suspend/resume events, and the template demonstrates best practices for handling the loss of an interface or a change in the display parameters.</source>
          <target>UWP apps have to support rotation events as well as suspend/resume events, and the template demonstrates best practices for handling the loss of an interface or a change in the display parameters.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source>Related topics</source>
          <target>Related topics</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</source>
          <target>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>Port the shader objects</source>
          <target>Port the shader objects</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source>Port the GLSL</source>
          <target>Port the GLSL</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source>Draw to the screen</source>
          <target>Draw to the screen</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>