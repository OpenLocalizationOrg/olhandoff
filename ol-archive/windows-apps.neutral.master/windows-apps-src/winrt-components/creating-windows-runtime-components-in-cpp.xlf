<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="zh-cn" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">windows-apps-src\winrt-components\creating-windows-runtime-components-in-cpp.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">1497175723738cc23ec21b280c9639b216a33ddd</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-781aacf</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>Creating Windows Runtime Components in C++</source>
          <target>Creating Windows Runtime Components in C++</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>This article shows how to use C++ to create a Windows Runtime component, which is a DLL that's callable from a Universal Windows app that's built by using JavaScript—or C#, Visual Basic, or C++.</source>
          <target>This article shows how to use C++ to create a Windows Runtime component, which is a DLL that's callable from a Universal Windows app that's built by using JavaScript—or C#, Visual Basic, or C++.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>Creating Windows Runtime Components in C++</source>
          <target>Creating Windows Runtime Components in C++</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>Updated for UWP apps on Windows 10.</source>
          <target>Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="105">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></source>
          <target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>This article shows how to use C++ to create a Windows Runtime component, which is a DLL that's callable from a Universal Windows app that's built by using JavaScript—or C#, Visual Basic, or C++.</source>
          <target>This article shows how to use C++ to create a Windows Runtime component, which is a DLL that's callable from a Universal Windows app that's built by using JavaScript—or C#, Visual Basic, or C++.</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>Here are several reasons for building such a component:</source>
          <target>Here are several reasons for building such a component:</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source>To get the performance advantage of C++ in complex or computationally intensive operations.</source>
          <target>To get the performance advantage of C++ in complex or computationally intensive operations.</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source>To reuse code that's already written and tested.</source>
          <target>To reuse code that's already written and tested.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>When you build a solution that contains a JavaScript or .NET project, and a Windows Runtime component project, the JavaScript project files and the compiled DLL are merged into one package, which you can debug locally in the simulator or remotely on a tethered device.</source>
          <target>When you build a solution that contains a JavaScript or .NET project, and a Windows Runtime component project, the JavaScript project files and the compiled DLL are merged into one package, which you can debug locally in the simulator or remotely on a tethered device.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source>You can also distribute just the component project as an Extension SDK.</source>
          <target>You can also distribute just the component project as an Extension SDK.</target>
        </segment>
      </unit>
      <unit id="112">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/hh768146.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating a Software Development Kit</pc>.</source>
          <target>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating a Software Development Kit</pc>.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source>In general, when you code your C++ component, use the regular C++ library and built-in types, except at the abstract binary interface (ABI) boundary where you are passing data to and from code in another .winmd package.</source>
          <target>In general, when you code your C++ component, use the regular C++ library and built-in types, except at the abstract binary interface (ABI) boundary where you are passing data to and from code in another .winmd package.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source>There, use Windows Runtime types and the special syntax that Visual C++ supports for creating and manipulating those types.</source>
          <target>There, use Windows Runtime types and the special syntax that Visual C++ supports for creating and manipulating those types.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source>In addition, in your Visual C++ code, use types such as delegate and event to implement events that can be fired from your component and handled in JavaScript, Visual Basic, or C#.</source>
          <target>In addition, in your Visual C++ code, use types such as delegate and event to implement events that can be fired from your component and handled in JavaScript, Visual Basic, or C#.</target>
        </segment>
      </unit>
      <unit id="116">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh699871.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>For more information about the new Visual C++ syntax, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visual C++ Language Reference (C++/CX)</pc>.</source>
          <target>For more information about the new Visual C++ syntax, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visual C++ Language Reference (C++/CX)</pc>.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source>Casing and naming rules</source>
          <target>Casing and naming rules</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source>JavaScript</source>
          <target>JavaScript</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source>JavaScript is case-sensitive.</source>
          <target>JavaScript is case-sensitive.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source>Therefore, you must follow these casing conventions:</source>
          <target>Therefore, you must follow these casing conventions:</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>When you reference C++ namespaces and classes, use the same casing that's used on the C++ side.</source>
          <target>When you reference C++ namespaces and classes, use the same casing that's used on the C++ side.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>When you call methods, use camel casing even if the method name is capitalized on the C++ side.</source>
          <target>When you call methods, use camel casing even if the method name is capitalized on the C++ side.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>For example, a C++ method GetDate() must be called from JavaScript as getDate().</source>
          <target>For example, a C++ method GetDate() must be called from JavaScript as getDate().</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>An activatable class name and namespace name can't contain UNICODE characters.</source>
          <target>An activatable class name and namespace name can't contain UNICODE characters.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>.NET</source>
          <target>.NET</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source>The .NET languages follow their normal casing rules.</source>
          <target>The .NET languages follow their normal casing rules.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source>Instantiating the object</source>
          <target>Instantiating the object</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source>Only Windows Runtime types can be passed across the ABI boundary.</source>
          <target>Only Windows Runtime types can be passed across the ABI boundary.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source>The compiler will raise an error if the component has a type like std::wstring as a return type or parameter in a public method.</source>
          <target>The compiler will raise an error if the component has a type like std::wstring as a return type or parameter in a public method.</target>
        </segment>
      </unit>
      <unit id="130">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh755822.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>The Visual C++ component extensions (C++/CX) built-in types include the usual scalars such as int and double, and also their typedef equivalents int32, float64, and so on.For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type System (C++/CX)</pc>.</source>
          <target>The Visual C++ component extensions (C++/CX) built-in types include the usual scalars such as int and double, and also their typedef equivalents int32, float64, and so on.For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type System (C++/CX)</pc>.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>C++ built-in types, library types, and Windows Runtime types</source>
          <target>C++ built-in types, library types, and Windows Runtime types</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>An activatable class (also known as a ref class) is one that can be instantiated from another language such as JavaScript, C# or Visual Basic.</source>
          <target>An activatable class (also known as a ref class) is one that can be instantiated from another language such as JavaScript, C# or Visual Basic.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>To be consumable from another language, a component must contain at least one activatable class.</source>
          <target>To be consumable from another language, a component must contain at least one activatable class.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>A Windows Runtime component can contain multiple public activatable classes as well as additional classes that are known only internally to the component.</source>
          <target>A Windows Runtime component can contain multiple public activatable classes as well as additional classes that are known only internally to the component.</target>
        </segment>
      </unit>
      <unit id="135">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.webhosthiddenattribute.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>Apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WebHostHidden</pc> attribute to C++ types that are not intended to be visible to JavaScript.</source>
          <target>Apply the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WebHostHidden</pc> attribute to C++ types that are not intended to be visible to JavaScript.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source>All public classes must reside in the same root namespace which has the same name as the component metadata file.</source>
          <target>All public classes must reside in the same root namespace which has the same name as the component metadata file.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>For example, a class that's named A.B.C.MyClass can be instantiated only if it's defined in a metadata file that's named A.winmd or A.B.winmd or A.B.C.winmd.</source>
          <target>For example, a class that's named A.B.C.MyClass can be instantiated only if it's defined in a metadata file that's named A.winmd or A.B.winmd or A.B.C.winmd.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source>The name of the DLL is not required to match the .winmd file name.</source>
          <target>The name of the DLL is not required to match the .winmd file name.</target>
        </segment>
      </unit>
      <unit id="139">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Client code creates an instance of the component by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">new</pc> (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">New</pc> in Visual Basic) keyword just as for any class.</source>
          <target>Client code creates an instance of the component by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">new</pc> (<pc dataRefEnd="id4" dataRefStart="id3" id="p2">New</pc> in Visual Basic) keyword just as for any class.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>An activatable class must be declared as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public ref class sealed</pc>.</source>
          <target>An activatable class must be declared as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public ref class sealed</pc>.</target>
        </segment>
      </unit>
      <unit id="141">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ref class</pc> keyword tells the compiler to create the class as a Windows Runtime compatible type, and the sealed keyword specifies that the class cannot be inherited.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ref class</pc> keyword tells the compiler to create the class as a Windows Runtime compatible type, and the sealed keyword specifies that the class cannot be inherited.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source>The Windows Runtime does not currently support a generalized inheritance model; a limited inheritance model supports creation of custom XAML controls.</source>
          <target>The Windows Runtime does not currently support a generalized inheritance model; a limited inheritance model supports creation of custom XAML controls.</target>
        </segment>
      </unit>
      <unit id="143">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh699870.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Ref classes and structs (C++/CX)</pc>.</source>
          <target>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Ref classes and structs (C++/CX)</pc>.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>For C++, all the numeric primitives are defined in the default namespace.</source>
          <target>For C++, all the numeric primitives are defined in the default namespace.</target>
        </segment>
      </unit>
      <unit id="145">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710417.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Platform</pc> namespace contains C++ classes that are specific to the Windows Runtime type system.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Platform</pc> namespace contains C++ classes that are specific to the Windows Runtime type system.</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/xaml/hh748265.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>These include <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Platform::String</pc> class and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Platform::Object</pc> class.</source>
          <target>These include <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Platform::String</pc> class and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Platform::Object</pc> class.</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh441508.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/xaml/hh441570.aspx)</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710418.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>The concrete collection types such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Platform::Collections::Map</pc> class and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Platform::Collections::Vector</pc> class are defined in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Platform::Collections</pc> namespace.</source>
          <target>The concrete collection types such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Platform::Collections::Map</pc> class and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Platform::Collections::Vector</pc> class are defined in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Platform::Collections</pc> namespace.</target>
        </segment>
      </unit>
      <unit id="148">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh441496.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>The public interfaces that these types implement are defined in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows::Foundation::Collections Namespace (C++/CX)</pc>.</source>
          <target>The public interfaces that these types implement are defined in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows::Foundation::Collections Namespace (C++/CX)</pc>.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>It is these interface types that are consumed by JavaScript, C# and Visual Basic.</source>
          <target>It is these interface types that are consumed by JavaScript, C# and Visual Basic.</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh755822.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type System (C++/CX)</pc>.</source>
          <target>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type System (C++/CX)</pc>.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source>Method that returns a value of built-in type</source>
          <target>Method that returns a value of built-in type</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>Method that returns a custom value struct</source>
          <target>Method that returns a custom value struct</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source>To pass user-defined value structs across the ABI, define a JavaScript object that has the same members as the value struct that's defined in C++.</source>
          <target>To pass user-defined value structs across the ABI, define a JavaScript object that has the same members as the value struct that's defined in C++.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>You can then pass that object as an argument to a C++ method so that the object is implicitly converted to the C++ type.</source>
          <target>You can then pass that object as an argument to a C++ method so that the object is implicitly converted to the C++ type.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>Another approach is to define a class that implements IPropertySet (not shown).</source>
          <target>Another approach is to define a class that implements IPropertySet (not shown).</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source>In the .NET languages, you just create a variable of the type that's defined in the C++ component.</source>
          <target>In the .NET languages, you just create a variable of the type that's defined in the C++ component.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source>Overloaded Methods</source>
          <target>Overloaded Methods</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>A C++ public ref class can contain overloaded methods, but JavaScript has limited ability to differentiate overloaded methods.</source>
          <target>A C++ public ref class can contain overloaded methods, but JavaScript has limited ability to differentiate overloaded methods.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>For example, it can tell the difference between these signatures:</source>
          <target>For example, it can tell the difference between these signatures:</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source>But it can’t tell the difference between these:</source>
          <target>But it can’t tell the difference between these:</target>
        </segment>
      </unit>
      <unit id="161">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>In ambiguous cases, you can ensure that JavaScript always calls a specific overload by applying the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows::Foundation::Metadata::DefaultOverload</pc> attribute to the method signature in the header file.</source>
          <target>In ambiguous cases, you can ensure that JavaScript always calls a specific overload by applying the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows::Foundation::Metadata::DefaultOverload</pc> attribute to the method signature in the header file.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source>This JavaScript always calls the attributed overload:</source>
          <target>This JavaScript always calls the attributed overload:</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source>.NET</source>
          <target>.NET</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source>The .NET languages recognize overloads in a C++ ref class just as in any .NET Framework class.</source>
          <target>The .NET languages recognize overloads in a C++ ref class just as in any .NET Framework class.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source>DateTime</source>
          <target>DateTime</target>
        </segment>
      </unit>
      <unit id="166">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.datetime.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>In the Windows Runtime, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows::Foundation::DateTime</pc> object is just a 64-bit signed integer that represents the number of 100-nanosecond intervals either before or after January 1, 1601.</source>
          <target>In the Windows Runtime, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows::Foundation::DateTime</pc> object is just a 64-bit signed integer that represents the number of 100-nanosecond intervals either before or after January 1, 1601.</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source>There are no methods on a Windows:Foundation::DateTime object.</source>
          <target>There are no methods on a Windows:Foundation::DateTime object.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source>Instead, each language projects the DateTime in the way that is native to that language: the Date object in JavaScript and the System.DateTime and System.DateTimeOffset types in the .NET Framework.</source>
          <target>Instead, each language projects the DateTime in the way that is native to that language: the Date object in JavaScript and the System.DateTime and System.DateTimeOffset types in the .NET Framework.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>When you pass a DateTime value from C++ to JavaScript, JavaScript accepts it as a Date object and displays it by default as a long-form date string.</source>
          <target>When you pass a DateTime value from C++ to JavaScript, JavaScript accepts it as a Date object and displays it by default as a long-form date string.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source>When a .NET language passes a System.DateTime to a C++ component, the method accepts it as a Windows::Foundation::DateTime.</source>
          <target>When a .NET language passes a System.DateTime to a C++ component, the method accepts it as a Windows::Foundation::DateTime.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source>When the component passes a Windows::Foundation::DateTime to a .NET Framework method, the Framework method accepts it as a DateTimeOffset.</source>
          <target>When the component passes a Windows::Foundation::DateTime to a .NET Framework method, the Framework method accepts it as a DateTimeOffset.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source>Collections and arrays</source>
          <target>Collections and arrays</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source>Collections are always passed across the ABI boundary as handles to Windows Runtime types such as Windows::Foundation::Collections::IVector^ and Windows::Foundation::Collections::IMap^.</source>
          <target>Collections are always passed across the ABI boundary as handles to Windows Runtime types such as Windows::Foundation::Collections::IVector^ and Windows::Foundation::Collections::IMap^.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source>For example, if you return a handle to a Platform::Collections::Map, it implicitly converts to a Windows::Foundation::Collections::IMap^.</source>
          <target>For example, if you return a handle to a Platform::Collections::Map, it implicitly converts to a Windows::Foundation::Collections::IMap^.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source>The collection interfaces are defined in a namespace that's separate from the C++ classes that provide the concrete implementations.</source>
          <target>The collection interfaces are defined in a namespace that's separate from the C++ classes that provide the concrete implementations.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source>JavaScript and .NET languages consume the interfaces.</source>
          <target>JavaScript and .NET languages consume the interfaces.</target>
        </segment>
      </unit>
      <unit id="177">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com//library/windows/apps/hh700103.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh700131.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Collections (C++/CX)</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Array and WriteOnlyArray (C++/CX)</pc>.</source>
          <target>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Collections (C++/CX)</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Array and WriteOnlyArray (C++/CX)</pc>.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source>Passing IVector</source>
          <target>Passing IVector</target>
        </segment>
      </unit>
      <unit id="179">
        <originalData>
          <data id="id1">&amp;lt;</data>
          <data id="id2">&amp;gt;</data>
          <data id="id3">&amp;lt;</data>
          <data id="id4">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>The .NET languages see IVector<ph dataRef="id1" id="ph1" />T<ph dataRef="id2" id="ph2" /> as IList<ph dataRef="id3" id="ph3" />T<ph dataRef="id4" id="ph4" />.</source>
          <target>The .NET languages see IVector<ph dataRef="id1" id="ph1" />T<ph dataRef="id2" id="ph2" /> as IList<ph dataRef="id3" id="ph3" />T<ph dataRef="id4" id="ph4" />.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source>Passing IMap</source>
          <target>Passing IMap</target>
        </segment>
      </unit>
      <unit id="181">
        <originalData>
          <data id="id1">&amp;lt;</data>
          <data id="id2">&amp;gt;</data>
        </originalData>
        <segment state="initial">
          <source>The .NET languages see IMap and IDictionary<ph dataRef="id1" id="ph1" />K, V<ph dataRef="id2" id="ph2" />.</source>
          <target>The .NET languages see IMap and IDictionary<ph dataRef="id1" id="ph1" />K, V<ph dataRef="id2" id="ph2" />.</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source>Properties</source>
          <target>Properties</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source>A public ref class in Visual C++ component extensions exposes public data members as properties, by using the property keyword.</source>
          <target>A public ref class in Visual C++ component extensions exposes public data members as properties, by using the property keyword.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source>The concept is identical to .NET Framework properties.</source>
          <target>The concept is identical to .NET Framework properties.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source>A trivial property resembles a data member because its functionality is implicit.</source>
          <target>A trivial property resembles a data member because its functionality is implicit.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source>A non-trivial property has explicit get and set accessors and a named private variable that's the "backing store" for the value.</source>
          <target>A non-trivial property has explicit get and set accessors and a named private variable that's the "backing store" for the value.</target>
        </segment>
      </unit>
      <unit id="187">
        <originalData>
          <data id="id1">\_</data>
        </originalData>
        <segment state="initial">
          <source>In this example, the private member variable <ph dataRef="id1" id="ph1" />propertyAValue is the backing store for PropertyA.</source>
          <target>In this example, the private member variable <ph dataRef="id1" id="ph1" />propertyAValue is the backing store for PropertyA.</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source>A property can fire an event when its value changes, and a client app can register to receive that event.</source>
          <target>A property can fire an event when its value changes, and a client app can register to receive that event.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source>The .NET languages access properties on a native C++ object just as they would on a .NET Framework object.</source>
          <target>The .NET languages access properties on a native C++ object just as they would on a .NET Framework object.</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source>Delegates and events</source>
          <target>Delegates and events</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source>A delegate is a Windows Runtime type that represents a function object.</source>
          <target>A delegate is a Windows Runtime type that represents a function object.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source>You can use delegates in connection with events, callbacks, and asynchronous method calls to specify an action to be performed later.</source>
          <target>You can use delegates in connection with events, callbacks, and asynchronous method calls to specify an action to be performed later.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source>Like a function object, the delegate provides type-safety by enabling the compiler to verify the return type and parameter types of the function.</source>
          <target>Like a function object, the delegate provides type-safety by enabling the compiler to verify the return type and parameter types of the function.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source>The declaration of a delegate resembles a function signature, the implementation resembles a class definition, and the invocation resembles a function invocation.</source>
          <target>The declaration of a delegate resembles a function signature, the implementation resembles a class definition, and the invocation resembles a function invocation.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source>Adding an event listener</source>
          <target>Adding an event listener</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source>You can use the event keyword to declare a public member of a specified delegate type.</source>
          <target>You can use the event keyword to declare a public member of a specified delegate type.</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source>Client code subscribes to the event by using the standard mechanisms that are provided in the particular language.</source>
          <target>Client code subscribes to the event by using the standard mechanisms that are provided in the particular language.</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source>This example uses the same C++ code as for the previous properties section.</source>
          <target>This example uses the same C++ code as for the previous properties section.</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source>In the .NET languages, subscribing to an event in a C++ component is the same as subscribing to an event in a .NET Framework class:</source>
          <target>In the .NET languages, subscribing to an event in a C++ component is the same as subscribing to an event in a .NET Framework class:</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source>Adding multiple event listeners for one event</source>
          <target>Adding multiple event listeners for one event</target>
        </segment>
      </unit>
      <unit id="201">
        <segment state="initial">
          <source>JavaScript has an addEventListener method that enables multiple handlers to subscribe to a single event.</source>
          <target>JavaScript has an addEventListener method that enables multiple handlers to subscribe to a single event.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source>In C#, any number of event handlers can subscribe to the event by using the += operator as shown in the previous example.</source>
          <target>In C#, any number of event handlers can subscribe to the event by using the += operator as shown in the previous example.</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source>Enums</source>
          <target>Enums</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source>A Windows Runtime enum in C++ is declared by using public class enum; it resembles a scoped enum in standard C++.</source>
          <target>A Windows Runtime enum in C++ is declared by using public class enum; it resembles a scoped enum in standard C++.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source>Enum values are passed between C++ and JavaScript as integers.</source>
          <target>Enum values are passed between C++ and JavaScript as integers.</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source>You can optionally declare a JavaScript object that contains the same named values as the C++ enum and use it as follows.</source>
          <target>You can optionally declare a JavaScript object that contains the same named values as the C++ enum and use it as follows.</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source>Both C# and Visual Basic have language support for enums.</source>
          <target>Both C# and Visual Basic have language support for enums.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source>These languages see a C++ public enum class just as they would see a .NET Framework enum.</source>
          <target>These languages see a C++ public enum class just as they would see a .NET Framework enum.</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source>Asynchronous methods</source>
          <target>Asynchronous methods</target>
        </segment>
      </unit>
      <unit id="210">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/hh750113.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>To consume asynchronous methods that are exposed by other Windows Runtime objects, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task Class (Concurrency Runtime)</pc>.</source>
          <target>To consume asynchronous methods that are exposed by other Windows Runtime objects, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task Class (Concurrency Runtime)</pc>.</target>
        </segment>
      </unit>
      <unit id="211">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/dd492427.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>For more information, see and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task Parallelism (Concurrency Runtime)</pc>.</source>
          <target>For more information, see and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Task Parallelism (Concurrency Runtime)</pc>.</target>
        </segment>
      </unit>
      <unit id="212">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/hh750102.aspx)</data>
          <data id="id3">\_</data>
        </originalData>
        <segment state="initial">
          <source>To implement asynchronous methods in C++, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">create<ph dataRef="id3" id="ph1" />async</pc> function that's defined in ppltasks.h.</source>
          <target>To implement asynchronous methods in C++, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">create<ph dataRef="id3" id="ph1" />async</pc> function that's defined in ppltasks.h.</target>
        </segment>
      </unit>
      <unit id="213">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/vstudio/hh750082.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating Asynchronous Operations in C++ for Windows Store Apps</pc>.</source>
          <target>For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating Asynchronous Operations in C++ for Windows Store Apps</pc>.</target>
        </segment>
      </unit>
      <unit id="214">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](walkthrough-creating-a-basic-windows-runtime-component-in-cpp-and-calling-it-from-javascript-or-csharp.md)</data>
        </originalData>
        <segment state="initial">
          <source>For an example, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Walkthrough: Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C#</pc>.</source>
          <target>For an example, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Walkthrough: Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C#</pc>.</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source>The .NET languages consume C++ asynchronous methods just as they would any asynchronous method that's defined in the .NET Framework.</source>
          <target>The .NET languages consume C++ asynchronous methods just as they would any asynchronous method that's defined in the .NET Framework.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source>Exceptions</source>
          <target>Exceptions</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source>You can throw any exception type that's defined by the Windows Runtime.</source>
          <target>You can throw any exception type that's defined by the Windows Runtime.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source>You cannot derive custom types from any Windows Runtime exception type.</source>
          <target>You cannot derive custom types from any Windows Runtime exception type.</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source>However, you can throw COMException and provide a custom HRESULT that can be accessed by the code that catches the exception.</source>
          <target>However, you can throw COMException and provide a custom HRESULT that can be accessed by the code that catches the exception.</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source>There's no way to specify a custom Message in a COMException.</source>
          <target>There's no way to specify a custom Message in a COMException.</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source>Debugging tips</source>
          <target>Debugging tips</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source>When you debug a JavaScript solution that has a component DLL, you can set the debugger to enable either stepping through script, or stepping through native code in the component, but not both at the same time.</source>
          <target>When you debug a JavaScript solution that has a component DLL, you can set the debugger to enable either stepping through script, or stepping through native code in the component, but not both at the same time.</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source>To change the setting, select the JavaScript project node in Solution Explorer and then choose Properties, Debugging, Debugger Type.</source>
          <target>To change the setting, select the JavaScript project node in Solution Explorer and then choose Properties, Debugging, Debugger Type.</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source>Be sure to select appropriate capabilities in the package designer.</source>
          <target>Be sure to select appropriate capabilities in the package designer.</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source>For example, if you are attempting to open an image file in the user's Pictures library by using the Windows Runtime APIs, be sure to select the Pictures Library check box in the Capabilities pane of the manifest designer.</source>
          <target>For example, if you are attempting to open an image file in the user's Pictures library by using the Windows Runtime APIs, be sure to select the Pictures Library check box in the Capabilities pane of the manifest designer.</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source>If your JavaScript code doesn't seem to be recognizing the public properties or methods in the component, make sure that in JavaScript you are using camel casing.</source>
          <target>If your JavaScript code doesn't seem to be recognizing the public properties or methods in the component, make sure that in JavaScript you are using camel casing.</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source>For example, the LogCalc C++ method must be referenced as logCalc in JavaScript.</source>
          <target>For example, the LogCalc C++ method must be referenced as logCalc in JavaScript.</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source>If you remove a C++ Windows Runtime component project from a solution, you must also manually remove the project reference from the JavaScript project.</source>
          <target>If you remove a C++ Windows Runtime component project from a solution, you must also manually remove the project reference from the JavaScript project.</target>
        </segment>
      </unit>
      <unit id="229">
        <segment state="initial">
          <source>Failure to do so prevents subsequent debug or build operations.</source>
          <target>Failure to do so prevents subsequent debug or build operations.</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source>If necessary, you can then add an assembly reference to the DLL.</source>
          <target>If necessary, you can then add an assembly reference to the DLL.</target>
        </segment>
      </unit>
      <unit id="231">
        <segment state="initial">
          <source>Related topics</source>
          <target>Related topics</target>
        </segment>
      </unit>
      <unit id="232">
        <segment state="initial">
          <source>Walkthrough: Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C</source>
          <target>Walkthrough: Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>