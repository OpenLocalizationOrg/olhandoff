<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="zh-cn" original="foo.file" tool-id="87a0eee5-210e-498d-bbb2-7451db9c325b" product-name="foo" product-version="1.0" build-num="1">
    <header>
      <tool tool-id="87a0eee5-210e-498d-bbb2-7451db9c325b" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
      <olfilehash xmlns="">51689a4533ba47ce22bed502089aaf485de7a27c</olfilehash>
    </header>
    <body>
      <group id="2af09e81-7856-470c-b167-888066e1e008">
        <trans-unit id="eb07b836-7f7b-4d86-8db7-60f540e9bb1f" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="new">Garbage Collection</target>
        </trans-unit>
        <trans-unit id="038b08d8-f3a4-4df0-9a54-2f204f13823f" xml:space="preserve">
          <source>Garbage collection is one of most important features of the .NET managed
code platform.</source>
          <target state="new">Garbage collection is one of most important features of the .NET managed
code platform.</target>
        </trans-unit>
        <trans-unit id="865d770a-5875-4782-a6b2-4d8fda8fae26" xml:space="preserve">
          <source>The garbage collector (GC) manages allocating and
releasing memory for you.</source>
          <target state="new">The garbage collector (GC) manages allocating and
releasing memory for you.</target>
        </trans-unit>
        <trans-unit id="084e2aca-7104-4b25-808c-f612562402e5" xml:space="preserve">
          <source>You do not need to how to allocate and release
memory or manage the lifetime of the objects that use that memory.</source>
          <target state="new">You do not need to how to allocate and release
memory or manage the lifetime of the objects that use that memory.</target>
        </trans-unit>
        <trans-unit id="cf6ad51d-9589-48d6-af57-93d6c2fe106c" xml:space="preserve">
          <source>An
allocation is made any time you <bpt id="24e96196-868a-4a1a-adf5-cdbb45585a24">&lt;em&gt;</bpt>new<ept id="24e96196-868a-4a1a-adf5-cdbb45585a24">&lt;/em&gt;</ept> an object or a value type is
boxed.</source>
          <target state="new">An
allocation is made any time you <bpt id="24e96196-868a-4a1a-adf5-cdbb45585a24">&lt;em&gt;</bpt>new<ept id="24e96196-868a-4a1a-adf5-cdbb45585a24">&lt;/em&gt;</ept> an object or a value type is
boxed.</target>
        </trans-unit>
        <trans-unit id="0cb4804e-8127-4ebe-b815-5eeab2337112" xml:space="preserve">
          <source>Allocations are typically very fast.</source>
          <target state="new">Allocations are typically very fast.</target>
        </trans-unit>
        <trans-unit id="091acf4a-daaa-48e4-9f36-eca4ebe76af5" xml:space="preserve">
          <source>When there isn't enough
memory to allocate an object, the GC must collect and dispose of garbage
memory to make memory available for new allocations.</source>
          <target state="new">When there isn't enough
memory to allocate an object, the GC must collect and dispose of garbage
memory to make memory available for new allocations.</target>
        </trans-unit>
        <trans-unit id="be5eadf7-7da4-454a-ab70-0c6afaa182fe" xml:space="preserve">
          <source>This process is
called "garbage collection".</source>
          <target state="new">This process is
called "garbage collection".</target>
        </trans-unit>
        <trans-unit id="0e17e941-787f-4ff9-ac74-d1ba1f3b937b" xml:space="preserve">
          <source>The garbage collector serves as an automatic memory manager.</source>
          <target state="new">The garbage collector serves as an automatic memory manager.</target>
        </trans-unit>
        <trans-unit id="1a7246e6-a229-415a-9fab-4c1b5e762ebc" xml:space="preserve">
          <source>It provides
the following benefits:</source>
          <target state="new">It provides
the following benefits:</target>
        </trans-unit>
        <trans-unit id="56304f6d-03ee-4519-aae6-cb17ef6ec45c" xml:space="preserve">
          <source>Enables you to develop your application without having to
free memory.</source>
          <target state="new">Enables you to develop your application without having to
free memory.</target>
        </trans-unit>
        <trans-unit id="54aa63f2-48d8-4273-ad90-548626e5447b" xml:space="preserve">
          <source>Allocates objects on the managed heap efficiently.</source>
          <target state="new">Allocates objects on the managed heap efficiently.</target>
        </trans-unit>
        <trans-unit id="864b323c-b403-4f3a-8766-0c14dab060cb" xml:space="preserve">
          <source>Reclaims objects that are no longer being used, clears their memory,
and keeps the memory available for future allocations.</source>
          <target state="new">Reclaims objects that are no longer being used, clears their memory,
and keeps the memory available for future allocations.</target>
        </trans-unit>
        <trans-unit id="761ce6d4-1132-4a56-9668-f67b240447b8" xml:space="preserve">
          <source>Managed
objects automatically get clean content to start with, so their
constructors do not have to initialize every data field.</source>
          <target state="new">Managed
objects automatically get clean content to start with, so their
constructors do not have to initialize every data field.</target>
        </trans-unit>
        <trans-unit id="8acd7245-f5a7-446f-8f22-dfd81a3195a7" xml:space="preserve">
          <source>Provides memory safety by making sure that an object cannot use the
content of another object.</source>
          <target state="new">Provides memory safety by making sure that an object cannot use the
content of another object.</target>
        </trans-unit>
        <trans-unit id="dcda2e7f-d023-4339-b5a0-8a06b117c2d8" xml:space="preserve">
          <source>The .NET GC is generational and has 3 generations.</source>
          <target state="new">The .NET GC is generational and has 3 generations.</target>
        </trans-unit>
        <trans-unit id="155f1848-368d-4081-8391-f17a39208f57" xml:space="preserve">
          <source>Each generation has
its own heap that it uses for storage of allocated objects.</source>
          <target state="new">Each generation has
its own heap that it uses for storage of allocated objects.</target>
        </trans-unit>
        <trans-unit id="1f63e440-f73d-4433-bb82-d4d49c3d5d32" xml:space="preserve">
          <source>There is a
basic principle that most objects are either short lived or long lived.</source>
          <target state="new">There is a
basic principle that most objects are either short lived or long lived.</target>
        </trans-unit>
        <trans-unit id="6ffc62e9-ec6a-4067-b6dd-c75d47b64161" xml:space="preserve">
          <source>Generation 0 is where objects are first allocated.</source>
          <target state="new">Generation 0 is where objects are first allocated.</target>
        </trans-unit>
        <trans-unit id="309ec662-701a-45a1-9fd6-e863d5b9b5ba" xml:space="preserve">
          <source>Objects often don't
live past the first generation, since they are no longer in use (out of
scope) by the time the next garbage collection occurs.</source>
          <target state="new">Objects often don't
live past the first generation, since they are no longer in use (out of
scope) by the time the next garbage collection occurs.</target>
        </trans-unit>
        <trans-unit id="085afcb5-478a-4808-a697-557c36f72df5" xml:space="preserve">
          <source>Generation 0 is
quick to collect because its associated heap is small.</source>
          <target state="new">Generation 0 is
quick to collect because its associated heap is small.</target>
        </trans-unit>
        <trans-unit id="ef648eac-9233-4773-a67b-c7438b6db04a" xml:space="preserve">
          <source>Generation 1 is
really a second chance space.</source>
          <target state="new">Generation 1 is
really a second chance space.</target>
        </trans-unit>
        <trans-unit id="b2c411f2-a90a-45f8-8bf0-8494110ccb8f" xml:space="preserve">
          <source>Objects that are short lived but survive
the generation 0 collection (often based on coincidental timing) go to
generation 1.</source>
          <target state="new">Objects that are short lived but survive
the generation 0 collection (often based on coincidental timing) go to
generation 1.</target>
        </trans-unit>
        <trans-unit id="9d1d1362-d7af-4515-a917-96b2c32a0e3f" xml:space="preserve">
          <source>Generation 1 collections are also quick because its
associated heap is also small.</source>
          <target state="new">Generation 1 collections are also quick because its
associated heap is also small.</target>
        </trans-unit>
        <trans-unit id="fc929837-26ed-4806-b1d3-88b472423825" xml:space="preserve">
          <source>The first two heaps remain small because
objects are either collected or are promoted to the next generation
heap.</source>
          <target state="new">The first two heaps remain small because
objects are either collected or are promoted to the next generation
heap.</target>
        </trans-unit>
        <trans-unit id="1611a7cf-2e58-4e6e-b56a-78825e128da7" xml:space="preserve">
          <source>Generation 2 is where all long lived objects are.</source>
          <target state="new">Generation 2 is where all long lived objects are.</target>
        </trans-unit>
        <trans-unit id="fc2c48f6-852a-496d-9ac2-b904de9eefd6" xml:space="preserve">
          <source>The generation 2
heap can grow to be very large, since the objects it contains can
survive a long time and there is no generation 3 heap to further promote
objects.</source>
          <target state="new">The generation 2
heap can grow to be very large, since the objects it contains can
survive a long time and there is no generation 3 heap to further promote
objects.</target>
        </trans-unit>
        <trans-unit id="2bbca9e7-1354-4a0d-8d22-74158dd35e7d" xml:space="preserve">
          <source>The GC has has an additional heap for large objects called the Large
Object Heap (LOH).</source>
          <target state="new">The GC has has an additional heap for large objects called the Large
Object Heap (LOH).</target>
        </trans-unit>
        <trans-unit id="eaff5f28-a6e4-43db-9511-cddfbe91f9e3" xml:space="preserve">
          <source>It is reserved for objects that are 85,000 bytes or
greater.</source>
          <target state="new">It is reserved for objects that are 85,000 bytes or
greater.</target>
        </trans-unit>
        <trans-unit id="1ce326d4-91f0-4d76-b8ab-88ebf42d391e" xml:space="preserve">
          <source>A byte array (Byte\[\]) with 85k elements would be an example
of a large object.</source>
          <target state="new">A byte array (Byte\[\]) with 85k elements would be an example
of a large object.</target>
        </trans-unit>
        <trans-unit id="9dab3f1d-cc04-4fd1-8e50-2d928d1dce4e" xml:space="preserve">
          <source>Large objects are not allocated to the generational
heaps but are allocated directly to the LOH.</source>
          <target state="new">Large objects are not allocated to the generational
heaps but are allocated directly to the LOH.</target>
        </trans-unit>
        <trans-unit id="26c046b6-7eae-4c34-a710-0178e4bc7975" xml:space="preserve">
          <source>Generation 2 and LOH collections can take noticeable time for programs
that have run for a long time or operate over large amounts of data.</source>
          <target state="new">Generation 2 and LOH collections can take noticeable time for programs
that have run for a long time or operate over large amounts of data.</target>
        </trans-unit>
        <trans-unit id="8481b8a4-6bf1-4bec-a9b6-60f47184e545" xml:space="preserve">
          <source>Large server programs are known to have heaps in the 10s of GBs.</source>
          <target state="new">Large server programs are known to have heaps in the 10s of GBs.</target>
        </trans-unit>
        <trans-unit id="5f470052-61c5-423b-886c-07b2cf536e33" xml:space="preserve">
          <source>The GC
employs a variety of techniques to reduce the amount of time that it
blocks program execution.</source>
          <target state="new">The GC
employs a variety of techniques to reduce the amount of time that it
blocks program execution.</target>
        </trans-unit>
        <trans-unit id="f512c3d4-1e92-4a98-bc77-faf0f60fb25d" xml:space="preserve">
          <source>The primary approach is to do as much garbage
collection work as possible on a background thread in a way that does
not interfere with program execution.</source>
          <target state="new">The primary approach is to do as much garbage
collection work as possible on a background thread in a way that does
not interfere with program execution.</target>
        </trans-unit>
        <trans-unit id="4b792022-3da1-4013-8cb5-8b13379b0357" xml:space="preserve">
          <source>The GC also exposes a few ways for
developers to influence its behavior, which can be quite useful to
improve performance.</source>
          <target state="new">The GC also exposes a few ways for
developers to influence its behavior, which can be quite useful to
improve performance.</target>
        </trans-unit>
        <trans-unit id="e3373fc8-6131-4ba7-8c0d-5489c3a29d25" xml:space="preserve">
          <source>For more information, see <bpt id="49f2f742-bba2-4ea7-bffb-a76a5ff7f5c3CapsExtId1">&lt;linkText&gt;</bpt>Garbage
Collection<ept id="49f2f742-bba2-4ea7-bffb-a76a5ff7f5c3CapsExtId1">&lt;/linkText&gt;</ept><bpt id="49f2f742-bba2-4ea7-bffb-a76a5ff7f5c3CapsExtId2">&lt;title&gt;</bpt><ept id="49f2f742-bba2-4ea7-bffb-a76a5ff7f5c3CapsExtId2">&lt;/title&gt;</ept> on MSDN.</source>
          <target state="new">For more information, see <bpt id="49f2f742-bba2-4ea7-bffb-a76a5ff7f5c3CapsExtId1">&lt;linkText&gt;</bpt>Garbage
Collection<ept id="49f2f742-bba2-4ea7-bffb-a76a5ff7f5c3CapsExtId1">&lt;/linkText&gt;</ept><bpt id="49f2f742-bba2-4ea7-bffb-a76a5ff7f5c3CapsExtId2">&lt;title&gt;</bpt><ept id="49f2f742-bba2-4ea7-bffb-a76a5ff7f5c3CapsExtId2">&lt;/title&gt;</ept> on MSDN.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>