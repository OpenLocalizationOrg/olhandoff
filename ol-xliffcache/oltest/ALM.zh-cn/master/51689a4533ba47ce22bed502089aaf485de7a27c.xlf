<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="zh-cn" original="foo.file" tool-id="04b59335-c725-4e12-a920-df5619c9a715" product-name="foo" product-version="1.0" build-num="1">
    <header>
      <tool tool-id="04b59335-c725-4e12-a920-df5619c9a715" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
      <olfilehash xmlns="">51689a4533ba47ce22bed502089aaf485de7a27c</olfilehash>
    </header>
    <body>
      <group id="c0a4edd0-ad46-446c-b10e-5fdde8b3f5b9">
        <trans-unit id="865adb95-bca2-4f23-bcec-205004157a6e" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="new">Garbage Collection</target>
        </trans-unit>
        <trans-unit id="dc9d70cb-33e0-4613-8024-fe3df1876e32" xml:space="preserve">
          <source>Garbage collection is one of most important features of the .NET managed
code platform.</source>
          <target state="new">Garbage collection is one of most important features of the .NET managed
code platform.</target>
        </trans-unit>
        <trans-unit id="1bb2e171-5953-498f-b797-2663e8ed78da" xml:space="preserve">
          <source>The garbage collector (GC) manages allocating and
releasing memory for you.</source>
          <target state="new">The garbage collector (GC) manages allocating and
releasing memory for you.</target>
        </trans-unit>
        <trans-unit id="493c92f1-857e-4ef1-9754-832edd8ba354" xml:space="preserve">
          <source>You do not need to how to allocate and release
memory or manage the lifetime of the objects that use that memory.</source>
          <target state="new">You do not need to how to allocate and release
memory or manage the lifetime of the objects that use that memory.</target>
        </trans-unit>
        <trans-unit id="277e8d82-823c-4ed2-bb9d-2b2a3a58c6cb" xml:space="preserve">
          <source>An
allocation is made any time you <bpt id="b8cb872d-b7bc-4444-ae54-d79f11fa1339">&lt;em&gt;</bpt>new<ept id="b8cb872d-b7bc-4444-ae54-d79f11fa1339">&lt;/em&gt;</ept> an object or a value type is
boxed.</source>
          <target state="new">An
allocation is made any time you <bpt id="b8cb872d-b7bc-4444-ae54-d79f11fa1339">&lt;em&gt;</bpt>new<ept id="b8cb872d-b7bc-4444-ae54-d79f11fa1339">&lt;/em&gt;</ept> an object or a value type is
boxed.</target>
        </trans-unit>
        <trans-unit id="4ec08dff-430a-4870-94b9-45a1be70962a" xml:space="preserve">
          <source>Allocations are typically very fast.</source>
          <target state="new">Allocations are typically very fast.</target>
        </trans-unit>
        <trans-unit id="165bac4c-1cc8-40e5-8669-b5b418449384" xml:space="preserve">
          <source>When there isn't enough
memory to allocate an object, the GC must collect and dispose of garbage
memory to make memory available for new allocations.</source>
          <target state="new">When there isn't enough
memory to allocate an object, the GC must collect and dispose of garbage
memory to make memory available for new allocations.</target>
        </trans-unit>
        <trans-unit id="c450d700-a4b5-4480-a50a-1ec1a9cede54" xml:space="preserve">
          <source>This process is
called "garbage collection".</source>
          <target state="new">This process is
called "garbage collection".</target>
        </trans-unit>
        <trans-unit id="a2d803ec-fc29-41da-8da6-dbad85dde8a6" xml:space="preserve">
          <source>The garbage collector serves as an automatic memory manager.</source>
          <target state="new">The garbage collector serves as an automatic memory manager.</target>
        </trans-unit>
        <trans-unit id="66a4933d-3ad1-43f0-947e-f8cef3a4ebb5" xml:space="preserve">
          <source>It provides
the following benefits:</source>
          <target state="new">It provides
the following benefits:</target>
        </trans-unit>
        <trans-unit id="fe76ccd3-f995-4159-8b89-dc42b789900e" xml:space="preserve">
          <source>Enables you to develop your application without having to
free memory.</source>
          <target state="new">Enables you to develop your application without having to
free memory.</target>
        </trans-unit>
        <trans-unit id="f40fedf2-82be-4da7-a462-00f71fcf1a42" xml:space="preserve">
          <source>Allocates objects on the managed heap efficiently.</source>
          <target state="new">Allocates objects on the managed heap efficiently.</target>
        </trans-unit>
        <trans-unit id="96997a03-483e-4cd0-b6f9-1dbee524d144" xml:space="preserve">
          <source>Reclaims objects that are no longer being used, clears their memory,
and keeps the memory available for future allocations.</source>
          <target state="new">Reclaims objects that are no longer being used, clears their memory,
and keeps the memory available for future allocations.</target>
        </trans-unit>
        <trans-unit id="29d87698-68bc-4cad-8227-3bd0e4e9e38a" xml:space="preserve">
          <source>Managed
objects automatically get clean content to start with, so their
constructors do not have to initialize every data field.</source>
          <target state="new">Managed
objects automatically get clean content to start with, so their
constructors do not have to initialize every data field.</target>
        </trans-unit>
        <trans-unit id="3e3b33c5-a64c-4b29-9db4-9be966b6b02e" xml:space="preserve">
          <source>Provides memory safety by making sure that an object cannot use the
content of another object.</source>
          <target state="new">Provides memory safety by making sure that an object cannot use the
content of another object.</target>
        </trans-unit>
        <trans-unit id="321067d7-ba4d-4f2a-a2bf-8a2760584346" xml:space="preserve">
          <source>The .NET GC is generational and has 3 generations.</source>
          <target state="new">The .NET GC is generational and has 3 generations.</target>
        </trans-unit>
        <trans-unit id="ff046736-9aac-4e50-b530-907071313b1f" xml:space="preserve">
          <source>Each generation has
its own heap that it uses for storage of allocated objects.</source>
          <target state="new">Each generation has
its own heap that it uses for storage of allocated objects.</target>
        </trans-unit>
        <trans-unit id="60a720ad-ae96-47ea-8489-be77977d1ea6" xml:space="preserve">
          <source>There is a
basic principle that most objects are either short lived or long lived.</source>
          <target state="new">There is a
basic principle that most objects are either short lived or long lived.</target>
        </trans-unit>
        <trans-unit id="373823c5-e622-4d29-8cd0-1064713bef5c" xml:space="preserve">
          <source>Generation 0 is where objects are first allocated.</source>
          <target state="new">Generation 0 is where objects are first allocated.</target>
        </trans-unit>
        <trans-unit id="73e8b144-bce0-4811-b80d-ac05c51f69e1" xml:space="preserve">
          <source>Objects often don't
live past the first generation, since they are no longer in use (out of
scope) by the time the next garbage collection occurs.</source>
          <target state="new">Objects often don't
live past the first generation, since they are no longer in use (out of
scope) by the time the next garbage collection occurs.</target>
        </trans-unit>
        <trans-unit id="2244d0cc-96df-49b8-bda8-cb0f53e8aadd" xml:space="preserve">
          <source>Generation 0 is
quick to collect because its associated heap is small.</source>
          <target state="new">Generation 0 is
quick to collect because its associated heap is small.</target>
        </trans-unit>
        <trans-unit id="963367aa-4152-4496-a7a9-d47f62ba8ba6" xml:space="preserve">
          <source>Generation 1 is
really a second chance space.</source>
          <target state="new">Generation 1 is
really a second chance space.</target>
        </trans-unit>
        <trans-unit id="44b5a3b9-3837-421c-bfa2-94a4dc2c36c9" xml:space="preserve">
          <source>Objects that are short lived but survive
the generation 0 collection (often based on coincidental timing) go to
generation 1.</source>
          <target state="new">Objects that are short lived but survive
the generation 0 collection (often based on coincidental timing) go to
generation 1.</target>
        </trans-unit>
        <trans-unit id="8a488a44-80ad-48f2-b96c-7058817a9ffb" xml:space="preserve">
          <source>Generation 1 collections are also quick because its
associated heap is also small.</source>
          <target state="new">Generation 1 collections are also quick because its
associated heap is also small.</target>
        </trans-unit>
        <trans-unit id="d9ac3a4b-daf7-4884-b171-ed7c00524163" xml:space="preserve">
          <source>The first two heaps remain small because
objects are either collected or are promoted to the next generation
heap.</source>
          <target state="new">The first two heaps remain small because
objects are either collected or are promoted to the next generation
heap.</target>
        </trans-unit>
        <trans-unit id="ec4e1552-c5b5-4c5c-8ac5-87f9f1c93615" xml:space="preserve">
          <source>Generation 2 is where all long lived objects are.</source>
          <target state="new">Generation 2 is where all long lived objects are.</target>
        </trans-unit>
        <trans-unit id="3d199ed7-1f64-442f-b9da-7abe23656c0b" xml:space="preserve">
          <source>The generation 2
heap can grow to be very large, since the objects it contains can
survive a long time and there is no generation 3 heap to further promote
objects.</source>
          <target state="new">The generation 2
heap can grow to be very large, since the objects it contains can
survive a long time and there is no generation 3 heap to further promote
objects.</target>
        </trans-unit>
        <trans-unit id="bec332bf-29c4-41eb-8e30-228ad8d13f5e" xml:space="preserve">
          <source>The GC has has an additional heap for large objects called the Large
Object Heap (LOH).</source>
          <target state="new">The GC has has an additional heap for large objects called the Large
Object Heap (LOH).</target>
        </trans-unit>
        <trans-unit id="f58d6968-104d-4377-946a-1e1a3ff09f25" xml:space="preserve">
          <source>It is reserved for objects that are 85,000 bytes or
greater.</source>
          <target state="new">It is reserved for objects that are 85,000 bytes or
greater.</target>
        </trans-unit>
        <trans-unit id="64c27fd3-60da-4b37-9f96-805b43f33e16" xml:space="preserve">
          <source>A byte array (Byte\[\]) with 85k elements would be an example
of a large object.</source>
          <target state="new">A byte array (Byte\[\]) with 85k elements would be an example
of a large object.</target>
        </trans-unit>
        <trans-unit id="2597fd77-27bb-4c16-b424-4b31c33b6d37" xml:space="preserve">
          <source>Large objects are not allocated to the generational
heaps but are allocated directly to the LOH.</source>
          <target state="new">Large objects are not allocated to the generational
heaps but are allocated directly to the LOH.</target>
        </trans-unit>
        <trans-unit id="b1e20c18-5c39-4ead-9da2-1cd8ec26d610" xml:space="preserve">
          <source>Generation 2 and LOH collections can take noticeable time for programs
that have run for a long time or operate over large amounts of data.</source>
          <target state="new">Generation 2 and LOH collections can take noticeable time for programs
that have run for a long time or operate over large amounts of data.</target>
        </trans-unit>
        <trans-unit id="a44ad988-da39-40e1-9587-42ea4e7c93fb" xml:space="preserve">
          <source>Large server programs are known to have heaps in the 10s of GBs.</source>
          <target state="new">Large server programs are known to have heaps in the 10s of GBs.</target>
        </trans-unit>
        <trans-unit id="d66ecf82-caf5-43d5-af42-7914ea575160" xml:space="preserve">
          <source>The GC
employs a variety of techniques to reduce the amount of time that it
blocks program execution.</source>
          <target state="new">The GC
employs a variety of techniques to reduce the amount of time that it
blocks program execution.</target>
        </trans-unit>
        <trans-unit id="9b6e3712-06b9-4683-bc86-4b5953c8f5ef" xml:space="preserve">
          <source>The primary approach is to do as much garbage
collection work as possible on a background thread in a way that does
not interfere with program execution.</source>
          <target state="new">The primary approach is to do as much garbage
collection work as possible on a background thread in a way that does
not interfere with program execution.</target>
        </trans-unit>
        <trans-unit id="51665f29-37f3-449a-8c90-baf7eb196b4f" xml:space="preserve">
          <source>The GC also exposes a few ways for
developers to influence its behavior, which can be quite useful to
improve performance.</source>
          <target state="new">The GC also exposes a few ways for
developers to influence its behavior, which can be quite useful to
improve performance.</target>
        </trans-unit>
        <trans-unit id="c3edc2f1-c78b-4240-b854-526973991f39" xml:space="preserve">
          <source>For more information, see <bpt id="6c92504a-6958-45af-97b1-e5bb7bbad200CapsExtId1">&lt;linkText&gt;</bpt>Garbage
Collection<ept id="6c92504a-6958-45af-97b1-e5bb7bbad200CapsExtId1">&lt;/linkText&gt;</ept><bpt id="6c92504a-6958-45af-97b1-e5bb7bbad200CapsExtId2">&lt;title&gt;</bpt><ept id="6c92504a-6958-45af-97b1-e5bb7bbad200CapsExtId2">&lt;/title&gt;</ept> on MSDN.</source>
          <target state="new">For more information, see <bpt id="6c92504a-6958-45af-97b1-e5bb7bbad200CapsExtId1">&lt;linkText&gt;</bpt>Garbage
Collection<ept id="6c92504a-6958-45af-97b1-e5bb7bbad200CapsExtId1">&lt;/linkText&gt;</ept><bpt id="6c92504a-6958-45af-97b1-e5bb7bbad200CapsExtId2">&lt;title&gt;</bpt><ept id="6c92504a-6958-45af-97b1-e5bb7bbad200CapsExtId2">&lt;/title&gt;</ept> on MSDN.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>