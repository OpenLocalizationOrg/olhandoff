<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="de-de" original="foo.file" tool-id="96b0fb29-6f27-47d6-8d49-d1406003fc15" product-name="foo" product-version="1.0" build-num="1">
    <header>
      <tool tool-id="96b0fb29-6f27-47d6-8d49-d1406003fc15" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
      <olfilehash xmlns="">51689a4533ba47ce22bed502089aaf485de7a27c</olfilehash>
    </header>
    <body>
      <group id="33bf41ae-d3fe-44c6-af2d-205ba7043097">
        <trans-unit id="ef6b835b-4413-4950-9ed8-17999692b4df" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="new">Garbage Collection</target>
        </trans-unit>
        <trans-unit id="138e0171-c9d3-4417-a4a2-2ff12e1410e2" xml:space="preserve">
          <source>Garbage collection is one of most important features of the .NET managed
code platform.</source>
          <target state="new">Garbage collection is one of most important features of the .NET managed
code platform.</target>
        </trans-unit>
        <trans-unit id="cb376c9e-0a9a-4538-ae25-5229b042d849" xml:space="preserve">
          <source>The garbage collector (GC) manages allocating and
releasing memory for you.</source>
          <target state="new">The garbage collector (GC) manages allocating and
releasing memory for you.</target>
        </trans-unit>
        <trans-unit id="670602a4-f3d9-4907-a410-cb8395b12e95" xml:space="preserve">
          <source>You do not need to how to allocate and release
memory or manage the lifetime of the objects that use that memory.</source>
          <target state="new">You do not need to how to allocate and release
memory or manage the lifetime of the objects that use that memory.</target>
        </trans-unit>
        <trans-unit id="ea245b43-0384-4fd0-88d1-6af40afd8f4a" xml:space="preserve">
          <source>An
allocation is made any time you <bpt id="cd28a12b-71b3-4557-b45b-fd517cdbcbd6">&lt;em&gt;</bpt>new<ept id="cd28a12b-71b3-4557-b45b-fd517cdbcbd6">&lt;/em&gt;</ept> an object or a value type is
boxed.</source>
          <target state="new">An
allocation is made any time you <bpt id="cd28a12b-71b3-4557-b45b-fd517cdbcbd6">&lt;em&gt;</bpt>new<ept id="cd28a12b-71b3-4557-b45b-fd517cdbcbd6">&lt;/em&gt;</ept> an object or a value type is
boxed.</target>
        </trans-unit>
        <trans-unit id="fd1b9d85-e19e-4a06-8b6c-d33f525cdb9e" xml:space="preserve">
          <source>Allocations are typically very fast.</source>
          <target state="new">Allocations are typically very fast.</target>
        </trans-unit>
        <trans-unit id="e7f334a2-b77c-4cf9-8ae9-3ff2fd58660d" xml:space="preserve">
          <source>When there isn't enough
memory to allocate an object, the GC must collect and dispose of garbage
memory to make memory available for new allocations.</source>
          <target state="new">When there isn't enough
memory to allocate an object, the GC must collect and dispose of garbage
memory to make memory available for new allocations.</target>
        </trans-unit>
        <trans-unit id="232c5f5f-14d2-45a3-ac15-f4f934a4e9eb" xml:space="preserve">
          <source>This process is
called "garbage collection".</source>
          <target state="new">This process is
called "garbage collection".</target>
        </trans-unit>
        <trans-unit id="6881ae5e-8a06-4cb0-ac32-6ed7d71a82a7" xml:space="preserve">
          <source>The garbage collector serves as an automatic memory manager.</source>
          <target state="new">The garbage collector serves as an automatic memory manager.</target>
        </trans-unit>
        <trans-unit id="8923ce77-c068-4811-b99d-30840bf7e2d6" xml:space="preserve">
          <source>It provides
the following benefits:</source>
          <target state="new">It provides
the following benefits:</target>
        </trans-unit>
        <trans-unit id="327c565c-6bdc-4fdf-97ed-b139ed3b18c8" xml:space="preserve">
          <source>Enables you to develop your application without having to
free memory.</source>
          <target state="new">Enables you to develop your application without having to
free memory.</target>
        </trans-unit>
        <trans-unit id="148f65a6-3d41-4aab-b718-5957410787ae" xml:space="preserve">
          <source>Allocates objects on the managed heap efficiently.</source>
          <target state="new">Allocates objects on the managed heap efficiently.</target>
        </trans-unit>
        <trans-unit id="31eb00ff-87e7-4f2e-8d3a-c51ee3c4ea27" xml:space="preserve">
          <source>Reclaims objects that are no longer being used, clears their memory,
and keeps the memory available for future allocations.</source>
          <target state="new">Reclaims objects that are no longer being used, clears their memory,
and keeps the memory available for future allocations.</target>
        </trans-unit>
        <trans-unit id="4be2e944-e66a-4663-a3bd-5216b40f9f78" xml:space="preserve">
          <source>Managed
objects automatically get clean content to start with, so their
constructors do not have to initialize every data field.</source>
          <target state="new">Managed
objects automatically get clean content to start with, so their
constructors do not have to initialize every data field.</target>
        </trans-unit>
        <trans-unit id="b5bc39d1-f731-4c58-8239-3397d3fb2e6c" xml:space="preserve">
          <source>Provides memory safety by making sure that an object cannot use the
content of another object.</source>
          <target state="new">Provides memory safety by making sure that an object cannot use the
content of another object.</target>
        </trans-unit>
        <trans-unit id="ea227fdd-302b-44c6-a3bc-3d1c9fe04676" xml:space="preserve">
          <source>The .NET GC is generational and has 3 generations.</source>
          <target state="new">The .NET GC is generational and has 3 generations.</target>
        </trans-unit>
        <trans-unit id="b3816249-45a3-44de-8e8f-beadd4c07c82" xml:space="preserve">
          <source>Each generation has
its own heap that it uses for storage of allocated objects.</source>
          <target state="new">Each generation has
its own heap that it uses for storage of allocated objects.</target>
        </trans-unit>
        <trans-unit id="e5ab8444-dc3b-4af9-a66f-957e4df074ff" xml:space="preserve">
          <source>There is a
basic principle that most objects are either short lived or long lived.</source>
          <target state="new">There is a
basic principle that most objects are either short lived or long lived.</target>
        </trans-unit>
        <trans-unit id="a1bfccd0-d71f-4150-8237-60e5dde800c9" xml:space="preserve">
          <source>Generation 0 is where objects are first allocated.</source>
          <target state="new">Generation 0 is where objects are first allocated.</target>
        </trans-unit>
        <trans-unit id="1931e56f-9bc6-42ef-8292-6806610bd563" xml:space="preserve">
          <source>Objects often don't
live past the first generation, since they are no longer in use (out of
scope) by the time the next garbage collection occurs.</source>
          <target state="new">Objects often don't
live past the first generation, since they are no longer in use (out of
scope) by the time the next garbage collection occurs.</target>
        </trans-unit>
        <trans-unit id="9c787ce9-e9f9-43f1-b04f-c0b59ea07fcb" xml:space="preserve">
          <source>Generation 0 is
quick to collect because its associated heap is small.</source>
          <target state="new">Generation 0 is
quick to collect because its associated heap is small.</target>
        </trans-unit>
        <trans-unit id="07308896-7e69-4e67-bcc2-d8d060f7f68a" xml:space="preserve">
          <source>Generation 1 is
really a second chance space.</source>
          <target state="new">Generation 1 is
really a second chance space.</target>
        </trans-unit>
        <trans-unit id="e4fa7036-bb6e-4f67-b4c9-d61efa767ca4" xml:space="preserve">
          <source>Objects that are short lived but survive
the generation 0 collection (often based on coincidental timing) go to
generation 1.</source>
          <target state="new">Objects that are short lived but survive
the generation 0 collection (often based on coincidental timing) go to
generation 1.</target>
        </trans-unit>
        <trans-unit id="f10f0c81-037c-4093-9642-1fe412d80bf9" xml:space="preserve">
          <source>Generation 1 collections are also quick because its
associated heap is also small.</source>
          <target state="new">Generation 1 collections are also quick because its
associated heap is also small.</target>
        </trans-unit>
        <trans-unit id="c9bae1c4-a163-40fa-bf10-3cc131fb80d5" xml:space="preserve">
          <source>The first two heaps remain small because
objects are either collected or are promoted to the next generation
heap.</source>
          <target state="new">The first two heaps remain small because
objects are either collected or are promoted to the next generation
heap.</target>
        </trans-unit>
        <trans-unit id="497e4bc0-18d9-4c3b-bb26-ea2cfc3cb7d7" xml:space="preserve">
          <source>Generation 2 is where all long lived objects are.</source>
          <target state="new">Generation 2 is where all long lived objects are.</target>
        </trans-unit>
        <trans-unit id="07483868-a415-4ee7-9429-7b181e4963bc" xml:space="preserve">
          <source>The generation 2
heap can grow to be very large, since the objects it contains can
survive a long time and there is no generation 3 heap to further promote
objects.</source>
          <target state="new">The generation 2
heap can grow to be very large, since the objects it contains can
survive a long time and there is no generation 3 heap to further promote
objects.</target>
        </trans-unit>
        <trans-unit id="7c38a573-fe9f-49c2-8c57-74be6d43dd6b" xml:space="preserve">
          <source>The GC has has an additional heap for large objects called the Large
Object Heap (LOH).</source>
          <target state="new">The GC has has an additional heap for large objects called the Large
Object Heap (LOH).</target>
        </trans-unit>
        <trans-unit id="39d224b8-7558-46c2-8da5-ab4c18a94d57" xml:space="preserve">
          <source>It is reserved for objects that are 85,000 bytes or
greater.</source>
          <target state="new">It is reserved for objects that are 85,000 bytes or
greater.</target>
        </trans-unit>
        <trans-unit id="c2fd8283-d0e1-4c7f-bd7e-c7822ed72a1d" xml:space="preserve">
          <source>A byte array (Byte\[\]) with 85k elements would be an example
of a large object.</source>
          <target state="new">A byte array (Byte\[\]) with 85k elements would be an example
of a large object.</target>
        </trans-unit>
        <trans-unit id="70dfdeec-3dc8-49a0-9b03-63e453e136fc" xml:space="preserve">
          <source>Large objects are not allocated to the generational
heaps but are allocated directly to the LOH.</source>
          <target state="new">Large objects are not allocated to the generational
heaps but are allocated directly to the LOH.</target>
        </trans-unit>
        <trans-unit id="5a77f197-ae28-41ed-a30a-31516e4dec1e" xml:space="preserve">
          <source>Generation 2 and LOH collections can take noticeable time for programs
that have run for a long time or operate over large amounts of data.</source>
          <target state="new">Generation 2 and LOH collections can take noticeable time for programs
that have run for a long time or operate over large amounts of data.</target>
        </trans-unit>
        <trans-unit id="54deef10-09f5-4302-bd17-22728231a1be" xml:space="preserve">
          <source>Large server programs are known to have heaps in the 10s of GBs.</source>
          <target state="new">Large server programs are known to have heaps in the 10s of GBs.</target>
        </trans-unit>
        <trans-unit id="cacaccf0-652c-4b48-9a74-67bbc9ffe2f5" xml:space="preserve">
          <source>The GC
employs a variety of techniques to reduce the amount of time that it
blocks program execution.</source>
          <target state="new">The GC
employs a variety of techniques to reduce the amount of time that it
blocks program execution.</target>
        </trans-unit>
        <trans-unit id="ecdc84a8-ccbc-49b4-ab27-a85c18ab9296" xml:space="preserve">
          <source>The primary approach is to do as much garbage
collection work as possible on a background thread in a way that does
not interfere with program execution.</source>
          <target state="new">The primary approach is to do as much garbage
collection work as possible on a background thread in a way that does
not interfere with program execution.</target>
        </trans-unit>
        <trans-unit id="5633a695-b8d3-4d77-93fd-84bdc9bcb01c" xml:space="preserve">
          <source>The GC also exposes a few ways for
developers to influence its behavior, which can be quite useful to
improve performance.</source>
          <target state="new">The GC also exposes a few ways for
developers to influence its behavior, which can be quite useful to
improve performance.</target>
        </trans-unit>
        <trans-unit id="b3895718-71c0-4dfb-a513-54604aa27ee9" xml:space="preserve">
          <source>For more information, see <bpt id="b953c56d-208b-47ee-a4c0-be1fe766e495CapsExtId1">&lt;linkText&gt;</bpt>Garbage
Collection<ept id="b953c56d-208b-47ee-a4c0-be1fe766e495CapsExtId1">&lt;/linkText&gt;</ept><bpt id="b953c56d-208b-47ee-a4c0-be1fe766e495CapsExtId2">&lt;title&gt;</bpt><ept id="b953c56d-208b-47ee-a4c0-be1fe766e495CapsExtId2">&lt;/title&gt;</ept> on MSDN.</source>
          <target state="new">For more information, see <bpt id="b953c56d-208b-47ee-a4c0-be1fe766e495CapsExtId1">&lt;linkText&gt;</bpt>Garbage
Collection<ept id="b953c56d-208b-47ee-a4c0-be1fe766e495CapsExtId1">&lt;/linkText&gt;</ept><bpt id="b953c56d-208b-47ee-a4c0-be1fe766e495CapsExtId2">&lt;title&gt;</bpt><ept id="b953c56d-208b-47ee-a4c0-be1fe766e495CapsExtId2">&lt;/title&gt;</ept> on MSDN.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>