{"nodes":[{"content":"Connect to identity providers with Web Account Manager","pos":[11,65]},{"content":"This article describes how to use the AccountsSettingsPane to connect your Universal Windows Platform (UWP) app to external identity providers, like Microsoft or Facebook, using the new Windows 10 Web Account Manager APIs.","pos":[79,301]},{"content":"Connect to identity providers with Web Account Manager","pos":[325,379]},{"content":"This article describes how to show the AccountsSettingsPane and connect your Universal Windows Platform (UWP) app to external identity providers, like Microsoft or Facebook, using the new Windows 10 Web Account Manager APIs.","pos":[381,605]},{"content":"You'll learn how to request a user's permission to use their Microsoft account, obtain an access token, and use it to perform basic operations (like get profile data or upload files to their OneDrive).","pos":[606,807]},{"content":"The steps are similar for getting user permission and access with any identity provider that supports the Web Account Manager.","pos":[808,934]},{"pos":[938,1069],"content":"Note: For a complete code sample, see the <bpt id=\"p1\">[</bpt>WebAccountManagement sample on GitHub<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkId=620621)</ept>."},{"content":"Get set up","pos":[1074,1084]},{"content":"First, create a new, blank app in Visual Studio.","pos":[1086,1134]},{"content":"Second, in order to connect to identity providers, you'll need to associate your app with the Store.","pos":[1137,1237]},{"content":"To do this, right click your project, choose <bpt id=\"p1\">**</bpt>Store<ept id=\"p1\">**</ept><ph id=\"ph1\"> &gt; </ph><bpt id=\"p2\">**</bpt>Associate app with the store<ept id=\"p2\">**</ept>, and follow the wizard's instructions.","pos":[1238,1366]},{"content":"Third, create a very basic UI consisting of a simple XAML button and two text boxes.","pos":[1369,1453]},{"content":"And an event handler attached to your button in the code-behind:","pos":[1715,1779]},{"content":"Lastly, add the following namespaces so you don't have to worry about any reference issues later:","pos":[1864,1961]},{"content":"Show the AccountSettingsPane","pos":[2238,2266]},{"content":"The system provides a built-in user interface for managing identity providers and web accounts called the AccountSettingsPane.","pos":[2268,2394]},{"content":"You can show it like this:","pos":[2395,2421]},{"content":"If you run your app and click the \"Log in\" button, it should display an empty window.","pos":[2537,2622]},{"content":"Account settings pane","pos":[2627,2648]},{"content":"The pane is empty because the system only provides a UI shell - it's up to the developer to programatically populate the pane with the identity providers.","pos":[2668,2822]},{"content":"Register for AccountCommandsRequested","pos":[2828,2865]},{"content":"To add commands to the pane, we start by registering for the AccountCommandsRequested event handler.","pos":[2867,2967]},{"content":"This tells the system to run our build logic when the user asks to see the pane (e.g., clicks our XAML button).","pos":[2968,3079]},{"content":"In your code behind, override the OnNavigatedTo and OnNavigatedFrom events and add the following code to them:","pos":[3082,3192]},{"content":"Users don't interact with accounts very often, so registering and deregistering your event handler in this fashion helps prevent memory leaks.","pos":[3529,3671]},{"content":"This way, your customized pane is only in memory when there's a high chance a user is going to ask for it (because they're on a \"settings\" or \"login\" page, for example).","pos":[3672,3841]},{"content":"Build the account settings pane","pos":[3847,3878]},{"content":"The BuildPaneAsync method is called whenever the AccountSettingsPane is shown.","pos":[3880,3958]},{"content":"This is where we'll put the code to customize the commands shown in the pane.","pos":[3959,4036]},{"content":"Start by obtaining a deferral.","pos":[4039,4069]},{"content":"This tells the system to delay showing the AccountsSettingsPane until we're finished building it.","pos":[4070,4167]},{"content":"Next, get a provider using the WebAuthenticationCoreManager.FindAccountProviderAsync method.","pos":[4367,4459]},{"content":"The URL for the provider varies based on the provider and can be found in the provider's documentation.","pos":[4460,4563]},{"content":"For Microsoft Accounts and Azure Active Directory, it's \"https://login.microsoft.com\".","pos":[4564,4650]},{"content":"Notice that we also pass the string \"consumers\" to the optional <bpt id=\"p1\">*</bpt>authority<ept id=\"p1\">*</ept> parameter.","pos":[4997,5083]},{"content":"This is because Microsoft provides two different types of authentication - Microsoft Accounts (MSA) for \"consumers\", and Azure Active Directory (AAD) for \"organizations\".","pos":[5084,5254]},{"content":"The \"consumers\" authority lets the provider know we are interested in the former option.","pos":[5255,5343]},{"content":"If you are developing an enterprise app, you may want to use the AAD graph endpoint instead.","pos":[5345,5437]},{"content":"See the full <bpt id=\"p1\">[</bpt>WebAccountManagement sample on GitHub<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkId=620621)</ept> and the Azure documentation for more on how to do this.","pos":[5438,5595]},{"content":"Finally, add the provider to the AccountsSettingsPane by creating a new WebAccountProviderCommand like this:","pos":[5598,5706]},{"content":"Note that the GetMsaToken method we passed to our new WebAccountProviderCommand doesn't exist yet (we'll build that in the next step), so feel free to add it as an empty method for now.","pos":[6167,6352]},{"content":"Run the above code and your pane should look something like this:","pos":[6354,6419]},{"content":"Account settings pane","pos":[6424,6445]},{"content":"Request a token","pos":[6469,6484]},{"content":"Once we have the Microsoft Account option displaying in the AccountsSettingsPane, we need to handle what happens when the user selects it.","pos":[6486,6624]},{"content":"We registered our GetMsaToken method to fire when the user chooses to log in with their Microsoft Account, so we'll obtain the token there.","pos":[6625,6764]},{"content":"To obtain a token, use the RequestTokenAsync method like this:","pos":[6767,6829]},{"content":"In this example, we pass the string \"wl.basic\" to the scope parameter.","pos":[7100,7170]},{"content":"Scope represents the type of information you are requesting from the providing service on a specific user.","pos":[7171,7277]},{"content":"Certain scopes provide access only to a user's basic information, like name and email address.","pos":[7278,7372]},{"content":"Other scopes might grant access to sensitive information such as the user's photos or email inbox.","pos":[7373,7471]},{"content":"Generally, your app should use the least permissive scope unless our app explicitly needs additional permission - e.g., don't ask for access to sensitive information if your app doesn't absolutely need it.","pos":[7472,7677]},{"content":"Service providers will provide documentation on which scopes need to be specified to get tokens for use with their service.","pos":[7680,7803]},{"content":"For Office 365 and Outlook.com scopes, see (Authenticate Office 365 and Outlook.com APIs using the v2.0 authentication endpoint)[https://msdn.microsoft.com/office/office365/howto/authenticate-Office-365-APIs-using-v2].","pos":[7806,8024]},{"content":"For OneDrive, see (OneDrive authentication and sign-in)[https://dev.onedrive.com/auth/msa_oauth.htm#authentication-scopes].","pos":[8027,8150]},{"content":"Use the token","pos":[8156,8169]},{"content":"The RequestTokenAsync method returns a WebTokenRequestResult object, which contains the results of your request.","pos":[8171,8283]},{"content":"If your request was successful, it will contain a token.","pos":[8284,8340]},{"content":"Once you have a token, you can use it to call your provider's API.","pos":[8754,8820]},{"content":"In the code below, we'll call the Microsoft Live APIs to obtain basic information about the user and display it in our UI.","pos":[8821,8943]},{"content":"How you call various REST APIs varies between providers; see the provider's API documentation for information on how to use your token.","pos":[9928,10063]},{"content":"Save account state","pos":[10069,10087]},{"content":"Tokens are useful for immediately obtaining information about a user, but they usually have varying lifespans - MSA tokens, for instance, are only valid for a few hours.","pos":[10089,10258]},{"content":"Fortunately, you don't need to re-show the AccountsSettingsPane each time a token expires.","pos":[10259,10349]},{"content":"Once a user has authorized your app once, you can store the user's account information for future use.","pos":[10350,10452]},{"content":"To do this, use the WebAccount class.","pos":[10455,10492]},{"content":"A WebAccount is returned along with requesting a token:","pos":[10493,10548]},{"content":"Once you have a WebAccount, you can easily store it.","pos":[10971,11023]},{"content":"In the following example, we use LocalSettings:","pos":[11024,11071]},{"content":"The next time the user launches your app, you can attempt to obtain a token silently (in the background) like this:","pos":[11332,11447]},{"content":"Because obtaining a token silently is very simple, you should use this process to refresh your token between sessions rather than caching an existing token (since that token might expire at any time).","pos":[12595,12795]},{"content":"Note the example above only covers basic success and fail cases.","pos":[12797,12861]},{"content":"Your app should also account for unusual scenarios (like a user revoking your app's permission or removing their account from Windows, for example) and handle them gracefully.","pos":[12862,13037]},{"content":"Log out an account","pos":[13044,13062]},{"content":"If you persist a WebAccount, you may want to provide \"log out\" functionality to your users so they can switch accounts or simply dissasociate their account with your app.","pos":[13065,13235]},{"content":"To do this, first remove any saved account and provider information.","pos":[13236,13304]},{"content":"Then call WebAccount.SignOutAsync() to clear the cache and invalidate any existing tokens your app may have.","pos":[13305,13413]},{"content":"Add providers that don't support WebAccountManager","pos":[13679,13729]},{"content":"If you want to integrate authentication from a service into your app but that service doesn't support WebAccountManager - Google+ or Twitter, for example - you can still manually add that provider to the AccountsSettingsPane.","pos":[13731,13956]},{"content":"To do so, create a new WebAccountProvider object and provide your own name and .png icon, then and add it to the WebAccountProviderCommands.","pos":[13957,14097]},{"content":"Here's some stub code:","pos":[14098,14120]},{"content":"Note this only adds an icon to the AccountsSettingsPane and runs the method you specify when the icon is clicked (GetTwitterTokenAsync, in this case).","pos":[14693,14843]},{"content":"You must provide the code that handles the actual authentication.","pos":[14844,14909]},{"content":"For more information, see (Web authentication broker)[web-authentication-broker], which provides helper methods for authenticating using REST services.","pos":[14910,15061]},{"content":"Add a custom header","pos":[15067,15086]},{"content":"You can customize the account settings pane using the HeaderText property, like this:","pos":[15088,15173]},{"content":"Account settings pane","pos":[15431,15452]},{"content":"Don't go overboard with header text; keep it short and sweet.","pos":[15472,15533]},{"content":"If your login process is complicated and you need to display more information, link the user to a separate page using a custom link.","pos":[15534,15666]},{"content":"Add custom links","pos":[15672,15688]},{"content":"You can add custom commands to the AccountsSettingsPane, which appear as links below your supported WebAccountProviders.","pos":[15690,15810]},{"content":"Custom commands are great for simple tasks related to user accounts, like displaying a privacy policy or launching a support page for users having trouble.","pos":[15811,15966]},{"content":"Here's an example:","pos":[15969,15987]},{"content":"Account settings pane","pos":[16410,16431]},{"content":"Theoretically, you can use settings commands for anything.","pos":[16451,16509]},{"content":"However, we suggest limiting their use to intuitive, account-related scenarios like those described above.","pos":[16510,16616]},{"content":"See also","pos":[16622,16630]},{"content":"Windows.Security.Authentication.Web.Core namespace","pos":[16633,16683]},{"content":"Windows.Security.Credentials namespace","pos":[16782,16820]},{"content":"AccountsSettingsPane","pos":[16907,16927]},{"content":"Web authentication broker","pos":[17032,17057]},{"content":"WebAccountManagement sample","pos":[17091,17118]}],"content":"---\ntitle: Connect to identity providers with Web Account Manager\ndescription: This article describes how to use the AccountsSettingsPane to connect your Universal Windows Platform (UWP) app to external identity providers, like Microsoft or Facebook, using the new Windows 10 Web Account Manager APIs. \nauthor: awkoren\n---\n# Connect to identity providers with Web Account Manager\n\nThis article describes how to show the AccountsSettingsPane and connect your Universal Windows Platform (UWP) app to external identity providers, like Microsoft or Facebook, using the new Windows 10 Web Account Manager APIs. You'll learn how to request a user's permission to use their Microsoft account, obtain an access token, and use it to perform basic operations (like get profile data or upload files to their OneDrive). The steps are similar for getting user permission and access with any identity provider that supports the Web Account Manager.\n\n> Note: For a complete code sample, see the [WebAccountManagement sample on GitHub](http://go.microsoft.com/fwlink/p/?LinkId=620621).\n\n## Get set up\n\nFirst, create a new, blank app in Visual Studio. \n\nSecond, in order to connect to identity providers, you'll need to associate your app with the Store. To do this, right click your project, choose **Store** > **Associate app with the store**, and follow the wizard's instructions. \n\nThird, create a very basic UI consisting of a simple XAML button and two text boxes.\n\n```XML\n<StackPanel HorizontalAlignment=\"Center\" VerticalAlignment=\"Center\">\n    <Button x:Name=\"LoginButton\" Content=\"Log in\" Click=\"LoginButton_Click\" />\n    <TextBlock x:Name=\"UserIdTextBlock\"/>\n    <TextBlock x:Name=\"UserNameTextBlock\"/>\n</StackPanel>\n```\n\nAnd an event handler attached to your button in the code-behind:\n\n```C#\nprivate void LoginButton_Click(object sender, RoutedEventArgs e)\n{   \n}\n```\n\nLastly, add the following namespaces so you don't have to worry about any reference issues later: \n\n```C#\nusing System;\nusing Windows.Security.Authentication.Web.Core;\nusing Windows.System;\nusing Windows.UI.ApplicationSettings;\nusing Windows.UI.Xaml;\nusing Windows.UI.Xaml.Controls;\nusing Windows.Data.Json;\nusing Windows.UI.Xaml.Navigation;\nusing Windows.Web.Http;\n```\n\n## Show the AccountSettingsPane\n\nThe system provides a built-in user interface for managing identity providers and web accounts called the AccountSettingsPane. You can show it like this:\n\n```C#\nprivate void LoginButton_Click(object sender, RoutedEventArgs e)\n{\n    AccountsSettingsPane.Show(); \n}\n```\n\nIf you run your app and click the \"Log in\" button, it should display an empty window. \n\n![Account settings pane](images/tb-1.png)\n\nThe pane is empty because the system only provides a UI shell - it's up to the developer to programatically populate the pane with the identity providers. \n\n## Register for AccountCommandsRequested\n\nTo add commands to the pane, we start by registering for the AccountCommandsRequested event handler. This tells the system to run our build logic when the user asks to see the pane (e.g., clicks our XAML button). \n\nIn your code behind, override the OnNavigatedTo and OnNavigatedFrom events and add the following code to them: \n\n```C#\nprotected override void OnNavigatedTo(NavigationEventArgs e)\n{\n    AccountsSettingsPane.GetForCurrentView().AccountCommandsRequested += BuildPaneAsync; \n}\n```\n\n```C#\nprotected override void OnNavigatedFrom(NavigationEventArgs e)\n{\n    AccountsSettingsPane.GetForCurrentView().AccountCommandsRequested -= BuildPaneAsync; \n}\n```\n\nUsers don't interact with accounts very often, so registering and deregistering your event handler in this fashion helps prevent memory leaks. This way, your customized pane is only in memory when there's a high chance a user is going to ask for it (because they're on a \"settings\" or \"login\" page, for example). \n\n## Build the account settings pane\n\nThe BuildPaneAsync method is called whenever the AccountSettingsPane is shown. This is where we'll put the code to customize the commands shown in the pane. \n\nStart by obtaining a deferral. This tells the system to delay showing the AccountsSettingsPane until we're finished building it.\n\n```C#\nprivate async void BuildPaneAsync(AccountsSettingsPane s,\n    AccountsSettingsPaneCommandsRequestedEventArgs e)\n{\n    var deferral = e.GetDeferral();\n        \n    deferral.Complete(); \n}\n```\n\nNext, get a provider using the WebAuthenticationCoreManager.FindAccountProviderAsync method. The URL for the provider varies based on the provider and can be found in the provider's documentation. For Microsoft Accounts and Azure Active Directory, it's \"https://login.microsoft.com\". \n\n```C#\nprivate async void BuildPaneAsync(AccountsSettingsPane s,\n    AccountsSettingsPaneCommandsRequestedEventArgs e)\n{\n    var deferral = e.GetDeferral();\n        \n    var msaProvider = await WebAuthenticationCoreManager.FindAccountProviderAsync(\n        \"https://login.microsoft.com\", \"consumers\"); \n        \n    deferral.Complete(); \n}\n```\n\nNotice that we also pass the string \"consumers\" to the optional *authority* parameter. This is because Microsoft provides two different types of authentication - Microsoft Accounts (MSA) for \"consumers\", and Azure Active Directory (AAD) for \"organizations\". The \"consumers\" authority lets the provider know we are interested in the former option.\n\nIf you are developing an enterprise app, you may want to use the AAD graph endpoint instead. See the full [WebAccountManagement sample on GitHub](http://go.microsoft.com/fwlink/p/?LinkId=620621) and the Azure documentation for more on how to do this. \n\nFinally, add the provider to the AccountsSettingsPane by creating a new WebAccountProviderCommand like this: \n\n```C#\nprivate async void BuildPaneAsync(AccountsSettingsPane s,\n    AccountsSettingsPaneCommandsRequestedEventArgs e)\n{\n    var deferral = e.GetDeferral();\n\n    var msaProvider = await WebAuthenticationCoreManager.FindAccountProviderAsync(\n        \"https://login.microsoft.com\", \"consumers\");\n\n    var command = new WebAccountProviderCommand(msaProvider, GetMsaTokenAsync);  \n\n    e.WebAccountProviderCommands.Add(command);\n\n    deferral.Complete(); \n}\n```\n\nNote that the GetMsaToken method we passed to our new WebAccountProviderCommand doesn't exist yet (we'll build that in the next step), so feel free to add it as an empty method for now.\n\nRun the above code and your pane should look something like this: \n\n![Account settings pane](images/tb-2.png)\n\n### Request a token\n\nOnce we have the Microsoft Account option displaying in the AccountsSettingsPane, we need to handle what happens when the user selects it. We registered our GetMsaToken method to fire when the user chooses to log in with their Microsoft Account, so we'll obtain the token there. \n\nTo obtain a token, use the RequestTokenAsync method like this: \n\n```C#\nprivate async void GetMsaTokenAsync(WebAccountProviderCommand command)\n{\n    WebTokenRequest request = new WebTokenRequest(command.WebAccountProvider, \"wl.basic\");\n    WebTokenRequestResult = await WebAuthenticationCoreManager.RequestTokenAsync(request);\n}\n```\n\nIn this example, we pass the string \"wl.basic\" to the scope parameter. Scope represents the type of information you are requesting from the providing service on a specific user. Certain scopes provide access only to a user's basic information, like name and email address. Other scopes might grant access to sensitive information such as the user's photos or email inbox. Generally, your app should use the least permissive scope unless our app explicitly needs additional permission - e.g., don't ask for access to sensitive information if your app doesn't absolutely need it. \n\nService providers will provide documentation on which scopes need to be specified to get tokens for use with their service. \n\nFor Office 365 and Outlook.com scopes, see (Authenticate Office 365 and Outlook.com APIs using the v2.0 authentication endpoint)[https://msdn.microsoft.com/office/office365/howto/authenticate-Office-365-APIs-using-v2]. \n\nFor OneDrive, see (OneDrive authentication and sign-in)[https://dev.onedrive.com/auth/msa_oauth.htm#authentication-scopes]. \n\n## Use the token\n\nThe RequestTokenAsync method returns a WebTokenRequestResult object, which contains the results of your request. If your request was successful, it will contain a token.  \n\n```C#\nprivate async void GetMsaTokenAsync(WebAccountProviderCommand command)\n{\n    WebTokenRequest request = new WebTokenRequest(command.WebAccountProvider, \"wl.basic\");\n    WebTokenRequestResult result = await WebAuthenticationCoreManager.RequestTokenAsync(request);\n    \n    if (result.ResponseStatus == WebTokenRequestStatus.Success)\n    {\n        string token = result.ResponseData[0].Token; \n    }\n}\n```\n\nOnce you have a token, you can use it to call your provider's API. In the code below, we'll call the Microsoft Live APIs to obtain basic information about the user and display it in our UI. \n\n```C#\nprivate async void GetMsaTokenAsync(WebAccountProviderCommand command)\n{\n    WebTokenRequest request = new WebTokenRequest(command.WebAccountProvider, \"wl.basic\");\n    WebTokenRequestResult result = await WebAuthenticationCoreManager.RequestTokenAsync(request);\n    \n    if (result.ResponseStatus == WebTokenRequestStatus.Success)\n    {\n        string token = result.ResponseData[0].Token; \n        \n        var restApi = new Uri(@\"https://apis.live.net/v5.0/me?access_token=\" + token);\n\n        using (var client = new HttpClient())\n        {\n            var infoResult = await client.GetAsync(restApi);\n            string content = await infoResult.Content.ReadAsStringAsync();\n\n            var jsonObject = JsonObject.Parse(content);\n            string id = jsonObject[\"id\"].GetString();\n            string name = jsonObject[\"name\"].GetString();\n\n            UserIdTextBlock.Text = \"Id: \" + id; \n            UserNameTextBlock.Text = \"Name: \" + name;\n        }\n    }\n}\n```\n\nHow you call various REST APIs varies between providers; see the provider's API documentation for information on how to use your token. \n\n## Save account state\n\nTokens are useful for immediately obtaining information about a user, but they usually have varying lifespans - MSA tokens, for instance, are only valid for a few hours. Fortunately, you don't need to re-show the AccountsSettingsPane each time a token expires. Once a user has authorized your app once, you can store the user's account information for future use. \n\nTo do this, use the WebAccount class. A WebAccount is returned along with requesting a token:\n\n```C#\nprivate async void GetMsaTokenAsync(WebAccountProviderCommand command)\n{\n    WebTokenRequest request = new WebTokenRequest(command.WebAccountProvider, \"wl.basic\");\n    WebTokenRequestResult result = await WebAuthenticationCoreManager.RequestTokenAsync(request);\n    \n    if (result.ResponseStatus == WebTokenRequestStatus.Success)\n    {\n        WebAccount account = result.ResponseData[0].WebAccount; \n    }\n}\n```\n\nOnce you have a WebAccount, you can easily store it. In the following example, we use LocalSettings: \n\n```C#\nprivate async void StoreWebAccount(WebAccount account)\n{\n    ApplicationData.Current.LocalSettings.Values[\"CurrentUserProviderId\"] = account.WebAccountProvider.Id;\n    ApplicationData.Current.LocalSettings.Values[\"CurrentUserId\"] = account.Id; \n}\n```\n\nThe next time the user launches your app, you can attempt to obtain a token silently (in the background) like this: \n\n```C#\nprivate async Task<string> GetTokenSilentlyAsync()\n{\n    string providerId = ApplicationData.Current.LocalSettings.Values[\"CurrentUserProviderId\"]?.ToString();\n    string accountId = ApplicationData.Current.LocalSettings.Values[\"CurrentUserId\"]?.ToString();\n\n    if (null == providerId || null == accountId)\n    {\n        return null; \n    }\n\n    WebAccountProvider provider = await WebAuthenticationCoreManager.FindAccountProviderAsync(providerId);\n    WebAccount account = await WebAuthenticationCoreManager.FindAccountAsync(provider, accountId);\n\n    WebTokenRequest request = new WebTokenRequest(provider, \"wl.basic\");\n\n    WebTokenRequestResult result = await WebAuthenticationCoreManager.GetTokenSilentlyAsync(request, account);\n    if (result.ResponseStatus == WebTokenRequestStatus.UserInteractionRequired)\n    {\n        // Unable to get a token silently - you'll need to show the UI\n        return null; \n    }\n    else if (result.ResponseStatus == WebTokenRequestStatus.Success)\n    {\n        // Success\n        return result.ResponseData[0].Token;\n    }\n    else\n    {\n        // Other error \n        return null; \n    }\n}\n```\n\nBecause obtaining a token silently is very simple, you should use this process to refresh your token between sessions rather than caching an existing token (since that token might expire at any time).\n\nNote the example above only covers basic success and fail cases. Your app should also account for unusual scenarios (like a user revoking your app's permission or removing their account from Windows, for example) and handle them gracefully.  \n\n## Log out an account \n\nIf you persist a WebAccount, you may want to provide \"log out\" functionality to your users so they can switch accounts or simply dissasociate their account with your app. To do this, first remove any saved account and provider information. Then call WebAccount.SignOutAsync() to clear the cache and invalidate any existing tokens your app may have. \n\n```C#\nprivate async Task SignOutAccountAsync(WebAccount account)\n{\n    ApplicationData.Current.LocalSettings.Values.Remove(\"CurrentUserProviderId\");\n    ApplicationData.Current.LocalSettings.Values.Remove(\"CurrentUserId\"); \n    account.SignOutAsync(); \n}\n```\n\n## Add providers that don't support WebAccountManager\n\nIf you want to integrate authentication from a service into your app but that service doesn't support WebAccountManager - Google+ or Twitter, for example - you can still manually add that provider to the AccountsSettingsPane. To do so, create a new WebAccountProvider object and provide your own name and .png icon, then and add it to the WebAccountProviderCommands. Here's some stub code: \n\n ```C#\nprivate async void BuildPaneAsync(AccountsSettingsPane s, AccountsSettingsPaneCommandsRequestedEventArgs e)\n{\n    // other code here \n\n    var twitterProvider = new WebAccountProvider(\"twitter\", \"Twitter\", new Uri(@\"ms-appx:///Assets/twitter-auth-icon.png\")); \n    var twitterCmd = new WebAccountProviderCommand(twitterProvider, GetTwitterTokenAsync);\n    e.WebAccountProviderCommands.Add(twitterCmd);   \n    \n    // other code here\n}\n\nprivate async void GetTwitterTokenAsync(WebAccountProviderCommand command)\n{\n    // Manually handle Twitter login here\n}\n\n```\n\nNote this only adds an icon to the AccountsSettingsPane and runs the method you specify when the icon is clicked (GetTwitterTokenAsync, in this case). You must provide the code that handles the actual authentication. For more information, see (Web authentication broker)[web-authentication-broker], which provides helper methods for authenticating using REST services. \n\n## Add a custom header\n\nYou can customize the account settings pane using the HeaderText property, like this: \n\n```C#\nprivate async void BuildPaneAsync(AccountsSettingsPane s, AccountsSettingsPaneCommandsRequestedEventArgs e)\n{\n    // other code here \n    \n    args.HeaderText = \"MyAwesomeApp works best if you're signed in.\";   \n    \n    // other code here\n}\n```\n\n![Account settings pane](images/tb-3.png)\n\nDon't go overboard with header text; keep it short and sweet. If your login process is complicated and you need to display more information, link the user to a separate page using a custom link. \n\n## Add custom links\n\nYou can add custom commands to the AccountsSettingsPane, which appear as links below your supported WebAccountProviders. Custom commands are great for simple tasks related to user accounts, like displaying a privacy policy or launching a support page for users having trouble. \n\nHere's an example: \n\n```C#\nprivate async void BuildPaneAsync(AccountsSettingsPane s, AccountsSettingsPaneCommandsRequestedEventArgs e)\n{\n    // other code here \n    \n    var settingsCmd = new SettingsCommand(\n        \"settings_privacy\", \n        \"Privacy policy\", \n        async (x) => await Launcher.LaunchUriAsync(new Uri(@\"https://privacy.microsoft.com/en-US/\"))); \n\n    e.Commands.Add(settingsCmd); \n    \n    // other code here\n}\n```\n\n![Account settings pane](images/tb-4.png)\n\nTheoretically, you can use settings commands for anything. However, we suggest limiting their use to intuitive, account-related scenarios like those described above. \n\n## See also\n\n[Windows.Security.Authentication.Web.Core namespace](https://msdn.microsoft.com/library/windows/apps/windows.security.authentication.web.core.aspx)\n\n[Windows.Security.Credentials namespace](https://msdn.microsoft.com/library/windows/apps/windows.security.credentials.aspx)\n\n[AccountsSettingsPane](https://msdn.microsoft.com/library/windows/apps/windows.ui.applicationsettings.accountssettingspane)\n\n[Web authentication broker](web-authentication-broker.md)\n\n[WebAccountManagement sample](http://go.microsoft.com/fwlink/p/?LinkId=620621)\n"}