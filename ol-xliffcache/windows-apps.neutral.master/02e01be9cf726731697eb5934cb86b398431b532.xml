{"nodes":[{"content":"Use the background transfer API to copy files reliably over the network.","pos":[32,104]},{"content":"Background transfers","pos":[112,132]},{"content":"Background transfers","pos":[189,209]},{"content":"Updated for UWP apps on Windows 10.","pos":[214,249]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[250,342]},{"content":"Important APIs","pos":[350,364]},{"content":"Windows.Networking.backgroundTransfer","pos":[375,412]},{"content":"Windows.Foundation.Uri","pos":[481,503]},{"content":"Windows.Networking.Sockets","pos":[572,598]},{"content":"Use the background transfer API to copy files reliably over the network.","pos":[661,733]},{"content":"The background transfer API provides advanced upload and download features that run in the background during app suspension and persist beyond app termination.","pos":[734,893]},{"content":"The API monitors network status and automatically suspends and resumes transfers when connectivity is lost, and transfers are also Data Sense-aware and Battery Sense-aware, meaning that download activity adjusts based on your current connectivity and device battery status.","pos":[894,1167]},{"content":"The API is ideal for uploading and downloading large files using HTTP(S).","pos":[1168,1241]},{"content":"FTP is also supported, but only for downloads.","pos":[1242,1288]},{"content":"Background Transfer runs separately from the calling app and is primarily designed for long-term transfer operations for resources like video, music, and large images.","pos":[1290,1457]},{"content":"For these scenarios, using Background Transfer is essential because downloads continue to progress even when the app is suspended.","pos":[1458,1588]},{"pos":[1590,1792],"content":"If you are downloading small resources that are likely to complete quickly, you should use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>HttpClient<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn298639)</ept> APIs instead of Background Transfer."},{"content":"Using Windows.Networking.BackgroundTransfer","pos":[1797,1840]},{"content":"How does the Background Transfer feature work?","pos":[1847,1893]},{"content":"When an app uses Background Transfer to initiate a transfer, the request is configured and initialized using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundDownloader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207126)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>BackgroundUploader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br207140)</ept> class objects.","pos":[1895,2189]},{"content":"Each transfer operation is handled individually by the system and separate from the calling app.","pos":[2190,2286]},{"content":"Progress information is available if you want to give status to the user in your app's UI, and your app can pause, resume, cancel, or even read from the data while the transfer is occurring.","pos":[2287,2477]},{"content":"The way transfers are handled by the system promotes smart power usage and prevents problems that can arise when a connected app encounters events such as app suspension, termination, or sudden network status changes.","pos":[2478,2695]},{"content":"Performing authenticated file requests with Background Transfer","pos":[2701,2764]},{"pos":[2766,3011],"content":"Background Transfer provides methods that support basic server and proxy credentials, cookies, and the use of custom HTTP headers (via <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetRequestHeader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207146)</ept>) for each transfer operation."},{"content":"How does this feature adapt to network status changes or unexpected shutdowns?","pos":[3017,3095]},{"content":"The Background Transfer feature maintains a consistent experience for each transfer operation when network status changes occur, by intelligently leveraging connectivity and carrier data-plan status information provided by the <bpt id=\"p1\">[</bpt>Connectivity<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh452990)</ept> feature.","pos":[3097,3405]},{"content":"To define behavior for different network scenarios, an app sets a cost policy for each operation using values defined by <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundTransferCostPolicy<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207138)</ept>.","pos":[3406,3620]},{"content":"For example, the cost policy defined for an operation can indicate that the operation should be paused automatically when the device is using a metered network.","pos":[3622,3782]},{"content":"The transfer is then automatically resumed (or restarted) when a connection to an \"unrestricted\" network has been established.","pos":[3783,3909]},{"content":"For more information on how networks are defined by cost, see <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>NetworkCostType<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207292)</ept>.","pos":[3910,4052]},{"content":"While the Background Transfer feature has its own mechanisms for handling network status changes, there are other general connectivity considerations for network-connected apps.","pos":[4054,4231]},{"content":"Read <bpt id=\"p1\">[</bpt>Leveraging available network connection information<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh452983)</ept> for additional info.","pos":[4232,4369]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  For apps running on mobile devices, there are features that allow the user to monitor and restrict the amount of data that is transferred based on the type of connection, roaming status, and the user's data plan.","pos":[4373,4595]},{"content":"Because of this, background transfers may be paused on the phone even when the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundTransferCostPolicy<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207138)</ept> indicates that the transfer should proceed.","pos":[4596,4811]},{"content":"The following table indicates when background transfers are allowed on the phone for each <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundTransferCostPolicy<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207138)</ept> value, given the current state of the phone.","pos":[4813,5040]},{"content":"You can use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ConnectionCost<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207244)</ept> class to determine the phone's current state.","pos":[5041,5181]},{"content":"Device State","pos":[5185,5197]},{"content":"UnrestrictedOnly","pos":[5317,5333]},{"content":"Default","pos":[5336,5343]},{"content":"Always","pos":[5346,5352]},{"content":"Connected to WiFi","pos":[5529,5546]},{"content":"Allow","pos":[5661,5666]},{"content":"Allow","pos":[5680,5685]},{"content":"Allow","pos":[5690,5695]},{"content":"Metered Connection, not roaming, under data limit, on track to stay under limit","pos":[5701,5780]},{"content":"Deny","pos":[5833,5837]},{"content":"Allow","pos":[5852,5857]},{"content":"Allow","pos":[5862,5867]},{"content":"Metered Connection, not roaming, under data limit, on track to exceed limit","pos":[5873,5948]},{"content":"Deny","pos":[6005,6009]},{"content":"Deny","pos":[6024,6028]},{"content":"Allow","pos":[6034,6039]},{"content":"Metered Connection, roaming, under data limit","pos":[6045,6090]},{"content":"Deny","pos":[6177,6181]},{"content":"Deny","pos":[6196,6200]},{"content":"Allow","pos":[6206,6211]},{"content":"Metered Connection, over data limit.","pos":[6217,6253]},{"content":"This state only occurs when the user enables \"Restrict background data in the Data Sense UI.","pos":[6254,6346]},{"content":"Deny","pos":[6349,6353]},{"content":"Deny","pos":[6368,6372]},{"content":"Deny","pos":[6378,6382]},{"content":"Uploading files","pos":[6394,6409]},{"content":"When using Background Transfer an upload exists as an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UploadOperation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207224)</ept> that exposes a number of control methods that are used to restart or cancel the operation.","pos":[6412,6636]},{"content":"App events (e.g. suspension or termination) and connectivity changes are handled automatically by the system per <bpt id=\"p1\">**</bpt>UploadOperation<ept id=\"p1\">**</ept>; uploads will continue during app suspension periods or pause and persist beyond app termination.","pos":[6637,6867]},{"content":"Additionally, setting the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CostPolicy<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701018)</ept> property will indicate whether or not your app will start uploads while a metered network is being used for Internet connectivity.","pos":[6868,7099]},{"content":"The following examples will walk you through the creation and initialization of a basic upload and how to enumerate and reintroduce operations persisted from a previous app session.","pos":[7101,7282]},{"content":"Uploading a single file","pos":[7288,7311]},{"content":"The creation of an upload begins with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundUploader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207140)</ept>.","pos":[7313,7434]},{"content":"This class is used to provide the methods that enable your app to configure the upload before creating the resultant <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UploadOperation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207224)</ept>.","pos":[7435,7632]},{"content":"The following example shows how to do this with the required <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Uri<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225998)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StorageFile<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227171)</ept> objects.","pos":[7633,7850]},{"content":"Identify the file and destination for the upload","pos":[7854,7902]},{"content":"Before we can begin with the creation of an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UploadOperation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207224)</ept>, we first need to identify the URI of the location to upload to, and the file that will be uploaded.","pos":[7906,8130]},{"content":"In the following example, the <bpt id=\"p1\">*</bpt>uriString<ept id=\"p1\">*</ept> value is populated using a string from UI input, and the <bpt id=\"p2\">*</bpt>file<ept id=\"p2\">*</ept> value using the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StorageFile<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227171)</ept> object returned by a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>PickSingleFileAsync<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/jj635275)</ept> operation.","pos":[8131,8444]},{"pos":[8455,8601],"content":"<bpt id=\"p1\">[</bpt>uploadFile<ept id=\"p1\">]</ept><bpt id=\"p2\">(./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_B \"</bpt>Identify the file and destination for the upload<ept id=\"p2\">\")</ept>"},{"content":"Create and initialize the upload operation","pos":[8606,8648]},{"content":"In the previous step the <bpt id=\"p1\">*</bpt>uriString<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>file<ept id=\"p2\">*</ept> values are passed to an instance of our next example, UploadOp, where they are used to configure and start the new upload operation.","pos":[8652,8832]},{"content":"First, <bpt id=\"p1\">*</bpt>uriString<ept id=\"p1\">*</ept> is parsed to create the required <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Uri<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br225998)</ept> object.","pos":[8833,8960]},{"content":"Next, the properties of the provided <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StorageFile<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227171)</ept> (<bpt id=\"p3\">*</bpt>file<ept id=\"p3\">*</ept>) are used by <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>BackgroundUploader<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br207140)</ept> to populate the request header and set the <bpt id=\"p6\">*</bpt>SourceFile<ept id=\"p6\">*</ept> property with the <bpt id=\"p7\">**</bpt>StorageFile<ept id=\"p7\">**</ept> object.","pos":[8962,9276]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetRequestHeader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207146)</ept> method is then called to insert the file name, provided as a string, and the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StorageFile.Name<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227220)</ept> property.","pos":[9277,9529]},{"pos":[9531,9726],"content":"Finally, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundUploader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207140)</ept> creates the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>UploadOperation<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br207224)</ept> (<bpt id=\"p5\">*</bpt>upload<ept id=\"p5\">*</ept>)."},{"pos":[9737,9877],"content":"<bpt id=\"p1\">[</bpt>uploadFile<ept id=\"p1\">]</ept><bpt id=\"p2\">(./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_A \"</bpt>Create and initialize the upload operation<ept id=\"p2\">\")</ept>"},{"content":"Note the asynchronous method calls defined using JavaScript promises.","pos":[9880,9949]},{"content":"Looking at a line from the last example:","pos":[9950,9990]},{"content":"Uploading multiple files","pos":[10425,10449]},{"content":"Identify the files and destination for the upload","pos":[10453,10502]},{"content":"Create objects for the provided parameters","pos":[11892,11934]},{"content":"Create and initialize the multi-part upload operation","pos":[13429,13482]},{"content":"Restarting interrupted upload operations","pos":[14450,14490]},{"content":"On completion or cancellation of an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UploadOperation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207224)</ept>, any associated system resources are released.","pos":[14492,14654]},{"content":"However, if your app is terminated before either of these things can occur, any active operations are paused and the resources associated with each remain occupied.","pos":[14655,14819]},{"content":"If these operations are not enumerated and re-introduced to the next app session, they will not be completed and will continue to occupy device resources.","pos":[14820,14974]},{"pos":[14980,15204],"content":"Before defining the function that enumerates persisted operations, we need to create an array that will contain the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UploadOperation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207224)</ept> objects that it will return:"},{"pos":[15215,15349],"content":"<bpt id=\"p1\">[</bpt>uploadFile<ept id=\"p1\">]</ept><bpt id=\"p2\">(./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_C \"</bpt>Restart interrupted upload operation<ept id=\"p2\">\")</ept>"},{"content":"Next we define the function that enumerates persisted operations and stores them in our array.","pos":[15356,15450]},{"content":"Note that the <bpt id=\"p1\">**</bpt>load<ept id=\"p1\">**</ept> method called to re-assign callbacks to the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>UploadOperation<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br207224)</ept>, should it persist through app termination, is in the UploadOp class we define later in this section.","pos":[15451,15699]},{"pos":[15710,15838],"content":"<bpt id=\"p1\">[</bpt>uploadFile<ept id=\"p1\">]</ept><bpt id=\"p2\">(./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_D \"</bpt>Enumerate persisted operations<ept id=\"p2\">\")</ept>"},{"content":"Downloading files","pos":[15844,15861]},{"content":"When using Background Transfer, each download exists as a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DownloadOperation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207154)</ept> that exposes a number of control methods used to pause, resume, restart, and cancel the operation.","pos":[15863,16101]},{"content":"App events (e.g. suspension or termination) and connectivity changes are handled automatically by the system per <bpt id=\"p1\">**</bpt>DownloadOperation<ept id=\"p1\">**</ept>; downloads will continue during app suspension periods or pause and persist beyond app termination.","pos":[16102,16336]},{"content":"For mobile network scenarios, setting the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CostPolicy<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701018)</ept> property will indicate whether or not your app will begin or continue downloads while a metered network is being used for Internet connectivity.","pos":[16337,16598]},{"pos":[16600,16802],"content":"If you are downloading small resources that are likely to complete quickly, you should use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>HttpClient<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn298639)</ept> APIs instead of Background Transfer."},{"content":"The following examples will walk you through the creation and initialization of a basic download, and how to enumerate and reintroduce operations persisted from a previous app session.","pos":[16804,16988]},{"content":"Configure and start a Background Transfer file download","pos":[16994,17049]},{"content":"The following example demonstrates how strings representing a URI and a file name can be used to create a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Uri<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225998)</ept> object and the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StorageFile<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227171)</ept> that will contain the requested file.","pos":[17051,17353]},{"content":"In this example, the new file is automatically placed in a pre-defined location.","pos":[17354,17434]},{"content":"Alternatively, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FileSavePicker<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207871)</ept> can be used allow users to indicate where to save the file on the device.","pos":[17435,17602]},{"content":"Note that the <bpt id=\"p1\">**</bpt>load<ept id=\"p1\">**</ept> method called to re-assign callbacks to the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DownloadOperation<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br207154)</ept>, should it persist through app termination, is in the DownloadOp class defined later in this section.","pos":[17603,17853]},{"pos":[17865,17875],"content":"uploadFile"},{"content":"Note the asynchronous method calls defined using JavaScript promises.","pos":[17966,18035]},{"content":"Looking at line 17 from the previous code example:","pos":[18036,18086]},{"content":"The async method call is followed by a then statement which indicates methods, defined by the app, that are called when a result from the async method call is returned.","pos":[18172,18340]},{"content":"For more information on this programming pattern, see <bpt id=\"p1\">[</bpt>Asynchronous programming in JavaScript using promises<ept id=\"p1\">](http://msdn.microsoft.com/library/windows/apps/hh464930.aspx)</ept>.","pos":[18341,18513]},{"content":"Adding additional operation control methods","pos":[18519,18562]},{"content":"The level of control can be increased by implementing additional <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DownloadOperation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207154)</ept> methods.","pos":[18564,18719]},{"content":"For example, adding the following code to the example above will introduce the ability to cancel the download.","pos":[18720,18830]},{"pos":[18842,18852],"content":"uploadFile"},{"content":"Enumerating persisted operations at start-up","pos":[18947,18991]},{"content":"On completion or cancellation of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DownloadOperation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207154)</ept>, any associated system resources are released.","pos":[18993,19156]},{"content":"However, if your app is terminated before either of these events occur, downloads will pause and persist in the background.","pos":[19157,19280]},{"content":"The following examples demonstrate how to re-introduce persisted downloads into a new app session.","pos":[19281,19379]},{"pos":[19385,19611],"content":"Before defining the function that enumerates persisted operations, we need to create an array that will contain the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DownloadOperation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207154)</ept> objects that it will return:"},{"pos":[19623,19633],"content":"uploadFile"},{"content":"Next we define the function that enumerates persisted operations and stores them in our array.","pos":[19728,19822]},{"content":"Note that the <bpt id=\"p1\">**</bpt>load<ept id=\"p1\">**</ept> method called to re-assign callbacks for a persisted <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DownloadOperation<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br207154)</ept> is in the DownloadOp example we define later in this section.","pos":[19823,20042]},{"pos":[20054,20064],"content":"uploadFile"},{"content":"You can now use the populated list to restart pending operations.","pos":[20159,20224]},{"content":"Post-processing","pos":[20229,20244]},{"content":"A new feature in Windows 10 is the ability to run application code at the completion of a background transfer even when the app is not running.","pos":[20246,20389]},{"content":"For example, your app might want to update a list of available movies after a movie has finished downloading, rather than have your app scan for new movies every time it starts.","pos":[20390,20567]},{"content":"Or your app might want to handle a failed file transfer by trying again using a different server or port.","pos":[20568,20673]},{"content":"Post-processing is invoked for both successful and failed transfers, so you can use it to implement custom error-handling and retry logic.","pos":[20674,20812]},{"content":"Postprocessing uses the existing background task infrastructure.","pos":[20814,20878]},{"content":"You create a background task and associate it with your transfers before you start the transfers.","pos":[20879,20976]},{"content":"The transfers are then executed in the background, and when they are complete, your background task is called to perform post-processing.","pos":[20977,21114]},{"content":"Post-processing uses a new class, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundTransferCompletionGroup<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn804209)</ept>.","pos":[21116,21248]},{"content":"This class is similar to the existing <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundTransferGroup<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn279030)</ept> in that it allows you to group background transfers together, but <bpt id=\"p3\">**</bpt>BackgroundTransferCompletionGroup<ept id=\"p3\">**</ept> adds the ability to designate a background task to be run when the transfer is complete.","pos":[21249,21567]},{"content":"You initiate a background transfer with post-processing as follows.","pos":[21569,21636]},{"content":"Create a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundTransferCompletionGroup<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn804209)</ept> object.","pos":[21642,21756]},{"content":"Then, create a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundTaskBuilder<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br224768)</ept> object.","pos":[21757,21865]},{"content":"Set the <bpt id=\"p1\">**</bpt>Trigger<ept id=\"p1\">**</ept> property of the builder object to the completion group object, and the <bpt id=\"p2\">**</bpt>TaskEngtyPoint<ept id=\"p2\">**</ept> property of the builder to the entry point of the background task that should execute on transfer completion.","pos":[21866,22085]},{"content":"Finally, call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundTaskBuilder.Register<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br224772)</ept> method to register your background task.","pos":[22086,22239]},{"content":"Note that many completion groups can share one background task entry point, but you can have only one completion group per background task registration.","pos":[22240,22392]},{"content":"Next you associate background transfers with the completion group.","pos":[22797,22863]},{"content":"Once all transfers are created, enable the completion group.","pos":[22864,22924]},{"content":"The code in the background task extracts the list of operations from the trigger details, and your code can then inspect the details for each operation and perform appropriate post-processing for each operation.","pos":[23404,23615]},{"content":"The post-processing task is a regular background task.","pos":[24056,24110]},{"content":"It is part of the pool of all background tasks, and it is subject to the same resource management policy as all background tasks.","pos":[24111,24240]},{"content":"Also, note that post-processing does not replace foreground completion handlers.","pos":[24242,24322]},{"content":"If your app defines a foreground completion handler, and your app is running when the file transfer completes, then both your foreground completion handler and your background completion handler will be called.","pos":[24323,24533]},{"content":"The order in which foreground and background tasks are called is not guaranteed.","pos":[24534,24614]},{"content":"If you define both, you should ensure that the two tasks will work properly and not interfere with each other if they are running concurrently.","pos":[24615,24758]},{"content":"Request timeouts","pos":[24763,24779]},{"content":"There are two primary connection timeout scenarios to take into consideration:","pos":[24781,24859]},{"content":"When establishing a new connection for a transfer, the connection request is aborted if it is not established within five minutes.","pos":[24865,24995]},{"content":"After a connection has been established, an HTTP request message that has not received a response within two minutes is aborted.","pos":[25001,25129]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  In either scenario, assuming there is Internet connectivity, Background Transfer will retry a request up to three times automatically.","pos":[25133,25277]},{"content":"In the event Internet connectivity is not detected, additional requests will wait until it is.","pos":[25278,25372]},{"content":"Debugging guidance","pos":[25377,25395]},{"content":"Stopping a debugging session in Microsoft Visual Studio is comparable to closing your app; PUT uploads are paused and POST uploads are terminated.","pos":[25397,25543]},{"content":"Even while debugging, your app should enumerate and then restart or cancel any persisted uploads.","pos":[25544,25641]},{"content":"For example, you can have your app cancel enumerated persisted upload operations at app startup if there is no interest in previous operations for that debug session.","pos":[25642,25808]},{"content":"While enumerating downloads/uploads on app startup during a debug session, you can have your app cancel them if there is no interest in previous operations for that debug session.","pos":[25810,25989]},{"content":"Note that if there are Visual Studio project updates, like changes to the app manifest, and the app is uninstalled and re-deployed, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GetCurrentUploadsAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701149)</ept> cannot enumerate operations created using the previous app deployment.","pos":[25990,26279]},{"content":"When using Background Transfer during development, you may get into a situation where the internal caches of active and completed transfer operations can get out of sync.","pos":[26281,26451]},{"content":"This may result in the inability to start new transfer operations or interact with existing operations and <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundTransferGroup<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn279030)</ept> objects.","pos":[26452,26655]},{"content":"In some cases, attempting to interact with existing operations may trigger a crash.","pos":[26656,26739]},{"content":"This result can occur if the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TransferBehavior<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn279033)</ept> property is set to <bpt id=\"p3\">**</bpt>Parallel<ept id=\"p3\">**</ept>.","pos":[26740,26882]},{"content":"This issue occurs only in certain scenarios during development and is not applicable to end users of your app.","pos":[26883,26993]},{"content":"Four scenarios using Visual Studio can cause this issue.","pos":[26995,27051]},{"content":"You create a new project with the same app name as an existing project, but a different language (from C++ to C#, for example).","pos":[27057,27184]},{"content":"You change the target architecture (from x86 to x64, for example) in an existing project.","pos":[27189,27278]},{"content":"You change the culture (from neutral to en-US, for example) in an existing project.","pos":[27283,27366]},{"pos":[27371,27501],"content":"You add or remove a capability in the package manifest (adding <bpt id=\"p1\">**</bpt>Enterprise Authentication<ept id=\"p1\">**</ept>, for example) in an existing project."},{"content":"Regular app servicing, including manifest updates which add or remove capabilities, do not trigger this issue on end user deployments of your app.","pos":[27503,27649]},{"content":"To work around this issue, completely uninstall all versions of the app and re-deploy with the new language, architecture, culture, or capability.","pos":[27650,27796]},{"content":"This can be done via the <bpt id=\"p1\">**</bpt>Start<ept id=\"p1\">**</ept> screen or using PowerShell and the <bpt id=\"p2\">**</bpt>Remove-AppxPackage<ept id=\"p2\">**</ept> cmdlet.","pos":[27797,27897]},{"content":"Exceptions in Windows.Networking.BackgroundTransfer","pos":[27902,27953]},{"pos":[27955,28176],"content":"An exception is thrown when an invalid string for a the Uniform Resource Identifier (URI) is passed to the constructor for the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Foundation.Uri<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225998)</ept> object."},{"pos":[28178,28396],"content":"<bpt id=\"p1\">**</bpt>.NET:  <ept id=\"p1\">**</ept>The <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Windows.Foundation.Uri<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br225998)</ept> type appears as <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>System.Uri<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.aspx)</ept> in C# and VB."},{"pos":[28398,28776],"content":"In C# and Visual Basic, this error can be avoided by using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>System.Uri<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.aspx)</ept> class in the .NET 4.5 and one of the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>System.Uri.TryCreate<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.trycreate.aspx)</ept> methods to test the string received from the app user before the URI is constructed."},{"content":"In C++, there is no method to try and parse a string to a URI.","pos":[28778,28840]},{"content":"If an app gets input from the user for the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Foundation.Uri<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225998)</ept>, the constructor should be in a try/catch block.","pos":[28841,29019]},{"content":"If an exception is thrown, the app can notify the user and request a new hostname.","pos":[29020,29102]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Networking.backgroundTransfer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207242)</ept> namespace has convenient helper methods and uses enumerations in the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Windows.Networking.Sockets<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226960)</ept> namespace for handling errors.","pos":[29104,29400]},{"content":"This can be useful for handling specific network exceptions differently in your app.","pos":[29401,29485]},{"content":"An error encountered on an asynchronous method in the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Networking.backgroundTransfer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br207242)</ept> namespace is returned as an <bpt id=\"p3\">**</bpt>HRESULT<ept id=\"p3\">**</ept> value.","pos":[29487,29689]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BackgroundTransferError.GetStatus<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701093)</ept> method is used to convert a network error from a background transfer operation to a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>WebErrorStatus<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh747818)</ept> enumeration value.","pos":[29690,29973]},{"content":"Most of the <bpt id=\"p1\">**</bpt>WebErrorStatus<ept id=\"p1\">**</ept> enumeration values correspond to an error returned by the native HTTP or FTP client operation.","pos":[29974,30099]},{"content":"An app can filter on specific <bpt id=\"p1\">**</bpt>WebErrorStatus<ept id=\"p1\">**</ept> enumeration values to modify app behavior depending on the cause of the exception.","pos":[30100,30231]},{"content":"For parameter validation errors, an app can also use the <bpt id=\"p1\">**</bpt>HRESULT<ept id=\"p1\">**</ept> from the exception to learn more detailed information on the error that caused the exception.","pos":[30233,30395]},{"content":"Possible <bpt id=\"p1\">**</bpt>HRESULT<ept id=\"p1\">**</ept> values are listed in the <bpt id=\"p2\">*</bpt>Winerror.h<ept id=\"p2\">*</ept> header file.","pos":[30396,30467]},{"content":"For most parameter validation errors, the <bpt id=\"p1\">**</bpt>HRESULT<ept id=\"p1\">**</ept> returned is <bpt id=\"p2\">**</bpt>E<ph id=\"ph1\">\\_</ph>INVALIDARG<ept id=\"p2\">**</ept>.","pos":[30468,30552]}],"content":"---\nauthor: DelfCo\ndescription: Use the background transfer API to copy files reliably over the network.\ntitle: Background transfers\nms.assetid: 1207B089-BC16-4BF0-BBD4-FD99950C764B\n---\n\n# Background transfers\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n**Important APIs**\n\n-   [**Windows.Networking.backgroundTransfer**](https://msdn.microsoft.com/library/windows/apps/br207242)\n-   [**Windows.Foundation.Uri**](https://msdn.microsoft.com/library/windows/apps/br225998)\n-   [**Windows.Networking.Sockets**](https://msdn.microsoft.com/library/windows/apps/br226960)\n\nUse the background transfer API to copy files reliably over the network. The background transfer API provides advanced upload and download features that run in the background during app suspension and persist beyond app termination. The API monitors network status and automatically suspends and resumes transfers when connectivity is lost, and transfers are also Data Sense-aware and Battery Sense-aware, meaning that download activity adjusts based on your current connectivity and device battery status. The API is ideal for uploading and downloading large files using HTTP(S). FTP is also supported, but only for downloads.\n\nBackground Transfer runs separately from the calling app and is primarily designed for long-term transfer operations for resources like video, music, and large images. For these scenarios, using Background Transfer is essential because downloads continue to progress even when the app is suspended.\n\nIf you are downloading small resources that are likely to complete quickly, you should use [**HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) APIs instead of Background Transfer.\n\n## Using Windows.Networking.BackgroundTransfer\n\n\n### How does the Background Transfer feature work?\n\nWhen an app uses Background Transfer to initiate a transfer, the request is configured and initialized using [**BackgroundDownloader**](https://msdn.microsoft.com/library/windows/apps/br207126) or [**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140) class objects. Each transfer operation is handled individually by the system and separate from the calling app. Progress information is available if you want to give status to the user in your app's UI, and your app can pause, resume, cancel, or even read from the data while the transfer is occurring. The way transfers are handled by the system promotes smart power usage and prevents problems that can arise when a connected app encounters events such as app suspension, termination, or sudden network status changes.\n\n### Performing authenticated file requests with Background Transfer\n\nBackground Transfer provides methods that support basic server and proxy credentials, cookies, and the use of custom HTTP headers (via [**SetRequestHeader**](https://msdn.microsoft.com/library/windows/apps/br207146)) for each transfer operation.\n\n### How does this feature adapt to network status changes or unexpected shutdowns?\n\nThe Background Transfer feature maintains a consistent experience for each transfer operation when network status changes occur, by intelligently leveraging connectivity and carrier data-plan status information provided by the [Connectivity](https://msdn.microsoft.com/library/windows/apps/hh452990) feature. To define behavior for different network scenarios, an app sets a cost policy for each operation using values defined by [**BackgroundTransferCostPolicy**](https://msdn.microsoft.com/library/windows/apps/br207138).\n\nFor example, the cost policy defined for an operation can indicate that the operation should be paused automatically when the device is using a metered network. The transfer is then automatically resumed (or restarted) when a connection to an \"unrestricted\" network has been established. For more information on how networks are defined by cost, see [**NetworkCostType**](https://msdn.microsoft.com/library/windows/apps/br207292).\n\nWhile the Background Transfer feature has its own mechanisms for handling network status changes, there are other general connectivity considerations for network-connected apps. Read [Leveraging available network connection information](https://msdn.microsoft.com/library/windows/apps/hh452983) for additional info.\n\n> **Note**  For apps running on mobile devices, there are features that allow the user to monitor and restrict the amount of data that is transferred based on the type of connection, roaming status, and the user's data plan. Because of this, background transfers may be paused on the phone even when the [**BackgroundTransferCostPolicy**](https://msdn.microsoft.com/library/windows/apps/br207138) indicates that the transfer should proceed.\n\nThe following table indicates when background transfers are allowed on the phone for each [**BackgroundTransferCostPolicy**](https://msdn.microsoft.com/library/windows/apps/br207138) value, given the current state of the phone. You can use the [**ConnectionCost**](https://msdn.microsoft.com/library/windows/apps/br207244) class to determine the phone's current state.\n\n| Device State                                                                                                                      | UnrestrictedOnly | Default | Always |\n|-----------------------------------------------------------------------------------------------------------------------------------|------------------|---------|--------|\n| Connected to WiFi                                                                                                                 | Allow            | Allow   | Allow  |\n| Metered Connection, not roaming, under data limit, on track to stay under limit                                                   | Deny             | Allow   | Allow  |\n| Metered Connection, not roaming, under data limit, on track to exceed limit                                                       | Deny             | Deny    | Allow  |\n| Metered Connection, roaming, under data limit                                                                                     | Deny             | Deny    | Allow  |\n| Metered Connection, over data limit. This state only occurs when the user enables \"Restrict background data in the Data Sense UI. | Deny             | Deny    | Deny   |\n\n \n\n## Uploading files\n\n\nWhen using Background Transfer an upload exists as an [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) that exposes a number of control methods that are used to restart or cancel the operation. App events (e.g. suspension or termination) and connectivity changes are handled automatically by the system per **UploadOperation**; uploads will continue during app suspension periods or pause and persist beyond app termination. Additionally, setting the [**CostPolicy**](https://msdn.microsoft.com/library/windows/apps/hh701018) property will indicate whether or not your app will start uploads while a metered network is being used for Internet connectivity.\n\nThe following examples will walk you through the creation and initialization of a basic upload and how to enumerate and reintroduce operations persisted from a previous app session.\n\n### Uploading a single file\n\nThe creation of an upload begins with [**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140). This class is used to provide the methods that enable your app to configure the upload before creating the resultant [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224). The following example shows how to do this with the required [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) and [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) objects.\n\n**Identify the file and destination for the upload**\n\nBefore we can begin with the creation of an [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224), we first need to identify the URI of the location to upload to, and the file that will be uploaded. In the following example, the *uriString* value is populated using a string from UI input, and the *file* value using the [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) object returned by a [**PickSingleFileAsync**](https://msdn.microsoft.com/library/windows/apps/jj635275) operation.\n\n[!code-js[uploadFile](./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_B \"Identify the file and destination for the upload\")]\n\n**Create and initialize the upload operation**\n\nIn the previous step the *uriString* and *file* values are passed to an instance of our next example, UploadOp, where they are used to configure and start the new upload operation. First, *uriString* is parsed to create the required [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) object.\n\nNext, the properties of the provided [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) (*file*) are used by [**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140) to populate the request header and set the *SourceFile* property with the **StorageFile** object. The [**SetRequestHeader**](https://msdn.microsoft.com/library/windows/apps/br207146) method is then called to insert the file name, provided as a string, and the [**StorageFile.Name**](https://msdn.microsoft.com/library/windows/apps/br227220) property.\n\nFinally, [**BackgroundUploader**](https://msdn.microsoft.com/library/windows/apps/br207140) creates the [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) (*upload*).\n\n[!code-js[uploadFile](./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_A \"Create and initialize the upload operation\")]\n\nNote the asynchronous method calls defined using JavaScript promises. Looking at a line from the last example:\n\n```javascript\npromise = upload.startAsync().then(complete, error, progress);\n```\n\n    The async method call is followed by a then statement which indicates methods, defined by the app, that are called when a result from the async method call is returned. For more information on this programming pattern, see [Asynchronous programming in JavaScript using promises](http://msdn.microsoft.com/library/windows/apps/hh464930.aspx).\n\n### Uploading multiple files\n\n**Identify the files and destination for the upload**\n\n    In a scenario involving multiple files transferred with a single [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224), the process begins as it usually does by first providing the required destination URI and local file information. Similar to the example in the previous section, the URI is provided as a string by the end-user and [**FileOpenPicker**](https://msdn.microsoft.com/library/windows/apps/br207847) can be used to provide the ability to indicate files through the user interface as well. However, in this scenario the app should instead call the [**PickMultipleFilesAsync**](https://msdn.microsoft.com/library/windows/apps/br207851) method to enable the selection of multiple files through the UI.\n\n```javascript\nfunction uploadFiles() {\n       var filePicker = new Windows.Storage.Pickers.FileOpenPicker();\n       filePicker.fileTypeFilter.replaceAll([\"*\"]);\n\n       filePicker.pickMultipleFilesAsync().then(function (files) {\n          if (files === 0) {\n             printLog(\"No file selected\");\n                return;\n          }\n\n          var upload = new UploadOperation();\n          var uriString = document.getElementById(\"serverAddressField\").value;\n          upload.startMultipart(uriString, files);\n\n          // Persist the upload operation in the global array.\n          uploadOperations.push(upload);\n       });\n    }\n```\n\n**Create objects for the provided parameters**\n\n    The next two examples use code contained in a single example method, **startMultipart**, which was called at the end of the last step. For the purpose of instruction the code in the method that creates an array of [**BackgroundTransferContentPart**](https://msdn.microsoft.com/library/windows/apps/hh923029) objects has been split from the code that creates the resultant [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224).\n\n    First, the URI string provided by the user is initialized as a [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998). Next, the array of [**IStorageFile**](https://msdn.microsoft.com/library/windows/apps/br227102) objects (**files**) passed to this method is iterated through, each object is used to create a new [**BackgroundTransferContentPart**](https://msdn.microsoft.com/library/windows/apps/hh923029) object which is then placed in the **contentParts** array.\n\n```javascript\nupload.startMultipart = function (uriString, files) {\n        try {\n            var uri = new Windows.Foundation.Uri(uriString);\n            var uploader = new Windows.Networking.BackgroundTransfer.BackgroundUploader();\n\n            var contentParts = [];\n            files.forEach(function (file, index) {\n                var part = new Windows.Networking.BackgroundTransfer.BackgroundTransferContentPart(\"File\" + index, file.name);\n                part.setFile(file);\n                contentParts.push(part);\n            });\n```\n\n**Create and initialize the multi-part upload operation**\n\n    With our contentParts array populated with all of the [**BackgroundTransferContentPart**](https://msdn.microsoft.com/library/windows/apps/hh923029) objects representing each [**IStorageFile**](https://msdn.microsoft.com/library/windows/apps/br227102) for upload, we are ready to call [**CreateUploadAsync**](https://msdn.microsoft.com/library/windows/apps/hh923973) using the [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) to indicate where the request will be sent.\n\n```javascript\n        // Create a new upload operation.\n            uploader.createUploadAsync(uri, contentParts).then(function (uploadOperation) {\n\n               // Start the upload and persist the promise to be able to cancel the upload.\n               upload = uploadOperation;\n               promise = uploadOperation.startAsync().then(complete, error, progress);\n            });\n\n         } catch (err) {\n             displayError(err);\n         }\n     };\n```\n\n### Restarting interrupted upload operations\n\nOn completion or cancellation of an [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224), any associated system resources are released. However, if your app is terminated before either of these things can occur, any active operations are paused and the resources associated with each remain occupied. If these operations are not enumerated and re-introduced to the next app session, they will not be completed and will continue to occupy device resources.\n\n1.  Before defining the function that enumerates persisted operations, we need to create an array that will contain the [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224) objects that it will return:\n\n[!code-js[uploadFile](./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_C \"Restart interrupted upload operation\")]\n\n2.  Next we define the function that enumerates persisted operations and stores them in our array. Note that the **load** method called to re-assign callbacks to the [**UploadOperation**](https://msdn.microsoft.com/library/windows/apps/br207224), should it persist through app termination, is in the UploadOp class we define later in this section.\n\n[!code-js[uploadFile](./code/backgroundtransfer/upload_quickstart/js/main.js#Snippetupload_quickstart_D \"Enumerate persisted operations\")]\n\n## Downloading files\n\nWhen using Background Transfer, each download exists as a [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) that exposes a number of control methods used to pause, resume, restart, and cancel the operation. App events (e.g. suspension or termination) and connectivity changes are handled automatically by the system per **DownloadOperation**; downloads will continue during app suspension periods or pause and persist beyond app termination. For mobile network scenarios, setting the [**CostPolicy**](https://msdn.microsoft.com/library/windows/apps/hh701018) property will indicate whether or not your app will begin or continue downloads while a metered network is being used for Internet connectivity.\n\nIf you are downloading small resources that are likely to complete quickly, you should use [**HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) APIs instead of Background Transfer.\n\nThe following examples will walk you through the creation and initialization of a basic download, and how to enumerate and reintroduce operations persisted from a previous app session.\n\n### Configure and start a Background Transfer file download\n\nThe following example demonstrates how strings representing a URI and a file name can be used to create a [**Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) object and the [**StorageFile**](https://msdn.microsoft.com/library/windows/apps/br227171) that will contain the requested file. In this example, the new file is automatically placed in a pre-defined location. Alternatively, [**FileSavePicker**](https://msdn.microsoft.com/library/windows/apps/br207871) can be used allow users to indicate where to save the file on the device. Note that the **load** method called to re-assign callbacks to the [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154), should it persist through app termination, is in the DownloadOp class defined later in this section.\n\n[!code-js[uploadFile](./code/backgroundtransfer/download_quickstart/js/main.js#Snippetdownload_quickstart_A)]\n\nNote the asynchronous method calls defined using JavaScript promises. Looking at line 17 from the previous code example:\n\n```javascript\npromise = download.startAsync().then(complete, error, progress);\n```\n\nThe async method call is followed by a then statement which indicates methods, defined by the app, that are called when a result from the async method call is returned. For more information on this programming pattern, see [Asynchronous programming in JavaScript using promises](http://msdn.microsoft.com/library/windows/apps/hh464930.aspx).\n\n### Adding additional operation control methods\n\nThe level of control can be increased by implementing additional [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) methods. For example, adding the following code to the example above will introduce the ability to cancel the download.\n\n[!code-js[uploadFile](./code/backgroundtransfer/download_quickstart/js/main.js#Snippetdownload_quickstart_B)]\n\n### Enumerating persisted operations at start-up\n\nOn completion or cancellation of a [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154), any associated system resources are released. However, if your app is terminated before either of these events occur, downloads will pause and persist in the background. The following examples demonstrate how to re-introduce persisted downloads into a new app session.\n\n1.  Before defining the function that enumerates persisted operations, we need to create an array that will contain the [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) objects that it will return:\n\n[!code-js[uploadFile](./code/backgroundtransfer/download_quickstart/js/main.js#Snippetdownload_quickstart_D)]\n\n2.  Next we define the function that enumerates persisted operations and stores them in our array. Note that the **load** method called to re-assign callbacks for a persisted [**DownloadOperation**](https://msdn.microsoft.com/library/windows/apps/br207154) is in the DownloadOp example we define later in this section.\n\n[!code-js[uploadFile](./code/backgroundtransfer/download_quickstart/js/main.js#Snippetdownload_quickstart_E)]\n\n3.  You can now use the populated list to restart pending operations.\n\n## Post-processing\n\nA new feature in Windows 10 is the ability to run application code at the completion of a background transfer even when the app is not running. For example, your app might want to update a list of available movies after a movie has finished downloading, rather than have your app scan for new movies every time it starts. Or your app might want to handle a failed file transfer by trying again using a different server or port. Post-processing is invoked for both successful and failed transfers, so you can use it to implement custom error-handling and retry logic.\n\nPostprocessing uses the existing background task infrastructure. You create a background task and associate it with your transfers before you start the transfers. The transfers are then executed in the background, and when they are complete, your background task is called to perform post-processing.\n\nPost-processing uses a new class, [**BackgroundTransferCompletionGroup**](https://msdn.microsoft.com/library/windows/apps/dn804209). This class is similar to the existing [**BackgroundTransferGroup**](https://msdn.microsoft.com/library/windows/apps/dn279030) in that it allows you to group background transfers together, but **BackgroundTransferCompletionGroup** adds the ability to designate a background task to be run when the transfer is complete.\n\nYou initiate a background transfer with post-processing as follows.\n\n1.  Create a [**BackgroundTransferCompletionGroup**](https://msdn.microsoft.com/library/windows/apps/dn804209) object. Then, create a [**BackgroundTaskBuilder**](https://msdn.microsoft.com/library/windows/apps/br224768) object. Set the **Trigger** property of the builder object to the completion group object, and the **TaskEngtyPoint** property of the builder to the entry point of the background task that should execute on transfer completion. Finally, call the [**BackgroundTaskBuilder.Register**](https://msdn.microsoft.com/library/windows/apps/br224772) method to register your background task. Note that many completion groups can share one background task entry point, but you can have only one completion group per background task registration.\n\n   ```csharp\n    var completionGroup = new BackgroundTransferCompletionGroup();\n    BackgroundTaskBuilder builder = new BackgroundTaskBuilder();\n\n    builder.Name = \"MyDownloadProcessingTask\";\n    builder.SetTrigger(completionGroup.Trigger);\n    builder.TaskEntryPoint = \"Tasks.BackgroundDownloadProcessingTask\";\n\n    BackgroundTaskRegistration downloadProcessingTask = builder.Register();\n    ```\n\n2.  Next you associate background transfers with the completion group. Once all transfers are created, enable the completion group.\n\n   ```csharp\n    BackgroundDownloader downloader = new BackgroundDownloader(completionGroup);\n    DownloadOperation download = downloader.CreateDownload(uri, file);\n    Task<DownloadOperation> startTask = download.StartAsync().AsTask();\n\n    // App still sees the normal completion path\n    startTask.ContinueWith(ForegroundCompletionHandler);\n\n    // Do not enable the CompletionGroup until after all downloads are created.\n    downloader.CompletinGroup.Enable();\n    ```\n\n3.  The code in the background task extracts the list of operations from the trigger details, and your code can then inspect the details for each operation and perform appropriate post-processing for each operation.\n\n   ```csharp\n    public class BackgroundDownloadProcessingTask : IBackgroundTask\n    {\n      public async void Run(IBackgroundTaskInstance taskInstance)\n      {\n        var details = (BackgroundTransferCompletionGroupTriggerDetails)taskInstance.TriggerDetails;\n        IReadOnlyList<DownloadOperation> downloads = details.Downloads;\n\n        // Do post-processing on each finished operation in the list of downloads\n      }\n    }\n    ```\n\nThe post-processing task is a regular background task. It is part of the pool of all background tasks, and it is subject to the same resource management policy as all background tasks.\n\nAlso, note that post-processing does not replace foreground completion handlers. If your app defines a foreground completion handler, and your app is running when the file transfer completes, then both your foreground completion handler and your background completion handler will be called. The order in which foreground and background tasks are called is not guaranteed. If you define both, you should ensure that the two tasks will work properly and not interfere with each other if they are running concurrently.\n\n## Request timeouts\n\nThere are two primary connection timeout scenarios to take into consideration:\n\n-   When establishing a new connection for a transfer, the connection request is aborted if it is not established within five minutes.\n\n-   After a connection has been established, an HTTP request message that has not received a response within two minutes is aborted.\n\n> **Note**  In either scenario, assuming there is Internet connectivity, Background Transfer will retry a request up to three times automatically. In the event Internet connectivity is not detected, additional requests will wait until it is.\n\n## Debugging guidance\n\nStopping a debugging session in Microsoft Visual Studio is comparable to closing your app; PUT uploads are paused and POST uploads are terminated. Even while debugging, your app should enumerate and then restart or cancel any persisted uploads. For example, you can have your app cancel enumerated persisted upload operations at app startup if there is no interest in previous operations for that debug session.\n\nWhile enumerating downloads/uploads on app startup during a debug session, you can have your app cancel them if there is no interest in previous operations for that debug session. Note that if there are Visual Studio project updates, like changes to the app manifest, and the app is uninstalled and re-deployed, [**GetCurrentUploadsAsync**](https://msdn.microsoft.com/library/windows/apps/hh701149) cannot enumerate operations created using the previous app deployment.\n\nWhen using Background Transfer during development, you may get into a situation where the internal caches of active and completed transfer operations can get out of sync. This may result in the inability to start new transfer operations or interact with existing operations and [**BackgroundTransferGroup**](https://msdn.microsoft.com/library/windows/apps/dn279030) objects. In some cases, attempting to interact with existing operations may trigger a crash. This result can occur if the [**TransferBehavior**](https://msdn.microsoft.com/library/windows/apps/dn279033) property is set to **Parallel**. This issue occurs only in certain scenarios during development and is not applicable to end users of your app.\n\nFour scenarios using Visual Studio can cause this issue.\n\n-   You create a new project with the same app name as an existing project, but a different language (from C++ to C#, for example).\n-   You change the target architecture (from x86 to x64, for example) in an existing project.\n-   You change the culture (from neutral to en-US, for example) in an existing project.\n-   You add or remove a capability in the package manifest (adding **Enterprise Authentication**, for example) in an existing project.\n\nRegular app servicing, including manifest updates which add or remove capabilities, do not trigger this issue on end user deployments of your app.\nTo work around this issue, completely uninstall all versions of the app and re-deploy with the new language, architecture, culture, or capability. This can be done via the **Start** screen or using PowerShell and the **Remove-AppxPackage** cmdlet.\n\n## Exceptions in Windows.Networking.BackgroundTransfer\n\nAn exception is thrown when an invalid string for a the Uniform Resource Identifier (URI) is passed to the constructor for the [**Windows.Foundation.Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) object.\n\n**.NET:  **The [**Windows.Foundation.Uri**](https://msdn.microsoft.com/library/windows/apps/br225998) type appears as [**System.Uri**](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.aspx) in C# and VB.\n\nIn C# and Visual Basic, this error can be avoided by using the [**System.Uri**](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.aspx) class in the .NET 4.5 and one of the [**System.Uri.TryCreate**](https://msdn.microsoft.com/library/windows/apps/xaml/system.uri.trycreate.aspx) methods to test the string received from the app user before the URI is constructed.\n\nIn C++, there is no method to try and parse a string to a URI. If an app gets input from the user for the [**Windows.Foundation.Uri**](https://msdn.microsoft.com/library/windows/apps/br225998), the constructor should be in a try/catch block. If an exception is thrown, the app can notify the user and request a new hostname.\n\nThe [**Windows.Networking.backgroundTransfer**](https://msdn.microsoft.com/library/windows/apps/br207242) namespace has convenient helper methods and uses enumerations in the [**Windows.Networking.Sockets**](https://msdn.microsoft.com/library/windows/apps/br226960) namespace for handling errors. This can be useful for handling specific network exceptions differently in your app.\n\nAn error encountered on an asynchronous method in the [**Windows.Networking.backgroundTransfer**](https://msdn.microsoft.com/library/windows/apps/br207242) namespace is returned as an **HRESULT** value. The [**BackgroundTransferError.GetStatus**](https://msdn.microsoft.com/library/windows/apps/hh701093) method is used to convert a network error from a background transfer operation to a [**WebErrorStatus**](https://msdn.microsoft.com/library/windows/apps/hh747818) enumeration value. Most of the **WebErrorStatus** enumeration values correspond to an error returned by the native HTTP or FTP client operation. An app can filter on specific **WebErrorStatus** enumeration values to modify app behavior depending on the cause of the exception.\n\nFor parameter validation errors, an app can also use the **HRESULT** from the exception to learn more detailed information on the error that caused the exception. Possible **HRESULT** values are listed in the *Winerror.h* header file. For most parameter validation errors, the **HRESULT** returned is **E\\_INVALIDARG**.\n\n"}