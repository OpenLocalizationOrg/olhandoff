{"nodes":[{"content":"You can define custom panels for XAML layout by deriving a custom class from the Panel class.","pos":[33,126]},{"content":"XAML custom panels overview","pos":[283,310]},{"content":"XAML custom panels overview","pos":[423,450]},{"content":"A <bpt id=\"p1\">*</bpt>panel<ept id=\"p1\">*</ept> is an object that provides a layout behavior for child elements it contains, when the Extensible Application Markup Language (XAML) layout system runs and your app UI is rendered.","pos":[452,641]},{"content":"You can define custom panels for XAML layout by deriving a custom class from the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> class.","pos":[642,799]},{"content":"You provide behavior for your panel by overriding the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ArrangeOverride<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept>, supplying logic that measures and arranges the child elements.","pos":[800,1081]},{"pos":[1086,1110],"content":"The <bpt id=\"p1\">**</bpt>Panel<ept id=\"p1\">**</ept> base class"},{"content":"To define a custom panel class, you can either derive from the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> class directly, or derive from one of the practical panel classes that aren't sealed, such as <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Grid<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242704)</ept> or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StackPanel<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br209635)</ept>.","pos":[1113,1487]},{"content":"It's easier to derive from <bpt id=\"p1\">**</bpt>Panel<ept id=\"p1\">**</ept>, because it can be difficult to work around the existing layout logic of a panel that already has layout behavior.","pos":[1488,1639]},{"content":"Also, a panel with behavior might have existing properties that aren't relevant for your panel's layout features.","pos":[1640,1753]},{"pos":[1755,1869],"content":"From <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept>, your custom panel inherits these APIs:"},{"pos":[1875,1961],"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Children<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> property."},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Background<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227512)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ChildrenTransitions<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227515)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>IsItemsHost<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br227517)</ept> properties, and the dependency property identifiers.","pos":[1966,2262]},{"content":"None of these properties are virtual, so you don't typically override or replace them.","pos":[2263,2349]},{"content":"You don't typically need these properties for custom panel scenarios, not even for reading values.","pos":[2350,2448]},{"content":"The layout override methods <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ArrangeOverride<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept>.","pos":[2453,2645]},{"content":"These were originally defined by <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FrameworkElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept>.","pos":[2646,2760]},{"content":"The base <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> class doesn't override these, but practical panels like <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Grid<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242704)</ept> do have override implementations that are implemented as native code and are run by the system.","pos":[2761,3060]},{"content":"Providing new (or additive) implementations for <bpt id=\"p1\">**</bpt>ArrangeOverride<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept> is the bulk of the effort you need to define a custom panel.","pos":[3061,3213]},{"content":"All the other APIs of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FrameworkElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>UIElement<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>DependencyObject<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>, such as <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>Height<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br208718)</ept>, <bpt id=\"p9\">[</bpt><bpt id=\"p10\">**</bpt>Visibility<ept id=\"p10\">**</ept><ept id=\"p9\">](https://msdn.microsoft.com/library/windows/apps/br208992)</ept> and so on.","pos":[3218,3647]},{"content":"You sometimes reference values of these properties in your layout overrides, but they aren't virtual so you don't typically override or replace them.","pos":[3648,3797]},{"content":"This focus here is to describe XAML layout concepts, so you can consider all the possibilities for how a custom panel can and should behave in layout.","pos":[3799,3949]},{"content":"If you'd rather jump right in and see an example custom panel implementation, see <bpt id=\"p1\">[</bpt>BoxPanel, an example custom panel<ept id=\"p1\">](boxpanel-example-custom-panel.md)</ept>.","pos":[3950,4102]},{"pos":[4107,4132],"content":"The <bpt id=\"p1\">**</bpt>Children<ept id=\"p1\">**</ept> property"},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Children<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> property is relevant to a custom panel because all classes derived from <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Panel<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> use the <bpt id=\"p5\">**</bpt>Children<ept id=\"p5\">**</ept> property as the place to store their contained child elements in a collection.","pos":[4135,4453]},{"content":"<bpt id=\"p1\">**</bpt>Children<ept id=\"p1\">**</ept> is designated as the XAML content property for the <bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept> class, and all classes derived from <bpt id=\"p3\">**</bpt>Panel<ept id=\"p3\">**</ept> can inherit the XAML content property behavior.","pos":[4454,4621]},{"content":"If a property is designated the XAML content property, that means that XAML markup can omit a property element when specifying that property in markup, and the values are set as immediate markup children (the \"content\").","pos":[4622,4842]},{"content":"For example, if you derive a class named <bpt id=\"p1\">**</bpt>CustomPanel<ept id=\"p1\">**</ept> from <bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept> that defines no new behavior, you can still use this markup:","pos":[4843,4975]},{"content":"When a XAML parser reads this markup, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Children<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> is known to be the XAML content property for all <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Panel<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> derived types, so the parser will add the two <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Button<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> elements to the <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>UIElementCollection<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br227633)</ept> value of the <bpt id=\"p9\">**</bpt>Children<ept id=\"p9\">**</ept> property.","pos":[5085,5567]},{"content":"The XAML content property facilitates a streamlined parent-child relationship in the XAML markup for a UI definition.","pos":[5568,5685]},{"content":"For more info about XAML content properties, and how collection properties are populated when XAML is parsed, see the <bpt id=\"p1\">[</bpt>XAML syntax guide<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt185596)</ept>.","pos":[5686,5882]},{"content":"The collection type that's maintaining the value of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Children<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> property is the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>UIElementCollection<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227633)</ept> class.","pos":[5884,6119]},{"content":"<bpt id=\"p1\">**</bpt>UIElementCollection<ept id=\"p1\">**</ept> is a strongly typed collection that uses <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>UIElement<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> as its enforced item type.","pos":[6120,6285]},{"content":"<bpt id=\"p1\">**</bpt>UIElement<ept id=\"p1\">**</ept> is a base type that's inherited by hundreds of practical UI element types, so the type enforcement here is deliberately loose.","pos":[6286,6426]},{"content":"But it does enforce that you couldn't have a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Brush<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br228076)</ept> as a direct child of a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Panel<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept>, and it generally means that only elements that are expected to be visible in UI and participate in layout will be found as child elements in a <bpt id=\"p5\">**</bpt>Panel<ept id=\"p5\">**</ept>.","pos":[6427,6789]},{"content":"Typically, a custom panel accepts any <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> child element by a XAML definition, by simply using the characteristics of the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Children<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> property as-is.","pos":[6791,7070]},{"content":"As an advanced scenario, you could support further type checking of child elements, when you iterate over the collection in your layout overrides.","pos":[7071,7217]},{"content":"Besides looping through the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Children<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> collection in the overrides, your panel logic might also be influenced by <ph id=\"ph1\">`Children.Count`</ph>.","pos":[7219,7411]},{"content":"You might have logic that is allocating space at least partly based on the number of items, rather than desired sizes and the other characteristics of individual items.","pos":[7412,7580]},{"content":"Overriding the layout methods","pos":[7585,7614]},{"content":"The basic model for the layout override methods (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ArrangeOverride<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept>) is that they should iterate through all the children and call each child element's specific layout method.","pos":[7617,7937]},{"content":"The first layout cycle starts when the XAML layout system sets the visual for the root window.","pos":[7938,8032]},{"content":"Because each parent invokes layout on its children, this propagates a call to layout methods to every possible UI element that is supposed to be part of a layout.","pos":[8033,8195]},{"content":"In XAML layout, there are two stages: measure, then arrange.","pos":[8196,8256]},{"content":"You don't get any built-in layout method behavior for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ArrangeOverride<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> from the base <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Panel<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> class.","pos":[8258,8566]},{"content":"Items in <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Children<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> won't automatically render as part of the XAML visual tree.","pos":[8567,8708]},{"content":"It is up to you to make the items known to the layout process, by invoking layout methods on each of the items you find in <bpt id=\"p1\">**</bpt>Children<ept id=\"p1\">**</ept> through a layout pass within your <bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>ArrangeOverride<ept id=\"p3\">**</ept> implementations.","pos":[8709,8939]},{"content":"There's no reason to call base implementations in layout overrides unless you have your own inheritance.","pos":[8941,9045]},{"content":"The native methods for layout behavior (if they exist) run regardless, and not calling base implementation from overrides won't prevent the native behavior from happening.","pos":[9046,9217]},{"content":"During the measure pass, your layout logic queries each child element for its desired size, by calling the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Measure<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> method on that child element.","pos":[9219,9427]},{"content":"Calling the <bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept> method establishes the value for the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DesiredSize<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> property.","pos":[9428,9574]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> return value is the desired size for the panel itself.","pos":[9575,9713]},{"content":"During the arrange pass, the positions and sizes of child elements are determined in x-y space and the layout composition is prepared for rendering.","pos":[9715,9863]},{"content":"Your code must call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Arrange<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> on each child element in <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Children<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> so that the layout system detects that the element belongs in the layout.","pos":[9864,10127]},{"content":"The <bpt id=\"p1\">**</bpt>Arrange<ept id=\"p1\">**</ept> call is a precursor to composition and rendering; it informs the layout system where that element goes, when the composition is submitted for rendering.","pos":[10128,10296]},{"content":"Many properties and values contribute to how the layout logic will work at runtime.","pos":[10298,10381]},{"content":"A way to think about the layout process is that the elements with no children (generally the most deeply nested element in the UI) are the ones that can finalize measurements first.","pos":[10382,10563]},{"content":"They don't have any dependencies on child elements that influence their desired size.","pos":[10564,10649]},{"content":"They might have their own desired sizes, and these are size suggestions until the layout actually takes place.","pos":[10650,10760]},{"content":"Then, the measure pass continues walking up the visual tree until the root element has its measurements and all the measurements can be finalized.","pos":[10761,10907]},{"content":"The candidate layout must fit within the current app window or else parts of the UI will be clipped.","pos":[10909,11009]},{"content":"Panels often are the place where the clipping logic is determined.","pos":[11010,11076]},{"content":"Panel logic can determine what size is available from within the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> implementation, and may have to push the size restrictions onto the children and divide space amongst children so that everything fits as best it can.","pos":[11077,11372]},{"content":"The result of layout is ideally something that uses various properties of all parts of the layout but still fits within the app window.","pos":[11373,11508]},{"content":"That requires both a good implementation for layout logic of the panels, and also a judicious UI design on the part of any app code that builds a UI using that panel.","pos":[11509,11675]},{"content":"No panel design is going to look good if the overall UI design includes more child elements than can possibly fit in the app.","pos":[11676,11801]},{"content":"A large part of what makes the layout system work is that any element that's based on <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FrameworkElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept> already has some of its own inherent behavior when acting as a child in a container.","pos":[11803,12054]},{"content":"For example, there are several APIs of <bpt id=\"p1\">**</bpt>FrameworkElement<ept id=\"p1\">**</ept> that either inform layout behavior or are needed to make layout work at all.","pos":[12055,12191]},{"content":"These include:","pos":[12192,12206]},{"pos":[12212,12383],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> (actually a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>UIElement<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> property)"},{"pos":[12388,12544],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ActualHeight<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208707)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ActualWidth<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208709)</ept>"},{"pos":[12549,12693],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Height<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208718)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Width<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept>"},{"content":"Margin","pos":[12701,12707]},{"pos":[12773,12856],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>LayoutUpdated<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208722)</ept> event"},{"pos":[12861,13030],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>HorizontalAlignment<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208720)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>VerticalAlignment<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208749)</ept>"},{"pos":[13035,13206],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ArrangeOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>MeasureOverride<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> methods"},{"pos":[13211,13549],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Arrange<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Measure<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> methods: these have native implementations defined at the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>FrameworkElement<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept> level, which handle the element-level layout action"},{"content":"MeasureOverride","pos":[13556,13571]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> method has a return value that's used by the layout system as the starting <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DesiredSize<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> for the panel itself, when the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Measure<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> method is called on the panel by its parent in layout.","pos":[13576,13968]},{"content":"The logic choices within the method are just as important as what it returns, and the logic often influences what value is returned.","pos":[13969,14101]},{"content":"All <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> implementations should loop through <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Children<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>, and call the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Measure<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> method on each child element.","pos":[14103,14411]},{"content":"Calling the <bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept> method establishes the value for the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DesiredSize<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> property.","pos":[14412,14558]},{"content":"This might inform how much space the panel itself needs, as well as how that space is divided among elements or sized for a particular child element.","pos":[14559,14708]},{"pos":[14710,14831],"content":"Here's a very basic skeleton of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> method:"},{"content":"Elements often have a natural size by the time they're ready for layout.","pos":[15485,15557]},{"content":"After the measure pass, the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> might indicate that natural size, if the <bpt id=\"p3\">*</bpt>availableSize<ept id=\"p3\">*</ept> you passed for <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>Measure<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> was smaller.","pos":[15558,15818]},{"content":"If the natural size is larger than <bpt id=\"p1\">*</bpt>availableSize<ept id=\"p1\">*</ept> you passed for <bpt id=\"p2\">**</bpt>Measure<ept id=\"p2\">**</ept>, the <bpt id=\"p3\">**</bpt>DesiredSize<ept id=\"p3\">**</ept> is constrained to <bpt id=\"p4\">*</bpt>availableSize<ept id=\"p4\">*</ept>.","pos":[15819,15952]},{"content":"That's how <bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept>'s internal implementation behaves, and your layout overrides should take that behavior into account.","pos":[15953,16076]},{"content":"Some elements don't have a natural size because they have <bpt id=\"p1\">**</bpt>Auto<ept id=\"p1\">**</ept> values for <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Height<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208718)</ept> and <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>Width<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept>.","pos":[16078,16301]},{"content":"These elements use the full <bpt id=\"p1\">*</bpt>availableSize<ept id=\"p1\">*</ept>, because that's what an <bpt id=\"p2\">**</bpt>Auto<ept id=\"p2\">**</ept> value represents: size the element to the maximum available size, which the immediate layout parent communicates by calling <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Measure<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> with <bpt id=\"p5\">*</bpt>availableSize<ept id=\"p5\">*</ept>.","pos":[16302,16596]},{"content":"In practice, there's always some measurement that a UI is sized to (even if that's the top level window.) Eventually, the measure pass resolves all the <bpt id=\"p1\">**</bpt>Auto<ept id=\"p1\">**</ept> values to parent constraints and all <bpt id=\"p2\">**</bpt>Auto<ept id=\"p2\">**</ept> value elements get real measurements (which you can get by checking <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ActualWidth<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208709)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ActualHeight<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208707)</ept>, after layout completes).","pos":[16597,17054]},{"content":"It's legal to pass a size to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Measure<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> that has at least one infinite dimension, to indicate that the panel can attempt to size itself to fit measurements of its content.","pos":[17056,17288]},{"content":"Each child element being measured sets its <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> value using its natural size.","pos":[17289,17437]},{"content":"Then, during the arrange pass, the panel typically arranges using that size.","pos":[17438,17514]},{"content":"Text elements such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TextBlock<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209652)</ept> have a calculated <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ActualWidth<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208709)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ActualHeight<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208707)</ept> based on their text string and text properties even if no <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>Height<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br208718)</ept> or <bpt id=\"p9\">[</bpt><bpt id=\"p10\">**</bpt>Width<ept id=\"p10\">**</ept><ept id=\"p9\">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept> value is set, and these dimensions should be respected by your panel logic.","pos":[17516,18064]},{"content":"Clipping text is a particularly bad UI experience.","pos":[18065,18115]},{"content":"Even if your implementation doesn't use the desired size measurements, it's best to call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Measure<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> method on each child element, because there are internal and native behaviors that are triggered by <bpt id=\"p3\">**</bpt>Measure<ept id=\"p3\">**</ept> being called.","pos":[18117,18407]},{"content":"For an element to participate in layout, each child element must have <bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept> called on it during the measure pass and the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Arrange<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> method called on it during the arrange pass.","pos":[18408,18651]},{"content":"Calling these methods sets internal flags on the object and populates values (such as the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> property) that the system's layout logic needs when it builds the visual tree and renders the UI.","pos":[18652,18915]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> return value is based on the panel's logic interpreting the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DesiredSize<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> or other size considerations for each of the child elements in <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Children<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> when <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>Measure<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> is called on them.","pos":[18917,19368]},{"content":"What to do with <bpt id=\"p1\">**</bpt>DesiredSize<ept id=\"p1\">**</ept> values from children and how the <bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept> return value should use them is up to your own logic's interpretation.","pos":[19369,19524]},{"content":"You don't typically add up the values without modification, because the input of <bpt id=\"p1\">**</bpt>MeasureOverride<ept id=\"p1\">**</ept> is often a fixed available size that's being suggested by the panel's parent.","pos":[19525,19703]},{"content":"If you exceed that size, the panel itself might get clipped.","pos":[19704,19764]},{"content":"You'd typically compare the total size of children to the panel's available size and make adjustments if necessary.","pos":[19765,19880]},{"content":"Tips and guidance","pos":[19886,19903]},{"content":"Ideally, a custom panel should be suitable for being the first true visual in a UI composition, perhaps at a level immediately under <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Page<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227503)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>UserControl<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227647)</ept> or another element that is the XAML page root.","pos":[19909,20234]},{"content":"In <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> implementations, don't routinely return the input <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Size<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> without examining the values.","pos":[20235,20466]},{"content":"If the return <bpt id=\"p1\">**</bpt>Size<ept id=\"p1\">**</ept> has an <bpt id=\"p2\">**</bpt>Infinity<ept id=\"p2\">**</ept> value in it, this can throw exceptions in runtime layout logic.","pos":[20467,20573]},{"content":"An <bpt id=\"p1\">**</bpt>Infinity<ept id=\"p1\">**</ept> value can come from the main app window, which is scrollable and therefore doesn't have a maximum height.","pos":[20574,20695]},{"content":"Other scrollable content might have the same behavior.","pos":[20696,20750]},{"content":"Another common mistake in <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> implementations is to return a new default <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Size<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> (values for height and width are 0).","pos":[20755,21009]},{"content":"You might start with that value, and it might even be the correct value if your panel determines that none of the children should be rendered.","pos":[21010,21152]},{"content":"But, a default <bpt id=\"p1\">**</bpt>Size<ept id=\"p1\">**</ept> results in your panel not being sized correctly by its host.","pos":[21153,21237]},{"content":"It requests no space in the UI, and therefore gets no space and doesn't render.","pos":[21238,21317]},{"content":"All your panel code otherwise might be functioning fine, but you still won't see your panel or contents thereof if it's being composed with zero height, zero width.","pos":[21318,21482]},{"content":"Within the overrides, avoid the temptation to cast child elements to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FrameworkElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept> and use properties that are calculated as a result of layout, particularly <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ActualWidth<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208709)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ActualHeight<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208707)</ept>.","pos":[21487,21869]},{"content":"For most common scenarios, you can base the logic on the child's <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> value and you won't need any of the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Height<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208718)</ept> or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Width<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept> related properties of a child element.","pos":[21870,22229]},{"content":"For specialized cases, where you know the type of element and have additional information, for example the natural size of an image file, you can use your element's specialized information because it's not a value that is actively being altered by layout systems.","pos":[22230,22493]},{"content":"Including layout-calculated properties as part of layout logic substantially increases the risk of defining an unintentional layout loop.","pos":[22494,22631]},{"content":"These loops cause a condition where a valid layout can't be created and the system can throw a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>LayoutCycleException<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh673799)</ept> if the loop is not recoverable.","pos":[22632,22843]},{"content":"Panels typically divide their available space between multiple child elements, although exactly how space is divided varies.","pos":[22848,22972]},{"content":"For example, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Grid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242704)</ept> implements layout logic that uses its <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>RowDefinition<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227606)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ColumnDefinition<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br209324)</ept> values to divide the space into the <bpt id=\"p7\">**</bpt>Grid<ept id=\"p7\">**</ept> cells, supporting both star-sizing and pixel values.","pos":[22973,23353]},{"content":"If they're pixel values, the size available for each child is already known, so that's what is passed as input size for a grid-style <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Measure<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept>.","pos":[23354,23559]},{"content":"Panels themselves can introduce reserved space for padding between items.","pos":[23564,23637]},{"content":"If you do this, make sure to expose the measurements as a property that's distinct from <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Margin<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208724)</ept> or any <bpt id=\"p3\">**</bpt>Padding<ept id=\"p3\">**</ept> property.","pos":[23638,23825]},{"content":"Elements might have values for their <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ActualWidth<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208709)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ActualHeight<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208707)</ept> properties based on a previous layout pass.","pos":[23830,24067]},{"content":"If values change, app UI code can put handlers for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>LayoutUpdated<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208722)</ept> on elements if there's special logic to run, but panel logic typically doesn't need to check for changes with event handling.","pos":[24068,24322]},{"content":"The layout system is already making the determinations of when to re-run layout because a layout-relevant property changed value, and a panel's <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MeasureOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ArrangeOverride<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> are called automatically in the appropriate circumstances.","pos":[24323,24688]},{"content":"ArrangeOverride","pos":[24695,24710]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ArrangeOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> method has a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Size<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> return value that's used by the layout system when rendering the panel itself, when the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Arrange<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> method is called on the panel by its parent in layout.","pos":[24715,25095]},{"content":"It's typical that the input <bpt id=\"p1\">*</bpt>finalSize<ept id=\"p1\">*</ept> and the <bpt id=\"p2\">**</bpt>ArrangeOverride<ept id=\"p2\">**</ept> returned <bpt id=\"p3\">**</bpt>Size<ept id=\"p3\">**</ept> are the same.","pos":[25096,25195]},{"content":"If they aren't, that means the panel is attempting to make itself a different size than what the other participants in layout claim is available.","pos":[25196,25341]},{"content":"The final size was based on having previously run the measure pass of layout through your panel code, so that's why returning a different size isn't typical: it means you are deliberately ignoring measure logic.","pos":[25342,25553]},{"content":"Don't return a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Size<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> with an <bpt id=\"p3\">**</bpt>Infinity<ept id=\"p3\">**</ept> component.","pos":[25555,25670]},{"content":"Trying to use such a <bpt id=\"p1\">**</bpt>Size<ept id=\"p1\">**</ept> throws an exception from internal layout.","pos":[25671,25742]},{"content":"All <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ArrangeOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> implementations should loop through <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Children<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>, and call the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Arrange<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> method on each child element.","pos":[25744,26052]},{"content":"Like <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Measure<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept>, <bpt id=\"p3\">**</bpt>Arrange<ept id=\"p3\">**</ept> doesn't have a return value.","pos":[26053,26171]},{"content":"Unlike <bpt id=\"p1\">**</bpt>Measure<ept id=\"p1\">**</ept>, no calculated property gets set as a result (however, the element in question typically fires a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>LayoutUpdated<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208722)</ept> event).","pos":[26172,26373]},{"pos":[26375,26497],"content":"Here's a very basic skeleton of an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ArrangeOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> method:"},{"content":"The arrange pass of layout might happen without being preceded by a measure pass.","pos":[27031,27112]},{"content":"However, this only happens when the layout system has determined no properties have changed that would have affected the previous measurements.","pos":[27113,27256]},{"content":"For example, if an alignment changes, there's no need to re-measure that particular element because its <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> would not change when its alignment choice changes.","pos":[27257,27488]},{"content":"On the other hand, if <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ActualHeight<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208707)</ept> changes on any element in a layout, a new measure pass is needed.","pos":[27489,27653]},{"content":"The layout system automatically detects true measure changes and invokes the measure pass again, and then runs another arrange pass.","pos":[27654,27786]},{"content":"The input for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Arrange<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> takes a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Rect<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br225994)</ept> value.","pos":[27788,27957]},{"content":"The most common way to construct this <bpt id=\"p1\">**</bpt>Rect<ept id=\"p1\">**</ept> is to use the constructor that has a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Point<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br225870)</ept> input and a <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>Size<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> input.","pos":[27958,28199]},{"content":"The <bpt id=\"p1\">**</bpt>Point<ept id=\"p1\">**</ept> is the point where the top left corner of the bounding box for the element should be placed.","pos":[28200,28306]},{"content":"The <bpt id=\"p1\">**</bpt>Size<ept id=\"p1\">**</ept> is the dimensions used to render that particular element.","pos":[28307,28377]},{"content":"You often use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DesiredSize<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> for that element as this <bpt id=\"p3\">**</bpt>Size<ept id=\"p3\">**</ept> value, because establishing the <bpt id=\"p4\">**</bpt>DesiredSize<ept id=\"p4\">**</ept> for all elements involved in layout was the purpose of the measure pass of layout.","pos":[28378,28636]},{"content":"(The measure pass determines all-up sizing of the elements in an iterative way so that the layout system can optimize how elements are placed once it gets to the arrange pass.)","pos":[28637,28813]},{"content":"What typically varies between <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ArrangeOverride<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> implementations is the logic by which the panel determines the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Point<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br225870)</ept> component of how it arranges each child.","pos":[28815,29098]},{"content":"An absolute positioning panel such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Canvas<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> uses the explicit placement info that it gets from each element through <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Canvas.Left<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh759771)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Canvas.Top<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh759772)</ept> values.","pos":[29099,29442]},{"content":"A space-dividing panel such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Grid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242704)</ept> would have mathematical operations that divided the available space into cells and each cell would have an x-y value for where its content should be placed and arranged.","pos":[29443,29712]},{"content":"An adaptive panel such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StackPanel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209635)</ept> might be expanding itself to fit content in its orientation dimension.","pos":[29713,29884]},{"content":"There are still additional positioning influences on elements in layout, beyond what you directly control and pass to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Arrange<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept>.","pos":[29886,30076]},{"content":"These come from the internal native implementation of <bpt id=\"p1\">**</bpt>Arrange<ept id=\"p1\">**</ept> that's common to all <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>FrameworkElement<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept> derived types and augmented by some other types such as text elements.","pos":[30077,30315]},{"content":"For example, elements can have margin and alignment, and some can have padding.","pos":[30316,30395]},{"content":"These properties often interact.","pos":[30396,30428]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Alignment, margin, and padding<ept id=\"p1\">](alignment-margin-padding.md)</ept>.","pos":[30429,30510]},{"content":"Panels and controls","pos":[30515,30534]},{"content":"Avoid putting functionality into a custom panel that should instead be built as a custom control.","pos":[30537,30634]},{"content":"The role of a panel is to present any child element content that exists within it, as a function of layout that happens automatically.","pos":[30635,30769]},{"content":"The panel might add decorations to content (similar to how a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Border<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209250)</ept> adds the border around the element it presents), or perform other layout-related adjustments like padding.","pos":[30770,31008]},{"content":"But that's about as far as you should go when extending the visual tree output beyond reporting and using information from the children.","pos":[31009,31145]},{"content":"If there's any interaction that's accessible to the user, you should write a custom control, not a panel.","pos":[31147,31252]},{"content":"For example, a panel shouldn't add scrolling viewports to content it presents, even if the goal is to prevent clipping, because the scrollbars, thumbs and so on are interactive control parts.","pos":[31253,31444]},{"content":"(Content might have scrollbars after all, but you should leave that up to the child's logic.","pos":[31445,31537]},{"content":"Don't force it by adding scrolling as a layout operation.) You might create a control and also write a custom panel that plays an important role in that control's visual tree, when it comes to presenting content in that control.","pos":[31538,31766]},{"content":"But the control and the panel should be distinct code objects.","pos":[31767,31829]},{"content":"One reason the distinction between control and panel is important is because of Microsoft UI Automation and accessibility.","pos":[31831,31953]},{"content":"Panels provide a visual layout behavior, not a logical behavior.","pos":[31954,32018]},{"content":"How a UI element appears visually is not an aspect of UI that is typically important to accessibility scenarios.","pos":[32019,32131]},{"content":"Accessibility is about exposing the parts of an app that are logically important to understanding a UI.","pos":[32132,32235]},{"content":"When interaction is required, controls should expose the interaction possibilities to the UI Automation infrastructure.","pos":[32236,32355]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Custom automation peers<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt297667)</ept>.","pos":[32356,32459]},{"content":"Other layout API","pos":[32464,32480]},{"content":"There are some other APIs that are part of the layout system, but aren't declared by <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Panel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept>.","pos":[32483,32638]},{"content":"You might use these in a panel implementation or in a custom control that uses panels.","pos":[32639,32725]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UpdateLayout<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208989)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>InvalidateMeasure<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208930)</ept>, and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>InvalidateArrange<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208929)</ept> are methods that initiate a layout pass.","pos":[32731,33018]},{"content":"<bpt id=\"p1\">**</bpt>InvalidateArrange<ept id=\"p1\">**</ept> might not trigger a measure pass, but the other two do.","pos":[33019,33096]},{"content":"Never call these methods from within a layout method override, because they're almost sure to cause a layout loop.","pos":[33097,33211]},{"content":"Control code doesn't typically need to call them either.","pos":[33212,33268]},{"content":"Most aspects of layout are triggered automatically by detecting changes to the framework-defined layout properties such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Width<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept> and so on.","pos":[33269,33472]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>LayoutUpdated<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208722)</ept> is an event that fires when some aspect of layout of the element has changed.","pos":[33477,33632]},{"content":"This isn't specific to panels; the event is defined by <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FrameworkElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept>.","pos":[33633,33769]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SizeChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208742)</ept> is an event that fires only after layout passes are finalized, and indicates that <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ActualHeight<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208707)</ept> or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ActualWidth<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208709)</ept> have changed as a result.","pos":[33774,34113]},{"content":"This is another <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FrameworkElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept> event.","pos":[34114,34217]},{"content":"There are cases where <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>LayoutUpdated<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208722)</ept> fires, but <bpt id=\"p3\">**</bpt>SizeChanged<ept id=\"p3\">**</ept> does not.","pos":[34218,34354]},{"content":"For example the internal contents might be rearranged, but the element's size didn't change.","pos":[34355,34447]},{"content":"Related topics","pos":[34453,34467]},{"content":"Reference","pos":[34471,34480]},{"content":"FrameworkElement.ArrangeOverride","pos":[34487,34519]},{"content":"FrameworkElement.MeasureOverride","pos":[34585,34617]},{"content":"Panel","pos":[34683,34688]},{"content":"Concepts","pos":[34753,34761]},{"content":"Alignment, margin, and padding","pos":[34766,34796]}],"content":"---\nauthor: Jwmsft\nDescription: 'You can define custom panels for XAML layout by deriving a custom class from the Panel class.'\nMS-HAID: 'dev\\_ctrl\\_layout\\_txt.xaml\\_custom\\_panels\\_overview'\nMSHAttr: 'PreferredLib:/library/windows/apps'\nSearch.Product: eADQiWindows 10XVcnh\ntitle: XAML custom panels overview\nms.assetid: 0CD395CD-E2AB-429D-BB49-56A71C5CC35D\nlabel: XAML custom panels overview\ntemplate: detail.hbs\n---\n\n# XAML custom panels overview\n\nA *panel* is an object that provides a layout behavior for child elements it contains, when the Extensible Application Markup Language (XAML) layout system runs and your app UI is rendered. You can define custom panels for XAML layout by deriving a custom class from the [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class. You provide behavior for your panel by overriding the [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) and [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711), supplying logic that measures and arranges the child elements.\n\n## The **Panel** base class\n\n\nTo define a custom panel class, you can either derive from the [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class directly, or derive from one of the practical panel classes that aren't sealed, such as [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) or [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635). It's easier to derive from **Panel**, because it can be difficult to work around the existing layout logic of a panel that already has layout behavior. Also, a panel with behavior might have existing properties that aren't relevant for your panel's layout features.\n\nFrom [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511), your custom panel inherits these APIs:\n\n-   The [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property.\n-   The [**Background**](https://msdn.microsoft.com/library/windows/apps/br227512), [**ChildrenTransitions**](https://msdn.microsoft.com/library/windows/apps/br227515) and [**IsItemsHost**](https://msdn.microsoft.com/library/windows/apps/br227517) properties, and the dependency property identifiers. None of these properties are virtual, so you don't typically override or replace them. You don't typically need these properties for custom panel scenarios, not even for reading values.\n-   The layout override methods [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) and [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711). These were originally defined by [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706). The base [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class doesn't override these, but practical panels like [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) do have override implementations that are implemented as native code and are run by the system. Providing new (or additive) implementations for **ArrangeOverride** and **MeasureOverride** is the bulk of the effort you need to define a custom panel.\n-   All the other APIs of [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706), [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) and [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356), such as [**Height**](https://msdn.microsoft.com/library/windows/apps/br208718), [**Visibility**](https://msdn.microsoft.com/library/windows/apps/br208992) and so on. You sometimes reference values of these properties in your layout overrides, but they aren't virtual so you don't typically override or replace them.\n\nThis focus here is to describe XAML layout concepts, so you can consider all the possibilities for how a custom panel can and should behave in layout. If you'd rather jump right in and see an example custom panel implementation, see [BoxPanel, an example custom panel](boxpanel-example-custom-panel.md).\n\n## The **Children** property\n\n\nThe [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property is relevant to a custom panel because all classes derived from [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) use the **Children** property as the place to store their contained child elements in a collection. **Children** is designated as the XAML content property for the **Panel** class, and all classes derived from **Panel** can inherit the XAML content property behavior. If a property is designated the XAML content property, that means that XAML markup can omit a property element when specifying that property in markup, and the values are set as immediate markup children (the \"content\"). For example, if you derive a class named **CustomPanel** from **Panel** that defines no new behavior, you can still use this markup:\n\n```XAML\n<local:CustomPanel>\n  <Button Name=\"button1\"/>\n  <Button Name=\"button2\"/>\n</local:CustomPanel>\n```\n\nWhen a XAML parser reads this markup, [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) is known to be the XAML content property for all [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) derived types, so the parser will add the two [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) elements to the [**UIElementCollection**](https://msdn.microsoft.com/library/windows/apps/br227633) value of the **Children** property. The XAML content property facilitates a streamlined parent-child relationship in the XAML markup for a UI definition. For more info about XAML content properties, and how collection properties are populated when XAML is parsed, see the [XAML syntax guide](https://msdn.microsoft.com/library/windows/apps/mt185596).\n\nThe collection type that's maintaining the value of the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property is the [**UIElementCollection**](https://msdn.microsoft.com/library/windows/apps/br227633) class. **UIElementCollection** is a strongly typed collection that uses [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) as its enforced item type. **UIElement** is a base type that's inherited by hundreds of practical UI element types, so the type enforcement here is deliberately loose. But it does enforce that you couldn't have a [**Brush**](https://msdn.microsoft.com/library/windows/apps/br228076) as a direct child of a [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511), and it generally means that only elements that are expected to be visible in UI and participate in layout will be found as child elements in a **Panel**.\n\nTypically, a custom panel accepts any [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) child element by a XAML definition, by simply using the characteristics of the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) property as-is. As an advanced scenario, you could support further type checking of child elements, when you iterate over the collection in your layout overrides.\n\nBesides looping through the [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) collection in the overrides, your panel logic might also be influenced by `Children.Count`. You might have logic that is allocating space at least partly based on the number of items, rather than desired sizes and the other characteristics of individual items.\n\n## Overriding the layout methods\n\n\nThe basic model for the layout override methods ([**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) and [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711)) is that they should iterate through all the children and call each child element's specific layout method. The first layout cycle starts when the XAML layout system sets the visual for the root window. Because each parent invokes layout on its children, this propagates a call to layout methods to every possible UI element that is supposed to be part of a layout. In XAML layout, there are two stages: measure, then arrange.\n\nYou don't get any built-in layout method behavior for [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) and [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) from the base [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511) class. Items in [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) won't automatically render as part of the XAML visual tree. It is up to you to make the items known to the layout process, by invoking layout methods on each of the items you find in **Children** through a layout pass within your **MeasureOverride** and **ArrangeOverride** implementations.\n\nThere's no reason to call base implementations in layout overrides unless you have your own inheritance. The native methods for layout behavior (if they exist) run regardless, and not calling base implementation from overrides won't prevent the native behavior from happening.\n\nDuring the measure pass, your layout logic queries each child element for its desired size, by calling the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method on that child element. Calling the **Measure** method establishes the value for the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) property. The [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) return value is the desired size for the panel itself.\n\nDuring the arrange pass, the positions and sizes of child elements are determined in x-y space and the layout composition is prepared for rendering. Your code must call [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) on each child element in [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) so that the layout system detects that the element belongs in the layout. The **Arrange** call is a precursor to composition and rendering; it informs the layout system where that element goes, when the composition is submitted for rendering.\n\nMany properties and values contribute to how the layout logic will work at runtime. A way to think about the layout process is that the elements with no children (generally the most deeply nested element in the UI) are the ones that can finalize measurements first. They don't have any dependencies on child elements that influence their desired size. They might have their own desired sizes, and these are size suggestions until the layout actually takes place. Then, the measure pass continues walking up the visual tree until the root element has its measurements and all the measurements can be finalized.\n\nThe candidate layout must fit within the current app window or else parts of the UI will be clipped. Panels often are the place where the clipping logic is determined. Panel logic can determine what size is available from within the [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementation, and may have to push the size restrictions onto the children and divide space amongst children so that everything fits as best it can. The result of layout is ideally something that uses various properties of all parts of the layout but still fits within the app window. That requires both a good implementation for layout logic of the panels, and also a judicious UI design on the part of any app code that builds a UI using that panel. No panel design is going to look good if the overall UI design includes more child elements than can possibly fit in the app.\n\nA large part of what makes the layout system work is that any element that's based on [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) already has some of its own inherent behavior when acting as a child in a container. For example, there are several APIs of **FrameworkElement** that either inform layout behavior or are needed to make layout work at all. These include:\n\n-   [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) (actually a [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) property)\n-   [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) and [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709)\n-   [**Height**](https://msdn.microsoft.com/library/windows/apps/br208718) and [**Width**](https://msdn.microsoft.com/library/windows/apps/br208751)\n-   [**Margin**](https://msdn.microsoft.com/library/windows/apps/br208724)\n-   [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) event\n-   [**HorizontalAlignment**](https://msdn.microsoft.com/library/windows/apps/br208720) and [**VerticalAlignment**](https://msdn.microsoft.com/library/windows/apps/br208749)\n-   [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) and [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) methods\n-   [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) and [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) methods: these have native implementations defined at the [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) level, which handle the element-level layout action\n\n## **MeasureOverride**\n\n\nThe [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) method has a return value that's used by the layout system as the starting [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) for the panel itself, when the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method is called on the panel by its parent in layout. The logic choices within the method are just as important as what it returns, and the logic often influences what value is returned.\n\nAll [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementations should loop through [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514), and call the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method on each child element. Calling the **Measure** method establishes the value for the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) property. This might inform how much space the panel itself needs, as well as how that space is divided among elements or sized for a particular child element.\n\nHere's a very basic skeleton of a [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) method:\n\n```CSharp\nprotected override Size MeasureOverride(Size availableSize)\n{\n    Size returnSize; //TODO might return availableSize, might do something else\n     \n    //loop through each Child, call Measure on each\n    foreach (UIElement child in Children)\n    {\n        child.Measure(new Size()); // TODO determine how much space the panel allots for this child, that's what you pass to Measure\n        Size childDesiredSize = child.DesiredSize; //TODO determine how the returned Size is influenced by each child's DesiredSize\n        //TODO, logic if passed-in Size and net DesiredSize are different, does that matter?\n    }\n    return returnSize;\n}\n```\n\nElements often have a natural size by the time they're ready for layout. After the measure pass, the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) might indicate that natural size, if the *availableSize* you passed for [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) was smaller. If the natural size is larger than *availableSize* you passed for **Measure**, the **DesiredSize** is constrained to *availableSize*. That's how **Measure**'s internal implementation behaves, and your layout overrides should take that behavior into account.\n\nSome elements don't have a natural size because they have **Auto** values for [**Height**](https://msdn.microsoft.com/library/windows/apps/br208718) and [**Width**](https://msdn.microsoft.com/library/windows/apps/br208751). These elements use the full *availableSize*, because that's what an **Auto** value represents: size the element to the maximum available size, which the immediate layout parent communicates by calling [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) with *availableSize*. In practice, there's always some measurement that a UI is sized to (even if that's the top level window.) Eventually, the measure pass resolves all the **Auto** values to parent constraints and all **Auto** value elements get real measurements (which you can get by checking [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) and [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707), after layout completes).\n\nIt's legal to pass a size to [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) that has at least one infinite dimension, to indicate that the panel can attempt to size itself to fit measurements of its content. Each child element being measured sets its [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) value using its natural size. Then, during the arrange pass, the panel typically arranges using that size.\n\nText elements such as [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) have a calculated [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) and [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) based on their text string and text properties even if no [**Height**](https://msdn.microsoft.com/library/windows/apps/br208718) or [**Width**](https://msdn.microsoft.com/library/windows/apps/br208751) value is set, and these dimensions should be respected by your panel logic. Clipping text is a particularly bad UI experience.\n\nEven if your implementation doesn't use the desired size measurements, it's best to call the [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) method on each child element, because there are internal and native behaviors that are triggered by **Measure** being called. For an element to participate in layout, each child element must have **Measure** called on it during the measure pass and the [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) method called on it during the arrange pass. Calling these methods sets internal flags on the object and populates values (such as the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) property) that the system's layout logic needs when it builds the visual tree and renders the UI.\n\nThe [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) return value is based on the panel's logic interpreting the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) or other size considerations for each of the child elements in [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514) when [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952) is called on them. What to do with **DesiredSize** values from children and how the **MeasureOverride** return value should use them is up to your own logic's interpretation. You don't typically add up the values without modification, because the input of **MeasureOverride** is often a fixed available size that's being suggested by the panel's parent. If you exceed that size, the panel itself might get clipped. You'd typically compare the total size of children to the panel's available size and make adjustments if necessary.\n\n### Tips and guidance\n\n-   Ideally, a custom panel should be suitable for being the first true visual in a UI composition, perhaps at a level immediately under [**Page**](https://msdn.microsoft.com/library/windows/apps/br227503), [**UserControl**](https://msdn.microsoft.com/library/windows/apps/br227647) or another element that is the XAML page root. In [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementations, don't routinely return the input [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) without examining the values. If the return **Size** has an **Infinity** value in it, this can throw exceptions in runtime layout logic. An **Infinity** value can come from the main app window, which is scrollable and therefore doesn't have a maximum height. Other scrollable content might have the same behavior.\n-   Another common mistake in [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) implementations is to return a new default [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) (values for height and width are 0). You might start with that value, and it might even be the correct value if your panel determines that none of the children should be rendered. But, a default **Size** results in your panel not being sized correctly by its host. It requests no space in the UI, and therefore gets no space and doesn't render. All your panel code otherwise might be functioning fine, but you still won't see your panel or contents thereof if it's being composed with zero height, zero width.\n-   Within the overrides, avoid the temptation to cast child elements to [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) and use properties that are calculated as a result of layout, particularly [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) and [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707). For most common scenarios, you can base the logic on the child's [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) value and you won't need any of the [**Height**](https://msdn.microsoft.com/library/windows/apps/br208718) or [**Width**](https://msdn.microsoft.com/library/windows/apps/br208751) related properties of a child element. For specialized cases, where you know the type of element and have additional information, for example the natural size of an image file, you can use your element's specialized information because it's not a value that is actively being altered by layout systems. Including layout-calculated properties as part of layout logic substantially increases the risk of defining an unintentional layout loop. These loops cause a condition where a valid layout can't be created and the system can throw a [**LayoutCycleException**](https://msdn.microsoft.com/library/windows/apps/hh673799) if the loop is not recoverable.\n-   Panels typically divide their available space between multiple child elements, although exactly how space is divided varies. For example, [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) implements layout logic that uses its [**RowDefinition**](https://msdn.microsoft.com/library/windows/apps/br227606) and [**ColumnDefinition**](https://msdn.microsoft.com/library/windows/apps/br209324) values to divide the space into the **Grid** cells, supporting both star-sizing and pixel values. If they're pixel values, the size available for each child is already known, so that's what is passed as input size for a grid-style [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952).\n-   Panels themselves can introduce reserved space for padding between items. If you do this, make sure to expose the measurements as a property that's distinct from [**Margin**](https://msdn.microsoft.com/library/windows/apps/br208724) or any **Padding** property.\n-   Elements might have values for their [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) and [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) properties based on a previous layout pass. If values change, app UI code can put handlers for [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) on elements if there's special logic to run, but panel logic typically doesn't need to check for changes with event handling. The layout system is already making the determinations of when to re-run layout because a layout-relevant property changed value, and a panel's [**MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730) or [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) are called automatically in the appropriate circumstances.\n\n## **ArrangeOverride**\n\n\nThe [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) method has a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) return value that's used by the layout system when rendering the panel itself, when the [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) method is called on the panel by its parent in layout. It's typical that the input *finalSize* and the **ArrangeOverride** returned **Size** are the same. If they aren't, that means the panel is attempting to make itself a different size than what the other participants in layout claim is available. The final size was based on having previously run the measure pass of layout through your panel code, so that's why returning a different size isn't typical: it means you are deliberately ignoring measure logic.\n\nDon't return a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) with an **Infinity** component. Trying to use such a **Size** throws an exception from internal layout.\n\nAll [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) implementations should loop through [**Children**](https://msdn.microsoft.com/library/windows/apps/br227514), and call the [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) method on each child element. Like [**Measure**](https://msdn.microsoft.com/library/windows/apps/br208952), **Arrange** doesn't have a return value. Unlike **Measure**, no calculated property gets set as a result (however, the element in question typically fires a [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) event).\n\nHere's a very basic skeleton of an [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) method:\n\n```CSharp\nprotected override Size ArrangeOverride(Size finalSize)\n{\n    //loop through each Child, call Arrange on each\n    foreach (UIElement child in Children)\n    {\n        Point anchorPoint = new Point(); //TODO more logic for topleft corner placement in your panel\n       // for this child, and based on finalSize or other internal state of your panel\n        child.Arrange(new Rect(anchorPoint, child.DesiredSize)); //OR, set a different Size \n    }\n    return finalSize; //OR, return a different Size, but that's rare\n}\n```\n\nThe arrange pass of layout might happen without being preceded by a measure pass. However, this only happens when the layout system has determined no properties have changed that would have affected the previous measurements. For example, if an alignment changes, there's no need to re-measure that particular element because its [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) would not change when its alignment choice changes. On the other hand, if [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) changes on any element in a layout, a new measure pass is needed. The layout system automatically detects true measure changes and invokes the measure pass again, and then runs another arrange pass.\n\nThe input for [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914) takes a [**Rect**](https://msdn.microsoft.com/library/windows/apps/br225994) value. The most common way to construct this **Rect** is to use the constructor that has a [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870) input and a [**Size**](https://msdn.microsoft.com/library/windows/apps/br225995) input. The **Point** is the point where the top left corner of the bounding box for the element should be placed. The **Size** is the dimensions used to render that particular element. You often use the [**DesiredSize**](https://msdn.microsoft.com/library/windows/apps/br208921) for that element as this **Size** value, because establishing the **DesiredSize** for all elements involved in layout was the purpose of the measure pass of layout. (The measure pass determines all-up sizing of the elements in an iterative way so that the layout system can optimize how elements are placed once it gets to the arrange pass.)\n\nWhat typically varies between [**ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711) implementations is the logic by which the panel determines the [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870) component of how it arranges each child. An absolute positioning panel such as [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) uses the explicit placement info that it gets from each element through [**Canvas.Left**](https://msdn.microsoft.com/library/windows/apps/hh759771) and [**Canvas.Top**](https://msdn.microsoft.com/library/windows/apps/hh759772) values. A space-dividing panel such as [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704) would have mathematical operations that divided the available space into cells and each cell would have an x-y value for where its content should be placed and arranged. An adaptive panel such as [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635) might be expanding itself to fit content in its orientation dimension.\n\nThere are still additional positioning influences on elements in layout, beyond what you directly control and pass to [**Arrange**](https://msdn.microsoft.com/library/windows/apps/br208914). These come from the internal native implementation of **Arrange** that's common to all [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) derived types and augmented by some other types such as text elements. For example, elements can have margin and alignment, and some can have padding. These properties often interact. For more info, see [Alignment, margin, and padding](alignment-margin-padding.md).\n\n## Panels and controls\n\n\nAvoid putting functionality into a custom panel that should instead be built as a custom control. The role of a panel is to present any child element content that exists within it, as a function of layout that happens automatically. The panel might add decorations to content (similar to how a [**Border**](https://msdn.microsoft.com/library/windows/apps/br209250) adds the border around the element it presents), or perform other layout-related adjustments like padding. But that's about as far as you should go when extending the visual tree output beyond reporting and using information from the children.\n\nIf there's any interaction that's accessible to the user, you should write a custom control, not a panel. For example, a panel shouldn't add scrolling viewports to content it presents, even if the goal is to prevent clipping, because the scrollbars, thumbs and so on are interactive control parts. (Content might have scrollbars after all, but you should leave that up to the child's logic. Don't force it by adding scrolling as a layout operation.) You might create a control and also write a custom panel that plays an important role in that control's visual tree, when it comes to presenting content in that control. But the control and the panel should be distinct code objects.\n\nOne reason the distinction between control and panel is important is because of Microsoft UI Automation and accessibility. Panels provide a visual layout behavior, not a logical behavior. How a UI element appears visually is not an aspect of UI that is typically important to accessibility scenarios. Accessibility is about exposing the parts of an app that are logically important to understanding a UI. When interaction is required, controls should expose the interaction possibilities to the UI Automation infrastructure. For more info, see [Custom automation peers](https://msdn.microsoft.com/library/windows/apps/mt297667).\n\n## Other layout API\n\n\nThere are some other APIs that are part of the layout system, but aren't declared by [**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511). You might use these in a panel implementation or in a custom control that uses panels.\n\n-   [**UpdateLayout**](https://msdn.microsoft.com/library/windows/apps/br208989), [**InvalidateMeasure**](https://msdn.microsoft.com/library/windows/apps/br208930), and [**InvalidateArrange**](https://msdn.microsoft.com/library/windows/apps/br208929) are methods that initiate a layout pass. **InvalidateArrange** might not trigger a measure pass, but the other two do. Never call these methods from within a layout method override, because they're almost sure to cause a layout loop. Control code doesn't typically need to call them either. Most aspects of layout are triggered automatically by detecting changes to the framework-defined layout properties such as [**Width**](https://msdn.microsoft.com/library/windows/apps/br208751) and so on.\n-   [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) is an event that fires when some aspect of layout of the element has changed. This isn't specific to panels; the event is defined by [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706).\n-   [**SizeChanged**](https://msdn.microsoft.com/library/windows/apps/br208742) is an event that fires only after layout passes are finalized, and indicates that [**ActualHeight**](https://msdn.microsoft.com/library/windows/apps/br208707) or [**ActualWidth**](https://msdn.microsoft.com/library/windows/apps/br208709) have changed as a result. This is another [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) event. There are cases where [**LayoutUpdated**](https://msdn.microsoft.com/library/windows/apps/br208722) fires, but **SizeChanged** does not. For example the internal contents might be rearranged, but the element's size didn't change.\n\n\n## Related topics\n\n**Reference**\n\n[**FrameworkElement.ArrangeOverride**](https://msdn.microsoft.com/library/windows/apps/br208711)\n\n[**FrameworkElement.MeasureOverride**](https://msdn.microsoft.com/library/windows/apps/br208730)\n\n[**Panel**](https://msdn.microsoft.com/library/windows/apps/br227511)\n\n**Concepts**\n\n[Alignment, margin, and padding](alignment-margin-padding.md)\n"}