{"nodes":[{"content":"Windows Unlock with companion (IoT) devices","pos":[11,54]},{"content":"A companion device is a device that can act in conjunction with your Windows 10 desktop to enhance the user authentication experience.","pos":[68,202]},{"content":"Using the Companion Device Framework, a companion device can provide a rich experience for Microsoft Passport even when Windows Hello is not available (e.g., if the Windows 10 desktop lacks a camera for face authentication or fingerprint reader device, for example).","pos":[203,469]},{"content":"Windows Unlock with companion (IoT) devices","pos":[492,535]},{"content":"A companion device is a device that can act in conjunction with your Windows 10 desktop to enhance the user authentication experience.","pos":[537,671]},{"content":"Using the Companion Device Framework, a companion device can provide a rich experience for Microsoft Passport even when Windows Hello is not available (e.g., if the Windows 10 desktop lacks a camera for face authentication or fingerprint reader device, for example).","pos":[672,938]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> The Companion Device Framework is a specialized feature not available to all app developers.","pos":[942,1043]},{"content":"To use this framework, your app must be specifically provisioned by Microsoft and list the restricted <bpt id=\"p1\">*</bpt>secondaryAuthenticationFactor<ept id=\"p1\">*</ept> capability in its manifest.","pos":[1044,1205]},{"content":"To obtain approval, contact <bpt id=\"p1\">[</bpt>cdfonboard@microsoft.com<ept id=\"p1\">](mailto:cdfonboard@microsoft.com)</ept>.","pos":[1206,1294]},{"content":"Introduction","pos":[1299,1311]},{"pos":[1315,1466],"content":"For a video overview, see the <bpt id=\"p1\">[</bpt>Windows Unlock with IoT Devices<ept id=\"p1\">](https://channel9.msdn.com/Events/Build/2016/P491)</ept> session from Build 2016 on Channel 9."},{"content":"Use cases","pos":[1472,1481]},{"content":"There are numerous ways one can use the Companion Device Framework to build a great Windows unlock experience with a companion device.","pos":[1483,1617]},{"content":"For example, users could:","pos":[1618,1643]},{"content":"Attach their companion device to PC via USB, touch the button on the companion device, and automatically unlock their PC.","pos":[1647,1768]},{"content":"Carry a phone in their pocket that is already paired with PC over Bluetooth.","pos":[1771,1847]},{"content":"Upon hitting the spacebar on their PC, their phone receives a notification.","pos":[1848,1923]},{"content":"Approve it and the PC simply unlocks.","pos":[1924,1961]},{"content":"Tap their companion device to an NFC reader to quickly unlock their PC.","pos":[1964,2035]},{"content":"Wear a fitness band that has already authenticated the wearer.","pos":[2038,2100]},{"content":"Upon approaching PC, and by performing a special gesture (like clapping), the PC unlocks.","pos":[2101,2190]},{"content":"Biometric enabled companion devices","pos":[2196,2231]},{"content":"If the companion device supports biometrics, in some cases the <bpt id=\"p1\">[</bpt>Windows Biometric framework<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/mt608302(v=vs.85).aspx)</ept> may be a better solution than the Companion Device Framework.","pos":[2233,2463]},{"content":"Please contact <bpt id=\"p1\">[</bpt>cdfonboard@microsoft.com<ept id=\"p1\">](mailto:cdfonboard@microsoft.com)</ept> and we'll help you pick the right approach.","pos":[2464,2582]},{"content":"Components of the solution","pos":[2588,2614]},{"content":"The diagram below depicts the components of the solution and who is responsible for building them.","pos":[2616,2714]},{"content":"framework overview","pos":[2718,2736]},{"content":"The Companion Device Framework is implemented as a service running on Windows (called Companion Authentication Service in this article).","pos":[2770,2906]},{"content":"This service is responsible for generating an unlock token which needs to be protected by an HMAC key stored on companion device.","pos":[2907,3036]},{"content":"This guarantees that access to the unlock token requires companion device presence.","pos":[3037,3120]},{"content":"Per each (PC, Windows user) tuple, there will be a unique unlock token.","pos":[3121,3192]},{"content":"Integration with the Companion Device Framework requires:","pos":[3194,3251]},{"pos":[3255,3466],"content":"A <bpt id=\"p1\">[</bpt>Universal Windows Platform (UWP)<ept id=\"p1\">](https://msdn.microsoft.com/windows/uwp/get-started/universal-application-platform-guide)</ept> companion device app for the companion device, downloaded from the Windows app store."},{"content":"The ability to create two 256 bit HMAC keys on the companion device and generate HMAC with it (using SHA-256).","pos":[3470,3580]},{"content":"Security settings on the Windows 10 desktop properly configured.","pos":[3583,3647]},{"content":"The Companion Authentication Service will require this PIN to be set up before any companion device can be plugged into it.","pos":[3648,3771]},{"content":"The users must set up a PIN via Settings &gt; Accounts &gt; Sign-in options.","pos":[3772,3842]},{"content":"In addition to the above requirements, the companion device app is responsible for:","pos":[3844,3927]},{"content":"User experience and branding of initial registration and later de-registration of the companion device.","pos":[3931,4034]},{"content":"Running in the background, discovering the companion device, communicating to the companion device and also Companion Authentication Service.","pos":[4037,4178]},{"content":"Error handling","pos":[4181,4195]},{"content":"Normally, companion devices ship with an app for initial setup, like setting up a fitness band for the first time.","pos":[4197,4311]},{"content":"The functionality described in this document can be part of that app and a separate app should not be required.","pos":[4312,4423]},{"content":"User signals","pos":[4431,4443]},{"content":"Each companion device should be combined with an app that supports three user signals.","pos":[4445,4531]},{"content":"These signals can be in form of an action or gesture.","pos":[4532,4585]},{"content":"<bpt id=\"p1\">**</bpt>Intent signal<ept id=\"p1\">**</ept>: Allows the user to show his intent for unlock by, for example, hitting a button on the companion device.","pos":[4589,4712]},{"content":"The intent signal must be collected on <bpt id=\"p1\">**</bpt>companion device<ept id=\"p1\">**</ept> side.","pos":[4713,4778]},{"content":"<bpt id=\"p1\">**</bpt>User presence signal<ept id=\"p1\">**</ept>: Proves the presence of the user.","pos":[4781,4839]},{"content":"The companion device might, for instance, require a PIN before it can be used for unlocking PC (not to be confused with PC PIN), or it might require press of a button.","pos":[4840,5007]},{"pos":[5010,5161],"content":"<bpt id=\"p1\">**</bpt>Disambiguation signal<ept id=\"p1\">**</ept>: Disambiguates which Windows 10 desktop the user wants to unlock when multiple options are available to the companion device."},{"content":"Any number of these user signals can be combined into one.","pos":[5163,5221]},{"content":"User presence and intent signals must be required on each use.","pos":[5222,5284]},{"content":"Registration and future communication between a PC and companion devices","pos":[5290,5362]},{"content":"Before a companion device can be plugged into Companion Device Framework, it needs to be registered with the framework.","pos":[5364,5483]},{"content":"The experience for registration is completely owned by the companion device app.","pos":[5484,5564]},{"content":"Registered relationship between the companion device and the Windows 10 desktop  device can be one to many (i.e., one companion device can be used for many Windows 10 desktop  devices).","pos":[5566,5751]},{"content":"However, each companion device can only be used for one user on each Windows 10 desktop  device.","pos":[5752,5848]},{"content":"Before a companion device can communicate with a PC, they need to agree on a transport to use.","pos":[5853,5947]},{"content":"Such choice is left to the companion device app; the Companion Device Framework does not impose any limitations on transport type (USB, NFC, WiFi, BT, BLE, etc) or protocol being used between the companion device and the companion device app on Windows 10 desktop device side.","pos":[5948,6224]},{"content":"It does, however, suggests certain security considerations for the transport layer as outlined in the \"Security Requirements\" section of this document.","pos":[6225,6376]},{"content":"It is the device providerâ€™s responsibility to provide those requirements.","pos":[6377,6450]},{"content":"The framework does not provide them for you.","pos":[6451,6495]},{"content":"User Interaction Model","pos":[6501,6523]},{"content":"Companion device app discovery, installation, and first-time registration","pos":[6529,6602]},{"content":"A typical user workflow is as follows:","pos":[6604,6642]},{"content":"The user sets up the PIN on each of target Windows 10 desktop devices she wants to unlock with that companion device.","pos":[6646,6763]},{"content":"The user runs the companion device app on their Windows 10 desktop device to register her companion device with Windows 10 desktop.","pos":[6766,6897]},{"content":"Notes:","pos":[6899,6905]},{"content":"We recommend the discovery, download, and launch of the companion device app is streamlined and, if possible, automated (e.g., the app can be downloaded upon tapping companion device app on an NFC reader on Windows 10 desktop device side).","pos":[6909,7148]},{"content":"This is, however, the responsibility of the companion device and companion device app.","pos":[7149,7235]},{"content":"In an enterprise environment, the companion device app can be deployed via MDM.","pos":[7238,7317]},{"content":"The companion device app is responsible to show user any error messages that happen as part of registration.","pos":[7320,7428]},{"content":"Registration and de-registration protocol","pos":[7434,7475]},{"content":"The following diagram illustrates how the companion device interacts with Companion Authentication Service during registration.","pos":[7477,7604]},{"content":"registration flow","pos":[7610,7627]},{"content":"There are two keys used in our protocol:","pos":[7661,7701]},{"pos":[7705,7795],"content":"Device key (<bpt id=\"p1\">**</bpt>devicekey<ept id=\"p1\">**</ept>): used to protect unlock tokens that PC needs to unlock Windows."},{"pos":[7798,7924],"content":"The authentication key (<bpt id=\"p1\">**</bpt>authkey<ept id=\"p1\">**</ept>): used to mutually authenticate the companion device and Companion Authentication Service."},{"content":"The device key and authentication keys are exchanged at registration time between companion device app and the companion device.","pos":[7926,8054]},{"content":"As a result, the companion device app and companion device must use a secure transport to protect keys.","pos":[8055,8158]},{"content":"Also, note that while the diagram above displays two HMAC keys generating on the companion device, it is also possible for app to generate them and send them to companion device for storage.","pos":[8160,8350]},{"content":"Starting authentication flows","pos":[8356,8385]},{"content":"There are two ways for user to start the signing in flow to Windows 10 desktop using Companion Device Framework (i.e., provide intent signal):","pos":[8387,8529]},{"content":"Open up the lid on laptop, or hit the space or swipe up on PC.","pos":[8533,8595]},{"content":"Perform a gesture or an action on companion device side.","pos":[8598,8654]},{"content":"It is the companion device's choice to select which one is the starting point.","pos":[8656,8734]},{"content":"The Companion Device Framework will inform companion device app when option one happens.","pos":[8735,8823]},{"content":"For option two, the companion device app should query the companion device to see if that event has been captured.","pos":[8824,8938]},{"content":"This ensures the companion device collects the intent signal before the unlock succeeds.","pos":[8939,9027]},{"content":"Companion device credential provider","pos":[9033,9069]},{"content":"There is a new credential provider in Windows 10 that handles all companion devices.","pos":[9071,9155]},{"content":"The companion device credential provider is responsible for launching companion device background task via activating a trigger.","pos":[9157,9285]},{"content":"The trigger is set for first time when the PC awakens and a lock screen is displayed.","pos":[9286,9371]},{"content":"The second time is when the PC is entering logon UI and the Companion Device Credential Provider is the selected tile.","pos":[9372,9490]},{"content":"The helper library for companion device app will listen to the lock screen status change and send the event corresponding to the companion device background task.","pos":[9492,9654]},{"content":"If there are multiple companion device background tasks, the first background task that has finished the authentication process will unlock the PC.","pos":[9656,9803]},{"content":"The companion device authentication service will ignore any remaining authentication calls.","pos":[9804,9895]},{"content":"The experience on companion device side is owned and managed by the companion device app.","pos":[9897,9986]},{"content":"The Companion Device Framework has no control over this part of the user experience.","pos":[9987,10071]},{"content":"More specifically, the companion authentication provider informs the companion device app (via its background app) about state changes in logon UI (e.g., lock screen just came down, or user just dispelled lock screen by hitting spacebar), and it is the responsibility of the companion device app to build an experience around that (e.g., upon user hitting spacebar and dispelling unlock screen, start looking for the device over USB).","pos":[10072,10506]},{"content":"The Companion Device Framework will provide a stock of (localized) text and error messages for the companion device app to choose from.","pos":[10508,10643]},{"content":"These will be displayed on top of lock screen (or in logon UI).","pos":[10644,10707]},{"content":"See the Dealing with Messages and Errors section for more details.","pos":[10708,10774]},{"content":"Authentication protocol","pos":[10780,10803]},{"content":"Once the background task associated with a companion device app is trigger started, it is responsible for asking companion device to help calculate two HMAC values:","pos":[10805,10969]},{"content":"The HMAC of the device key with a nonce.","pos":[10972,11012]},{"content":"The HMAC of the authentication key with first HMAC value concatenated with a nonce generated by Companion Authentication Service.","pos":[11015,11144]},{"content":"The second value is used by the service to authenticate the device and also prevent replay attack in transport channel.","pos":[11146,11265]},{"content":"registration flow","pos":[11269,11286]},{"content":"Lifecycle management","pos":[11323,11343]},{"content":"Register once, use everywhere","pos":[11349,11378]},{"content":"Without a backend server, users must register their companion device with each Windows 10 desktop device separately.","pos":[11380,11496]},{"content":"A companion device vendor or OEM can implement a web service to roam the registration state across user Windows 10 desktops or mobile devices.","pos":[11498,11640]},{"content":"For more details, see the Roaming, Revocation, and Filter Service section.","pos":[11641,11715]},{"content":"PIN management","pos":[11721,11735]},{"content":"Before a companion device can be used, a PIN needs to be set up on Windows 10 desktop device.","pos":[11737,11830]},{"content":"This ensures the user has a backup in case their companion device is not working.","pos":[11831,11912]},{"content":"The PIN is something that Windows manages and that apps never see.","pos":[11913,11979]},{"content":"To change it, the user navigates to Settings &gt; Accounts &gt; Sign-in options.","pos":[11980,12054]},{"content":"Management and policy","pos":[12060,12081]},{"content":"Users can remove a companion device from a Windows 10 desktops by running the companion device app on that desktop device.","pos":[12083,12205]},{"content":"Enterprises have two options for controlling the Companion Device Framework:","pos":[12207,12283]},{"content":"Turn the feature on or off","pos":[12287,12313]},{"content":"Define the whitelist of companion devices allowed using Windows app locker","pos":[12316,12390]},{"content":"The Companion Device Framework does not support any centralized way to keep inventory of available companion devices, or a method to further filter which instances of a companion device type is allowed (for example, only companion device with serial number between X and Y are allowed).","pos":[12392,12678]},{"content":"Apps developers can, however, build a service to provide such functionality.","pos":[12679,12755]},{"content":"For more details, see the Roaming, Revocation, and Filter Service section.","pos":[12756,12830]},{"content":"Revocation","pos":[12836,12846]},{"content":"The Companion Device Framework does not support removing a companion device from a specific Windows 10 desktop device remotely.","pos":[12848,12975]},{"content":"Instead, users can remove the companion device via the companion device app running on that Windows 10 desktop.","pos":[12976,13087]},{"content":"Companion device vendors, however, can build a service to provide remote revocation functionality.","pos":[13089,13187]},{"content":"For more details, see Roaming, Revocation, and Filter Service section.","pos":[13188,13258]},{"content":"Roaming and filter services","pos":[13264,13291]},{"content":"Companion device vendors can implement a web service that can be used for the following scenarios:","pos":[13293,13391]},{"content":"A filter service for enterprise: An enterprise can limit the set of companion devices that can work in their environment to a select few from a specific vendor.","pos":[13395,13555]},{"content":"For example, the company Contoso could order 10,000 Model Y companion devices from Vendor X and ensure only those devices will work in the Contoso domain (and not any other device model from Vendor X).","pos":[13556,13757]},{"content":"Inventory:  An enterprise can determine the list of existing companion devices used in an enterprise environment.","pos":[13760,13873]},{"content":"Real time revocation: If an employee reports that his companion device is lost or stolen, the web service can be used to revoke that device.","pos":[13876,14016]},{"content":"Roaming: A user only has to register his companion device once and it works on all of his Windows 10 desktops and Mobile.","pos":[14019,14140]},{"content":"Implementing these features requires the companion device app to check with the web service at registration and usage time.","pos":[14142,14265]},{"content":"The companion device app can optimize for cached logon scenarios like requiring checking with web service only once a day (at the cost of extending the revocation time to up to one day).","pos":[14266,14452]},{"content":"Companion Device Framework API model","pos":[14459,14495]},{"content":"Overview","pos":[14501,14509]},{"content":"A companion app should contain two components: a foregroud app with UI responsible for registering and unregistering the device, and a background task that handles authentication.","pos":[14511,14690]},{"content":"The overall API flow is as follows:","pos":[14692,14727]},{"content":"Register the companion device","pos":[14732,14761]},{"content":"Make sure device is nearby and query its capability (if required)","pos":[14768,14833]},{"content":"Generate two HMAC keys (either on the companion device side or the app side","pos":[14840,14915]},{"content":"Call RequestStartRegisteringDeviceAsync","pos":[14922,14961]},{"content":"Call FinishRegisteringDeviceAsync","pos":[14968,15001]},{"content":"Make sure companion device app stores HMAC keys (if supported) and companion device app discards its copies","pos":[15008,15115]},{"content":"Register your background task","pos":[15119,15148]},{"content":"Wait for the right event in the background task","pos":[15152,15199]},{"content":"WaitingForUserConfirmation: Wait for this event if the user action/gesture on the companion device side is required to start authentication flow","pos":[15206,15350]},{"content":"CollectingCredential: Wait for this event if the companion device relies on user action/gesture on the PC side to start authentication flow (e.g., by hitting spacebar)","pos":[15357,15524]},{"content":"Other trigger, like a smartcard: Make sure to query for current authentication state to call the right APIs.","pos":[15531,15639]},{"content":"Keep user informed about error messages or required next steps by calling ShowNotificationMessageAsync.","pos":[15643,15746]},{"content":"Only call this API once an intent signal is collected","pos":[15747,15800]},{"content":"Unlock","pos":[15804,15810]},{"content":"Make sure intent and user presence signals were collected","pos":[15817,15874]},{"content":"Call StartAuthenticationAsync","pos":[15881,15910]},{"content":"Communicate with the companion device to perform required HMAC operations","pos":[15917,15990]},{"content":"Call FinishAuthenticationAsync","pos":[15997,16027]},{"content":"Un-register a companion device when the user requests it (for example, if they've lost their companion device)","pos":[16031,16141]},{"content":"Enumerate the companion device for logged in user via FindAllRegisteredDeviceInfoAsync","pos":[16148,16234]},{"content":"Un-register it using UnregisterDeviceAsync","pos":[16241,16283]},{"content":"Registration and de-registration","pos":[16289,16321]},{"content":"Registration requires two API calls to the Companion Authentication Service: RequestStartRegisteringDeviceAsync and FinishRegisteringDeviceAsync.","pos":[16323,16468]},{"content":"Before any of these calls are made, the companion device app must make sure that the companion device is available.","pos":[16470,16585]},{"content":"If the companion device is responsible for generating HMAC keys (authentication and device keys), then the companion device app should also ask companion device to generate them before making any of the above two calls.","pos":[16586,16805]},{"content":"If companion device app is responsible for generating HMAC keys, then it should do so before calling above two calls.","pos":[16806,16923]},{"content":"Additionally, as part of first API call (RequestStartRegisteringDeviceAsync), the companion device app must decide on device capability and be prepared to pass it as part of the API call; for example, whether companion device supports secure storage for HMAC keys.","pos":[16925,17189]},{"content":"If the same companion device app is used to manage multiple versions of the same companion device and those capabilities change (and requires a device query to decide), we recommend this queries occurs before first API call is made.","pos":[17190,17422]},{"content":"The first API (RequestStartRegisteringDeviceAsync) will return a handle used by the second API (FinishRegisteringDeviceAsync).","pos":[17427,17553]},{"content":"The first call for registration will launch the PIN prompt to make sure user is present.","pos":[17554,17642]},{"content":"If no PIN is set up, this call will fail.","pos":[17643,17684]},{"content":"Companion device app can query whether PIN is set up or not via KeyCredentialManager.IsSupportedAsync call as well.","pos":[17685,17800]},{"content":"RequestStartRegisteringDeviceAsync call can also fail if policy has disabled the usage of companion device.","pos":[17801,17908]},{"content":"The result of first call is returned via SecondaryAuthenticationFactorRegistrationStatus enum:","pos":[17910,18004]},{"content":"The second call (FinishRegisteringDeviceAsync) finishes the registration.","pos":[18322,18395]},{"content":"As part of registration process, the companion device app can store companion device configuration data with Companion Authentication Service.","pos":[18396,18538]},{"content":"There is a 4K size limit for this data.","pos":[18539,18578]},{"content":"This data will be available to companion device app at authentication time.","pos":[18579,18654]},{"content":"This data can be used, as an example, to connect to companion device, like a MAC address, or if companion device does not have storage and companion device wants to use PC for storage, then configuration data can be used.","pos":[18655,18876]},{"content":"Note that any sensitive data stored as part of configuration data must be encrypted with a key that only companion device knows.","pos":[18877,19005]},{"content":"Also, given that configuration data is stored by a Windows service, it is available to companion device app across user profiles.","pos":[19006,19135]},{"content":"The companion device app can call AbortRegisteringDeviceAsync to cancel the registration and pass in an error code.","pos":[19137,19252]},{"content":"The Companion Authentication Service will log the error in the telemetry data.","pos":[19253,19331]},{"content":"A good example for this call would be when something went wrong with companion device and it could not finish registration (e.g., it cannot store HMAC keys or BT connection was lost).","pos":[19332,19515]},{"content":"The companion device app must provide an option for user to de-register their companion device from their Windows 10 desktop (e.g., if they lost their companion device or bought a newer version).","pos":[19517,19712]},{"content":"When user selects that option, then the companion device app must call UnregisterDeviceAsync.","pos":[19713,19806]},{"content":"This call by the companion device app will trigger companion device authentication service to delete all data (including HMAC keys) corresponding to the specific device Id and AppId of the caller app from PC side.","pos":[19807,20020]},{"content":"This API call does not attempt to delete HMAC keys from companion device app or companion device side.","pos":[20021,20123]},{"content":"That is left for companion device app to implement.","pos":[20124,20175]},{"content":"The companion device app is responsible for showing any error messages that happen in registration and de-registration phase.","pos":[20177,20302]},{"content":"Authentication","pos":[24660,24674]},{"content":"Authentication requires two API calls to the Companion Authentication Service: StartAuthenticationAsync and FinishAuthencationAsync.","pos":[24676,24808]},{"content":"The first initiation API will return a handle used by the second API.","pos":[24810,24879]},{"content":"The first call returns, among other things, a nonce that â€“ once concatenated with other things - needs to be HMAC'ed with the device key stored on the companion device.","pos":[24881,25049]},{"content":"The second call returns the results of HMAC with device key and can potentially end in successful authentication (i.e., the user will see their desktop).","pos":[25050,25203]},{"content":"The first initiation API (StartAuthenticationAsync) can fail if policy has disabled that companion device after initial registration.","pos":[25205,25338]},{"content":"It can also fail if the API call was made outside WaitingForUserConfirmation or CollectingCredential states (more on this later in this section).","pos":[25339,25484]},{"content":"It can also fail if an unregistered companion device app calls it.","pos":[25485,25551]},{"content":"SecondaryAuthenticationFactorAuthenticationStatus Enum summarizes the possible outcomes:","pos":[25552,25640]},{"content":"The second API call (FinishAuthencationAsync) can fail if the nonce that was provided in the first call is expired (20 seconds).","pos":[26103,26231]},{"content":"SecondaryAuthenticationFactorFinishAuthenticationStatus enum captures possible outcomes.","pos":[26232,26320]},{"content":"The timing of two API calls (StartAuthenticationAsync and FinishAuthencationAsync) need to align with how the companion device collects intent, user presence and disambiguation signals (see User Signals for more details).","pos":[26481,26702]},{"content":"For example, the second call must not be submitted until intent signal is available.","pos":[26703,26787]},{"content":"In other words, PC should not unlock if user has not expressed intent for it.","pos":[26788,26865]},{"content":"To make this more clear, assume that Bluetooth proximity is used for PC unlock, then an explicit intent signal must be collected otherwise, as soon as user walks by his PC on the way to kitchen, PC will unlock.","pos":[26866,27076]},{"content":"Also, the nonce returned from the first call is time bound (20 seconds) and will expire after certain period.","pos":[27077,27186]},{"content":"As a result, the first call only should be made when companion device app has good indication of companion device presence, e.g., companion device is inserted into USB port, or tapped on NFC reader.","pos":[27187,27385]},{"content":"With Bluetooth, care must be taken to avoid affecting battery on PC side or affecting other Bluetooth activities going on at that point when checking for companion device presence.","pos":[27386,27566]},{"content":"Also, if user presence signal needs to be provided (e.g., by typing in PIN), it is recommended that the first authentication call is only made after that signal is collected.","pos":[27567,27741]},{"content":"The Companion Device Framework helps the companion device app to make informed decision on when to make above two calls by providing a complete picture of where user is in authentication flow.","pos":[27743,27935]},{"content":"Companion Device Framework provides this functionality by providing lock state change notification to app background task.","pos":[27936,28058]},{"content":"companion device flow","pos":[28062,28083]},{"content":"Details of each of these states are as follows:","pos":[28117,28164]},{"content":"State","pos":[28168,28173]},{"content":"Description","pos":[28200,28211]},{"content":"WaitingForUserConfirmation","pos":[30020,30046]},{"content":"This state change notification event is fired when lock screen comes down (e.g., user pressed Windows + L).","pos":[30052,30159]},{"content":"We recommend not to request any error messages relating to having difficulty finding a device in this state.","pos":[30160,30268]},{"content":"In general, we recommend to only show messages, when intent signal is available.","pos":[30269,30349]},{"content":"The companion device app should make the first API call for authentication in this state if companion device collects intent signal (e.g., tapping on NFC reader, press of a button on the companion device or a specific gesture, like clapping), and the companion device app background task receives indication from the companion device that intent signal was detected.","pos":[30350,30716]},{"content":"Otherwise, if companion device app relies on PC to start authentication flow (by having user swipe up the unlock screen or hitting space bar), then companion device app needs to wait for next state (CollectingCredential).","pos":[30717,30938]},{"content":"CollectingCredential","pos":[30946,30966]},{"content":"This state change notification event is fired when user either opens their laptop lid, hits any key on their keyboard, or swipes up to the unlock screen.","pos":[30978,31131]},{"content":"If companion device relies on above actions to start collecting intent signal then companion device app should start collecting it (e.g., via a pop up on companion device asking whether user wants to unlock the PC).","pos":[31132,31347]},{"content":"This would be a good time to provide error cases if companion device app needs user to provide user presence signal on the companion device (like typing in PIN on the companion device).","pos":[31348,31533]},{"content":"Suspendingauthentication","pos":[31872,31896]},{"content":"When companion device app receives this state, it means that Companion Authentication Service has stopped accepting authentication requests.","pos":[31904,32044]},{"content":"CredentialCollected","pos":[32798,32817]},{"content":"This means that another companion device app has called the second API and that Companion Authentication Service is verifying what was submitted.","pos":[32830,32975]},{"content":"At this point, Companion Authentication Service is not accepting any other authentication requests unless the currently submitted one does not pass verification.","pos":[32976,33137]},{"content":"Companion device app should stay tuned until next state is reached.","pos":[33138,33205]},{"content":"CredentialAuthenticated","pos":[33724,33747]},{"content":"This means that the submitted credential worked.","pos":[33756,33804]},{"content":"The credentialAuthenticated has device ID of the companion device that succeeded.","pos":[33805,33886]},{"content":"Companion device app should make sure to check on that to see if its associated device was the winner.","pos":[33887,33989]},{"content":"If not, then the companion device app should avoid showing any post authentication flows (like success message on the companion device or perhaps a vibration on that device).","pos":[33990,34164]},{"content":"Note that if the submitted credential did not work, then state will change to CollectingCredential state.","pos":[34165,34270]},{"content":"StoppoingAuthentication","pos":[34650,34673]},{"content":"Authentication succeeded and user saw desktop.","pos":[34682,34728]},{"content":"Time to kill your background task","pos":[34729,34762]},{"content":"Companion device apps should only call the two authentication APIs in the first two states.","pos":[35577,35668]},{"content":"Companion device apps should check is what scenario this event is being fired.","pos":[35670,35748]},{"content":"There are two possibilities: unlock or post unlock.","pos":[35749,35800]},{"content":"Currently, only unlock is supported.","pos":[35801,35837]},{"content":"In upcoming releases, post-unlock scenarios may be supported.","pos":[35838,35899]},{"content":"The SecondaryAuthenticationFactorAuthenticationScenario enum captures these two options:","pos":[35900,35988]},{"content":"Complete code sample:","pos":[36110,36131]},{"content":"Register a background task","pos":[42804,42830]},{"content":"When the companion device app registers the first companion device, it should also register its background task component which will pass authentication information between device and companion device authentication service.","pos":[42832,43056]},{"content":"Errors and messages","pos":[44713,44732]},{"content":"The Companion Device Framework is responsible for providing feedback to the user about success or failure of the signing in.","pos":[44734,44858]},{"content":"The Companion Device Framework will provide a stock of (localized) text and error messages for the companion device app to choose from.","pos":[44859,44994]},{"content":"These will be displayed in logon UI.","pos":[44995,45031]},{"content":"companion device error","pos":[45035,45057]},{"content":"Companion device apps can use ShowNotificationMessageAsync to show messages to user as part of logon UI.","pos":[45091,45195]},{"content":"Call this API when intent signal is available.","pos":[45196,45242]},{"content":"Note that intent signal must always be collected on companion device side.","pos":[45243,45317]},{"content":"There are two types of messages: guidance and errors.","pos":[45319,45372]},{"content":"Guidance messages are designed to show to user how to start the unlock process.","pos":[45374,45453]},{"content":"Those messages are only shown to user once, upon first device registration and never shown again.","pos":[45454,45551]},{"content":"Error messages are always shown.","pos":[45553,45585]},{"content":"Error messages will be shown to user for 5 seconds and then disappear.","pos":[45586,45656]},{"content":"Given that intent signal must be collected before showing messages to user, and user will provide that intent only using one of this companion devices, there must not be a situation where multiple companion devices race for showing error messages.","pos":[45657,45904]},{"content":"As a result, Companion Device Framework does not maintain any queue.","pos":[45905,45973]},{"content":"When a caller asks for an error message, it will be shown for 5 seconds and all other requests for showing error message in that 5 seconds are dropped.","pos":[45974,46125]},{"content":"Once 5 second is passed, then opportunity arises for another caller to show error message.","pos":[46126,46216]},{"content":"We prohibit any caller from jamming the error channel.","pos":[46217,46271]},{"content":"Guidance and error messages are as follows.","pos":[46273,46316]},{"content":"Device name is a parameter passed by companion device app as part of ShowNotificationMessageAsync.","pos":[46317,46415]},{"content":"Guidance","pos":[46419,46427]},{"pos":[46433,46493],"content":"\"Swipe up or press space bar to sign in with <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept>.\""},{"pos":[46496,46545],"content":"\"Tap <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> to the NFC reader to sign in.\""},{"pos":[46548,46579],"content":"\"Looking for <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> ...\""},{"pos":[46582,46630],"content":"\"Plug <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> into a USB port to sign in.\""},{"content":"Errors","pos":[46634,46640]},{"pos":[46646,46691],"content":"\"See <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> for sign-in instructions.\""},{"pos":[46694,46746],"content":"\"Turn on Bluetooth to use <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> to sign in.\""},{"pos":[46749,46795],"content":"\"Turn on NFC to use <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> to sign in.\""},{"pos":[46798,46859],"content":"\"Connect to a Wi-Fi network to use <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> to sign in.\""},{"pos":[46862,46888],"content":"\"Tap <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> again.\""},{"content":"\"Your enterprise prevents sign in with <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept>.","pos":[46891,46944]},{"content":"Use another sign-in option.\"","pos":[46945,46973]},{"pos":[46976,47007],"content":"\"Tap <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> to sign in.\""},{"pos":[47010,47057],"content":"\"Rest your finger on <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> to sign in.\""},{"pos":[47060,47108],"content":"\"Swipe your finger on <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> to sign in.\""},{"content":"\"Couldnâ€™t sign in with <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept>.","pos":[47111,47148]},{"content":"Use another sign-in option.\"","pos":[47149,47177]},{"content":"\"Something went wrong.","pos":[47180,47202]},{"content":"Use another sign-in option, and then set up <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> again.\"","pos":[47203,47268]},{"content":"\"Try again.\"","pos":[47271,47283]},{"pos":[47286,47334],"content":"\"Say your Spoken Passphrase into <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept>.\""},{"pos":[47337,47375],"content":"\"Ready to sign in with <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept>.\""},{"pos":[47378,47456],"content":"\"Use another sign-in option first, then you can use <bpt id=\"p1\">*</bpt>device name<ept id=\"p1\">*</ept> to sign in.\""},{"content":"Enumerating registered devices","pos":[47462,47492]},{"content":"Companion device app can enumerate the list of registered companion devices via FindAllRegisteredDeviceInfoAsync call.","pos":[47494,47612]},{"content":"This API supports two query type defined via enum SecondaryAuthenticaitonFactorDeviceFindScope:","pos":[47613,47708]},{"content":"The first scope returns the list of devices for the logged on user.","pos":[47753,47820]},{"content":"The second one returns the list for all users on that PC.","pos":[47821,47878]},{"content":"The first scope must be used at un-registration time to avoid un-registering other user's companion device.","pos":[47879,47986]},{"content":"The second one must be used at authentication or registration time: at registration time, this enumeration can help app avoid trying to register the same companion device twice.","pos":[47987,48164]},{"content":"Note that even if app does not perform this check, PC does and will reject the same companion device be registered more than once.","pos":[48166,48296]},{"content":"At authentication time, using AllUsers scope helps companion device app support switch user flow: log on user A when user B is logged in (this requires that both users have installed the companion device app and user A has registered their companion devices with PC and PC is sitting on lock screen (or logon screen)).","pos":[48297,48615]},{"content":"Security requirements","pos":[48620,48641]},{"content":"The Companion Authentication Service provides the following security protections.","pos":[48643,48724]},{"content":"Malware on a Windows 10 desktop  device running as medium user or app container cannot use the companion device to access user credential keys (stored as part of Microsoft Passport) on PC silently.","pos":[48728,48925]},{"content":"A malicious user on a Windows 10 desktop device cannot use the companion device that belongs to another user on that Windows 10 desktop device to get silent access to his user credential keys (on the same Windows 10 desktop device).","pos":[48928,49160]},{"content":"Malware on the companion device cannot silently get access to user credential keys on Windows 10 desktop  device, including leveraging functionality or code developed specifically for the Companion Device Framework.","pos":[49163,49378]},{"content":"A malicious user cannot unlock Windows 10 desktop  device by capturing traffic between the companion device and the Windows 10 desktop  device and replaying it later.","pos":[49381,49547]},{"content":"Usage of nonce, authkey, and HMAC in our protocol guarantees protection against a replay attack.","pos":[49548,49644]},{"content":"Malware or a malicious user on a rouge PC cannot use companion device to get access to honest user PC.","pos":[49647,49749]},{"content":"This is achieved through mutual authentication between Companion Authenticaiton Service and companion device through usage of authkey and HMAC in our protocol.","pos":[49750,49909]},{"content":"The key to achieve the security protections enumerated above is to protect HMAC keys from unauthorized access and also verifying user presence.","pos":[49911,50054]},{"content":"More specifically, it must satisfy these requirements:","pos":[50055,50109]},{"content":"Provide protection against cloning the companion device","pos":[50113,50168]},{"content":"Provide protection against eavesdropping when sending HMAC keys at registration time to PC","pos":[50171,50261]},{"content":"Make sure that user presence signal is available.","pos":[50264,50313]}],"content":"---\ntitle: Windows Unlock with companion (IoT) devices\ndescription: A companion device is a device that can act in conjunction with your Windows 10 desktop to enhance the user authentication experience. Using the Companion Device Framework, a companion device can provide a rich experience for Microsoft Passport even when Windows Hello is not available (e.g., if the Windows 10 desktop lacks a camera for face authentication or fingerprint reader device, for example).\nauthor: awkoren\n---\n# Windows Unlock with companion (IoT) devices\n\nA companion device is a device that can act in conjunction with your Windows 10 desktop to enhance the user authentication experience. Using the Companion Device Framework, a companion device can provide a rich experience for Microsoft Passport even when Windows Hello is not available (e.g., if the Windows 10 desktop lacks a camera for face authentication or fingerprint reader device, for example).\n\n> **Note** The Companion Device Framework is a specialized feature not available to all app developers. To use this framework, your app must be specifically provisioned by Microsoft and list the restricted *secondaryAuthenticationFactor* capability in its manifest. To obtain approval, contact [cdfonboard@microsoft.com](mailto:cdfonboard@microsoft.com).\n\n## Introduction\n\n> For a video overview, see the [Windows Unlock with IoT Devices](https://channel9.msdn.com/Events/Build/2016/P491) session from Build 2016 on Channel 9.\n\n### Use cases\n\nThere are numerous ways one can use the Companion Device Framework to build a great Windows unlock experience with a companion device. For example, users could:\n\n- Attach their companion device to PC via USB, touch the button on the companion device, and automatically unlock their PC.\n- Carry a phone in their pocket that is already paired with PC over Bluetooth. Upon hitting the spacebar on their PC, their phone receives a notification. Approve it and the PC simply unlocks.\n- Tap their companion device to an NFC reader to quickly unlock their PC.\n- Wear a fitness band that has already authenticated the wearer. Upon approaching PC, and by performing a special gesture (like clapping), the PC unlocks.\n\n### Biometric enabled companion devices\n\nIf the companion device supports biometrics, in some cases the [Windows Biometric framework](https://msdn.microsoft.com/library/windows/hardware/mt608302(v=vs.85).aspx) may be a better solution than the Companion Device Framework. Please contact [cdfonboard@microsoft.com](mailto:cdfonboard@microsoft.com) and we'll help you pick the right approach.\n\n### Components of the solution\n\nThe diagram below depicts the components of the solution and who is responsible for building them.\n\n![framework overview](images/companion-device-1.png)\n\nThe Companion Device Framework is implemented as a service running on Windows (called Companion Authentication Service in this article). This service is responsible for generating an unlock token which needs to be protected by an HMAC key stored on companion device. This guarantees that access to the unlock token requires companion device presence. Per each (PC, Windows user) tuple, there will be a unique unlock token.\n\nIntegration with the Companion Device Framework requires:\n\n- A [Universal Windows Platform (UWP)](https://msdn.microsoft.com/windows/uwp/get-started/universal-application-platform-guide) companion device app for the companion device, downloaded from the Windows app store. \n- The ability to create two 256 bit HMAC keys on the companion device and generate HMAC with it (using SHA-256).\n- Security settings on the Windows 10 desktop properly configured. The Companion Authentication Service will require this PIN to be set up before any companion device can be plugged into it. The users must set up a PIN via Settings > Accounts > Sign-in options.\n\nIn addition to the above requirements, the companion device app is responsible for:\n\n- User experience and branding of initial registration and later de-registration of the companion device.\n- Running in the background, discovering the companion device, communicating to the companion device and also Companion Authentication Service.\n- Error handling\n\nNormally, companion devices ship with an app for initial setup, like setting up a fitness band for the first time. The functionality described in this document can be part of that app and a separate app should not be required.  \n\n### User signals\n\nEach companion device should be combined with an app that supports three user signals. These signals can be in form of an action or gesture.\n\n- **Intent signal**: Allows the user to show his intent for unlock by, for example, hitting a button on the companion device. The intent signal must be collected on **companion device** side.\n- **User presence signal**: Proves the presence of the user. The companion device might, for instance, require a PIN before it can be used for unlocking PC (not to be confused with PC PIN), or it might require press of a button.\n- **Disambiguation signal**: Disambiguates which Windows 10 desktop the user wants to unlock when multiple options are available to the companion device.\n\nAny number of these user signals can be combined into one. User presence and intent signals must be required on each use.\n\n### Registration and future communication between a PC and companion devices\n\nBefore a companion device can be plugged into Companion Device Framework, it needs to be registered with the framework. The experience for registration is completely owned by the companion device app.\n\nRegistered relationship between the companion device and the Windows 10 desktop  device can be one to many (i.e., one companion device can be used for many Windows 10 desktop  devices). However, each companion device can only be used for one user on each Windows 10 desktop  device.   \n\nBefore a companion device can communicate with a PC, they need to agree on a transport to use. Such choice is left to the companion device app; the Companion Device Framework does not impose any limitations on transport type (USB, NFC, WiFi, BT, BLE, etc) or protocol being used between the companion device and the companion device app on Windows 10 desktop device side. It does, however, suggests certain security considerations for the transport layer as outlined in the \"Security Requirements\" section of this document. It is the device providerâ€™s responsibility to provide those requirements. The framework does not provide them for you.\n\n\n## User Interaction Model\n\n### Companion device app discovery, installation, and first-time registration\n\nA typical user workflow is as follows:\n\n- The user sets up the PIN on each of target Windows 10 desktop devices she wants to unlock with that companion device.\n- The user runs the companion device app on their Windows 10 desktop device to register her companion device with Windows 10 desktop.\n\nNotes:\n\n- We recommend the discovery, download, and launch of the companion device app is streamlined and, if possible, automated (e.g., the app can be downloaded upon tapping companion device app on an NFC reader on Windows 10 desktop device side). This is, however, the responsibility of the companion device and companion device app.\n- In an enterprise environment, the companion device app can be deployed via MDM.\n- The companion device app is responsible to show user any error messages that happen as part of registration.\n\n### Registration and de-registration protocol\n\nThe following diagram illustrates how the companion device interacts with Companion Authentication Service during registration.  \n\n![registration flow](images/companion-device-2.png)\n\nThere are two keys used in our protocol:\n\n- Device key (**devicekey**): used to protect unlock tokens that PC needs to unlock Windows.\n- The authentication key (**authkey**): used to mutually authenticate the companion device and Companion Authentication Service.\n\nThe device key and authentication keys are exchanged at registration time between companion device app and the companion device. As a result, the companion device app and companion device must use a secure transport to protect keys.\n\nAlso, note that while the diagram above displays two HMAC keys generating on the companion device, it is also possible for app to generate them and send them to companion device for storage.\n\n### Starting authentication flows\n\nThere are two ways for user to start the signing in flow to Windows 10 desktop using Companion Device Framework (i.e., provide intent signal):\n\n- Open up the lid on laptop, or hit the space or swipe up on PC.\n- Perform a gesture or an action on companion device side.\n\nIt is the companion device's choice to select which one is the starting point. The Companion Device Framework will inform companion device app when option one happens. For option two, the companion device app should query the companion device to see if that event has been captured. This ensures the companion device collects the intent signal before the unlock succeeds.\n\n### Companion device credential provider\n\nThere is a new credential provider in Windows 10 that handles all companion devices.\n\nThe companion device credential provider is responsible for launching companion device background task via activating a trigger. The trigger is set for first time when the PC awakens and a lock screen is displayed. The second time is when the PC is entering logon UI and the Companion Device Credential Provider is the selected tile.\n\nThe helper library for companion device app will listen to the lock screen status change and send the event corresponding to the companion device background task.\n\nIf there are multiple companion device background tasks, the first background task that has finished the authentication process will unlock the PC. The companion device authentication service will ignore any remaining authentication calls.\n\nThe experience on companion device side is owned and managed by the companion device app. The Companion Device Framework has no control over this part of the user experience. More specifically, the companion authentication provider informs the companion device app (via its background app) about state changes in logon UI (e.g., lock screen just came down, or user just dispelled lock screen by hitting spacebar), and it is the responsibility of the companion device app to build an experience around that (e.g., upon user hitting spacebar and dispelling unlock screen, start looking for the device over USB).\n\nThe Companion Device Framework will provide a stock of (localized) text and error messages for the companion device app to choose from. These will be displayed on top of lock screen (or in logon UI). See the Dealing with Messages and Errors section for more details.\n\n### Authentication protocol\n\nOnce the background task associated with a companion device app is trigger started, it is responsible for asking companion device to help calculate two HMAC values:\n- The HMAC of the device key with a nonce.\n- The HMAC of the authentication key with first HMAC value concatenated with a nonce generated by Companion Authentication Service.\n\nThe second value is used by the service to authenticate the device and also prevent replay attack in transport channel.\n\n![registration flow](images/companion-device-3.png)\n\n## Lifecycle management\n\n### Register once, use everywhere\n\nWithout a backend server, users must register their companion device with each Windows 10 desktop device separately.\n\nA companion device vendor or OEM can implement a web service to roam the registration state across user Windows 10 desktops or mobile devices. For more details, see the Roaming, Revocation, and Filter Service section.\n\n### PIN management\n\nBefore a companion device can be used, a PIN needs to be set up on Windows 10 desktop device. This ensures the user has a backup in case their companion device is not working. The PIN is something that Windows manages and that apps never see. To change it, the user navigates to Settings > Accounts > Sign-in options.\n\n### Management and policy\n\nUsers can remove a companion device from a Windows 10 desktops by running the companion device app on that desktop device.\n\nEnterprises have two options for controlling the Companion Device Framework:\n\n- Turn the feature on or off\n- Define the whitelist of companion devices allowed using Windows app locker\n\nThe Companion Device Framework does not support any centralized way to keep inventory of available companion devices, or a method to further filter which instances of a companion device type is allowed (for example, only companion device with serial number between X and Y are allowed). Apps developers can, however, build a service to provide such functionality. For more details, see the Roaming, Revocation, and Filter Service section.\n\n### Revocation\n\nThe Companion Device Framework does not support removing a companion device from a specific Windows 10 desktop device remotely. Instead, users can remove the companion device via the companion device app running on that Windows 10 desktop.\n\nCompanion device vendors, however, can build a service to provide remote revocation functionality. For more details, see Roaming, Revocation, and Filter Service section.\n\n### Roaming and filter services\n\nCompanion device vendors can implement a web service that can be used for the following scenarios:\n\n- A filter service for enterprise: An enterprise can limit the set of companion devices that can work in their environment to a select few from a specific vendor. For example, the company Contoso could order 10,000 Model Y companion devices from Vendor X and ensure only those devices will work in the Contoso domain (and not any other device model from Vendor X).\n- Inventory:  An enterprise can determine the list of existing companion devices used in an enterprise environment.\n- Real time revocation: If an employee reports that his companion device is lost or stolen, the web service can be used to revoke that device.\n- Roaming: A user only has to register his companion device once and it works on all of his Windows 10 desktops and Mobile.\n\nImplementing these features requires the companion device app to check with the web service at registration and usage time. The companion device app can optimize for cached logon scenarios like requiring checking with web service only once a day (at the cost of extending the revocation time to up to one day).  \n\n## Companion Device Framework API model\n\n### Overview\n\nA companion app should contain two components: a foregroud app with UI responsible for registering and unregistering the device, and a background task that handles authentication.\n\nThe overall API flow is as follows:\n\n1. Register the companion device\n    * Make sure device is nearby and query its capability (if required)\n    * Generate two HMAC keys (either on the companion device side or the app side\n    * Call RequestStartRegisteringDeviceAsync\n    * Call FinishRegisteringDeviceAsync\n    * Make sure companion device app stores HMAC keys (if supported) and companion device app discards its copies\n2. Register your background task\n3. Wait for the right event in the background task\n    * WaitingForUserConfirmation: Wait for this event if the user action/gesture on the companion device side is required to start authentication flow\n    * CollectingCredential: Wait for this event if the companion device relies on user action/gesture on the PC side to start authentication flow (e.g., by hitting spacebar)\n    * Other trigger, like a smartcard: Make sure to query for current authentication state to call the right APIs.\n4. Keep user informed about error messages or required next steps by calling ShowNotificationMessageAsync. Only call this API once an intent signal is collected\n5. Unlock\n    * Make sure intent and user presence signals were collected\n    * Call StartAuthenticationAsync\n    * Communicate with the companion device to perform required HMAC operations\n    * Call FinishAuthenticationAsync\n6. Un-register a companion device when the user requests it (for example, if they've lost their companion device)\n    * Enumerate the companion device for logged in user via FindAllRegisteredDeviceInfoAsync\n    * Un-register it using UnregisterDeviceAsync\n\n### Registration and de-registration\n\nRegistration requires two API calls to the Companion Authentication Service: RequestStartRegisteringDeviceAsync and FinishRegisteringDeviceAsync.\n\nBefore any of these calls are made, the companion device app must make sure that the companion device is available. If the companion device is responsible for generating HMAC keys (authentication and device keys), then the companion device app should also ask companion device to generate them before making any of the above two calls. If companion device app is responsible for generating HMAC keys, then it should do so before calling above two calls.\n\nAdditionally, as part of first API call (RequestStartRegisteringDeviceAsync), the companion device app must decide on device capability and be prepared to pass it as part of the API call; for example, whether companion device supports secure storage for HMAC keys. If the same companion device app is used to manage multiple versions of the same companion device and those capabilities change (and requires a device query to decide), we recommend this queries occurs before first API call is made.   \n\nThe first API (RequestStartRegisteringDeviceAsync) will return a handle used by the second API (FinishRegisteringDeviceAsync). The first call for registration will launch the PIN prompt to make sure user is present. If no PIN is set up, this call will fail. Companion device app can query whether PIN is set up or not via KeyCredentialManager.IsSupportedAsync call as well. RequestStartRegisteringDeviceAsync call can also fail if policy has disabled the usage of companion device.\n\nThe result of first call is returned via SecondaryAuthenticationFactorRegistrationStatus enum:\n\n```C#\n{\n    Failed = 0,         // Something went wrong in the underlying components\n    Started,            // First call succeeded\n    CanceledByUser,     // User cancelled PIN prompt\n    PinSetupRequired,   // PIN is not set up\n    DisabledByPolicy,   // Companion device framework or this app is disabled\n}\n```\n\nThe second call (FinishRegisteringDeviceAsync) finishes the registration. As part of registration process, the companion device app can store companion device configuration data with Companion Authentication Service. There is a 4K size limit for this data. This data will be available to companion device app at authentication time. This data can be used, as an example, to connect to companion device, like a MAC address, or if companion device does not have storage and companion device wants to use PC for storage, then configuration data can be used. Note that any sensitive data stored as part of configuration data must be encrypted with a key that only companion device knows. Also, given that configuration data is stored by a Windows service, it is available to companion device app across user profiles.\n\nThe companion device app can call AbortRegisteringDeviceAsync to cancel the registration and pass in an error code. The Companion Authentication Service will log the error in the telemetry data. A good example for this call would be when something went wrong with companion device and it could not finish registration (e.g., it cannot store HMAC keys or BT connection was lost).\n\nThe companion device app must provide an option for user to de-register their companion device from their Windows 10 desktop (e.g., if they lost their companion device or bought a newer version). When user selects that option, then the companion device app must call UnregisterDeviceAsync. This call by the companion device app will trigger companion device authentication service to delete all data (including HMAC keys) corresponding to the specific device Id and AppId of the caller app from PC side. This API call does not attempt to delete HMAC keys from companion device app or companion device side. That is left for companion device app to implement.\n\nThe companion device app is responsible for showing any error messages that happen in registration and de-registration phase.\n\n```C#\nusing System;\nusing Windows.Security.Authentication.Identity.Provider;\nusing Windows.Storage.Streams;\nusing Windows.Security.Cryptography;\nusing Windows.UI.Popups;\n\nnamespace SecondaryAuthFactorSample\n{\n    public class DeviceRegistration\n    {\n\n        public void async OnRegisterButtonClick()\n        {\n            //\n            // Pseudo function, the deviceId should be retrieved by the application from the device\n            //\n            string deviceId = await ReadSerialNumberFromDevice();\n\n            IBuffer deviceKey = CryptographicBuffer.GenerateRandom(256/8);\n            IBuffer mutualAuthenticationKey = CryptographicBuffer.GenerateRandom(256/8);\n\n            SecondaryAuthenticationFactorRegistration registrationResult =\n                await SecondaryAuthenticationFactorRegistration.RequestStartRegisteringDeviceAsync(\n                    deviceId,  // deviceId: max 40 wide characters. For example, serial number of the device\n                    SecondaryAuthenticaitonFactorDeviceCapabilities.SupportSecureStorage |\n                        SecondaryAuthenticaitonFactorDeviceCapabilities.SupportSha2 |\n                        SecondaryAuthenticaitonFactorDeviceCapabilities.StoreKeys,\n                    \"My test device 1\", // deviceFriendlyName: max 64 wide characters. For example: John's card\n                    \"SAMPLE-001\", // deviceModelNumber: max 32 wide characters. The app should read the model number from device.\n                    deviceKey,\n                    mutualAuthenticationKey);\n\n            switch(registerResult.Status)\n            {\n            case SecondaryAuthenticationFactorRegistrationStatus.Started:\n                //\n                // Pseudo function:\n                // The app needs to retrieve the value from device and set into opaqueBlob\n                //\n                IBuffer deviceConfigData = ReadConfigurationDataFromDevice();\n\n                if (deviceConfigData != null)\n                {\n                    await registrationResult.Registration.FinishRegisteringDeviceAsync(deviceConfigData); //config data limited to 4096 bytes\n                    MessageDialog dialog = new MessageDialog(\"The device is registered correctly.\");\n                    await dialog.ShowAsync();\n                }\n                else\n                {\n                    await registrationResult.Registration.AbortRegisteringDeviceAsync(\"Failed to connect to the device\");\n                    MessageDialog dialog = new MessageDialog(\"Failed to connect to the device.\");\n                    await dialog.ShowAsync();\n                }\n                break;\n\n            case SecondaryAuthenticationFactorRegistrationStatus.CanceledByUser:\n                MessageDialog dialog = new MessageDialog(\"You didn't enter your PIN.\");\n                await dialog.ShowAsync();\n                break;\n\n            case SecondaryAuthenticationFactorRegistrationStatus.PinSetupRequired:\n                MessageDialog dialog = new MessageDialog(\"Please setup PIN in settings.\");\n                await dialog.ShowAsync();\n                break;\n\n            case SecondaryAuthenticationFactorRegistrationStatus.DisabledByPolicy:\n                MessageDialog dialog = new MessageDialog(\"Your enterprise prevents using this device to sign in.\");\n                await dialog.ShowAsync();\n                break;\n            }\n        }\n\n        public void async UpdateDeviceList()\n        {\n            IReadOnlyList<SecondaryAuthenticationFactorInfo> deviceInfoList =\n                await SecondaryAuthenticationFactorRegistration.FindAllRegisteredDeviceInfoAsync(\n                    SecondaryAuthenticaitonFactorDeviceFindScope.User);\n\n            if (deviceInfoList.Count > 0)\n            {\n                foreach (SecondaryAuthenticationFactorInfo deviceInfo in deviceInfoList)\n                {\n                    //\n                    // Add deviceInfo.FriendlyName and deviceInfo.DeviceId into a combo box\n                    //\n                }\n            }\n        }\n\n        public void async OnUnregisterButtonClick()\n        {\n            string deviceId;\n            //\n            // Read the deviceId from the selected item in the combo box\n            //\n            await SecondaryAuthenticationFactorRegistration.UnregisterDeviceAsync(deviceId);\n        }\n    }\n}\n```\n\n### Authentication\n\nAuthentication requires two API calls to the Companion Authentication Service: StartAuthenticationAsync and FinishAuthencationAsync.\n\nThe first initiation API will return a handle used by the second API.  The first call returns, among other things, a nonce that â€“ once concatenated with other things - needs to be HMAC'ed with the device key stored on the companion device. The second call returns the results of HMAC with device key and can potentially end in successful authentication (i.e., the user will see their desktop).\n\nThe first initiation API (StartAuthenticationAsync) can fail if policy has disabled that companion device after initial registration. It can also fail if the API call was made outside WaitingForUserConfirmation or CollectingCredential states (more on this later in this section). It can also fail if an unregistered companion device app calls it. SecondaryAuthenticationFactorAuthenticationStatus Enum summarizes the possible outcomes:\n\n```C#\n{\n    Failed = 0,                     // Something went wrong in the underlying components\n    Started,\n    UnknownDevice,                  // Companion device app is not registered with framework\n    DisabledByPolicy,               // Policy disabled this device after registration\n    InvalidAuthenticationStage,     // Companion device framework is not currently accepting\n                                    // incoming authentication requests\n}\n```\n\nThe second API call (FinishAuthencationAsync) can fail if the nonce that was provided in the first call is expired (20 seconds). SecondaryAuthenticationFactorFinishAuthenticationStatus enum captures possible outcomes.\n\n```C#\n{\n    Failed = 0,     // Something went wrong in the underlying components\n    Completed,      // Success\n    NonceExpired,   // Nonce is expired\n}\n```\n\nThe timing of two API calls (StartAuthenticationAsync and FinishAuthencationAsync) need to align with how the companion device collects intent, user presence and disambiguation signals (see User Signals for more details). For example, the second call must not be submitted until intent signal is available. In other words, PC should not unlock if user has not expressed intent for it. To make this more clear, assume that Bluetooth proximity is used for PC unlock, then an explicit intent signal must be collected otherwise, as soon as user walks by his PC on the way to kitchen, PC will unlock. Also, the nonce returned from the first call is time bound (20 seconds) and will expire after certain period. As a result, the first call only should be made when companion device app has good indication of companion device presence, e.g., companion device is inserted into USB port, or tapped on NFC reader. With Bluetooth, care must be taken to avoid affecting battery on PC side or affecting other Bluetooth activities going on at that point when checking for companion device presence. Also, if user presence signal needs to be provided (e.g., by typing in PIN), it is recommended that the first authentication call is only made after that signal is collected.\n\nThe Companion Device Framework helps the companion device app to make informed decision on when to make above two calls by providing a complete picture of where user is in authentication flow. Companion Device Framework provides this functionality by providing lock state change notification to app background task.\n\n![companion device flow](images/companion-device-4.png)\n\nDetails of each of these states are as follows:\n\n| State                         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n|----------------------------   |-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------    |\n| WaitingForUserConfirmation    | This state change notification event is fired when lock screen comes down (e.g., user pressed Windows + L). We recommend not to request any error messages relating to having difficulty finding a device in this state. In general, we recommend to only show messages, when intent signal is available. The companion device app should make the first API call for authentication in this state if companion device collects intent signal (e.g., tapping on NFC reader, press of a button on the companion device or a specific gesture, like clapping), and the companion device app background task receives indication from the companion device that intent signal was detected. Otherwise, if companion device app relies on PC to start authentication flow (by having user swipe up the unlock screen or hitting space bar), then companion device app needs to wait for next state (CollectingCredential).    |\n| CollectingCredential          | This state change notification event is fired when user either opens their laptop lid, hits any key on their keyboard, or swipes up to the unlock screen. If companion device relies on above actions to start collecting intent signal then companion device app should start collecting it (e.g., via a pop up on companion device asking whether user wants to unlock the PC). This would be a good time to provide error cases if companion device app needs user to provide user presence signal on the companion device (like typing in PIN on the companion device).                                                                                                                                                                                                                                                                                                                                               |\n| Suspendingauthentication      | When companion device app receives this state, it means that Companion Authentication Service has stopped accepting authentication requests.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| CredentialCollected           | This means that another companion device app has called the second API and that Companion Authentication Service is verifying what was submitted. At this point, Companion Authentication Service is not accepting any other authentication requests unless the currently submitted one does not pass verification. Companion device app should stay tuned until next state is reached.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| CredentialAuthenticated       | This means that the submitted credential worked. The credentialAuthenticated has device ID of the companion device that succeeded. Companion device app should make sure to check on that to see if its associated device was the winner. If not, then the companion device app should avoid showing any post authentication flows (like success message on the companion device or perhaps a vibration on that device). Note that if the submitted credential did not work, then state will change to CollectingCredential state.                                                                                                                                                                                                                                                                                                                                                                                        |\n| StoppoingAuthentication       | Authentication succeeded and user saw desktop. Time to kill your background task                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n\n\n\nCompanion device apps should only call the two authentication APIs in the first two states.  Companion device apps should check is what scenario this event is being fired. There are two possibilities: unlock or post unlock. Currently, only unlock is supported. In upcoming releases, post-unlock scenarios may be supported. The SecondaryAuthenticationFactorAuthenticationScenario enum captures these two options:\n\n```C#\n{\n    SignIn = 0,         // Running under lock screen mode\n    CredentialPrompt,   // Running post unlock\n}\n```\n\nComplete code sample:\n\n```C#\nusing System;\nusing Windows.Security.Authentication.Identity.Provider;\nusing Windows.Storage.Streams;\nusing Windows.Security.Cryptography;\nusing System.Threading;\nusing Windows.ApplicationModel.Background;\n\nnamespace SecondaryAuthFactorSample\n{\n    public sealed class AuthenticationTask : IBackgroundTask\n    {\n        private string _deviceId;\n        private static AutoResetEvent _exitTaskEvent = new AutoResetEvent(false);\n        private static IBackgroundTaskInstance _taskInstance;\n        private BackgroundTaskDeferral _deferral;\n\n        private void Authenticate()\n        {\n            int retryCount = 0;\n\n            while (retryCount < 3)\n            {\n                //\n                // Pseudo code, the svcAuthNonce should be passed to device or generated from device\n                //\n                IBuffer svcAuthNonce = CryptographicBuffer.GenerateRandom(256/8);\n\n                SecondaryAuthenticationFactorAuthenticationResult authResult = await\n                    SecondaryAuthenticationFactorAuthentication.StartAuthenticationAsync(\n                        _deviceId,\n                        svcAuthNonce);\n                if (authResult.Status != SecondaryAuthenticationFactorAuthenticationStatus.Started)\n                {\n                    SecondaryAuthenticationFactorAuthenticationMessage message;\n                    switch (authResult.Status)\n                    {\n                        case SecondaryAuthenticationFactorAuthenticationStatus.DisabledByPolicy:\n                            message = SecondaryAuthenticationFactorAuthenticationMessage.DisabledByPolicy;\n                            break;\n                        case SecondaryAuthenticationFactorAuthenticationStatus.InvalidAuthenticationStage:\n                            // The task might need to wait for a SecondaryAuthenticationFactorAuthenticationStageChangedEvent\n                            break;\n                        default:\n                            return;\n                    }\n\n                    // Show error message. Limited to 512 characters wide\n                    await SecondaryAuthenticationFactorAuthentication.ShowNotificationMessageAsync(null, message);\n                    return;\n                }\n\n                //\n                // Pseudo function:\n                // The device calculates and returns sessionHmac and deviceHmac\n                //\n                await GetHmacsFromDevice(\n                    authResult.Authentication.ServiceAuthenticationHmac,\n                    authResult.Authentication.DeviceNonce,\n                    authResult.Authentication.SessionNonce,\n                    out deviceHmac,\n                    out sessionHmac);\n                if (sessionHmac == null ||\n                    deviceHmac == null)\n                {\n                    await authResult.Authentication.AbortAuthenticationAsync(\n                        \"Failed to read data from device\");\n                    return;\n                }\n\n                SecondaryAuthenticationFactorFinishAuthenticationStatus status =\n                    await authResult.Authentication.FinishAuthencationAsync(deviceHmac, sessionHmac);\n                if (status == SecondaryAuthenticationFactorFinishAuthenticationStatus.NonceExpired)\n                {\n                    retryCount++;\n                    continue;\n                }\n                else if (status == SecondaryAuthenticationFactorFinishAuthenticationStatus.Completed)\n                {\n                    // The credential data is collected and ready for unlock\n                    return;\n                }\n            }\n        }\n\n        public void OnAuthenticationStageChanged(\n            object sender,\n            SecondaryAuthenticationFactorAuthenticationStageChangedEventArgs args)\n        {\n            // The application should check the args.StageInfo.Stage to determine what to do in next. Note that args.StageInfo.Scenario will have the scenario information (SignIn vs CredentialPrompt).\n\n            switch(args.StageInfo.Stage)\n            {\n            case SecondaryAuthenticationFactorAuthenticationStage.WaitingForUserConfirmation:\n                // Show welcome message\n                await SecondaryAuthenticationFactorAuthentication.ShowNotificationMessageAsync(\n                    null,\n                    SecondaryAuthenticationFactorAuthenticationMessage.WelcomeMessageSwipeUp);\n                break;\n\n            case SecondaryAuthenticationFactorAuthenticationStage.CollectingCredential:\n                // Authenticate device\n                Authenticate();\n                break;\n\n            case SecondaryAuthenticationFactorAuthenticationStage.CredentialAuthenticated:\n                if (args.StageInfo.DeviceId = _deviceId)\n                {\n                    // Show notification on device about PC unlock\n                }\n                break;\n\n            case SecondaryAuthenticationFactorAuthenticationStage.StoppingAuthentication:\n                // Quit from background task\n                _exitTaskEvent.Set();\n                break;\n            }\n\n            Debug.WriteLine(\"Authentication Stage = \" + args.StageInfo.AuthenticationStage.ToString());\n        }\n\n        //\n        // The Run method is the entry point of a background task.\n        //\n        public void Run(IBackgroundTaskInstance taskInstance)\n        {\n            _taskInstance = taskInstance;\n            _deferral = taskInstance.GetDeferral();\n\n            // Register canceled event for this task\n            taskInstance.Canceled += TaskInstanceCanceled;\n\n            // Find all device registred by this application\n            IReadOnlyList<SecondaryAuthenticationFactorInfo> deviceInfoList =\n                await SecondaryAuthenticationFactorRegistration.FindAllRegisteredDeviceInfoAsync(\n                    SecondaryAuthenticaitonFactorDeviceFindScope.AllUsers);\n\n            if (deviceInfoList.Count == 0)\n            {\n                // Quit the task silently\n                return;\n            }\n            _deviceId = deviceInfoList[0].DeviceId;\n            Debug.WriteLine(\"Use first device '\" + _deviceId + \"' in the list to signin\");\n\n            // Register AuthenticationStageChanged event\n            SecondaryAuthenticationFactorRegistration.AuthenticationStageChanged += OnAuthenticationStageChanged;\n\n            // Wait the task exit event\n            _exitTaskEvent.WaitOne();\n\n            _deferral.Complete();\n        }\n\n        void TaskInstanceCanceled(IBackgroundTaskInstance sender, BackgroundTaskCancellationReason reason)\n        {\n            _exitTaskEvent.Set();\n        }\n    }\n}\n```\n\n### Register a background task\n\nWhen the companion device app registers the first companion device, it should also register its background task component which will pass authentication information between device and companion device authentication service.\n\n```C#\nusing System;\nusing Windows.Security.Authentication.Identity.Provider;\nusing Windows.Storage.Streams;\nusing Windows.ApplicationModel.Background;\n\nnamespace SecondaryAuthFactorSample\n{\n    public class BackgroundTaskManager\n    {\n        // Register background task\n        public static async Task<IBackgroundTaskRegistration> GetOrRegisterBackgroundTaskAsync(\n            string bgTaskName,\n            string taskEntryPoint)\n        {\n            // Check if there's an existing background task already registered\n            var bgTask = (from t in BackgroundTaskRegistration.AllTasks\n                          where t.Value.Name.Equals(bgTaskName)\n                          select t.Value).SingleOrDefault();\n            if (bgTask == null)\n            {\n                BackgroundAccessStatus status =\n                    BackgroundExecutionManager.RequestAccessAsync().AsTask().GetAwaiter().GetResult();\n\n                if (status == BackgroundAccessStatus.Denied)\n                {\n                    Debug.WriteLine(\"Background Execution is denied.\");\n                    return null;\n                }\n\n                var taskBuilder = new BackgroundTaskBuilder();\n                taskBuilder.Name = bgTaskName;\n                taskBuilder.TaskEntryPoint = taskEntryPoint;\n                taskBuilder.SetTrigger(new SecondaryAuthenticationFactorAuthenticationTrigger());\n                bgTask = taskBuilder.Register();\n                // Background task is registered\n            }\n\n            bgTask.Completed += BgTask_Completed;\n            bgTask.Progress += BgTask_Progress;\n\n            return bgTask;\n        }\n    }\n}\n```\n\n### Errors and messages\n\nThe Companion Device Framework is responsible for providing feedback to the user about success or failure of the signing in. The Companion Device Framework will provide a stock of (localized) text and error messages for the companion device app to choose from. These will be displayed in logon UI.\n\n![companion device error](images/companion-device-5.png)\n\nCompanion device apps can use ShowNotificationMessageAsync to show messages to user as part of logon UI. Call this API when intent signal is available. Note that intent signal must always be collected on companion device side.\n\nThere are two types of messages: guidance and errors.\n\nGuidance messages are designed to show to user how to start the unlock process. Those messages are only shown to user once, upon first device registration and never shown again.\n\nError messages are always shown. Error messages will be shown to user for 5 seconds and then disappear. Given that intent signal must be collected before showing messages to user, and user will provide that intent only using one of this companion devices, there must not be a situation where multiple companion devices race for showing error messages. As a result, Companion Device Framework does not maintain any queue. When a caller asks for an error message, it will be shown for 5 seconds and all other requests for showing error message in that 5 seconds are dropped. Once 5 second is passed, then opportunity arises for another caller to show error message. We prohibit any caller from jamming the error channel.\n\nGuidance and error messages are as follows. Device name is a parameter passed by companion device app as part of ShowNotificationMessageAsync.\n\n**Guidance**\n\n- \"Swipe up or press space bar to sign in with *device name*.\"\n- \"Tap *device name* to the NFC reader to sign in.\"\n- \"Looking for *device name* ...\"\n- \"Plug *device name* into a USB port to sign in.\"\n\n**Errors**\n\n- \"See *device name* for sign-in instructions.\"\n- \"Turn on Bluetooth to use *device name* to sign in.\"\n- \"Turn on NFC to use *device name* to sign in.\"\n- \"Connect to a Wi-Fi network to use *device name* to sign in.\"\n- \"Tap *device name* again.\"\n- \"Your enterprise prevents sign in with *device name*. Use another sign-in option.\"\n- \"Tap *device name* to sign in.\"\n- \"Rest your finger on *device name* to sign in.\"\n- \"Swipe your finger on *device name* to sign in.\"\n- \"Couldnâ€™t sign in with *device name*. Use another sign-in option.\"\n- \"Something went wrong. Use another sign-in option, and then set up *device name* again.\"\n- \"Try again.\"\n- \"Say your Spoken Passphrase into *device name*.\"\n- \"Ready to sign in with *device name*.\"\n- \"Use another sign-in option first, then you can use *device name* to sign in.\"\n\n### Enumerating registered devices\n\nCompanion device app can enumerate the list of registered companion devices via FindAllRegisteredDeviceInfoAsync call. This API supports two query type defined via enum SecondaryAuthenticaitonFactorDeviceFindScope:\n\n```C#\n{\n    User = 0,\n    AllUsers,\n}\n```\n\nThe first scope returns the list of devices for the logged on user. The second one returns the list for all users on that PC. The first scope must be used at un-registration time to avoid un-registering other user's companion device. The second one must be used at authentication or registration time: at registration time, this enumeration can help app avoid trying to register the same companion device twice.\n\nNote that even if app does not perform this check, PC does and will reject the same companion device be registered more than once. At authentication time, using AllUsers scope helps companion device app support switch user flow: log on user A when user B is logged in (this requires that both users have installed the companion device app and user A has registered their companion devices with PC and PC is sitting on lock screen (or logon screen)).\n\n## Security requirements\n\nThe Companion Authentication Service provides the following security protections.\n\n- Malware on a Windows 10 desktop  device running as medium user or app container cannot use the companion device to access user credential keys (stored as part of Microsoft Passport) on PC silently.\n- A malicious user on a Windows 10 desktop device cannot use the companion device that belongs to another user on that Windows 10 desktop device to get silent access to his user credential keys (on the same Windows 10 desktop device).\n- Malware on the companion device cannot silently get access to user credential keys on Windows 10 desktop  device, including leveraging functionality or code developed specifically for the Companion Device Framework.\n- A malicious user cannot unlock Windows 10 desktop  device by capturing traffic between the companion device and the Windows 10 desktop  device and replaying it later. Usage of nonce, authkey, and HMAC in our protocol guarantees protection against a replay attack.\n- Malware or a malicious user on a rouge PC cannot use companion device to get access to honest user PC. This is achieved through mutual authentication between Companion Authenticaiton Service and companion device through usage of authkey and HMAC in our protocol.\n\nThe key to achieve the security protections enumerated above is to protect HMAC keys from unauthorized access and also verifying user presence. More specifically, it must satisfy these requirements:\n\n- Provide protection against cloning the companion device\n- Provide protection against eavesdropping when sending HMAC keys at registration time to PC\n- Make sure that user presence signal is available.\n"}