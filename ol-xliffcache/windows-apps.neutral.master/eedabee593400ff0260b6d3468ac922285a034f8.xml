{"nodes":[{"content":"Enable usermode access on Windows 10 IoT Core","pos":[29,74]},{"content":"This tutorial describes how to enable usermode access to GPIO, I2C, SPI, and UART on Windows 10 IoT Core.","pos":[88,193]},{"content":"Enable usermode access on Windows 10 IoT Core","pos":[200,245]},{"content":"Updated for UWP apps on Windows 10.","pos":[250,285]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[286,378]},{"content":"Windows 10 IoT Core contains new APIs for accessing GPIO, I2C, SPI, and UART directly from usermode.","pos":[384,484]},{"content":"Development boards like Raspberry Pi 2 expose a subset of these connections which enable users to extend a base compute module with custom circuitry to address a particular application.","pos":[485,670]},{"content":"These low level buses are usually shared with other critical onboard functions, with only a subset of GPIO pins and buses exposed on headers.","pos":[671,812]},{"content":"To preserve system stability, it is necessary to specify which pins and buses are safe for modification by usermode applications.","pos":[813,942]},{"content":"This document describes how to specify this configuration in ACPI and provides tools to validate that the configuration was specified correctly.","pos":[945,1089]},{"pos":[1094,1241],"content":"[!IMPORTANT]\nThe audience for this document is UEFI and ACPI developers. Some familiarity with ACPI, ASL authoring, and SpbCx/GpioClx is assumed.","leadings":["","> "],"nodes":[{"content":"The audience for this document is UEFI and ACPI developers.","pos":[13,72]},{"content":"Some familiarity with ACPI, ASL authoring, and SpbCx/GpioClx is assumed.","pos":[73,145]}]},{"content":"Usermode access to low level buses on Windows is plumbed through the existing <ph id=\"ph1\">`GpioClx`</ph> and <ph id=\"ph2\">`SpbCx`</ph> frameworks.","pos":[1243,1354]},{"content":"A new driver called <bpt id=\"p1\">*</bpt>RhProxy<ept id=\"p1\">*</ept>, only available on Windows 10 IoT Core, exposes <ph id=\"ph1\">`GpioClx`</ph> and <ph id=\"ph2\">`SpbCx`</ph> resources to usermode.","pos":[1355,1477]},{"content":"To enable the APIs, a device node for rhproxy must be declared in your ACPI tables with each of the GPIO and SPB resources that should be exposed to usermode.","pos":[1478,1636]},{"content":"This document walks through authoring and verifying the ASL.","pos":[1637,1697]},{"content":"ASL by example","pos":[1704,1718]},{"content":"Let’s walk through the rhproxy device node declaration on Raspberry Pi 2.","pos":[1720,1793]},{"content":"First, create the ACPI device declaration in the <ph id=\"ph1\">\\\\</ph>_SB scope.","pos":[1794,1855]},{"content":"_HID – Hardware Id.","pos":[1970,1989]},{"content":"Set this to a vendor-specific hardware ID.","pos":[1990,2032]},{"content":"_CID – Compatible Id.","pos":[2036,2057]},{"content":"Must be “MSFT8000”.","pos":[2058,2077]},{"content":"_UID – Unique Id.","pos":[2082,2099]},{"content":"Set to 1.","pos":[2100,2109]},{"content":"Next we declare each of the GPIO and SPB resources that should be exposed to usermode.","pos":[2113,2199]},{"content":"The order in which resources are declared is important because resource indexes are used to associate properties with resources.","pos":[2200,2328]},{"content":"If there are multiple I2C or SPI busses exposed, the first declared bus is considered the ‘default’ bus for that type, and will be the instance returned by the <ph id=\"ph1\">`GetDefaultAsync()`</ph> methods of <bpt id=\"p1\">[</bpt>Windows.Devices.I2c.I2cController<ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.devices.i2c.i2ccontroller.aspx)</ept> and <bpt id=\"p2\">[</bpt>Windows.Devices.Spi.SpiController<ept id=\"p2\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.devices.spi.spicontroller.aspx)</ept>.","pos":[2329,2784]},{"content":"SPI","pos":[2791,2794]},{"content":"Raspberry Pi has two exposed SPI buses.","pos":[2797,2836]},{"content":"SPI0 has two hardware chip select lines and SPI1 has one hardware chip select line.","pos":[2837,2920]},{"content":"One SPISerialBus() resource declaration is required for each chip select line for each bus.","pos":[2921,3012]},{"content":"The following two SPISerialBus resource declarations are for the two chip select lines on SPI0.","pos":[3013,3108]},{"content":"The DeviceSelection field contains a unique value which the driver interprets as a hardware chip select line identifier.","pos":[3109,3229]},{"content":"The exact value that you put in the DeviceSelection field depends on how your driver interprets this field of the ACPI connection descriptor.","pos":[3230,3371]},{"content":"How does software know that these two resources should be associated with the same bus?","pos":[5125,5212]},{"content":"The mapping between bus friendly name and resource index is specified in the DSD:","pos":[5213,5294]},{"content":"This creates a bus named “SPI0” with two chip select lines – resource indexes 0 and 1.","pos":[5361,5447]},{"content":"Several more properties are required to declare the capabilities of the SPI bus.","pos":[5448,5528]},{"content":"The <bpt id=\"p1\">**</bpt>MinClockInHz<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>MaxClockInHz<ept id=\"p2\">**</ept> properties specify the minimum and maximum clock speeds that are supported by the controller.","pos":[5634,5769]},{"content":"The API will prevent users from specifying values outside this range.","pos":[5770,5839]},{"content":"The clock speed is passed to your SPB driver in the _SPE field of the connection descriptor (ACPI section 6.4.3.8.2.2).","pos":[5840,5959]},{"content":"The <bpt id=\"p1\">**</bpt>SupportedDataBitLengths<ept id=\"p1\">**</ept> property lists the data bit lengths supported by the controller.","pos":[6039,6135]},{"content":"Multiple values can be specified in a comma-separated list.","pos":[6136,6195]},{"content":"The API will prevent users from specifying values outside this list.","pos":[6196,6264]},{"content":"The data bit length is passed to your SPB driver in the _LEN field of the connection descriptor (ACPI section 6.4.3.8.2.2).","pos":[6265,6388]},{"content":"You can think of these resource declarations as “templates.”","pos":[6392,6452]},{"content":"Some of the fields are fixed at system boot while others are specified dynamically at runtime.","pos":[6453,6547]},{"content":"The following fields of the SPISerialBus descriptor are fixed:","pos":[6548,6610]},{"content":"DeviceSelection","pos":[6615,6630]},{"content":"DeviceSelectionPolarity","pos":[6634,6657]},{"content":"WireMode","pos":[6661,6669]},{"content":"SlaveMode","pos":[6673,6682]},{"content":"ResourceSource","pos":[6686,6700]},{"content":"The following fields are placeholders for values specified by the user at runtime:","pos":[6703,6785]},{"content":"DataBitLength","pos":[6790,6803]},{"content":"ConnectionSpeed","pos":[6807,6822]},{"content":"ClockPolarity","pos":[6826,6839]},{"content":"ClockPhase","pos":[6843,6853]},{"pos":[6856,6955],"content":"Since SPI1 contains only a single chip select line, a single <ph id=\"ph1\">`SPISerialBus()`</ph> resource is declared:"},{"content":"The accompanying friendly name declaration – which is required – is specified in the DSD and refers to the index of this resource declaration.","pos":[7840,7982]},{"content":"This creates a bus named “SPI1” and associates it with resource index 2.","pos":[8045,8117]},{"content":"SPI Driver Requirements","pos":[8126,8149]},{"pos":[8154,8193],"content":"Must use <ph id=\"ph1\">`SpbCx`</ph> or be SpbCx-compatible"},{"pos":[8197,8301],"content":"Must have passed the <bpt id=\"p1\">[</bpt>MITT SPI Tests<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/dn919873.aspx)</ept>"},{"content":"Must support 4Mhz clock speed","pos":[8304,8333]},{"content":"Must support 8-bit data length","pos":[8337,8367]},{"content":"Must support all SPI Modes: 0, 1, 2, 3","pos":[8371,8409]},{"content":"I2C","pos":[8416,8419]},{"content":"Next, we declare the I2C resources.","pos":[8422,8457]},{"content":"Raspberry Pi exposes a single I2C bus on pins 3 and 5.","pos":[8458,8512]},{"content":"The accompanying friendly name declaration – which is required – is specified in the DSD:","pos":[8985,9074]},{"content":"This declares an I2C bus with friendly name “I2C1” that refers to resource index 3, which is the index of the I2CSerialBus() resource that we declared above.","pos":[9137,9294]},{"content":"The following fields of the I2CSerialBus() descriptor are fixed:","pos":[9297,9361]},{"content":"SlaveMode","pos":[9366,9375]},{"content":"ResourceSource","pos":[9379,9393]},{"content":"The following fields are placeholders for values specified by the user at runtime.","pos":[9396,9478]},{"content":"SlaveAddress","pos":[9483,9495]},{"content":"ConnectionSpeed","pos":[9499,9514]},{"content":"AddressingMode","pos":[9518,9532]},{"content":"I2C Driver Requirements","pos":[9540,9563]},{"content":"Must use SpbCx or be SpbCx-compatible","pos":[9568,9605]},{"pos":[9609,9713],"content":"Must have passed the <bpt id=\"p1\">[</bpt>MITT I2C Tests<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/dn919852.aspx)</ept>"},{"content":"Must support 7-bit addressing","pos":[9717,9746]},{"content":"Must support 100kHz clock speed","pos":[9750,9781]},{"content":"Must support 400kHz clock speed","pos":[9785,9816]},{"content":"GPIO","pos":[9823,9827]},{"content":"Next, we declare all the GPIO pins that are exposed to usermode.","pos":[9830,9894]},{"content":"We offer the following guidance in deciding which pins to expose:","pos":[9895,9960]},{"content":"Declare all pins on exposed headers.","pos":[9965,10001]},{"content":"Declare pins that are connected to useful onboard functions like buttons and LEDs.","pos":[10005,10087]},{"content":"Do not declare pins that are reserved for system functions or are not connected to anything.","pos":[10091,10183]},{"content":"The following block of ASL declares two pins – GPIO4 and GPIO5.","pos":[10186,10249]},{"content":"The other pins are not shown here for brevity.","pos":[10250,10296]},{"content":"Appendix C contains a sample powershell script which can be used to generate the GPIO resources.","pos":[10297,10393]},{"content":"The following requirements must be observed when declaring GPIO pins:","pos":[10701,10770]},{"content":"Only memory mapped GPIO controllers are supported.","pos":[10775,10825]},{"content":"GPIO controllers interfaced over I2C/SPI are not supported.","pos":[10826,10885]},{"content":"The controller driver is a memory mapped controller if it sets the <bpt id=\"p1\">[</bpt>MemoryMappedController<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/hh439449.aspx)</ept> flag in the <bpt id=\"p2\">[</bpt>CLIENT_CONTROLLER_BASIC_INFORMATION<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/hardware/hh439358.aspx)</ept> structure in response to the <bpt id=\"p3\">[</bpt>CLIENT_QueryControllerBasicInformation<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/hardware/hh439399.aspx)</ept> callback.","pos":[10886,11308]},{"content":"Each pin requires both a GpioIO and a GpioInt resource.","pos":[11312,11367]},{"content":"The GpioInt resource must immediately follow the GpioIO resource and must refer to the same pin number.","pos":[11368,11471]},{"content":"GPIO resources must be ordered by increasing pin number.","pos":[11475,11531]},{"content":"Each GpioIO and GpioInt resource must contain exactly one pin number in the pin list.","pos":[11535,11620]},{"content":"The ShareType field of both descriptors must be Shared","pos":[11624,11678]},{"content":"The EdgeLevel field of the GpioInt descriptor must be Edge","pos":[11682,11740]},{"content":"The ActiveLevel field of the GpioInt descriptor must be ActiveBoth","pos":[11744,11810]},{"content":"The PinConfig field","pos":[11814,11833]},{"content":"Must be the same in both the GpioIO and GpioInt descriptors","pos":[11839,11898]},{"content":"Must be one of PullUp, PullDown, or PullNone.","pos":[11904,11949]},{"content":"It cannot be PullDefault.","pos":[11950,11975]},{"content":"The pull configuration must match the power-on state of the pin.","pos":[11980,12044]},{"content":"Putting the pin in the specified pull mode from power-on state must not change the state of the pin.","pos":[12045,12145]},{"content":"For example, if the datasheet specifies that the pin comes up with a pull up, specify PinConfig as PullUp.","pos":[12146,12252]},{"content":"Firmware, UEFI, and driver initialization code should not change the state of a pin from its power-on state during boot.","pos":[12256,12376]},{"content":"Only the user knows what’s attached to a pin and therefore which state transitions are safe.","pos":[12377,12469]},{"content":"The power-on state of each pin must be documented so that users can design hardware that correctly interfaces with a pin.","pos":[12470,12591]},{"content":"A pin must not change state unexpectedly during boot.","pos":[12592,12645]},{"content":"If an exposed pin has multiple alternate functions, it is the responsibility of firmware to initialize the pin in the correct mux configuration for subsequent use by the OS.","pos":[12648,12821]},{"content":"Dynamically changing the function of a pin (“muxing”) is not currently supported on Windows.","pos":[12822,12914]},{"content":"Supported Drive Modes","pos":[12922,12943]},{"content":"If your GPIO controller supports built-in pull up and pull down resistors in addition to high impedance input and CMOS output, you must specify this with the optional SupportedDriveModes property.","pos":[12946,13142]},{"content":"The SupportedDriveModes property indicates which drive modes are supported by the GPIO controller.","pos":[13207,13305]},{"content":"In the example above, all of the following drive modes are supported.","pos":[13306,13375]},{"content":"The property is a bitmask of the following values:","pos":[13376,13426]},{"content":"Flag Value","pos":[13431,13441]},{"content":"Drive Mode","pos":[13444,13454]},{"content":"Description","pos":[13457,13468]},{"content":"0x1","pos":[13515,13518]},{"content":"InputHighImpedance","pos":[13528,13546]},{"content":"The pin supports high impedance input, which corresponds to the “PullNone” value in ACPI.","pos":[13549,13638]},{"content":"0x2","pos":[13643,13646]},{"content":"InputPullUp","pos":[13656,13667]},{"content":"The pin supports a built-in pull-up resistor, which corresponds to the “PullUp” value in ACPI.","pos":[13670,13764]},{"content":"0x4","pos":[13769,13772]},{"content":"InputPullDown","pos":[13782,13795]},{"content":"The pin supports a built-in pull-down resistor, which corresponds to the “PullDown” value in ACPI.","pos":[13798,13896]},{"content":"0x8","pos":[13901,13904]},{"content":"OutputCmos","pos":[13914,13924]},{"content":"The pin supports generating both strong highs and strong lows (as opposed to open drain).","pos":[13927,14016]},{"content":"InputHighImpedance and OutputCmos are supported by almost all GPIO controllers.","pos":[14020,14099]},{"content":"If the SupportedDriveModes property is not specified, this is the default.","pos":[14100,14174]},{"content":"If a GPIO signal goes through a level shifter before reaching an exposed header, declare the drive modes supported by the SOC, even if the drive mode would not be observable on the external header.","pos":[14177,14374]},{"content":"For example, if a pin goes through a bidirectional level shifter that makes a pin appear as open drain with resistive pull up, you will never observe a high impedance state on the exposed header even if the pin is configured as a high impedance input.","pos":[14375,14626]},{"content":"You should still declare that the pin supports high impedance input.","pos":[14627,14695]},{"content":"Pin Numbering","pos":[14703,14716]},{"content":"Windows supports two pin numbering schemes:","pos":[14719,14762]},{"content":"Sequential Pin Numbering – Users see numbers like 0, 1, 2 …","pos":[14767,14826]},{"content":"up to the number of exposed pins.","pos":[14827,14860]},{"content":"0 is the first GpioIo resource declared in ASL, 1 is the second GpioIo resource declared in ASL, and so on.","pos":[14861,14968]},{"content":"Native Pin Numbering – Users see the pin numbers specified in GpioIo descriptors, e.g. 4, 5, 12, 13, …","pos":[14972,15074]},{"content":".","pos":[15075,15076]},{"content":"The <bpt id=\"p1\">**</bpt>UseDescriptorPinNumbers<ept id=\"p1\">**</ept> property tells Windows to use native pin numbering instead of sequential pin numbering.","pos":[15144,15263]},{"content":"If the UseDescriptorPinNumbers property is not specified or its value is zero, Windows will default to Sequential pin numbering.","pos":[15264,15392]},{"pos":[15395,15476],"content":"If native pin numbering is used, you must also specify the <bpt id=\"p1\">**</bpt>PinCount<ept id=\"p1\">**</ept> property."},{"pos":[15529,15770],"content":"The <bpt id=\"p1\">**</bpt>PinCount<ept id=\"p1\">**</ept> property should match the value returned through the <bpt id=\"p2\">**</bpt>TotalPins<ept id=\"p2\">**</ept> property in the <bpt id=\"p3\">[</bpt>CLIENT_QueryControllerBasicInformation<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/hardware/hh439399.aspx)</ept> callback of the <ph id=\"ph1\">`GpioClx`</ph> driver."},{"content":"Choose the numbering scheme that is most compatible with existing published documentation for your board.","pos":[15773,15878]},{"content":"For example, Raspberry Pi uses native pin numbering because many existing pinout diagrams use the BCM2835 pin numbers.","pos":[15879,15997]},{"content":"MinnowBoardMax uses sequential pin numbering because there are few existing pinout diagrams, and sequential pin numbering simplifies the developer experience because only 10 pins are exposed out of more than 200 pins.","pos":[15998,16215]},{"content":"The decision to use sequential or native pin numbering should aim to reduce developer confusion.","pos":[16216,16312]},{"content":"GPIO Driver Requirements","pos":[16320,16344]},{"pos":[16349,16357],"content":"Must use"},{"content":"Must be on-SOC memory mapped","pos":[16370,16398]},{"content":"Must use emulated ActiveBoth interrupt handling","pos":[16402,16449]},{"content":"UART","pos":[16456,16460]},{"content":"UART is not supported on Raspberry Pi at the time of writing, so the following UART declaration is from MinnowBoardMax.","pos":[16463,16582]},{"content":"Only the ResourceSource field is fixed while all other fields are placeholders for values specified at runtime by the user.","pos":[17341,17464]},{"content":"The accompanying friendly name declaration is:","pos":[17467,17513]},{"content":"This assigns the friendly name “UART2” to the controller, which is the identifier users will use to access the bus from usermode.","pos":[17578,17707]},{"content":"Runtime Pin Muxing","pos":[17714,17732]},{"content":"Pin muxing is the ability to use the same physical pin for different functions.","pos":[17735,17814]},{"content":"Several different on-chip peripherals, such as an I2C controller, SPI controller, and GPIO controller, might be routed to the same physical pin on a SOC.","pos":[17815,17968]},{"content":"The mux block controls which function is active on the pin at any given time.","pos":[17969,18046]},{"content":"Traditionally, firmware is responsible for establishing function assignments at boot, and this assignment remains static through the boot session.","pos":[18047,18193]},{"content":"Runtime pin muxing adds the ability to reconfigure pin function assignments at runtime.","pos":[18194,18281]},{"content":"Enabling users to choose a pin’s function at runtime speeds development by enabling users to quickly reconfigure a board’s pins, and enables hardware to support a broader range of applications than would a static configuration.","pos":[18282,18509]},{"content":"Users consume muxing support for GPIO, I2C, SPI, and UART without writing any additional code.","pos":[18512,18606]},{"content":"When a user opens a GPIO or bus using <bpt id=\"p1\">[</bpt>OpenPin()<ept id=\"p1\">](https://msdn.microsoft.com/library/dn960157.aspx)</ept> or <bpt id=\"p2\">[</bpt>FromIdAsync()<ept id=\"p2\">](https://msdn.microsoft.com/windows.devices.i2c.i2cdevice.fromidasync)</ept>, the underlying physical pins are automatically muxed to the requested function.","pos":[18607,18876]},{"content":"If the pins are already in use by a different function, the OpenPin() or FromIdAsync() call will fail.","pos":[18877,18979]},{"content":"When the user closes the device by disposing the <bpt id=\"p1\">[</bpt>GpioPin<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.devices.gpio.gpiopin.aspx)</ept>, <bpt id=\"p2\">[</bpt>I2cDevice<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/windows.devices.i2c.i2cdevice.aspx)</ept>, <bpt id=\"p3\">[</bpt>SpiDevice<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/windows.devices.spi.spidevice.aspx)</ept>, or <bpt id=\"p4\">[</bpt>SerialDevice<ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/windows.devices.serialcommunication.serialdevice.aspx)</ept> object, the pins are released, allowing them to later be opened for a different function.","pos":[18980,19527]},{"content":"Windows contains built-in support for pin muxing in the <bpt id=\"p1\">[</bpt>GpioClx<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/hh439515.aspx)</ept>, <bpt id=\"p2\">[</bpt>SpbCx<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/hardware/hh406203.aspx)</ept>, and <bpt id=\"p3\">[</bpt>SerCx<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/hardware/dn265349.aspx)</ept> frameworks.","pos":[19530,19830]},{"content":"These frameworks work together to automatically switch a pin to the correct function when a GPIO pin or bus is accessed.","pos":[19831,19951]},{"content":"Access to the pins is arbitrated to prevent conflicts among multiple clients.","pos":[19952,20029]},{"content":"In addition to this built-in support, the interfaces and protocols for pin muxing are general purpose and can be extended to support additional devices and scenarios.","pos":[20030,20196]},{"content":"This document first describes the underlying interfaces and protocols involved in pin muxing, and then describes how to add support for pin muxing to GpioClx, SpbCx, and SerCx controller drivers.","pos":[20199,20394]},{"content":"Pin Muxing Architecture","pos":[20401,20424]},{"content":"This section describes the underlying interfaces and protocols involved in pin muxing.","pos":[20427,20513]},{"content":"Knowledge of the underlying protocols is not necessarily needed to support pin muxing with GpioClx/SpbCx/SerCx drivers.","pos":[20514,20633]},{"content":"For details on how to support pin muxing with GpioCls/SpbCx/SerCx drivers, see <bpt id=\"p1\">[</bpt>Implementing pin muxing support in GpioClx client drivers<ept id=\"p1\">](#supporting-muxing-support-in-GpioClx-client-drivers)</ept> and <bpt id=\"p2\">[</bpt>Consuming muxing support in SpbCx and SerCx controller drivers<ept id=\"p2\">](#supporting-muxing-in-SpbCx-and-SerCx-controller-drivers)</ept>.","pos":[20634,20954]},{"content":"Pin muxing is accomplished by the cooperation of several components.","pos":[20957,21025]},{"content":"Pin muxing servers – these are drivers that control the pin muxing control block.","pos":[21030,21111]},{"content":"Pin muxing servers receive pin muxing requests from clients via requests to reserve muxing resources (via <bpt id=\"p1\">*</bpt>IRP_MJ_CREATE<ept id=\"p1\">*</ept>) requests, and requests to switch a pin’s function (via <bpt id=\"p2\">*</bpt>IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS<ept id=\"p2\">*</ept> requests).","pos":[21112,21341]},{"content":"The pin muxing server is usually the GPIO driver, since the muxing block is sometimes part of the GPIO block.","pos":[21342,21451]},{"content":"Even if the muxing block is a separate peripheral, the GPIO driver is a logical place to put muxing functionality.","pos":[21452,21566]},{"content":"Pin muxing clients – these are drivers that consume pin muxing.","pos":[21570,21633]},{"content":"Pin muxing clients receive pin muxing resources from ACPI firmware.","pos":[21634,21701]},{"content":"Pin muxing resources are a type of connection resource and are managed by the resource hub.","pos":[21702,21793]},{"content":"Pin muxing clients reserve pin muxing resources by opening a handle to the resource.","pos":[21794,21878]},{"content":"To effect a hardware change, clients must commit the configuration by sending an <bpt id=\"p1\">*</bpt>IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS<ept id=\"p1\">*</ept> request.","pos":[21879,22009]},{"content":"Clients release pin muxing resources by closing the handle, at which point muxing configuration is reverted to its default state.","pos":[22010,22139]},{"content":"ACPI firmware – specifies muxing configuration with <ph id=\"ph1\">`MsftFunctionConfig()`</ph> resources.","pos":[22143,22228]},{"content":"MsftFunctionConfig resources express which pins, in which muxing configuration, are required by a client.","pos":[22229,22334]},{"content":"MsftFunctionConfig resources contain function number, pull configuration, and list of pin numbers.","pos":[22335,22433]},{"content":"MsftFunctionConfig resources are supplied to pin muxing clients as hardware resources, which are received by drivers in their PrepareHardware callback similarly to GPIO and SPB connection resources.","pos":[22434,22632]},{"content":"Clients receive a resource hub ID which can be used to open a handle to the resource.","pos":[22633,22718]},{"content":"You must pass the <ph id=\"ph1\">`/MsftInternal`</ph> command line switch to <ph id=\"ph2\">`asl.exe`</ph> to compile ASL files containing <ph id=\"ph3\">`MsftFunctionConfig()`</ph> descriptors since these descriptors are currently under review by the ACPI working committee.","pos":[22723,22938]},{"content":"For example:","pos":[22939,22951]},{"content":"The sequence of operations involved in pin muxing is shown below.","pos":[22986,23051]},{"content":"Pin muxing client server interaction","pos":[23056,23092]},{"pos":[23137,23317],"content":"The client receives MsftFunctionConfig resources from ACPI firmware in its <bpt id=\"p1\">[</bpt>EvtDevicePrepareHardware()<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/ff540880.aspx)</ept> callback."},{"pos":[23322,23759],"content":"The client uses the resource hub helper function <ph id=\"ph1\">`RESOURCE_HUB_CREATE_PATH_FROM_ID()`</ph> to create a path from the resource ID, then opens a handle to the path (using <bpt id=\"p1\">[</bpt>ZwCreateFile()<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/ff566424.aspx)</ept>, <bpt id=\"p2\">[</bpt>IoGetDeviceObjectPointer()<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/hardware/ff549198.aspx)</ept>, or <bpt id=\"p3\">[</bpt>WdfIoTargetOpen()<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/hardware/ff548634.aspx)</ept>)."},{"pos":[23764,23956],"content":"The server extracts the resource hub ID from the file path using resource hub helper functions <ph id=\"ph1\">`RESOURCE_HUB_ID_FROM_FILE_NAME()`</ph>, then queries the resource hub to get the resource descriptor."},{"content":"The server performs sharing arbitration for each pin in the descriptor and completes the IRP_MJ_CREATE request.","pos":[23961,24072]},{"pos":[24077,24170],"content":"The client issues an <bpt id=\"p1\">*</bpt>IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS<ept id=\"p1\">*</ept> request on the received handle."},{"pos":[24175,24334],"content":"In response to <bpt id=\"p1\">*</bpt>IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS<ept id=\"p1\">*</ept>, the server performs the hardware muxing operation by making the specified function active on each pin."},{"content":"The client proceeds with operations that depend on the requested pin muxing configuration.","pos":[24339,24429]},{"content":"When the client no longer requires the pins to be muxed, it closes the handle.","pos":[24434,24512]},{"content":"In response to the handle being closed, the server reverts the pins back to their initial state.","pos":[24517,24613]},{"content":"Protocol description for pin muxing clients","pos":[24619,24662]},{"content":"This section describes how a client consumes pin muxing functionality.","pos":[24664,24734]},{"content":"This does not apply to <ph id=\"ph1\">`SerCx`</ph> and <ph id=\"ph2\">`SpbCx`</ph> controller drivers, since the frameworks implement this protocol on behalf of controller drivers.","pos":[24735,24875]},{"content":"Parsing resources","pos":[24885,24902]},{"content":"A WDF driver receives <ph id=\"ph1\">`MsftFunctionConfig()`</ph> resources in its <bpt id=\"p1\">[</bpt>EvtDevicePrepareHardware()<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/ff540880.aspx)</ept> routine.","pos":[24904,25070]},{"content":"MsftFunctionConfig resources can be identified by the following fields:","pos":[25071,25142]},{"pos":[25414,25508],"content":"An <ph id=\"ph1\">`EvtDevicePrepareHardware()`</ph> routine might extract MsftFunctionConfig resources as follows:"},{"content":"Reserving and committing resources","pos":[27359,27393]},{"content":"When a client wants to mux pins, it reserves and commits the MsftFunctionConfig resource.","pos":[27395,27484]},{"content":"The following example shows how a client might reserve and commit MsftFunctionConfig resources.","pos":[27485,27580]},{"content":"The driver should store the WDFIOTARGET in one of its context areas so that it can be closed later.","pos":[29423,29522]},{"content":"When the driver is ready to release the muxing configuration, it should close the resource handle by calling <bpt id=\"p1\">[</bpt>WdfObjectDelete()<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/ff548734.aspx)</ept>, or <bpt id=\"p2\">[</bpt>WdfIoTargetClose()<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/hardware/ff548586.aspx)</ept> if you intend to reuse the WDFIOTARGET.","pos":[29523,29850]},{"content":"When the client closes its resource handle, the pins are muxed back to their initial state, and can now be acquired by a different client.","pos":[29901,30039]},{"content":"Protocol description for pin muxing servers","pos":[30045,30088]},{"content":"This section describes how a pin muxing server exposes its functionality to clients.","pos":[30090,30174]},{"content":"This does not apply to <ph id=\"ph1\">`GpioClx`</ph> miniport drivers, since the framework implements this protocol on behalf of client drivers.","pos":[30175,30299]},{"content":"For details on how to support pin muxing in <ph id=\"ph1\">`GpioClx`</ph> client drivers, see <bpt id=\"p1\">[</bpt>Implementing muxing support in GpioClx Client Drivers<ept id=\"p1\">](#supporting-muxing-support-in-GpioClx-client-drivers)</ept>.","pos":[30300,30484]},{"content":"Handling IRP_MJ_CREATE requests","pos":[30494,30525]},{"content":"Clients open a handle to a resource when they want to reserve a pin muxing resource.","pos":[30527,30611]},{"content":"A pin muxing server receives <bpt id=\"p1\">*</bpt>IRP_MJ_CREATE<ept id=\"p1\">*</ept> requests by way of a reparse operation from the resource hub.","pos":[30612,30718]},{"content":"The trailing path component of the <bpt id=\"p1\">*</bpt>IRP_MJ_CREATE<ept id=\"p1\">*</ept> request contains the resource hub ID, which is a 64-bit integer in hexadecimal format.","pos":[30719,30856]},{"content":"The server should extract the resource hub ID from the filename using <ph id=\"ph1\">`RESOURCE_HUB_ID_FROM_FILE_NAME()`</ph> from reshub.h, and send <bpt id=\"p1\">*</bpt>IOCTL_RH_QUERY_CONNECTION_PROPERTIES<ept id=\"p1\">*</ept> to the resource hub to obtain the <ph id=\"ph2\">`MsftFunctionConfig()`</ph> descriptor.","pos":[30857,31093]},{"content":"The server should validate the descriptor and extract the sharing mode and pin list from the descriptor.","pos":[31095,31199]},{"content":"It should then perform sharing arbitration for the pins, and if successful, mark the pins as reserved before completing the request.","pos":[31200,31332]},{"content":"Sharing arbitration succeeds overall if sharing arbitration succeeds for each pin in the pin list.","pos":[31334,31432]},{"content":"Each pin should be arbitrated as follows:","pos":[31433,31474]},{"content":"If the pin is not already reserved, sharing arbitration succeeds.","pos":[31480,31545]},{"content":"If the pin is already reserved as exclusive, sharing arbitration fails.","pos":[31550,31621]},{"content":"If the pin is already reserved as shared,","pos":[31626,31667]},{"content":"and the incoming request is shared, sharing arbitration succeeds.","pos":[31672,31737]},{"content":"and the incoming request is exclusive, sharing arbitration fails.","pos":[31742,31807]},{"content":"If sharing arbitration fails, the request should be completed with <bpt id=\"p1\">*</bpt>STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE<ept id=\"p1\">*</ept>.","pos":[31809,31916]},{"content":"If sharing arbitration succeeds, the request should completed with <bpt id=\"p1\">*</bpt>STATUS_SUCCESS<ept id=\"p1\">*</ept>.","pos":[31917,32001]},{"pos":[32003,32220],"content":"Note that the sharing mode of the incoming request should be taken from the MsftFunctionConfig descriptor, not <bpt id=\"p1\">[</bpt>IrpSp-&gt;Parameters.Create.ShareAccess<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/ff548630.aspx)</ept>."},{"content":"Handling IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS requests","pos":[32230,32286]},{"content":"After the client has successfully reserved a MsftFunctionConfig resource by opening a handle, it can send <bpt id=\"p1\">*</bpt>IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS<ept id=\"p1\">*</ept> to request the server to perform the actual hardware muxing operation.","pos":[32288,32505]},{"content":"When the server receives <bpt id=\"p1\">*</bpt>IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS<ept id=\"p1\">*</ept>, for each pin in the pin list it should","pos":[32506,32611]},{"content":"Set the pull mode specified in the PinConfiguration member of the PNP_FUNCTION_CONFIG_DESCRIPTOR structure into hardware.","pos":[32618,32739]},{"content":"Mux the pin to the function specified by the FunctionNumber member of the PNP_FUNCTION_CONFIG_DESCRIPTOR structure.","pos":[32744,32859]},{"pos":[32861,32927],"content":"The server should then complete the request with <bpt id=\"p1\">*</bpt>STATUS_SUCCESS<ept id=\"p1\">*</ept>."},{"content":"The meaning of FunctionNumber is defined by the server, and it is understood that the MsftFunctionConfig descriptor was authored with knowledge of how the server interprets this field.","pos":[32929,33113]},{"content":"Remember that when the handle is closed, the server will have to revert the pins to the configuration they were in when IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS was received, so the server may need to save the pins’ state before modifying them.","pos":[33115,33357]},{"content":"Handling IRP_MJ_CLOSE requests","pos":[33367,33397]},{"content":"When a client no longer requires a muxing resource, it closes its handle.","pos":[33399,33472]},{"content":"When a server receives a <bpt id=\"p1\">*</bpt>IRP_MJ_CLOSE<ept id=\"p1\">*</ept> request, it should revert the pins to the state they were in when <bpt id=\"p2\">*</bpt>IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS<ept id=\"p2\">*</ept> was received.","pos":[33473,33633]},{"content":"If the client never sent a <bpt id=\"p1\">*</bpt>IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS<ept id=\"p1\">*</ept>, no action is necessary.","pos":[33634,33726]},{"content":"The server should then mark the pins as available with respect to sharing arbitration, and complete the request with <bpt id=\"p1\">*</bpt>STATUS_SUCCESS<ept id=\"p1\">*</ept>.","pos":[33727,33861]},{"content":"Be sure to properly synchronize <bpt id=\"p1\">*</bpt>IRP_MJ_CLOSE<ept id=\"p1\">*</ept> handling with <bpt id=\"p2\">*</bpt>IRP_MJ_CREATE<ept id=\"p2\">*</ept> handling.","pos":[33862,33948]},{"content":"Authoring guidelines for ACPI tables","pos":[33954,33990]},{"content":"This section describes how to supply muxing resources to client drivers.","pos":[33992,34064]},{"content":"Note that you will need Microsoft ASL compiler build 14327 or later to compile tables containing <ph id=\"ph1\">`MsftFunctionConfig()`</ph> resources.","pos":[34065,34195]},{"content":"resources are supplied to pin muxing clients as hardware resources.","pos":[34219,34286]},{"content":"resources should be supplied to drivers that require pin muxing changes, which are typically SPB and serial controller drivers, but should not be supplied to SPB and serial peripheral drivers, since the controller driver handles muxing configuration.","pos":[34310,34560]},{"content":"The <ph id=\"ph1\">`MsftFunctionConfig()`</ph> ACPI macro is defined as follows:","pos":[34561,34621]},{"content":"Shared/Exclusive – If exclusive, this pin can be acquired by a single client at a time.","pos":[34900,34987]},{"content":"If shared, multiple shared clients can acquire the resource.","pos":[34988,35048]},{"content":"Always set this to exclusive since allowing multiple uncoordinated clients to access a mutable resource can lead to data races and therefore unpredictable results.","pos":[35049,35212]},{"content":"PinPullConfig – one of","pos":[35216,35238]},{"content":"PullDefault – use the SOC-defined power-on default pull configuration","pos":[35244,35313]},{"content":"PullUp – enable pull-up resistor","pos":[35319,35351]},{"content":"PullDown – enable pull-down resistor","pos":[35357,35393]},{"content":"PullNone – disable all pull resistors","pos":[35399,35436]},{"content":"FunctionNumber – the function number to program into the mux.","pos":[35440,35501]},{"content":"ResourceSource – The ACPI namespace path of the pin muxing server","pos":[35505,35570]},{"content":"ResourceSourceIndex – set this to 0","pos":[35574,35609]},{"content":"ResourceConsumer/ResourceProducer – set this to ResourceConsumer","pos":[35613,35677]},{"content":"VendorData – optional binary data whose meaning is defined by the pin muxing server.","pos":[35681,35765]},{"content":"This should usually be left blank","pos":[35766,35799]},{"content":"Pin List – a comma separated list of pin numbers to which the configuration applies.","pos":[35802,35886]},{"content":"When the pin muxing server is a GpioClx driver, these are GPIO pin numbers and have the same meaning as pin numbers in a GpioIo descriptor.","pos":[35887,36026]},{"content":"The following example shows how one might supply a MsftFunctionConfig() resource to an I2C controller driver.","pos":[36029,36138]},{"content":"In addition to the memory and interrupt resources typically required by a controller driver, a <ph id=\"ph1\">`MsftFunctionConfig()`</ph> resource is also specified.","pos":[36669,36814]},{"content":"This resource enables the I2C controller driver to put pins 2 and 3 - managed by the device node at <ph id=\"ph1\">\\\\</ph>_SB.GPIO0 – in function 4 with pull-up resistor enabled.","pos":[36815,36973]},{"content":"Supporting muxing support in GpioClx client drivers","pos":[36980,37031]},{"content":"has built-in support for pin muxing.","pos":[37044,37080]},{"content":"GpioClx miniport drivers (also referred to as “GpioClx client drivers”), drive GPIO controller hardware.","pos":[37081,37185]},{"content":"As of Windows 10 build 14327, GpioClx miniport drivers can add support for pin muxing by implementing two new DDIs:","pos":[37186,37301]},{"pos":[37306,37436],"content":"CLIENT_ConnectFunctionConfigPins – called by <ph id=\"ph1\">`GpioClx`</ph> to command the miniport driver to apply the specified muxing configuration."},{"pos":[37440,37564],"content":"CLIENT_DisconnectFunctionConfigPins – called by <ph id=\"ph1\">`GpioClx`</ph> to command the miniport driver to revert the muxing configuration."},{"pos":[37567,37709],"content":"See <bpt id=\"p1\">[</bpt>GpioClx Event Callback Functions<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/hh439464.aspx)</ept> for a description of these routines."},{"content":"In addition to these two new DDIs, existing DDIs should be audited for pin muxing compatibility:","pos":[37711,37807]},{"content":"CLIENT_ConnectIoPins/CLIENT_ConnectInterrupt – CLIENT_ConnectIoPins is called by GpioClx to command the miniport driver to configure a set pins for GPIO input or output.","pos":[37812,37981]},{"content":"GPIO is mutually exclusive with MsftFunctionConfig, meaning a pin will never be connected for GPIO and MsftFunctionConfig at the same time.","pos":[37982,38121]},{"content":"Since a pin’s default function is not required to be GPIO, a pin may not necessarily not be muxed to GPIO when ConnectIoPins is called.","pos":[38122,38257]},{"content":"ConnectIoPins is required to perform all operations necessary to make the pin ready for GPIO IO, including muxing operations.","pos":[38258,38383]},{"content":"<bpt id=\"p1\">*</bpt>CLIENT_ConnectInterrupt<ept id=\"p1\">*</ept> should behave similarly, since interrupts can be thought of as a special case of GPIO input.","pos":[38384,38502]},{"content":"CLIENT_DisconnectIoPins/CLIENT_DisconnectInterrupt – These routine should return pins to the state they were in when CLIENT_ConnectIoPins/CLIENT_ConnectInterrupt was called, unless the PreserveConfiguration flag is specified.","pos":[38506,38731]},{"content":"In addition to reverting the direction of pins to their default state, the miniport should also revert each pin’s muxing state to the state it was in when the _Connect routine was called.","pos":[38732,38919]},{"content":"For example, assume that a pin’s default muxing configuration is UART, and the pin can also be used as GPIO.","pos":[38922,39030]},{"content":"When CLIENT_ConnectIoPins is called to connect the pin for GPIO, it should mux the pin to GPIO, and in CLIENT_DisconnectIoPins, it should mux the pin back to UART.","pos":[39031,39194]},{"content":"In general, the _Disconnect routines should undo operations done by the _Connect routines.","pos":[39195,39285]},{"content":"Supporting muxing in SpbCx and SerCx controller drivers","pos":[39292,39347]},{"content":"As of Windows 10 build 14327, the <ph id=\"ph1\">`SpbCx`</ph> and <ph id=\"ph2\">`SerCx`</ph> frameworks contain built-in support for pin muxing that enables <ph id=\"ph3\">`SpbCx`</ph> and <ph id=\"ph4\">`SerCx`</ph> controller drivers to be pin muxing clients without any code changes to the controller drivers themselves.","pos":[39350,39594]},{"content":"By extension, any SpbCx/SerCx peripheral driver that connects to a muxing-enabled SpbCx/SerCx controller driver will trigger pin muxing activity.","pos":[39595,39740]},{"content":"The following diagram shows the dependencies between each of these components.","pos":[39743,39821]},{"content":"As you can see, pin muxing introduces a dependency from SerCx and SpbCx controller drivers to the GPIO driver, which is usually responsible for muxing.","pos":[39822,39973]},{"content":"Pin muxing dependency","pos":[39978,39999]},{"content":"At device initialization time, the <ph id=\"ph1\">`SpbCx`</ph> and <ph id=\"ph2\">`SerCx`</ph> frameworks parse all <ph id=\"ph3\">`MsftFunctionConfig()`</ph> resources supplied as hardware resources to the device.","pos":[40040,40194]},{"content":"SpbCx/SerCx then acquire and release the pin muxing resources on demand.","pos":[40195,40267]},{"content":"applies pin muxing configuration in its <bpt id=\"p1\">*</bpt>IRP_MJ_CREATE<ept id=\"p1\">*</ept> handler, just before calling the client driver’s <bpt id=\"p2\">[</bpt>EvtSpbTargetConnect()<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/hardware/hh450818.aspx)</ept> callback.","pos":[40277,40482]},{"content":"If muxing configuration could not be applied, the controller driver’s <ph id=\"ph1\">`EvtSpbTargetConnect()`</ph> callback will not be called.","pos":[40483,40605]},{"content":"Therefore, an SPB controller driver may assume that pins are muxed to the SPB function by the time <ph id=\"ph1\">`EvtSpbTargetConnect()`</ph> is called.","pos":[40606,40739]},{"content":"reverts pin muxing configuration in its <bpt id=\"p1\">*</bpt>IRP_MJ_CLOSE<ept id=\"p1\">*</ept> handler, just after invoking the controller driver’s <bpt id=\"p2\">[</bpt>EvtSpbTargetDisconnect()<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/hardware/hh450820.aspx)</ept> callback.","pos":[40749,40960]},{"content":"The result is that pins are muxed to the SPB function whenever a peripheral driver opens a handle to the SPB controller driver, and are muxed away when the peripheral driver closes their handle.","pos":[40961,41155]},{"content":"behaves similarly.","pos":[41165,41183]},{"content":"acquires all <ph id=\"ph1\">`MsftFunctionConfig()`</ph> resources in its <bpt id=\"p1\">*</bpt>IRP_MJ_CREATE<ept id=\"p1\">*</ept> handler just before invoking the controller driver’s <bpt id=\"p2\">[</bpt>EvtSerCx2FileOpen()<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/hardware/dn265209.aspx)</ept> callback, and releases all resources in its IRP_MJ_CLOSE handler, just after invoking the controller driver’s <bpt id=\"p3\">[</bpt>EvtSerCx2FileClose<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/hardware/dn265208.aspx)</ept> callback.","pos":[41192,41610]},{"content":"The implication of dynamic pin muxing for <ph id=\"ph1\">`SerCx`</ph> and <ph id=\"ph2\">`SpbCx`</ph> controller drivers is that they must be able to tolerate pins being muxed away from SPB/UART function at certain times.","pos":[41612,41793]},{"content":"Controller drivers need to assume that pins will not be muxed until <ph id=\"ph1\">`EvtSpbTargetConnect()`</ph> or <ph id=\"ph2\">`EvtSerCx2FileOpen()`</ph> is called.","pos":[41794,41921]},{"content":"Pins are not necessary muxed to SPB/UART function during the following callbacks.","pos":[41922,42003]},{"content":"The following is not a complete list, but represents the most common PNP routines implemented by controller drivers.","pos":[42004,42120]},{"content":"DriverEntry","pos":[42124,42135]},{"content":"EvtDriverDeviceAdd","pos":[42139,42157]},{"content":"EvtDevicePrepareHardware/EvtDeviceReleaseHardware","pos":[42161,42210]},{"content":"EvtDeviceD0Entry/EvtDeviceD0Exit","pos":[42214,42246]},{"content":"Verification","pos":[42252,42264]},{"content":"When you’ve finished authoring your ASL, you should run the <bpt id=\"p1\">[</bpt>Hardware Lab Kit (HLK)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/hardware/dn930814.aspx)</ept> tests to verify that all resources are exposed correctly and the underlying busses meet the functional contract of the API.","pos":[42267,42542]},{"content":"The following sections describe how to load the rhproxy device node for testing without recompiling your firmware and how to run the HLK tests.","pos":[42543,42686]},{"content":"Compile and load ASL with ACPITABL.dat","pos":[42693,42731]},{"content":"The first step is to compile and load the ASL file onto your system under test.","pos":[42734,42813]},{"content":"We recommend using ACPITABL.dat during development and validation as it does not require a full UEFI rebuild to test ASL changes.","pos":[42814,42943]},{"content":"Create a file named yourboard.asl and put the RHPX device node inside a DefinitionBlock:","pos":[42949,43037]},{"content":"Download the WDK and get asl.exe","pos":[43203,43235]},{"content":"Run the following command to generate ACPITABL.dat:","pos":[43240,43291]},{"content":"Copy the resulting ACPITABL.dat file to c:\\windows\\system32 on your system under test.","pos":[43326,43412]},{"content":"Turn on testsigning on your system under test:","pos":[43417,43463]},{"content":"Reboot the system under test.","pos":[43504,43533]},{"content":"The system will append the ACPI tables defined in ACPITABL.dat to the system firmware tables.","pos":[43534,43627]},{"content":"Verify that the RHPX device node was added to the system:","pos":[43633,43690]},{"content":"The output of devcon should indicate that the device is present, although the driver may have failed to initialize if there are bugs in the ASL that need to be worked out.","pos":[43723,43894]},{"content":"Run the HLK Tests","pos":[43900,43917]},{"content":"When you select the rhproxy device node in HLK manager, the applicable tests will automatically be selected.","pos":[43919,44027]},{"content":"In the HLK manager, select “Resource Hub Proxy device”:","pos":[44029,44084]},{"content":"HLK manager screenshot","pos":[44088,44110]},{"content":"Then click the Tests tab, and select I2C WinRT, Gpio WinRT, and Spi WinRT tests.","pos":[44140,44220]},{"content":"HLK manager screenshot","pos":[44224,44246]},{"content":"Click Run Selected.","pos":[44276,44295]},{"content":"Further documentation on each test is available by right clicking on the test and clicking “Test Description.”","pos":[44296,44406]},{"content":"More testing resources","pos":[44412,44434]},{"content":"Simple command line tools for Gpio, I2c, Spi, and Serial are available on the ms-iot github samples repository  (https://github.com/ms-iot/samples).","pos":[44436,44584]},{"content":"These tools can be helpful for manual debugging.","pos":[44585,44633]},{"content":"Tool","pos":[44637,44641]},{"content":"Link","pos":[44644,44648]},{"content":"GpioTestTool","pos":[44669,44681]},{"content":"https://developer.microsoft.com/en-us/windows/iot/win10/samples/GPIOTestTool","pos":[44684,44760]},{"content":"I2cTestTool","pos":[44765,44776]},{"content":"https://developer.microsoft.com/en-us/windows/iot/win10/samples/I2cTestTool","pos":[44781,44856]},{"content":"SpiTestTool","pos":[44862,44873]},{"content":"https://developer.microsoft.com/en-us/windows/iot/win10/samples/spitesttool","pos":[44876,44951]},{"content":"MinComm (Serial)","pos":[44956,44972]},{"content":"https://github.com/ms-iot/samples/tree/develop/MinComm","pos":[44978,45032]},{"content":"Resources","pos":[45039,45048]},{"content":"Destination","pos":[45052,45063]},{"content":"Link","pos":[45066,45070]},{"content":"ACPI 5.0 specification","pos":[45098,45120]},{"content":"http://acpi.info/spec.htm","pos":[45123,45148]},{"content":"Asl.exe (Microsoft ASL Compiler)","pos":[45153,45185]},{"content":"https://msdn.microsoft.com/library/windows/hardware/dn551195.aspx","pos":[45188,45253]},{"content":"Windows.Devices.Gpio","pos":[45258,45278]},{"content":"https://msdn.microsoft.com/library/windows/apps/windows.devices.gpio.aspx","pos":[45282,45355]},{"content":"Windows.Devices.I2c","pos":[45361,45380]},{"content":"https://msdn.microsoft.com/library/windows/apps/windows.devices.i2c.aspx","pos":[45383,45455]},{"content":"Windows.Devices.Spi","pos":[45460,45479]},{"content":"https://msdn.microsoft.com/library/windows/apps/windows.devices.spi.aspx","pos":[45482,45554]},{"content":"Windows.Devices.SerialCommunication","pos":[45559,45594]},{"content":"https://msdn.microsoft.com/library/windows/apps/windows.devices.serialcommunication.aspx","pos":[45597,45685]},{"content":"Test Authoring and Execution Framework (TAEF)","pos":[45690,45735]},{"content":"https://msdn.microsoft.com/library/windows/hardware/hh439725.aspx","pos":[45738,45803]},{"content":"SpbCx","pos":[45808,45813]},{"content":"https://msdn.microsoft.com/library/windows/hardware/hh450906.aspx","pos":[45816,45881]},{"content":"GpioClx","pos":[45886,45893]},{"content":"https://msdn.microsoft.com/library/windows/hardware/hh439508.aspx","pos":[45898,45963]},{"content":"SerCx","pos":[45968,45973]},{"content":"https://msdn.microsoft.com/library/windows/hardware/ff546939.aspx","pos":[45976,46041]},{"content":"MITT I2C Tests","pos":[46046,46060]},{"content":"https://msdn.microsoft.com/library/windows/hardware/dn919852.aspx","pos":[46063,46128]},{"content":"GpioTestTool","pos":[46133,46145]},{"content":"https://developer.microsoft.com/en-us/windows/iot/win10/samples/GPIOTestTool","pos":[46148,46224]},{"content":"I2cTestTool","pos":[46229,46240]},{"content":"https://developer.microsoft.com/en-us/windows/iot/win10/samples/I2cTestTool","pos":[46245,46320]},{"content":"SpiTestTool","pos":[46326,46337]},{"content":"https://developer.microsoft.com/en-us/windows/iot/win10/samples/spitesttool","pos":[46340,46415]},{"content":"MinComm (Serial)","pos":[46420,46436]},{"content":"https://github.com/ms-iot/samples/tree/develop/MinComm","pos":[46442,46496]},{"content":"Hardware Lab Kit (HLK)","pos":[46501,46523]},{"content":"https://msdn.microsoft.com/library/windows/hardware/dn930814.aspx","pos":[46526,46591]},{"content":"Apendix","pos":[46598,46605]},{"content":"Appendix A - Raspberry Pi ASL Listing","pos":[46611,46648]},{"content":"Header pinout: https://developer.microsoft.com/en-us/windows/iot/win10/samples/PinMappingsRPi2","pos":[46650,46744]},{"content":"Appendix B - MinnowBoardMax ASL Listing","pos":[55746,55785]},{"content":"Header pinout: https://developer.microsoft.com/en-us/windows/iot/win10/samples/PinMappingsMBM","pos":[55787,55880]},{"content":"Appendix C - Sample Powershell script to generate GPIO resources","pos":[63944,64008]},{"content":"The following script can be used to generate the GPIO resource declarations for Raspberry Pi:","pos":[64010,64103]}],"content":"---\nauthor: JordanRh1\ntitle: Enable usermode access on Windows 10 IoT Core\ndescription: This tutorial describes how to enable usermode access to GPIO, I2C, SPI, and UART on Windows 10 IoT Core.\n---\n# Enable usermode access on Windows 10 IoT Core\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nWindows 10 IoT Core contains new APIs for accessing GPIO, I2C, SPI, and UART directly from usermode. Development boards like Raspberry Pi 2 expose a subset of these connections which enable users to extend a base compute module with custom circuitry to address a particular application. These low level buses are usually shared with other critical onboard functions, with only a subset of GPIO pins and buses exposed on headers. To preserve system stability, it is necessary to specify which pins and buses are safe for modification by usermode applications. \n\nThis document describes how to specify this configuration in ACPI and provides tools to validate that the configuration was specified correctly. \n\n> [!IMPORTANT]\n> The audience for this document is UEFI and ACPI developers. Some familiarity with ACPI, ASL authoring, and SpbCx/GpioClx is assumed.\n\nUsermode access to low level buses on Windows is plumbed through the existing `GpioClx` and `SpbCx` frameworks. A new driver called *RhProxy*, only available on Windows 10 IoT Core, exposes `GpioClx` and `SpbCx` resources to usermode. To enable the APIs, a device node for rhproxy must be declared in your ACPI tables with each of the GPIO and SPB resources that should be exposed to usermode. This document walks through authoring and verifying the ASL. \n\n\n## ASL by example\n\nLet’s walk through the rhproxy device node declaration on Raspberry Pi 2. First, create the ACPI device declaration in the \\\\_SB scope.  \n\n```cpp\nDevice(RHPX) \n{ \n    Name(_HID, \"MSFT8000\") \n    Name(_CID, \"MSFT8000\") \n    Name(_UID, 1) \n    \n```\n\n* _HID – Hardware Id. Set this to a vendor-specific hardware ID. \n* _CID – Compatible Id. Must be “MSFT8000”.  \n* _UID – Unique Id. Set to 1.  \n\nNext we declare each of the GPIO and SPB resources that should be exposed to usermode. The order in which resources are declared is important because resource indexes are used to associate properties with resources. If there are multiple I2C or SPI busses exposed, the first declared bus is considered the ‘default’ bus for that type, and will be the instance returned by the `GetDefaultAsync()` methods of [Windows.Devices.I2c.I2cController](https://msdn.microsoft.com/en-us/library/windows/apps/windows.devices.i2c.i2ccontroller.aspx) and [Windows.Devices.Spi.SpiController](https://msdn.microsoft.com/en-us/library/windows/apps/windows.devices.spi.spicontroller.aspx). \n\n### SPI \n\nRaspberry Pi has two exposed SPI buses. SPI0 has two hardware chip select lines and SPI1 has one hardware chip select line. One SPISerialBus() resource declaration is required for each chip select line for each bus. The following two SPISerialBus resource declarations are for the two chip select lines on SPI0. The DeviceSelection field contains a unique value which the driver interprets as a hardware chip select line identifier. The exact value that you put in the DeviceSelection field depends on how your driver interprets this field of the ACPI connection descriptor.  \n\n```cpp\n// Index 0 \nSPISerialBus(              // SCKL - GPIO 11 - Pin 23 \n                           // MOSI - GPIO 10 - Pin 19 \n                           // MISO - GPIO 9  - Pin 21 \n                           // CE0  - GPIO 8  - Pin 24 \n    0,                     // Device selection (CE0) \n    PolarityLow,           // Device selection polarity \n    FourWireMode,          // wiremode \n    0,                     // databit len: placeholder \n    ControllerInitiated,   // slave mode \n    0,                     // connection speed: placeholder \n    ClockPolarityLow,      // clock polarity: placeholder \n    ClockPhaseFirst,       // clock phase: placeholder \n    \"\\\\_SB.SPI0\",          // ResourceSource: SPI bus controller name \n    0,                     // ResourceSourceIndex \n                           // Resource usage \n    )                      // Vendor Data \n\n// Index 1 \nSPISerialBus(              // SCKL - GPIO 11 - Pin 23 \n                           // MOSI - GPIO 10 - Pin 19 \n                           // MISO - GPIO 9  - Pin 21 \n                           // CE1  - GPIO 7  - Pin 26 \n    1,                     // Device selection (CE1) \n    PolarityLow,           // Device selection polarity \n    FourWireMode,          // wiremode \n    0,                     // databit len: placeholder \n    ControllerInitiated,   // slave mode \n    0,                     // connection speed: placeholder \n    ClockPolarityLow,      // clock polarity: placeholder \n    ClockPhaseFirst,       // clock phase: placeholder \n    \"\\\\_SB.SPI0\",          // ResourceSource: SPI bus controller name \n    0,                     // ResourceSourceIndex \n                           // Resource usage \n    )                      // Vendor Data \n\n```\n\nHow does software know that these two resources should be associated with the same bus? The mapping between bus friendly name and resource index is specified in the DSD:  \n\n```cpp\nPackage(2) { \"bus-SPI-SPI0\", Package() { 0, 1 }}, \n```\n\nThis creates a bus named “SPI0” with two chip select lines – resource indexes 0 and 1. Several more properties are required to declare the capabilities of the SPI bus.  \n\n```cpp\nPackage(2) { \"SPI0-MinClockInHz\", 7629 }, \nPackage(2) { \"SPI0-MaxClockInHz\", 125000000 },\n```\n\nThe **MinClockInHz** and **MaxClockInHz** properties specify the minimum and maximum clock speeds that are supported by the controller. The API will prevent users from specifying values outside this range. The clock speed is passed to your SPB driver in the _SPE field of the connection descriptor (ACPI section 6.4.3.8.2.2).  \n\n```cpp\nPackage(2) { \"SPI0-SupportedDataBitLengths\", Package() { 8 }}, \n```\n\nThe **SupportedDataBitLengths** property lists the data bit lengths supported by the controller. Multiple values can be specified in a comma-separated list. The API will prevent users from specifying values outside this list. The data bit length is passed to your SPB driver in the _LEN field of the connection descriptor (ACPI section 6.4.3.8.2.2).  \n\nYou can think of these resource declarations as “templates.” Some of the fields are fixed at system boot while others are specified dynamically at runtime. The following fields of the SPISerialBus descriptor are fixed: \n\n* DeviceSelection \n* DeviceSelectionPolarity \n* WireMode \n* SlaveMode \n* ResourceSource \n\nThe following fields are placeholders for values specified by the user at runtime: \n\n* DataBitLength \n* ConnectionSpeed \n* ClockPolarity \n* ClockPhase \n\nSince SPI1 contains only a single chip select line, a single `SPISerialBus()` resource is declared: \n\n```cpp\n// Index 2 \n\nSPISerialBus(              // SCKL - GPIO 21 - Pin 40 \n                           // MOSI - GPIO 20 - Pin 38 \n                           // MISO - GPIO 19 - Pin 35 \n                           // CE1  - GPIO 17 - Pin 11 \n    1,                     // Device selection (CE1) \n    PolarityLow,           // Device selection polarity \n    FourWireMode,          // wiremode \n    0,                     // databit len: placeholder \n    ControllerInitiated,   // slave mode \n    0,                     // connection speed: placeholder \n    ClockPolarityLow,      // clock polarity: placeholder \n    ClockPhaseFirst,       // clock phase: placeholder \n    \"\\\\_SB.SPI1\",          // ResourceSource: SPI bus controller name \n    0,                     // ResourceSourceIndex \n                           // Resource usage \n    )                      // Vendor Data \n\n```\n\nThe accompanying friendly name declaration – which is required – is specified in the DSD and refers to the index of this resource declaration. \n\n```cpp\nPackage(2) { \"bus-SPI-SPI1\", Package() { 2 }}, \n```\n\nThis creates a bus named “SPI1” and associates it with resource index 2.  \n\n#### SPI Driver Requirements \n\n* Must use `SpbCx` or be SpbCx-compatible \n* Must have passed the [MITT SPI Tests](https://msdn.microsoft.com/library/windows/hardware/dn919873.aspx)\n* Must support 4Mhz clock speed \n* Must support 8-bit data length \n* Must support all SPI Modes: 0, 1, 2, 3 \n\n### I2C \n\nNext, we declare the I2C resources. Raspberry Pi exposes a single I2C bus on pins 3 and 5. \n\n```cpp\n// Index 3 \nI2CSerialBus(              // Pin 3 (GPIO2, SDA1), 5 (GPIO3, SCL1) \n    0xFFFF,                // SlaveAddress: placeholder \n    ,                      // SlaveMode: default to ControllerInitiated \n    0,                     // ConnectionSpeed: placeholder \n    ,                      // Addressing Mode: placeholder \n    \"\\\\_SB.I2C1\",          // ResourceSource: I2C bus controller name \n    , \n    , \n    )                      // VendorData \n\n```\n\nThe accompanying friendly name declaration – which is required – is specified in the DSD: \n\n```cpp\nPackage(2) { \"bus-I2C-I2C1\", Package() { 3 }}, \n```\n\nThis declares an I2C bus with friendly name “I2C1” that refers to resource index 3, which is the index of the I2CSerialBus() resource that we declared above. \n\nThe following fields of the I2CSerialBus() descriptor are fixed: \n\n* SlaveMode \n* ResourceSource \n\nThe following fields are placeholders for values specified by the user at runtime. \n\n* SlaveAddress \n* ConnectionSpeed \n* AddressingMode \n\n#### I2C Driver Requirements \n\n* Must use SpbCx or be SpbCx-compatible \n* Must have passed the [MITT I2C Tests](https://msdn.microsoft.com/library/windows/hardware/dn919852.aspx) \n* Must support 7-bit addressing \n* Must support 100kHz clock speed \n* Must support 400kHz clock speed \n\n### GPIO \n\nNext, we declare all the GPIO pins that are exposed to usermode. We offer the following guidance in deciding which pins to expose: \n\n* Declare all pins on exposed headers. \n* Declare pins that are connected to useful onboard functions like buttons and LEDs. \n* Do not declare pins that are reserved for system functions or are not connected to anything. \n\nThe following block of ASL declares two pins – GPIO4 and GPIO5. The other pins are not shown here for brevity. Appendix C contains a sample powershell script which can be used to generate the GPIO resources. \n\n```cpp\n// Index 4 – GPIO 4 \nGpioIO(Shared, PullUp, , , , “\\\\_SB.GPI0”, , , , ) { 4 } \nGpioInt(Edge, ActiveBoth, Shared, PullUp, 0, “\\\\_SB.GPI0”,) { 4 } \n\n// Index 6 – GPIO 5 \nGpioIO(Shared, PullUp, , , , “\\\\_SB.GPI0”, , , , ) { 5 } \nGpioInt(Edge, ActiveBoth, Shared, PullUp, 0, “\\\\_SB.GPI0”,) { 5 } \n```\n\nThe following requirements must be observed when declaring GPIO pins: \n\n* Only memory mapped GPIO controllers are supported. GPIO controllers interfaced over I2C/SPI are not supported. The controller driver is a memory mapped controller if it sets the [MemoryMappedController](https://msdn.microsoft.com/library/windows/hardware/hh439449.aspx) flag in the [CLIENT_CONTROLLER_BASIC_INFORMATION](https://msdn.microsoft.com/library/windows/hardware/hh439358.aspx) structure in response to the [CLIENT_QueryControllerBasicInformation](https://msdn.microsoft.com/library/windows/hardware/hh439399.aspx) callback. \n* Each pin requires both a GpioIO and a GpioInt resource. The GpioInt resource must immediately follow the GpioIO resource and must refer to the same pin number. \n* GPIO resources must be ordered by increasing pin number. \n* Each GpioIO and GpioInt resource must contain exactly one pin number in the pin list. \n* The ShareType field of both descriptors must be Shared \n* The EdgeLevel field of the GpioInt descriptor must be Edge \n* The ActiveLevel field of the GpioInt descriptor must be ActiveBoth \n* The PinConfig field \n  * Must be the same in both the GpioIO and GpioInt descriptors \n  * Must be one of PullUp, PullDown, or PullNone. It cannot be PullDefault.\n  * The pull configuration must match the power-on state of the pin. Putting the pin in the specified pull mode from power-on state must not change the state of the pin. For example, if the datasheet specifies that the pin comes up with a pull up, specify PinConfig as PullUp.  \n\nFirmware, UEFI, and driver initialization code should not change the state of a pin from its power-on state during boot. Only the user knows what’s attached to a pin and therefore which state transitions are safe. The power-on state of each pin must be documented so that users can design hardware that correctly interfaces with a pin. A pin must not change state unexpectedly during boot. \n\nIf an exposed pin has multiple alternate functions, it is the responsibility of firmware to initialize the pin in the correct mux configuration for subsequent use by the OS. Dynamically changing the function of a pin (“muxing”) is not currently supported on Windows. \n\n#### Supported Drive Modes \n\nIf your GPIO controller supports built-in pull up and pull down resistors in addition to high impedance input and CMOS output, you must specify this with the optional SupportedDriveModes property. \n\n```cpp\nPackage (2) { “GPIO-SupportedDriveModes”, 0xf }, \n```\n\nThe SupportedDriveModes property indicates which drive modes are supported by the GPIO controller. In the example above, all of the following drive modes are supported. The property is a bitmask of the following values: \n\n| Flag Value | Drive Mode | Description |\n|------------|------------|-------------|\n| 0x1        | InputHighImpedance | The pin supports high impedance input, which corresponds to the “PullNone” value in ACPI. |\n| 0x2        | InputPullUp | The pin supports a built-in pull-up resistor, which corresponds to the “PullUp” value in ACPI. |\n| 0x4        | InputPullDown | The pin supports a built-in pull-down resistor, which corresponds to the “PullDown” value in ACPI. |\n| 0x8        | OutputCmos | The pin supports generating both strong highs and strong lows (as opposed to open drain). |\n\nInputHighImpedance and OutputCmos are supported by almost all GPIO controllers. If the SupportedDriveModes property is not specified, this is the default. \n\nIf a GPIO signal goes through a level shifter before reaching an exposed header, declare the drive modes supported by the SOC, even if the drive mode would not be observable on the external header. For example, if a pin goes through a bidirectional level shifter that makes a pin appear as open drain with resistive pull up, you will never observe a high impedance state on the exposed header even if the pin is configured as a high impedance input. You should still declare that the pin supports high impedance input. \n\n#### Pin Numbering \n\nWindows supports two pin numbering schemes: \n\n* Sequential Pin Numbering – Users see numbers like 0, 1, 2 … up to the number of exposed pins. 0 is the first GpioIo resource declared in ASL, 1 is the second GpioIo resource declared in ASL, and so on. \n* Native Pin Numbering – Users see the pin numbers specified in GpioIo descriptors, e.g. 4, 5, 12, 13, … .  \n\n```cpp\nPackage (2) { “GPIO-UseDescriptorPinNumbers”, 1 }, \n```\n\nThe **UseDescriptorPinNumbers** property tells Windows to use native pin numbering instead of sequential pin numbering. If the UseDescriptorPinNumbers property is not specified or its value is zero, Windows will default to Sequential pin numbering. \n\nIf native pin numbering is used, you must also specify the **PinCount** property. \n\n```cpp\nPackage (2) { “GPIO-PinCount”, 54 }, \n```\n\nThe **PinCount** property should match the value returned through the **TotalPins** property in the [CLIENT_QueryControllerBasicInformation](https://msdn.microsoft.com/library/windows/hardware/hh439399.aspx) callback of the `GpioClx` driver. \n\nChoose the numbering scheme that is most compatible with existing published documentation for your board. For example, Raspberry Pi uses native pin numbering because many existing pinout diagrams use the BCM2835 pin numbers. MinnowBoardMax uses sequential pin numbering because there are few existing pinout diagrams, and sequential pin numbering simplifies the developer experience because only 10 pins are exposed out of more than 200 pins. The decision to use sequential or native pin numbering should aim to reduce developer confusion. \n\n#### GPIO Driver Requirements \n\n* Must use `GpioClx`\n* Must be on-SOC memory mapped \n* Must use emulated ActiveBoth interrupt handling \n\n### UART \n\nUART is not supported on Raspberry Pi at the time of writing, so the following UART declaration is from MinnowBoardMax. \n\n```cpp\n// Index 2 \nUARTSerialBus(           // Pin 17, 19 of JP1, for SIO_UART2 \n    115200,                // InitialBaudRate: in bits ber second \n    ,                      // BitsPerByte: default to 8 bits \n    ,                      // StopBits: Defaults to one bit \n    0xfc,                  // LinesInUse: 8 1-bit flags to declare line enabled \n    ,                      // IsBigEndian: default to LittleEndian \n    ,                      // Parity: Defaults to no parity \n    ,                      // FlowControl: Defaults to no flow control \n    32,                    // ReceiveBufferSize \n    32,                    // TransmitBufferSize \n    \"\\\\_SB.URT2\",          // ResourceSource: UART bus controller name \n    , \n    , \n    , \n    )\n```\n\nOnly the ResourceSource field is fixed while all other fields are placeholders for values specified at runtime by the user. \n\nThe accompanying friendly name declaration is: \n\n```cpp\nPackage(2) { \"bus-UART-UART2\", Package() { 2 }}, \n```\n\nThis assigns the friendly name “UART2” to the controller, which is the identifier users will use to access the bus from usermode.  \n\n## Runtime Pin Muxing \n\nPin muxing is the ability to use the same physical pin for different functions. Several different on-chip peripherals, such as an I2C controller, SPI controller, and GPIO controller, might be routed to the same physical pin on a SOC. The mux block controls which function is active on the pin at any given time. Traditionally, firmware is responsible for establishing function assignments at boot, and this assignment remains static through the boot session. Runtime pin muxing adds the ability to reconfigure pin function assignments at runtime. Enabling users to choose a pin’s function at runtime speeds development by enabling users to quickly reconfigure a board’s pins, and enables hardware to support a broader range of applications than would a static configuration. \n\nUsers consume muxing support for GPIO, I2C, SPI, and UART without writing any additional code. When a user opens a GPIO or bus using [OpenPin()](https://msdn.microsoft.com/library/dn960157.aspx) or [FromIdAsync()](https://msdn.microsoft.com/windows.devices.i2c.i2cdevice.fromidasync), the underlying physical pins are automatically muxed to the requested function. If the pins are already in use by a different function, the OpenPin() or FromIdAsync() call will fail. When the user closes the device by disposing the [GpioPin](https://msdn.microsoft.com/library/windows/apps/windows.devices.gpio.gpiopin.aspx), [I2cDevice](https://msdn.microsoft.com/library/windows/apps/windows.devices.i2c.i2cdevice.aspx), [SpiDevice](https://msdn.microsoft.com/library/windows/apps/windows.devices.spi.spidevice.aspx), or [SerialDevice](https://msdn.microsoft.com/library/windows/apps/windows.devices.serialcommunication.serialdevice.aspx) object, the pins are released, allowing them to later be opened for a different function. \n\nWindows contains built-in support for pin muxing in the [GpioClx](https://msdn.microsoft.com/library/windows/hardware/hh439515.aspx), [SpbCx](https://msdn.microsoft.com/library/windows/hardware/hh406203.aspx), and [SerCx](https://msdn.microsoft.com/library/windows/hardware/dn265349.aspx) frameworks. These frameworks work together to automatically switch a pin to the correct function when a GPIO pin or bus is accessed. Access to the pins is arbitrated to prevent conflicts among multiple clients. In addition to this built-in support, the interfaces and protocols for pin muxing are general purpose and can be extended to support additional devices and scenarios. \n\nThis document first describes the underlying interfaces and protocols involved in pin muxing, and then describes how to add support for pin muxing to GpioClx, SpbCx, and SerCx controller drivers. \n\n### Pin Muxing Architecture \n\nThis section describes the underlying interfaces and protocols involved in pin muxing. Knowledge of the underlying protocols is not necessarily needed to support pin muxing with GpioClx/SpbCx/SerCx drivers. For details on how to support pin muxing with GpioCls/SpbCx/SerCx drivers, see [Implementing pin muxing support in GpioClx client drivers](#supporting-muxing-support-in-GpioClx-client-drivers) and [Consuming muxing support in SpbCx and SerCx controller drivers](#supporting-muxing-in-SpbCx-and-SerCx-controller-drivers). \n\nPin muxing is accomplished by the cooperation of several components. \n\n* Pin muxing servers – these are drivers that control the pin muxing control block. Pin muxing servers receive pin muxing requests from clients via requests to reserve muxing resources (via *IRP_MJ_CREATE*) requests, and requests to switch a pin’s function (via *IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS* requests). The pin muxing server is usually the GPIO driver, since the muxing block is sometimes part of the GPIO block. Even if the muxing block is a separate peripheral, the GPIO driver is a logical place to put muxing functionality. \n* Pin muxing clients – these are drivers that consume pin muxing. Pin muxing clients receive pin muxing resources from ACPI firmware. Pin muxing resources are a type of connection resource and are managed by the resource hub. Pin muxing clients reserve pin muxing resources by opening a handle to the resource. To effect a hardware change, clients must commit the configuration by sending an *IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS* request. Clients release pin muxing resources by closing the handle, at which point muxing configuration is reverted to its default state. \n* ACPI firmware – specifies muxing configuration with `MsftFunctionConfig()` resources. MsftFunctionConfig resources express which pins, in which muxing configuration, are required by a client. MsftFunctionConfig resources contain function number, pull configuration, and list of pin numbers. MsftFunctionConfig resources are supplied to pin muxing clients as hardware resources, which are received by drivers in their PrepareHardware callback similarly to GPIO and SPB connection resources. Clients receive a resource hub ID which can be used to open a handle to the resource. \n\n> You must pass the `/MsftInternal` command line switch to `asl.exe` to compile ASL files containing `MsftFunctionConfig()` descriptors since these descriptors are currently under review by the ACPI working committee. For example: `asl.exe /MsftInternal dsdt.asl`\n\nThe sequence of operations involved in pin muxing is shown below. \n\n![Pin muxing client server interaction](images/usermode-access-diagram-1.png)\n\n1.  The client receives MsftFunctionConfig resources from ACPI firmware in its [EvtDevicePrepareHardware()](https://msdn.microsoft.com/library/windows/hardware/ff540880.aspx) callback.\n2.  The client uses the resource hub helper function `RESOURCE_HUB_CREATE_PATH_FROM_ID()` to create a path from the resource ID, then opens a handle to the path (using [ZwCreateFile()](https://msdn.microsoft.com/library/windows/hardware/ff566424.aspx), [IoGetDeviceObjectPointer()](https://msdn.microsoft.com/library/windows/hardware/ff549198.aspx), or [WdfIoTargetOpen()](https://msdn.microsoft.com/library/windows/hardware/ff548634.aspx)).\n3.  The server extracts the resource hub ID from the file path using resource hub helper functions `RESOURCE_HUB_ID_FROM_FILE_NAME()`, then queries the resource hub to get the resource descriptor.\n4.  The server performs sharing arbitration for each pin in the descriptor and completes the IRP_MJ_CREATE request.\n5.  The client issues an *IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS* request on the received handle.\n6.  In response to *IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS*, the server performs the hardware muxing operation by making the specified function active on each pin.\n7.  The client proceeds with operations that depend on the requested pin muxing configuration.\n8.  When the client no longer requires the pins to be muxed, it closes the handle.\n9.  In response to the handle being closed, the server reverts the pins back to their initial state.\n\n### Protocol description for pin muxing clients\n\nThis section describes how a client consumes pin muxing functionality. This does not apply to `SerCx` and `SpbCx` controller drivers, since the frameworks implement this protocol on behalf of controller drivers.\n\n####    Parsing resources\n\nA WDF driver receives `MsftFunctionConfig()` resources in its [EvtDevicePrepareHardware()](https://msdn.microsoft.com/library/windows/hardware/ff540880.aspx) routine. MsftFunctionConfig resources can be identified by the following fields:\n\n```cpp\nCM_PARTIAL_RESOURCE_DESCRIPTOR::Type = CmResourceTypeConnection\nCM_PARTIAL_RESOURCE_DESCRIPTOR::u.Connection.Class = CM_RESOURCE_CONNECTION_CLASS_FUNCTION_CONFIG\nCM_PARTIAL_RESOURCE_DESCRIPTOR::u.Connection.Type = CM_RESOURCE_CONNECTION_TYPE_FUNCTION_CONFIG\n```\n\nAn `EvtDevicePrepareHardware()` routine might extract MsftFunctionConfig resources as follows:\n\n```cpp\nEVT_WDF_DEVICE_PREPARE_HARDWARE evtDevicePrepareHardware;\n\n_Use_decl_annotations_\nNTSTATUS\nevtDevicePrepareHardware (\n    WDFDEVICE WdfDevice,\n    WDFCMRESLIST ResourcesTranslated\n    )\n{\n    PAGED_CODE();\n\n    LARGE_INTEGER connectionId;\n    ULONG functionConfigCount = 0;\n\n    const ULONG resourceCount = WdfCmResourceListGetCount(ResourcesTranslated);\n    for (ULONG index = 0; index < resourceCount; ++index) {\n        const CM_PARTIAL_RESOURCE_DESCRIPTOR* resDescPtr =\n            WdfCmResourceListGetDescriptor(ResourcesTranslated, index);\n\n        switch (resDescPtr->Type) {\n        case CmResourceTypeConnection:\n            switch (resDescPtr->u.Connection.Class) {\n            case CM_RESOURCE_CONNECTION_CLASS_FUNCTION_CONFIG:\n                switch (resDescPtr->u.Connection.Type) {\n                case CM_RESOURCE_CONNECTION_TYPE_FUNCTION_CONFIG:                    \n                    switch (functionConfigCount) {\n                    case 0:\n                        // save the connection ID\n                        connectionId.LowPart = resDescPtr->u.Connection.IdLowPart;\n                        connectionId.HighPart = resDescPtr->u.Connection.IdHighPart;\n                        break;\n                    } // switch (functionConfigCount)\n                    ++functionConfigCount;\n                    break; // CM_RESOURCE_CONNECTION_TYPE_FUNCTION_CONFIG\n\n                } // switch (resDescPtr->u.Connection.Type)\n                break; // CM_RESOURCE_CONNECTION_CLASS_FUNCTION_CONFIG\n            } // switch (resDescPtr->u.Connection.Class)\n            break;\n        } // switch\n    } // for (resource list)\n\n    if (functionConfigCount < 1) {\n        return STATUS_INVALID_DEVICE_CONFIGURATION;\n    }\n    // TODO: save connectionId in the device context for later use\n\n    return STATUS_SUCCESS;\n}\n```\n\n####    Reserving and committing resources\n\nWhen a client wants to mux pins, it reserves and commits the MsftFunctionConfig resource. The following example shows how a client might reserve and commit MsftFunctionConfig resources.\n\n```cpp\n_IRQL_requires_max_(PASSIVE_LEVEL)\nNTSTATUS AcquireFunctionConfigResource (\n    WDFDEVICE WdfDevice,\n    LARGE_INTEGER ConnectionId,\n    _Out_ WDFIOTARGET* ResourceHandlePtr\n    )\n{\n    PAGED_CODE();\n\n    //\n    // Form the resource path from the connection ID\n    //\n    DECLARE_UNICODE_STRING_SIZE(resourcePath, RESOURCE_HUB_PATH_CHARS);\n    NTSTATUS status = RESOURCE_HUB_CREATE_PATH_FROM_ID(\n            &resourcePath,\n            ConnectionId.LowPart,\n            ConnectionId.HighPart);\n    if (!NT_SUCCESS(status)) {\n        return status;\n    }\n    \n    //\n    // Create a WDFIOTARGET\n    //\n    WDFIOTARGET resourceHandle;\n    status = WdfIoTargetCreate(WdfDevice, WDF_NO_ATTRIBUTES, &resourceHandle);\n    if (!NT_SUCCESS(status)) {\n        return status;\n    }\n\n    //\n    // Reserve the resource by opening a WDFIOTARGET to the resource\n    //\n    WDF_IO_TARGET_OPEN_PARAMS openParams;\n    WDF_IO_TARGET_OPEN_PARAMS_INIT_OPEN_BY_NAME(\n        &openParams,\n        &resourcePath,\n        FILE_GENERIC_READ | FILE_GENERIC_WRITE);\n\n    status = WdfIoTargetOpen(resourceHandle, &openParams);\n    if (!NT_SUCCESS(status)) {\n        return status;\n    }\n    //\n    // Commit the resource\n    //\n    status = WdfIoTargetSendIoctlSynchronously(\n            resourceHandle,\n            WDF_NO_HANDLE,      // WdfRequest\n            IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS,\n            nullptr,            // InputBuffer\n            nullptr,            // OutputBuffer\n            nullptr,            // RequestOptions\n            nullptr);           // BytesReturned\n    \n    if (!NT_SUCCESS(status)) {\n        WdfIoTargetClose(resourceHandle);\n        return status;\n    }\n\n    //\n    // Pins were successfully muxed, return the handle to the caller\n    //\n    *ResourceHandlePtr = resourceHandle;\n    return STATUS_SUCCESS;\n}\n```\n\nThe driver should store the WDFIOTARGET in one of its context areas so that it can be closed later. When the driver is ready to release the muxing configuration, it should close the resource handle by calling [WdfObjectDelete()](https://msdn.microsoft.com/library/windows/hardware/ff548734.aspx), or [WdfIoTargetClose()](https://msdn.microsoft.com/library/windows/hardware/ff548586.aspx) if you intend to reuse the WDFIOTARGET.\n\n```cpp\n    WdfObjectDelete(resourceHandle);\n```\n\nWhen the client closes its resource handle, the pins are muxed back to their initial state, and can now be acquired by a different client.\n\n### Protocol description for pin muxing servers\n\nThis section describes how a pin muxing server exposes its functionality to clients. This does not apply to `GpioClx` miniport drivers, since the framework implements this protocol on behalf of client drivers. For details on how to support pin muxing in `GpioClx` client drivers, see [Implementing muxing support in GpioClx Client Drivers](#supporting-muxing-support-in-GpioClx-client-drivers).\n\n####    Handling IRP_MJ_CREATE requests\n\nClients open a handle to a resource when they want to reserve a pin muxing resource. A pin muxing server receives *IRP_MJ_CREATE* requests by way of a reparse operation from the resource hub. The trailing path component of the *IRP_MJ_CREATE* request contains the resource hub ID, which is a 64-bit integer in hexadecimal format. The server should extract the resource hub ID from the filename using `RESOURCE_HUB_ID_FROM_FILE_NAME()` from reshub.h, and send *IOCTL_RH_QUERY_CONNECTION_PROPERTIES* to the resource hub to obtain the `MsftFunctionConfig()` descriptor.\n\nThe server should validate the descriptor and extract the sharing mode and pin list from the descriptor. It should then perform sharing arbitration for the pins, and if successful, mark the pins as reserved before completing the request.\n\nSharing arbitration succeeds overall if sharing arbitration succeeds for each pin in the pin list. Each pin should be arbitrated as follows:\n\n*   If the pin is not already reserved, sharing arbitration succeeds.\n*   If the pin is already reserved as exclusive, sharing arbitration fails.\n*   If the pin is already reserved as shared,\n  * and the incoming request is shared, sharing arbitration succeeds.\n  * and the incoming request is exclusive, sharing arbitration fails.\n\nIf sharing arbitration fails, the request should be completed with *STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE*. If sharing arbitration succeeds, the request should completed with *STATUS_SUCCESS*.\n\nNote that the sharing mode of the incoming request should be taken from the MsftFunctionConfig descriptor, not [IrpSp->Parameters.Create.ShareAccess](https://msdn.microsoft.com/library/windows/hardware/ff548630.aspx).\n\n####    Handling IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS requests\n\nAfter the client has successfully reserved a MsftFunctionConfig resource by opening a handle, it can send *IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS* to request the server to perform the actual hardware muxing operation. When the server receives *IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS*, for each pin in the pin list it should \n\n*   Set the pull mode specified in the PinConfiguration member of the PNP_FUNCTION_CONFIG_DESCRIPTOR structure into hardware.\n*   Mux the pin to the function specified by the FunctionNumber member of the PNP_FUNCTION_CONFIG_DESCRIPTOR structure.\n\nThe server should then complete the request with *STATUS_SUCCESS*.\n\nThe meaning of FunctionNumber is defined by the server, and it is understood that the MsftFunctionConfig descriptor was authored with knowledge of how the server interprets this field.\n\nRemember that when the handle is closed, the server will have to revert the pins to the configuration they were in when IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS was received, so the server may need to save the pins’ state before modifying them.\n\n####    Handling IRP_MJ_CLOSE requests\n\nWhen a client no longer requires a muxing resource, it closes its handle. When a server receives a *IRP_MJ_CLOSE* request, it should revert the pins to the state they were in when *IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS* was received. If the client never sent a *IOCTL_GPIO_COMMIT_FUNCTION_CONFIG_PINS*, no action is necessary. The server should then mark the pins as available with respect to sharing arbitration, and complete the request with *STATUS_SUCCESS*. Be sure to properly synchronize *IRP_MJ_CLOSE* handling with *IRP_MJ_CREATE* handling.\n\n### Authoring guidelines for ACPI tables\n\nThis section describes how to supply muxing resources to client drivers. Note that you will need Microsoft ASL compiler build 14327 or later to compile tables containing `MsftFunctionConfig()` resources. `MsftFunctionConfig()` resources are supplied to pin muxing clients as hardware resources. `MsftFunctionConfig()` resources should be supplied to drivers that require pin muxing changes, which are typically SPB and serial controller drivers, but should not be supplied to SPB and serial peripheral drivers, since the controller driver handles muxing configuration.\nThe `MsftFunctionConfig()` ACPI macro is defined as follows:\n\n```cpp\n  MsftFunctionConfig(Shared/Exclusive\n                PinPullConfig,\n                FunctionNumber,\n                ResourceSource,\n                ResourceSourceIndex,\n                ResourceConsumer/ResourceProducer,\n                VendorData) { Pin List }\n\n```\n\n* Shared/Exclusive – If exclusive, this pin can be acquired by a single client at a time. If shared, multiple shared clients can acquire the resource. Always set this to exclusive since allowing multiple uncoordinated clients to access a mutable resource can lead to data races and therefore unpredictable results. \n* PinPullConfig – one of \n  * PullDefault – use the SOC-defined power-on default pull configuration \n  * PullUp – enable pull-up resistor \n  * PullDown – enable pull-down resistor \n  * PullNone – disable all pull resistors \n* FunctionNumber – the function number to program into the mux. \n* ResourceSource – The ACPI namespace path of the pin muxing server \n* ResourceSourceIndex – set this to 0 \n* ResourceConsumer/ResourceProducer – set this to ResourceConsumer \n* VendorData – optional binary data whose meaning is defined by the pin muxing server. This should usually be left blank\n* Pin List – a comma separated list of pin numbers to which the configuration applies. When the pin muxing server is a GpioClx driver, these are GPIO pin numbers and have the same meaning as pin numbers in a GpioIo descriptor. \n\nThe following example shows how one might supply a MsftFunctionConfig() resource to an I2C controller driver. \n\n```cpp\nDevice(I2C1) \n{ \n    Name(_HID, \"BCM2841\") \n    Name(_CID, \"BCMI2C\") \n    Name(_UID, 0x1) \n    Method(_STA) \n    { \n        Return(0xf) \n    } \n    Method(_CRS, 0x0, NotSerialized) \n    { \n        Name(RBUF, ResourceTemplate() \n        { \n            Memory32Fixed(ReadWrite, 0x3F804000, 0x20) \n            Interrupt(ResourceConsumer, Level, ActiveHigh, Shared) { 0x55 } \n            MsftFunctionConfig(Exclusive, PullUp, 4, \"\\\\_SB.GPI0\", 0, ResourceConsumer, ) { 2, 3 } \n        }) \n        Return(RBUF) \n    } \n} \n```\n\nIn addition to the memory and interrupt resources typically required by a controller driver, a `MsftFunctionConfig()` resource is also specified. This resource enables the I2C controller driver to put pins 2 and 3 - managed by the device node at \\\\_SB.GPIO0 – in function 4 with pull-up resistor enabled. \n\n### Supporting muxing support in GpioClx client drivers \n\n`GpioClx` has built-in support for pin muxing. GpioClx miniport drivers (also referred to as “GpioClx client drivers”), drive GPIO controller hardware. As of Windows 10 build 14327, GpioClx miniport drivers can add support for pin muxing by implementing two new DDIs: \n\n* CLIENT_ConnectFunctionConfigPins – called by `GpioClx` to command the miniport driver to apply the specified muxing configuration. \n* CLIENT_DisconnectFunctionConfigPins – called by `GpioClx` to command the miniport driver to revert the muxing configuration. \n\nSee [GpioClx Event Callback Functions](https://msdn.microsoft.com/library/windows/hardware/hh439464.aspx) for a description of these routines.\n\nIn addition to these two new DDIs, existing DDIs should be audited for pin muxing compatibility: \n\n* CLIENT_ConnectIoPins/CLIENT_ConnectInterrupt – CLIENT_ConnectIoPins is called by GpioClx to command the miniport driver to configure a set pins for GPIO input or output. GPIO is mutually exclusive with MsftFunctionConfig, meaning a pin will never be connected for GPIO and MsftFunctionConfig at the same time. Since a pin’s default function is not required to be GPIO, a pin may not necessarily not be muxed to GPIO when ConnectIoPins is called. ConnectIoPins is required to perform all operations necessary to make the pin ready for GPIO IO, including muxing operations. *CLIENT_ConnectInterrupt* should behave similarly, since interrupts can be thought of as a special case of GPIO input. \n* CLIENT_DisconnectIoPins/CLIENT_DisconnectInterrupt – These routine should return pins to the state they were in when CLIENT_ConnectIoPins/CLIENT_ConnectInterrupt was called, unless the PreserveConfiguration flag is specified. In addition to reverting the direction of pins to their default state, the miniport should also revert each pin’s muxing state to the state it was in when the _Connect routine was called. \n\nFor example, assume that a pin’s default muxing configuration is UART, and the pin can also be used as GPIO. When CLIENT_ConnectIoPins is called to connect the pin for GPIO, it should mux the pin to GPIO, and in CLIENT_DisconnectIoPins, it should mux the pin back to UART. In general, the _Disconnect routines should undo operations done by the _Connect routines. \n\n### Supporting muxing in SpbCx and SerCx controller drivers \n\nAs of Windows 10 build 14327, the `SpbCx` and `SerCx` frameworks contain built-in support for pin muxing that enables `SpbCx` and `SerCx` controller drivers to be pin muxing clients without any code changes to the controller drivers themselves. By extension, any SpbCx/SerCx peripheral driver that connects to a muxing-enabled SpbCx/SerCx controller driver will trigger pin muxing activity. \n\nThe following diagram shows the dependencies between each of these components. As you can see, pin muxing introduces a dependency from SerCx and SpbCx controller drivers to the GPIO driver, which is usually responsible for muxing. \n\n![Pin muxing dependency](images/usermode-access-diagram-2.png)\n\nAt device initialization time, the `SpbCx` and `SerCx` frameworks parse all `MsftFunctionConfig()` resources supplied as hardware resources to the device. SpbCx/SerCx then acquire and release the pin muxing resources on demand.\n\n`SpbCx` applies pin muxing configuration in its *IRP_MJ_CREATE* handler, just before calling the client driver’s [EvtSpbTargetConnect()](https://msdn.microsoft.com/library/windows/hardware/hh450818.aspx) callback. If muxing configuration could not be applied, the controller driver’s `EvtSpbTargetConnect()` callback will not be called. Therefore, an SPB controller driver may assume that pins are muxed to the SPB function by the time `EvtSpbTargetConnect()` is called.\n\n`SpbCx` reverts pin muxing configuration in its *IRP_MJ_CLOSE* handler, just after invoking the controller driver’s [EvtSpbTargetDisconnect()](https://msdn.microsoft.com/library/windows/hardware/hh450820.aspx) callback. The result is that pins are muxed to the SPB function whenever a peripheral driver opens a handle to the SPB controller driver, and are muxed away when the peripheral driver closes their handle.\n\n`SerCx` behaves similarly. `SerCx` acquires all `MsftFunctionConfig()` resources in its *IRP_MJ_CREATE* handler just before invoking the controller driver’s [EvtSerCx2FileOpen()](https://msdn.microsoft.com/library/windows/hardware/dn265209.aspx) callback, and releases all resources in its IRP_MJ_CLOSE handler, just after invoking the controller driver’s [EvtSerCx2FileClose](https://msdn.microsoft.com/library/windows/hardware/dn265208.aspx) callback.\n\nThe implication of dynamic pin muxing for `SerCx` and `SpbCx` controller drivers is that they must be able to tolerate pins being muxed away from SPB/UART function at certain times. Controller drivers need to assume that pins will not be muxed until `EvtSpbTargetConnect()` or `EvtSerCx2FileOpen()` is called. Pins are not necessary muxed to SPB/UART function during the following callbacks. The following is not a complete list, but represents the most common PNP routines implemented by controller drivers.\n\n* DriverEntry \n* EvtDriverDeviceAdd \n* EvtDevicePrepareHardware/EvtDeviceReleaseHardware \n* EvtDeviceD0Entry/EvtDeviceD0Exit \n\n## Verification \n\nWhen you’ve finished authoring your ASL, you should run the [Hardware Lab Kit (HLK)](https://msdn.microsoft.com/library/windows/hardware/dn930814.aspx) tests to verify that all resources are exposed correctly and the underlying busses meet the functional contract of the API. The following sections describe how to load the rhproxy device node for testing without recompiling your firmware and how to run the HLK tests. \n\n### Compile and load ASL with ACPITABL.dat \n\nThe first step is to compile and load the ASL file onto your system under test. We recommend using ACPITABL.dat during development and validation as it does not require a full UEFI rebuild to test ASL changes. \n\n1. Create a file named yourboard.asl and put the RHPX device node inside a DefinitionBlock: \n```\nDefinitionBlock (\"ACPITABL.dat\", \"SSDT\", 1, \"MSFT\", \"RHPROXY\", 1)\n{\n    Scope (\\_SB)\n    {\n        Device(RHPX)\n        {\n        ...\n        }\n    }\n}\n```\n2.  Download the WDK and get asl.exe\n3.  Run the following command to generate ACPITABL.dat:\n```\nasl.exe yourboard.asl\n```\n4.  Copy the resulting ACPITABL.dat file to c:\\windows\\system32 on your system under test.\n5.  Turn on testsigning on your system under test:\n```\nbcdedit /set testsigning on\n```\n6.  Reboot the system under test. The system will append the ACPI tables defined in ACPITABL.dat to the system firmware tables. \n7.  Verify that the RHPX device node was added to the system:\n```\ndevcon status *msft8000\n```\nThe output of devcon should indicate that the device is present, although the driver may have failed to initialize if there are bugs in the ASL that need to be worked out.\n\n### Run the HLK Tests\n\nWhen you select the rhproxy device node in HLK manager, the applicable tests will automatically be selected.\n\nIn the HLK manager, select “Resource Hub Proxy device”:\n\n![HLK manager screenshot](images/usermode-hlk-1.png)\n\nThen click the Tests tab, and select I2C WinRT, Gpio WinRT, and Spi WinRT tests.\n\n![HLK manager screenshot](images/usermode-hlk-2.png)\n\nClick Run Selected. Further documentation on each test is available by right clicking on the test and clicking “Test Description.”\n\n### More testing resources\n\nSimple command line tools for Gpio, I2c, Spi, and Serial are available on the ms-iot github samples repository  (https://github.com/ms-iot/samples). These tools can be helpful for manual debugging.\n\n| Tool | Link |\n|------|------|\n| GpioTestTool | https://developer.microsoft.com/en-us/windows/iot/win10/samples/GPIOTestTool |\n| I2cTestTool   | https://developer.microsoft.com/en-us/windows/iot/win10/samples/I2cTestTool | \n| SpiTestTool | https://developer.microsoft.com/en-us/windows/iot/win10/samples/spitesttool |\n| MinComm (Serial) |    https://github.com/ms-iot/samples/tree/develop/MinComm |\n\n## Resources\n\n| Destination | Link |\n|-------------|------|\n| ACPI 5.0 specification | http://acpi.info/spec.htm |\n| Asl.exe (Microsoft ASL Compiler) | https://msdn.microsoft.com/library/windows/hardware/dn551195.aspx |\n| Windows.Devices.Gpio  | https://msdn.microsoft.com/library/windows/apps/windows.devices.gpio.aspx | \n| Windows.Devices.I2c | https://msdn.microsoft.com/library/windows/apps/windows.devices.i2c.aspx |\n| Windows.Devices.Spi | https://msdn.microsoft.com/library/windows/apps/windows.devices.spi.aspx |\n| Windows.Devices.SerialCommunication | https://msdn.microsoft.com/library/windows/apps/windows.devices.serialcommunication.aspx |\n| Test Authoring and Execution Framework (TAEF) | https://msdn.microsoft.com/library/windows/hardware/hh439725.aspx |\n| SpbCx | https://msdn.microsoft.com/library/windows/hardware/hh450906.aspx |\n| GpioClx   | https://msdn.microsoft.com/library/windows/hardware/hh439508.aspx |\n| SerCx | https://msdn.microsoft.com/library/windows/hardware/ff546939.aspx |\n| MITT I2C Tests | https://msdn.microsoft.com/library/windows/hardware/dn919852.aspx |\n| GpioTestTool | https://developer.microsoft.com/en-us/windows/iot/win10/samples/GPIOTestTool |\n| I2cTestTool   | https://developer.microsoft.com/en-us/windows/iot/win10/samples/I2cTestTool | \n| SpiTestTool | https://developer.microsoft.com/en-us/windows/iot/win10/samples/spitesttool |\n| MinComm (Serial) |    https://github.com/ms-iot/samples/tree/develop/MinComm |\n| Hardware Lab Kit (HLK) | https://msdn.microsoft.com/library/windows/hardware/dn930814.aspx |\n\n## Apendix\n\n### Appendix A - Raspberry Pi ASL Listing\n\nHeader pinout: https://developer.microsoft.com/en-us/windows/iot/win10/samples/PinMappingsRPi2\n\n```\nDefinitionBlock (\"ACPITABL.dat\", \"SSDT\", 1, \"MSFT\", \"RHPROXY\", 1)\n{\n\n    Scope (\\_SB)\n    {\n        //\n        // RHProxy Device Node to enable WinRT API\n        //\n        Device(RHPX)\n        {\n            Name(_HID, \"MSFT8000\")\n            Name(_CID, \"MSFT8000\")\n            Name(_UID, 1)\n\n            Name(_CRS, ResourceTemplate()\n            {\n                // Index 0\n                SPISerialBus(              // SCKL - GPIO 11 - Pin 23\n                                           // MOSI - GPIO 10 - Pin 19\n                                           // MISO - GPIO 9  - Pin 21\n                                           // CE0  - GPIO 8  - Pin 24\n                    0,                     // Device selection (CE0)\n                    PolarityLow,           // Device selection polarity\n                    FourWireMode,          // wiremode\n                    0,                     // databit len: placeholder\n                    ControllerInitiated,   // slave mode\n                    0,                     // connection speed: placeholder\n                    ClockPolarityLow,      // clock polarity: placeholder\n                    ClockPhaseFirst,       // clock phase: placeholder\n                    \"\\\\_SB.SPI0\",          // ResourceSource: SPI bus controller name\n                    0,                     // ResourceSourceIndex\n                                           // Resource usage\n                    )                      // Vendor Data\n\n                // Index 1\n                SPISerialBus(              // SCKL - GPIO 11 - Pin 23\n                                           // MOSI - GPIO 10 - Pin 19\n                                           // MISO - GPIO 9  - Pin 21\n                                           // CE1  - GPIO 7  - Pin 26\n                    1,                     // Device selection (CE1)\n                    PolarityLow,           // Device selection polarity\n                    FourWireMode,          // wiremode\n                    0,                     // databit len: placeholder\n                    ControllerInitiated,   // slave mode\n                    0,                     // connection speed: placeholder\n                    ClockPolarityLow,      // clock polarity: placeholder\n                    ClockPhaseFirst,       // clock phase: placeholder\n                    \"\\\\_SB.SPI0\",          // ResourceSource: SPI bus controller name\n                    0,                     // ResourceSourceIndex\n                                           // Resource usage\n                    )                      // Vendor Data\n\n                // Index 2\n                SPISerialBus(              // SCKL - GPIO 21 - Pin 40\n                                           // MOSI - GPIO 20 - Pin 38\n                                           // MISO - GPIO 19 - Pin 35\n                                           // CE1  - GPIO 17 - Pin 11\n                    1,                     // Device selection (CE1)\n                    PolarityLow,           // Device selection polarity\n                    FourWireMode,          // wiremode\n                    0,                     // databit len: placeholder\n                    ControllerInitiated,   // slave mode\n                    0,                     // connection speed: placeholder\n                    ClockPolarityLow,      // clock polarity: placeholder\n                    ClockPhaseFirst,       // clock phase: placeholder\n                    \"\\\\_SB.SPI1\",          // ResourceSource: SPI bus controller name\n                    0,                     // ResourceSourceIndex\n                                           // Resource usage\n                    )                      // Vendor Data\n                // Index 3\n                I2CSerialBus(              // Pin 3 (GPIO2, SDA1), 5 (GPIO3, SCL1)\n                    0xFFFF,                // SlaveAddress: placeholder\n                    ,                      // SlaveMode: default to ControllerInitiated\n                    0,                     // ConnectionSpeed: placeholder\n                    ,                      // Addressing Mode: placeholder\n                    \"\\\\_SB.I2C1\",          // ResourceSource: I2C bus controller name\n                    ,\n                    ,\n                    )                      // VendorData\n\n                // Index 4 - GPIO 4 -\n                GpioIO(Shared, PullUp, , , , \"\\\\_SB.GPI0\", , , , ) { 4 }\n                GpioInt(Edge, ActiveBoth, Shared, PullUp, 0, \"\\\\_SB.GPI0\",) { 4 }\n                // Index 6 - GPIO 5 -\n                GpioIO(Shared, PullUp, , , , \"\\\\_SB.GPI0\", , , , ) { 5 }\n                GpioInt(Edge, ActiveBoth, Shared, PullUp, 0, \"\\\\_SB.GPI0\",) { 5 }\n                // Index 8 - GPIO 6 -\n                GpioIO(Shared, PullUp, , , , \"\\\\_SB.GPI0\", , , , ) { 6 }\n                GpioInt(Edge, ActiveBoth, Shared, PullUp, 0, \"\\\\_SB.GPI0\",) { 6 }\n                // Index 10 - GPIO 12 -\n                GpioIO(Shared, PullDown, , , , \"\\\\_SB.GPI0\", , , , ) { 12 }\n                GpioInt(Edge, ActiveBoth, Shared, PullDown, 0, \"\\\\_SB.GPI0\",) { 12 }\n                // Index 12 - GPIO 13 -\n                GpioIO(Shared, PullDown, , , , \"\\\\_SB.GPI0\", , , , ) { 13 }\n                GpioInt(Edge, ActiveBoth, Shared, PullDown, 0, \"\\\\_SB.GPI0\",) { 13 }\n                // Index 14 - GPIO 16 -\n                GpioIO(Shared, PullDown, , , , \"\\\\_SB.GPI0\", , , , ) { 16 }\n                GpioInt(Edge, ActiveBoth, Shared, PullDown, 0, \"\\\\_SB.GPI0\",) { 16 }\n                // Index 16 - GPIO 18 -\n                GpioIO(Shared, PullDown, , , , \"\\\\_SB.GPI0\", , , , ) { 18 }\n                GpioInt(Edge, ActiveBoth, Shared, PullDown, 0, \"\\\\_SB.GPI0\",) { 18 }\n                // Index 18 - GPIO 22 -\n                GpioIO(Shared, PullDown, , , , \"\\\\_SB.GPI0\", , , , ) { 22 }\n                GpioInt(Edge, ActiveBoth, Shared, PullDown, 0, \"\\\\_SB.GPI0\",) { 22 }\n                // Index 20 - GPIO 23 -\n                GpioIO(Shared, PullDown, , , , \"\\\\_SB.GPI0\", , , , ) { 23 }\n                GpioInt(Edge, ActiveBoth, Shared, PullDown, 0, \"\\\\_SB.GPI0\",) { 23 }\n                // Index 22 - GPIO 24 -\n                GpioIO(Shared, PullDown, , , , \"\\\\_SB.GPI0\", , , , ) { 24 }\n                GpioInt(Edge, ActiveBoth, Shared, PullDown, 0, \"\\\\_SB.GPI0\",) { 24 }\n                // Index 24 - GPIO 25 -\n                GpioIO(Shared, PullDown, , , , \"\\\\_SB.GPI0\", , , , ) { 25 }\n                GpioInt(Edge, ActiveBoth, Shared, PullDown, 0, \"\\\\_SB.GPI0\",) { 25 }\n                // Index 26 - GPIO 26 -\n                GpioIO(Shared, PullDown, , , , \"\\\\_SB.GPI0\", , , , ) { 26 }\n                GpioInt(Edge, ActiveBoth, Shared, PullDown, 0, \"\\\\_SB.GPI0\",) { 26 }\n                // Index 28 - GPIO 27 -\n                GpioIO(Shared, PullDown, , , , \"\\\\_SB.GPI0\", , , , ) { 27 }\n                GpioInt(Edge, ActiveBoth, Shared, PullDown, 0, \"\\\\_SB.GPI0\",) { 27 }\n                // Index 30 - GPIO 35 -\n                GpioIO(Shared, PullUp, , , , \"\\\\_SB.GPI0\", , , , ) { 35 }\n                GpioInt(Edge, ActiveBoth, Shared, PullUp, 0, \"\\\\_SB.GPI0\",) { 35 }\n                // Index 32 - GPIO 47 -\n                GpioIO(Shared, PullUp, , , , \"\\\\_SB.GPI0\", , , , ) { 47 }\n                GpioInt(Edge, ActiveBoth, Shared, PullUp, 0, \"\\\\_SB.GPI0\",) { 47 }\n            })\n\n            Name(_DSD, Package()\n            {\n                ToUUID(\"daffd814-6eba-4d8c-8a91-bc9bbf4aa301\"),\n                Package()\n                {\n                    // Reference http://www.raspberrypi.org/documentation/hardware/raspberrypi/spi/README.md\n                    // SPI 0\n                    Package(2) { \"bus-SPI-SPI0\", Package() { 0, 1 }},                       // Index 0 & 1\n                    Package(2) { \"SPI0-MinClockInHz\", 7629 },                               // 7629 Hz\n                    Package(2) { \"SPI0-MaxClockInHz\", 125000000 },                          // 125 MHz\n                    Package(2) { \"SPI0-SupportedDataBitLengths\", Package() { 8 }},          // Data Bit Length\n                    // SPI 1\n                    Package(2) { \"bus-SPI-SPI1\", Package() { 2 }},                          // Index 2\n                    Package(2) { \"SPI1-MinClockInHz\", 30518 },                              // 30518 Hz\n                    Package(2) { \"SPI1-MaxClockInHz\", 125000000 },                          // 125 MHz\n                    Package(2) { \"SPI1-SupportedDataBitLengths\", Package() { 8 }},          // Data Bit Length\n                    // I2C1\n                    Package(2) { \"bus-I2C-I2C1\", Package() { 3 }},\n                    // GPIO Pin Count and supported drive modes\n                    Package (2) { \"GPIO-PinCount\", 54 },\n                    Package (2) { \"GPIO-UseDescriptorPinNumbers\", 1 },\n                    Package (2) { \"GPIO-SupportedDriveModes\", 0xf },                        // InputHighImpedance, InputPullUp, InputPullDown, OutputCmos\n                }\n            })\n        }\n    }\n}\n\n```\n\n### Appendix B - MinnowBoardMax ASL Listing\n\nHeader pinout: https://developer.microsoft.com/en-us/windows/iot/win10/samples/PinMappingsMBM\n\n```\nDefinitionBlock (\"ACPITABL.dat\", \"SSDT\", 1, \"MSFT\", \"RHPROXY\", 1)\n{\n    Scope (\\_SB)\n    {\n        Device(RHPX)\n        {\n            Name(_HID, \"MSFT8000\")\n            Name(_CID, \"MSFT8000\")\n            Name(_UID, 1)\n\n            Name(_CRS, ResourceTemplate() \n            {  \n                // Index 0 \n                SPISerialBus(            // Pin 5, 7, 9 , 11 of JP1 for SIO_SPI\n                    1,                     // Device selection\n                    PolarityLow,           // Device selection polarity\n                    FourWireMode,          // wiremode\n                    8,                     // databit len\n                    ControllerInitiated,   // slave mode\n                    8000000,               // Connection speed\n                    ClockPolarityLow,      // Clock polarity\n                    ClockPhaseSecond,      // clock phase\n                    \"\\\\_SB.SPI1\",          // ResourceSource: SPI bus controller name\n                    0,                     // ResourceSourceIndex\n                    ResourceConsumer,      // Resource usage\n                    JSPI,                  // DescriptorName: creates name for offset of resource descriptor\n                    )                      // Vendor Data  \n    \n                // Index 1     \n                I2CSerialBus(            // Pin 13, 15 of JP1, for SIO_I2C5 (signal)\n                    0xFF,                  // SlaveAddress: bus address (TBD)\n                    ,                      // SlaveMode: default to ControllerInitiated\n                    400000,                // ConnectionSpeed: in Hz\n                    ,                      // Addressing Mode: default to 7 bit\n                    \"\\\\_SB.I2C6\",          // ResourceSource: I2C bus controller name (For MinnowBoard Max, hardware I2C5(0-based) is reported as ACPI I2C6(1-based))\n                    ,\n                    ,\n                    JI2C,                  // Descriptor Name: creates name for offset of resource descriptor\n                    )                      // VendorData\n    \n                // Index 2\n                UARTSerialBus(           // Pin 17, 19 of JP1, for SIO_UART2\n                    115200,                // InitialBaudRate: in bits ber second\n                    ,                      // BitsPerByte: default to 8 bits\n                    ,                      // StopBits: Defaults to one bit\n                    0xfc,                  // LinesInUse: 8 1-bit flags to declare line enabled\n                    ,                      // IsBigEndian: default to LittleEndian\n                    ,                      // Parity: Defaults to no parity\n                    ,                      // FlowControl: Defaults to no flow control\n                    32,                    // ReceiveBufferSize\n                    32,                    // TransmitBufferSize\n                    \"\\\\_SB.URT2\",          // ResourceSource: UART bus controller name\n                    ,\n                    ,\n                    UAR2,                  // DescriptorName: creates name for offset of resource descriptor\n                    )                      \n    \n                // Index 3\n                GpioIo (Shared, PullNone, 0, 0, IoRestrictionNone, \"\\\\_SB.GPO2\",) {0}  // Pin 21 of JP1 (GPIO_S5[00])\n                // Index 4\n                GpioInt(Edge, ActiveBoth, SharedAndWake, PullNone, 0,\"\\\\_SB.GPO2\",) {0} \n    \n                // Index 5\n                GpioIo (Shared, PullNone, 0, 0, IoRestrictionNone, \"\\\\_SB.GPO2\",) {1}  // Pin 23 of JP1 (GPIO_S5[01])\n                // Index 6\n                GpioInt(Edge, ActiveBoth, SharedAndWake, PullNone, 0,\"\\\\_SB.GPO2\",) {1}\n    \n                // Index 7\n                GpioIo (Shared, PullNone, 0, 0, IoRestrictionNone, \"\\\\_SB.GPO2\",) {2}  // Pin 25 of JP1 (GPIO_S5[02])\n                // Index 8\n                GpioInt(Edge, ActiveBoth, SharedAndWake, PullNone, 0,\"\\\\_SB.GPO2\",) {2} \n    \n                // Index 9\n                UARTSerialBus(           // Pin 6, 8, 10, 12 of JP1, for SIO_UART1\n                    115200,                // InitialBaudRate: in bits ber second\n                    ,                      // BitsPerByte: default to 8 bits\n                    ,                      // StopBits: Defaults to one bit\n                    0xfc,                  // LinesInUse: 8 1-bit flags to declare line enabled\n                    ,                      // IsBigEndian: default to LittleEndian\n                    ,                      // Parity: Defaults to no parity\n                    FlowControlHardware,   // FlowControl: Defaults to no flow control\n                    32,                    // ReceiveBufferSize\n                    32,                    // TransmitBufferSize\n                    \"\\\\_SB.URT1\",          // ResourceSource: UART bus controller name\n                    ,\n                    ,\n                    UAR1,              // DescriptorName: creates name for offset of resource descriptor\n                    )  \n    \n                // Index 10\n                GpioIo (Shared, PullNone, 0, 0, IoRestrictionNone, \"\\\\_SB.GPO0\",) {62}  // Pin 14 of JP1 (GPIO_SC[62])\n                // Index 11\n                GpioInt(Edge, ActiveBoth, SharedAndWake, PullNone, 0,\"\\\\_SB.GPO0\",) {62} \n\n                // Index 12\n                GpioIo (Shared, PullNone, 0, 0, IoRestrictionNone, \"\\\\_SB.GPO0\",) {63}  // Pin 16 of JP1 (GPIO_SC[63])\n                // Index 13\n                GpioInt(Edge, ActiveBoth, SharedAndWake, PullNone, 0,\"\\\\_SB.GPO0\",) {63} \n    \n                // Index 14\n                GpioIo (Shared, PullNone, 0, 0, IoRestrictionNone, \"\\\\_SB.GPO0\",) {65}  // Pin 18 of JP1 (GPIO_SC[65])\n                // Index 15\n                GpioInt(Edge, ActiveBoth, SharedAndWake, PullNone, 0,\"\\\\_SB.GPO0\",) {65} \n    \n                // Index 16\n                GpioIo (Shared, PullNone, 0, 0, IoRestrictionNone, \"\\\\_SB.GPO0\",) {64}  // Pin 20 of JP1 (GPIO_SC[64])\n                // Index 17\n                GpioInt(Edge, ActiveBoth, SharedAndWake, PullNone, 0,\"\\\\_SB.GPO0\",) {64} \n    \n                // Index 18\n                GpioIo (Shared, PullNone, 0, 0, IoRestrictionNone, \"\\\\_SB.GPO0\",) {94}  // Pin 22 of JP1 (GPIO_SC[94])\n                // Index 19\n                GpioInt(Edge, ActiveBoth, SharedAndWake, PullNone, 0,\"\\\\_SB.GPO0\",) {94} \n    \n                // Index 20\n                GpioIo (Shared, PullNone, 0, 0, IoRestrictionNone, \"\\\\_SB.GPO0\",) {95}  // Pin 24 of JP1 (GPIO_SC[95])\n                // Index 21\n                GpioInt(Edge, ActiveBoth, SharedAndWake, PullNone, 0,\"\\\\_SB.GPO0\",) {95} \n    \n                // Index 22\n                GpioIo (Shared, PullNone, 0, 0, IoRestrictionNone, \"\\\\_SB.GPO0\",) {54}  // Pin 26 of JP1 (GPIO_SC[54])\n                // Index 23\n                GpioInt(Edge, ActiveBoth, SharedAndWake, PullNone, 0,\"\\\\_SB.GPO0\",) {54}\n            })\n    \n            Name(_DSD, Package() \n            {\n                ToUUID(\"daffd814-6eba-4d8c-8a91-bc9bbf4aa301\"),\n                Package() \n                {\n                    // SPI Mapping\n                    Package(2) { \"bus-SPI-SPI0\", Package() { 0 }},\n\n                    Package(2) { \"SPI0-MinClockInHz\", 100000 },\n                    Package(2) { \"SPI0-MaxClockInHz\", 15000000 },\n                    // SupportedDataBitLengths takes a list of support data bit length\n                    // Example : Package(2) { \"SPI0-SupportedDataBitLengths\", Package() { 8, 7, 16 }},\n                    Package(2) { \"SPI0-SupportedDataBitLengths\", Package() { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32 }},\n                     // I2C Mapping\n                    Package(2) { \"bus-I2C-I2C5\", Package() { 1 }},\n                    // UART Mapping\n                    Package(2) { \"bus-UART-UART2\", Package() { 2 }},\n                    Package(2) { \"bus-UART-UART1\", Package() { 9 }},\n                }\n            })\n        }\n    }\n}\n```\n\n### Appendix C - Sample Powershell script to generate GPIO resources\n\nThe following script can be used to generate the GPIO resource declarations for Raspberry Pi:\n\n```\n$pins = @(\n    @{PinNumber=4;PullConfig='PullUp'},\n    @{PinNumber=5;PullConfig='PullUp'},\n    @{PinNumber=6;PullConfig='PullUp'},\n    @{PinNumber=12;PullConfig='PullDown'},\n    @{PinNumber=13;PullConfig='PullDown'},\n    @{PinNumber=16;PullConfig='PullDown'},\n    @{PinNumber=18;PullConfig='PullDown'},\n    @{PinNumber=22;PullConfig='PullDown'},\n    @{PinNumber=23;PullConfig='PullDown'},\n    @{PinNumber=24;PullConfig='PullDown'},\n    @{PinNumber=25;PullConfig='PullDown'},\n    @{PinNumber=26;PullConfig='PullDown'},\n    @{PinNumber=27;PullConfig='PullDown'},\n    @{PinNumber=35;PullConfig='PullUp'},\n    @{PinNumber=47;PullConfig='PullUp'})\n    \n# generate the resources\n$FIRST_RESOURCE_INDEX = 4\n$resourceIndex = $FIRST_RESOURCE_INDEX\n$pins | % {\n    $a = @\"\n// Index $resourceIndex - GPIO $($_.PinNumber) - $($_.Name)\nGpioIO(Shared, $($_.PullConfig), , , , \"\\\\_SB.GPI0\", , , , ) { $($_.PinNumber) }\nGpioInt(Edge, ActiveBoth, Shared, $($_.PullConfig), 0, \"\\\\_SB.GPI0\",) { $($_.PinNumber) }\n\"@    \n    Write-Host $a\n    $resourceIndex += 2;\n}\n```\n"}