{"nodes":[{"content":"Respond to keystroke actions from hardware or software keyboards in your apps using both keyboard and class event handlers.","pos":[47,170]},{"content":"Keyboard interactions","pos":[178,199]},{"content":"Keyboard interactions","pos":[306,327]},{"content":"Keyboard input is an important part of the overall user interaction experience for apps.","pos":[330,418]},{"content":"The keyboard is indispensable to people with certain disabilities or users who just consider it a more efficient way to interact with an app.","pos":[419,560]},{"content":"For example, users should be able to navigate your app by using Tab and arrow keys, activate UI elements by using Spacebar and Enter, and access commands by using keyboard shortcuts.","pos":[561,743]},{"content":"keyboard hero image","pos":[746,765]},{"content":"Important APIs","pos":[820,834]},{"content":"KeyDown","pos":[845,852]},{"content":"KeyUp","pos":[921,926]},{"content":"KeyRoutedEventArgs","pos":[995,1013]},{"content":"A well-designed keyboard UI is an important aspect of software accessibility.","pos":[1077,1154]},{"content":"It enables users with vision impairments or who have certain motor disabilities to navigate an app and interact with its features.","pos":[1155,1285]},{"content":"Such users might not be able to operate a mouse and instead rely on various assistive technologies such as keyboard enhancement tools, on-screen keyboards, screen enlargers, screen readers, and voice input utilities.","pos":[1286,1502]},{"content":"Users can interact with universal apps through a hardware keyboard and two software keyboards: the On-Screen Keyboard (OSK) and the touch keyboard.","pos":[1504,1651]},{"content":"On-Screen Keyboard","pos":[1653,1671]},{"content":"The On-Screen Keyboard is a visual, software keyboard that you can use instead of the physical keyboard to type and enter data using touch, mouse, pen/stylus or other pointing device (a touch screen is not required).","pos":[1674,1890]},{"content":"The On-Screen Keyboard is provided for systems that don't have a physical keyboard, or for users whose mobility impairments prevent them from using traditional physical input devices.","pos":[1891,2074]},{"content":"The On-Screen Keyboard emulates most, if not all, the functionality of a hardware keyboard.","pos":[2075,2166]},{"content":"The On-Screen Keyboard can be turned on from the Keyboard page in Settings <ph id=\"ph1\">&amp;gt;</ph> Ease of access.","pos":[2168,2263]},{"pos":[2265,2394],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  The On-Screen Keyboard has priority over the touch keyboard, which won't be shown if the On-Screen Keyboard is present."},{"content":"the on-screen keyboard","pos":[2401,2423]},{"pos":[2462,2480],"content":"On-Screen Keyboard"},{"content":"Touch keyboard","pos":[2488,2502]},{"content":"The touch keyboard is a visual, software keyboard used for text entry with touch input.","pos":[2505,2592]},{"content":"It is not a replacement for the On-Screen Keyboard as it's used for text input only (it doesn't emulate the hardware keyboard).","pos":[2593,2720]},{"pos":[2722,2908],"content":"Depending on the device, the touch keyboard appears when a text field or other editable text control gets focus, or when the user manually enables it through the <bpt id=\"p1\">**</bpt>Notification Center<ept id=\"p1\">**</ept>:"},{"content":"touch keyboard icon in the notification center","pos":[2912,2958]},{"pos":[3022,3251],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  The user might have to go to the <bpt id=\"p2\">**</bpt>Tablet mode<ept id=\"p2\">**</ept> screen in Settings <ph id=\"ph1\">&amp;gt;</ph> System and turn on \"Make Windows more touch-friendly when using your device as a tablet\" to enable the automatic appearance of the touch keyboard."},{"content":"If your app sets focus programmatically to a text input control, the touch keyboard is not invoked.","pos":[3256,3355]},{"content":"This eliminates unexpected behaviors not instigated directly by the user.","pos":[3356,3429]},{"content":"However, the keyboard does automatically hide when focus is moved programmatically to a non-text input control.","pos":[3430,3541]},{"content":"The touch keyboard typically remains visible while the user navigates between controls in a form.","pos":[3543,3640]},{"content":"This behavior can vary based on the other control types within the form.","pos":[3641,3713]},{"content":"The following is a list of non-edit controls that can receive focus during a text entry session using the touch keyboard without dismissing the keyboard.","pos":[3715,3868]},{"content":"Rather than needlessly churn the UI and potentially disorient the user, the touch keyboard remains in view because the user is likely to go back and forth between these controls and text entry with the touch keyboard.","pos":[3869,4086]},{"content":"Check box","pos":[4092,4101]},{"content":"Combo box","pos":[4106,4115]},{"content":"Radio button","pos":[4120,4132]},{"content":"Scroll bar","pos":[4137,4147]},{"content":"Tree","pos":[4152,4156]},{"content":"Tree item","pos":[4161,4170]},{"content":"Menu","pos":[4175,4179]},{"content":"Menu bar","pos":[4184,4192]},{"content":"Menu item","pos":[4197,4206]},{"content":"Toolbar","pos":[4211,4218]},{"content":"List","pos":[4223,4227]},{"content":"List item","pos":[4232,4241]},{"content":"Here are examples of different modes for the touch keyboard.","pos":[4243,4303]},{"content":"The first image is the default layout, the second is the thumb layout (which might not be available in all languages).","pos":[4304,4422]},{"content":"Here are examples of different modes for the touch keyboard.","pos":[4424,4484]},{"content":"The first image is the default layout, the second is the thumb layout (which might not be available in all languages).","pos":[4485,4603]},{"content":"The touch keyboard in default layout mode:","pos":[4627,4669]},{"content":"The touch keyboard in expanded layout mode:","pos":[4793,4836]},{"content":"The touch keyboard in default thumb layout mode:","pos":[4961,5009]},{"content":"The touch keyboard in numeric thumb layout mode:","pos":[5128,5176]},{"content":"Successful keyboard interactions enable users to accomplish basic app scenarios using only the keyboard; that is, users can reach all interactive elements and activate default functionality.","pos":[5307,5497]},{"content":"A number of factors can affect the degree of success, including keyboard navigation, access keys for accessibility, and accelerator (or shortcut) keys for advanced users.","pos":[5498,5668]},{"pos":[5670,5793],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  The touch keyboard does not support toggle and most system commands (see <bpt id=\"p2\">[</bpt>Patterns<ept id=\"p2\">](#keyboard_command_patterns)</ept>)."},{"content":"Navigation","pos":[5798,5808]},{"content":"To use a control (including navigation elements) with the keyboard, the control must have focus.","pos":[5811,5907]},{"content":"One way for a control to receive keyboard focus is to make it accessible via tab navigation.","pos":[5908,6000]},{"content":"A well designed keyboard navigation model provides a logical and predictable tab order that enables a user to explore and use your app quickly and efficiently.","pos":[6001,6160]},{"content":"All interactive controls should have tab stops (unless they are in a group), whereas non-interactive controls, such as labels, should not.","pos":[6162,6300]},{"content":"A set of related controls can be made into a control group and assigned a single tab stop.","pos":[6302,6392]},{"content":"Control groups are used for sets of controls that behave like a single control, such as radio buttons.","pos":[6393,6495]},{"content":"They can also be used when there too many controls to navigate efficiently with the Tab key alone.","pos":[6496,6594]},{"content":"The arrow keys, Home, End, Page Up, and Page Down move input focus among the controls within a group (it is not possible to navigate out of a control group using these keys).","pos":[6595,6769]},{"content":"You should set initial keyboard focus on the element that users will intuitively (or most likely) interact with first when your app starts.","pos":[6771,6910]},{"content":"Often, this is the main content view of the app so that a user can immediately start using the arrow keys to scroll the app content.","pos":[6911,7043]},{"content":"Don’t set initial keyboard focus on an element with potentially negative, or even disastrous, results.","pos":[7045,7147]},{"content":"This can prevent loss of data or system access.","pos":[7148,7195]},{"content":"Try to rank and present the most important commands, controls, and content first in both the tab order and the display order (or visual hierarchy).","pos":[7197,7344]},{"content":"However, the actual display position can depend on the parent layout container and certain properties of the child elements that influence the layout.","pos":[7345,7495]},{"content":"In particular, layouts that use a grid metaphor or a table metaphor can have a reading order quite different from the tab order.","pos":[7496,7624]},{"content":"This is not always a problem, but you should test your app's functionality, both as a touchable UI and as a keyboard-accessible UI.","pos":[7625,7756]},{"content":"Tab order should follow reading order, whenever possible.","pos":[7758,7815]},{"content":"This can reduce confusion and is dependent on locale and language.","pos":[7816,7882]},{"content":"Associate keyboard buttons with appropriate UI (back and forward buttons) in your app.","pos":[7884,7970]},{"content":"Try to make navigating back to the start screen of your app and between key content as easy and straightforward as possible.","pos":[7972,8096]},{"content":"Use the arrow keys as keyboard shortcuts for proper inner navigation among child elements of composite elements.","pos":[8098,8210]},{"content":"If tree view nodes have separate child elements for handling expand–collapse and node activation, use the left and right arrow keys to provide keyboard expand–collapse functionality.","pos":[8211,8393]},{"content":"This is consistent with the platform controls.","pos":[8394,8440]},{"content":"Because the touch keyboard occludes a large portion of the screen, the Universal Windows Platform (UWP) ensures that the input field with focus scrolls into view as a user navigates through the controls on the form, including controls that are not currently in view.","pos":[8442,8708]},{"content":"Custom controls should emulate this behavior.","pos":[8709,8754]},{"content":"a form with and without the touch keyboard showing","pos":[8758,8808]},{"content":"In some cases, there are UI elements that should stay on the screen the entire time.","pos":[8858,8942]},{"content":"Design the UI so that the form controls are contained in a panning region and the important UI elements are static.","pos":[8943,9058]},{"content":"For example:","pos":[9059,9071]},{"content":"a form that contains areas that should always stay in view","pos":[9075,9133]},{"content":"Activation","pos":[9185,9195]},{"content":"A control can be activated in a number of different ways, whether it currently has focus or not.","pos":[9198,9294]},{"content":"Spacebar, Enter, and Esc","pos":[9296,9320]},{"content":"The spacebar should activate the control with input focus.","pos":[9323,9381]},{"content":"The Enter key should activate a default control or the control with input focus.","pos":[9382,9462]},{"content":"A default control is the control with initial focus or one that responds exclusively to the Enter key (typically it changes with input focus).","pos":[9463,9605]},{"content":"In addition, the Esc key should close or exit transitory UI, such as menus and dialogs.","pos":[9606,9693]},{"content":"The Calculator app shown here uses the spacebar to activate the button with focus, locks the Enter key to the “=” button, and locks the Esc key to the “C” button.","pos":[9695,9857]},{"content":"the calculator app","pos":[9861,9879]},{"content":"Keyboard modifiers","pos":[9920,9938]},{"content":"Keyboard modifiers fall into the following categories:","pos":[9941,9995]},{"content":"Category","pos":[10000,10008]},{"content":"Description","pos":[10011,10022]},{"content":"Shortcut key","pos":[10054,10066]},{"content":"Perform a common action without UI such as \"Ctrl-S\" for <bpt id=\"p1\">**</bpt>Save<ept id=\"p1\">**</ept>.","pos":[10069,10134]},{"content":"Implement keyboard shortcuts for key app functionality.","pos":[10135,10190]},{"content":"Not every command has, or requires, a shortcut.","pos":[10191,10238]},{"content":"Access key/Hot key","pos":[10246,10264]},{"content":"Assigned to every visible, top-level control such as \"Alt-F\" for the <bpt id=\"p1\">**</bpt>File<ept id=\"p1\">**</ept> menu.","pos":[10267,10350]},{"content":"An access key does not invoke or activate a command.","pos":[10351,10403]},{"content":"Accelerator key","pos":[10408,10423]},{"content":"Perform default system or app-defined commands such as \"Alt-PrtScrn\" for screen capture, \"Alt-Tab\" to switch apps, or \"F1\" for help.","pos":[10426,10558]},{"content":"A command associated with an accelerator key does not have to be a menu item.","pos":[10559,10636]},{"content":"Application key/Menu key","pos":[10641,10665]},{"content":"Show context menu.","pos":[10668,10686]},{"content":"Window key/Command key","pos":[10691,10713]},{"pos":[10716,10803],"content":"Activate system commands such as <bpt id=\"p1\">**</bpt>System Menu<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>Lock Screen<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>Show Desktop<ept id=\"p3\">**</ept>."},{"content":"Access keys and accelerator keys support interaction with controls directly instead of navigating to them using the Tab key.","pos":[10807,10931]},{"content":"While some controls have intrinsic labels, such as command buttons, check boxes, and radio buttons, other controls have external labels, such as list views.","pos":[10934,11090]},{"content":"For controls with external labels, the access key is assigned to the label, which, when invoked, sets focus to an element or value within the associated control.","pos":[11091,11252]},{"pos":[11255,11335],"content":"The example here, shows the access keys for the <bpt id=\"p1\">**</bpt>Page Layout<ept id=\"p1\">**</ept> tab in <bpt id=\"p2\">**</bpt>Word<ept id=\"p2\">**</ept>."},{"content":"the access keys for the page layout tab in word","pos":[11339,11386]},{"content":"Here, the Indent Left text field value is highlighted after entering the access key identified in the associated label.","pos":[11432,11551]},{"content":"the indent left text field value is highlighted after entering the access key identified in the associated label","pos":[11555,11667]},{"content":"Usability and accessibility","pos":[11719,11746]},{"content":"A well-designed keyboard interaction experience is an important aspect of software accessibility.","pos":[11749,11846]},{"content":"It enables users with vision impairments or who have certain motor disabilities to navigate an app and interact with its features.","pos":[11847,11977]},{"content":"Such users might be unable to operate a mouse and must, instead, rely on various assistive technologies that include keyboard enhancement tools and on-screen keyboards (along with screen enlargers, screen readers, and voice input utilities).","pos":[11978,12219]},{"content":"For these users, comprehensiveness is more important than consistency.","pos":[12220,12290]},{"content":"Experienced users often have a strong preference for using the keyboard, because keyboard-based commands can be entered more quickly and don't require removing their hands from the keyboard.","pos":[12292,12482]},{"content":"For these users, efficiency and consistency are crucial; comprehensiveness is important only for the most frequently used commands.","pos":[12483,12614]},{"content":"There are subtle distinctions when designing for usability and accessibility, which is why two different keyboard access mechanisms are supported.","pos":[12616,12762]},{"content":"Access keys have the following characteristics:","pos":[12764,12811]},{"content":"An access key is a shortcut to a UI element in your app.","pos":[12817,12873]},{"content":"They use the Alt key plus an alphanumeric key.","pos":[12878,12924]},{"content":"They are primarily for accessibility.","pos":[12929,12966]},{"content":"They are assigned to all menus and most dialog box controls.","pos":[12971,13031]},{"content":"They aren't intended to be memorized, so they are documented directly in the UI by underlining the corresponding control label character.","pos":[13036,13173]},{"content":"They have effect only in the current window, and navigate to the corresponding menu item or control.","pos":[13178,13278]},{"content":"They aren't assigned consistently because they can't always be.","pos":[13283,13346]},{"content":"However, access keys should be assigned consistently for commonly used commands, especially commit buttons.","pos":[13347,13454]},{"content":"They are localized.","pos":[13459,13478]},{"content":"Because access keys aren't intended to be memorized, they are assigned to a character that is early in the label to make them easy to find, even if there is a keyword that appears later in the label.","pos":[13480,13679]},{"content":"In contrast, accelerator keys have the following characteristics:","pos":[13681,13746]},{"content":"An accelerator key is a shortcut to an app command.","pos":[13752,13803]},{"content":"They primarily use Ctrl and Function key sequences (Windows system shortcut keys also use Alt+non-alphanumeric keys and the Windows logo key).","pos":[13808,13950]},{"content":"They are primarily for efficiency for advanced users.","pos":[13955,14008]},{"content":"They are assigned only to the most commonly used commands.","pos":[14013,14071]},{"content":"They are intended to be memorized, and are documented only in menus, tooltips, and Help.","pos":[14076,14164]},{"content":"They have effect throughout the entire program, but have no effect if they don't apply.","pos":[14169,14256]},{"content":"They must be assigned consistently because they are memorized and not directly documented.","pos":[14261,14351]},{"content":"They aren't localized.","pos":[14356,14378]},{"content":"Because accelerator keys are intended to be memorized, the most frequently used accelerator keys ideally use letters from the first or most memorable characters within the command's keywords, such as Ctrl+C for Copy and Ctrl+Q for Request.","pos":[14380,14619]},{"content":"Users should be able to accomplish all tasks supported by your app using only the hardware keyboard or the On-Screen Keyboard.","pos":[14621,14747]},{"content":"You should provide an easy way for users who rely on screen readers and other assistive technology to discover your app's accelerator keys.","pos":[14749,14888]},{"content":"Communicate accelerator keys by using tooltips, accessible names, accessible descriptions, or some other form of on-screen communication.","pos":[14889,15026]},{"content":"At a minimum, access and accelerator keys should be well documented in your app's Help content.","pos":[15027,15122]},{"content":"Don’t assign well-known or standard accelerator keys to other functionality.","pos":[15124,15200]},{"content":"For example, Ctrl+F is typically used for find or search.","pos":[15201,15258]},{"content":"Don’t bother trying to assign access keys to all interactive controls in a dense UI.","pos":[15260,15344]},{"content":"Just ensure the most important and the most used have access keys, or use control groups and assign an access key to the control group label.","pos":[15345,15486]},{"content":"Don't change commands using keyboard modifiers.","pos":[15488,15535]},{"content":"Doing so is undiscoverable and can cause confusion.","pos":[15536,15587]},{"content":"Don't disable a control while it has input focus.","pos":[15589,15638]},{"content":"This can interfere with keyboard input.","pos":[15639,15678]},{"content":"To ensure successful keyboard interaction experiences, it is critical to test your app thoroughly and exclusively with the keyboard.","pos":[15680,15812]},{"content":"Text input","pos":[15817,15827]},{"content":"Always query the device capabilities when relying on keyboard input.","pos":[15830,15898]},{"content":"On some devices (such as phone), the touch keyboard can only be used for text input as it does not provide many of the accelerators or command keys found on a hardware keyboard (such as alt, the function keys, or the Windows Logo key).","pos":[15899,16134]},{"content":"Don't make users navigate the app using the touch keyboard.","pos":[16136,16195]},{"content":"Depending on the control getting focus, the touch keyboard might get dismissed.","pos":[16196,16275]},{"content":"Try to display the keyboard throughout the entire interaction with your form.","pos":[16277,16354]},{"content":"This eliminates UI churn that can disorient the user in the middle of a form or text entry flow.","pos":[16355,16451]},{"content":"Ensure that users can always see the input field that they're typing into.","pos":[16453,16527]},{"content":"The touch keyboard occludes half of the screen, so the input field with focus should scroll into view as the user traverses the form.","pos":[16528,16661]},{"content":"A standard hardware keyboard or OSK consists of seven types of keys, each supporting unique functionality:","pos":[16663,16769]},{"content":"Character key: sends a literal character to the window with input focus.","pos":[16775,16847]},{"content":"Modifier key: alters the function of a primary key when pressed simultaneously, such as Ctrl, Alt, Shift, and the Windows logo key.","pos":[16852,16983]},{"content":"Navigation key: moves input focus or text input location, such as the Tab, Home, End, Page Up, Page Down, and directional arrow keys.","pos":[16988,17121]},{"content":"Editing key: manipulates text, such as the Shift, Tab, Enter, Insert, Backspace, and Delete keys.","pos":[17126,17223]},{"content":"Function key: performs a special function, such as F1 through F12 keys.","pos":[17228,17299]},{"content":"Toggle key: puts the system into a mode, such as Caps Lock, ScrLk, and Num Lock keys.","pos":[17304,17389]},{"content":"Command key: performs a system task or command activation, such as Spacebar, Enter, Esc, Pause/Break, and Print Screen keys.","pos":[17394,17518]},{"content":"In addition to these categories, a secondary class of keys and key combinations exist that can be used as shortcuts to app functionality:","pos":[17520,17657]},{"content":"Access key: exposes controls or menu items by pressing the Alt key with a character key, indicated by underlining of the access key character assignment in a menu, or displaying of the access key character(s) in an overlay.","pos":[17663,17886]},{"content":"Accelerator key: exposes app commands by pressing a function key or the Ctrl key with a character key.","pos":[17891,17993]},{"content":"Your app might or might not have UI that corresponds to the command.","pos":[17994,18062]},{"content":"Another class of key combinations, known as secure attention sequence (SAS), cannot be intercepted by an app.","pos":[18064,18173]},{"content":"This is a security feature intended to protect the user's system during login, and include Ctrl-Alt-Del and Win-L.","pos":[18174,18288]},{"content":"The Notepad app is shown here with the expanded File menu that includes both access keys and accelerator keys.","pos":[18290,18400]},{"content":"the notepad app with expanded file menu that includes both access keys and accelerator keys.","pos":[18404,18496]},{"content":"Keyboard commands","pos":[18537,18554]},{"content":"The following is a comprehensive list of the keyboard interactions provided across the various devices that support keyboard input.","pos":[18557,18688]},{"content":"Some devices and platforms require native keystrokes and interactions, these are noted.","pos":[18689,18776]},{"content":"When designing custom controls and interactions, use this keyboard language consistently to make your app feel familiar, dependable, and easy to learn.","pos":[18778,18929]},{"content":"Don't redefine the default keyboard shortcuts.","pos":[18931,18977]},{"content":"The following tables list frequently used keyboard commands.","pos":[18979,19039]},{"content":"For a complete list of keyboard commands, see <bpt id=\"p1\">[</bpt>Windows Keyboard Shortcut Keys<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=325424)</ept>.","pos":[19040,19168]},{"content":"Navigation commands","pos":[19172,19191]},{"content":"Action","pos":[19197,19203]},{"content":"Key command","pos":[19236,19247]},{"content":"Back","pos":[19381,19385]},{"content":"Alt+Left or the back button on special keyboards","pos":[19420,19468]},{"content":"Forward","pos":[19473,19480]},{"content":"Alt+Right","pos":[19512,19521]},{"content":"Up","pos":[19565,19567]},{"content":"Alt+Up","pos":[19604,19610]},{"content":"Cancel or Escape from current mode","pos":[19657,19691]},{"content":"Esc","pos":[19696,19699]},{"content":"Move through items in a list","pos":[19749,19777]},{"content":"Arrow key (Left, Right, Up, Down)","pos":[19788,19821]},{"content":"Jump to next list of items","pos":[19841,19867]},{"content":"Ctrl+Left","pos":[19880,19889]},{"content":"Semantic zoom","pos":[19933,19946]},{"content":"Ctrl++ or Ctrl+-","pos":[19972,19988]},{"content":"Jump to a named item in a collection","pos":[20025,20061]},{"content":"Start typing item name","pos":[20064,20086]},{"content":"Next page","pos":[20117,20126]},{"content":"Page Up, Page Down or Spacebar","pos":[20156,20186]},{"content":"Next tab","pos":[20209,20217]},{"content":"Ctrl+Tab","pos":[20248,20256]},{"content":"Previous tab","pos":[20301,20313]},{"content":"Ctrl+Shift+Tab","pos":[20340,20354]},{"content":"Open app bar","pos":[20393,20405]},{"content":"Windows+Z","pos":[20432,20441]},{"content":"Activate or Navigate into an item","pos":[20485,20518]},{"content":"Enter","pos":[20524,20529]},{"content":"Select","pos":[20577,20583]},{"content":"Spacebar","pos":[20616,20624]},{"content":"Continuously select","pos":[20669,20688]},{"content":"Shift+Arrow key","pos":[20708,20723]},{"content":"Select all","pos":[20761,20771]},{"content":"Ctrl+A","pos":[20800,20806]},{"content":"Common commands","pos":[20857,20872]},{"content":"Action","pos":[20878,20884]},{"content":"Key command","pos":[20935,20946]},{"content":"Pin an item","pos":[21032,21043]},{"content":"Ctrl+Shift+1","pos":[21089,21101]},{"content":"Save","pos":[21109,21113]},{"content":"Ctrl+S","pos":[21166,21172]},{"content":"Find","pos":[21186,21190]},{"content":"Ctrl+F","pos":[21243,21249]},{"content":"Print","pos":[21263,21268]},{"content":"Ctrl+P","pos":[21320,21326]},{"content":"Copy","pos":[21340,21344]},{"content":"Ctrl+C","pos":[21397,21403]},{"content":"Cut","pos":[21417,21420]},{"content":"Ctrl+X","pos":[21474,21480]},{"content":"New item","pos":[21494,21502]},{"content":"Ctrl+N","pos":[21551,21557]},{"content":"Paste","pos":[21571,21576]},{"content":"Ctrl+V","pos":[21628,21634]},{"content":"Open","pos":[21648,21652]},{"content":"Ctrl+O","pos":[21705,21711]},{"content":"Open address (for example, a URL in Internet Explorer)","pos":[21725,21779]},{"content":"Ctrl+L or Alt+D","pos":[21782,21797]},{"content":"Media navigation commands","pos":[21806,21831]},{"content":"Action","pos":[21837,21843]},{"content":"Key command","pos":[21852,21863]},{"content":"Play/Pause","pos":[21899,21909]},{"content":"Ctrl+P","pos":[21914,21920]},{"content":"Next item","pos":[21930,21939]},{"content":"Ctrl+F","pos":[21945,21951]},{"content":"Preview item","pos":[21961,21973]},{"content":"Ctrl+B","pos":[21976,21982]},{"content":"Note: The media navigation key commands for Play/Pause and Next item are the same as the key commands for Print and Find, respectively.","pos":[21994,22129]},{"content":"Common commands should take priority over media navigation commands.","pos":[22130,22198]},{"content":"For example, if an app supports both plays media and prints, the key command Ctrl+P should print.","pos":[22199,22296]},{"content":"Visual feedback","pos":[22300,22315]},{"content":"Use focus rectangles only with keyboard interactions.","pos":[22318,22371]},{"content":"If the user initiates a touch interaction, make the keyboard UI gradually fade away.","pos":[22372,22456]},{"content":"This keeps the UI clean and uncluttered.","pos":[22457,22497]},{"content":"Don't display visual feedback if an element doesn't support interaction (such as static text).","pos":[22499,22593]},{"content":"Again, this keeps the UI clean and uncluttered.","pos":[22594,22641]},{"content":"Try to display visual feedback concurrently for all elements that represent the same input target.","pos":[22643,22741]},{"content":"Try to provide on-screen buttons (such as + and -) as hints for emulating touch-based manipulations such as panning, rotating, zooming, and so on.","pos":[22743,22889]},{"pos":[22891,23008],"content":"For more general guidance on visual feedback, see <bpt id=\"p1\">[</bpt>Guidelines for visual feedback<ept id=\"p1\">](guidelines-for-visualfeedback.md)</ept>."},{"content":"Keyboard events and focus","pos":[23014,23039]},{"content":"The following keyboard events can occur for both hardware and touch keyboards.","pos":[23042,23120]},{"content":"Event","pos":[23124,23129]},{"content":"Description","pos":[23169,23180]},{"content":"KeyDown","pos":[23287,23294]},{"content":"Occurs when a key is pressed.","pos":[23358,23387]},{"content":"KeyUp","pos":[23396,23401]},{"content":"Occurs when a key is released.","pos":[23469,23499]},{"content":"Important","pos":[23506,23515]},{"content":"Some Windows Runtime controls handle input events internally.","pos":[23520,23581]},{"content":"In these cases, it might appear that an input event doesn't occur because your event listener doesn't invoke the associated handler.","pos":[23582,23714]},{"content":"Typically, this subset of keys is processed by the class handler to provide built in support of basic keyboard accessibility.","pos":[23715,23840]},{"content":"For example, the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Button<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> class overrides the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>OnKeyDown<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh967982)</ept> events for both the Space key and the Enter key (as well as <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>OnPointerPressed<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh967989)</ept>) and routes them to the <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>Click<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br227737)</ept> event of the control.","pos":[23841,24279]},{"content":"When a key press is handled by the control class, the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>KeyUp<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> events are not raised.","pos":[24280,24502]},{"content":"This provides a built-in keyboard equivalent for invoking the button, similar to tapping it with a finger or clicking it with a mouse.","pos":[24504,24638]},{"content":"Keys other than Space or Enter still fire <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>KeyUp<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> events.","pos":[24639,24834]},{"content":"For more info about how class-based handling of events works (specifically, the \"Input event handlers in controls\" section), see <bpt id=\"p1\">[</bpt>Events and routed events overview<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt185584)</ept>.","pos":[24835,25058]},{"content":"Controls in your UI generate keyboard events only when they have input focus.","pos":[25061,25138]},{"content":"An individual control gains focus when the user clicks or taps directly on that control in the layout, or uses the Tab key to step into a tab sequence within the content area.","pos":[25139,25314]},{"content":"You can also call a control's <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Focus<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh702161)</ept> method to force focus.","pos":[25316,25438]},{"content":"This is necessary when you implement shortcut keys, because keyboard focus is not set by default when your UI loads.","pos":[25439,25555]},{"content":"For more info, see the <bpt id=\"p1\">[</bpt>Shortcut keys example<ept id=\"p1\">](#shortcut_keys_example)</ept> later in this topic.","pos":[25556,25647]},{"content":"For a control to receive input focus, it must be enabled, visible, and have <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IsTabStop<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209422)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>HitTestVisible<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208933)</ept> property values of <bpt id=\"p5\">**</bpt>true<ept id=\"p5\">**</ept>.","pos":[25649,25910]},{"content":"This is the default state for most controls.","pos":[25911,25955]},{"content":"When a control has input focus, it can raise and respond to keyboard input events as described later in this topic.","pos":[25956,26071]},{"content":"You can also respond to a control that is receiving or losing focus by handling the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GotFocus<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208927)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>LostFocus<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208943)</ept> events.","pos":[26072,26314]},{"content":"By default, the tab sequence of controls is the order in which they appear in the Extensible Application Markup Language (XAML).","pos":[26316,26444]},{"content":"However, you can modify this order by using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TabIndex<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209461)</ept> property.","pos":[26445,26575]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Implementing keyboard accessibility<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh868161)</ept>.","pos":[26576,26691]},{"content":"Keyboard event handlers","pos":[26696,26719]},{"content":"An input event handler implements a delegate that provides the following information:","pos":[26722,26807]},{"content":"The sender of the event.","pos":[26813,26837]},{"content":"The sender reports the object where the event handler is attached.","pos":[26838,26904]},{"content":"Event data.","pos":[26909,26920]},{"content":"For keyboard events, that data will be an instance of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyRoutedEventArgs<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh943072)</ept>.","pos":[26921,27058]},{"content":"The delegate for handlers is <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyEventHandler<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227904)</ept>.","pos":[27059,27168]},{"content":"The most relevant properties of <bpt id=\"p1\">**</bpt>KeyRoutedEventArgs<ept id=\"p1\">**</ept> for most handler scenarios are <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Key<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh943074)</ept> and possibly <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>KeyStatus<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/hh943075)</ept>.","pos":[27169,27410]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>OriginalSource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208810)</ept>.","pos":[27415,27494]},{"content":"Because the keyboard events are routed events, the event data provides <bpt id=\"p1\">**</bpt>OriginalSource<ept id=\"p1\">**</ept>.","pos":[27495,27585]},{"content":"If you deliberately allow events to bubble up through an object tree, <bpt id=\"p1\">**</bpt>OriginalSource<ept id=\"p1\">**</ept> is sometimes the object of concern rather than sender.","pos":[27586,27729]},{"content":"However, that depends on your design.","pos":[27730,27767]},{"content":"For more information about how you might use <bpt id=\"p1\">**</bpt>OriginalSource<ept id=\"p1\">**</ept> rather than sender, see the \"Keyboard Routed Events\" section of this topic, or <bpt id=\"p2\">[</bpt>Events and routed events overview<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/mt185584)</ept>.","pos":[27768,28005]},{"content":"Attaching a keyboard event handler","pos":[28011,28045]},{"content":"You can attach keyboard event-handler functions for any object that includes the event as a member.","pos":[28047,28146]},{"content":"This includes any <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> derived class.","pos":[28147,28253]},{"content":"The following XAML example shows how to attach handlers for the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyUp<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> event for a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Grid<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242704)</ept>.","pos":[28254,28469]},{"content":"You can also attach an event handler in code.","pos":[28524,28569]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Events and routed events overview<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt185584)</ept>.","pos":[28570,28683]},{"content":"Defining a keyboard event handler","pos":[28689,28722]},{"pos":[28724,28927],"content":"The following example shows the incomplete event handler definition for the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyUp<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> event handler that was attached in the preceding example."},{"content":"Using KeyRoutedEventArgs","pos":[29329,29353]},{"pos":[29355,29539],"content":"All keyboard events use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyRoutedEventArgs<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh943072)</ept> for event data, and <bpt id=\"p3\">**</bpt>KeyRoutedEventArgs<ept id=\"p3\">**</ept> contains the following properties:"},{"content":"Key","pos":[29548,29551]},{"content":"KeyStatus","pos":[29620,29629]},{"content":"Handled","pos":[29698,29705]},{"pos":[29771,29946],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>OriginalSource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208810)</ept> (inherited from <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>RoutedEventArgs<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208809)</ept>)"},{"content":"Key","pos":[29952,29955]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> event is raised if a key is pressed.","pos":[29957,30069]},{"content":"Likewise, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyUp<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> is raised if a key is released.","pos":[30070,30181]},{"content":"Usually, you listen to the events to process a specific key value.","pos":[30182,30248]},{"content":"To determine which key is pressed or released, check the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Key<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh943074)</ept> value in the event data.","pos":[30249,30398]},{"content":"<bpt id=\"p1\">**</bpt>Key<ept id=\"p1\">**</ept> returns a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>VirtualKey<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br241812)</ept> value.","pos":[30399,30498]},{"content":"The <bpt id=\"p1\">**</bpt>VirtualKey<ept id=\"p1\">**</ept> enumeration includes all the supported keys.","pos":[30499,30562]},{"content":"Modifier keys","pos":[30568,30581]},{"content":"Modifier keys are keys such as Ctrl or Shift that users typically press in combination with other keys.","pos":[30583,30686]},{"content":"Your app can use these combinations as keyboard shortcuts to invoke app commands.","pos":[30687,30768]},{"content":"You detect shortcut key combinations by using code in your <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>KeyUp<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> event handlers.","pos":[30770,30990]},{"content":"You can then track the pressed state of the modifier keys you are interested in.","pos":[30991,31071]},{"content":"When a keyboard event occurs for a non-modifier key, you can check whether a modifier key is in the pressed state at the same time.","pos":[31072,31203]},{"pos":[31205,31275],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  The Alt key is represented by the <bpt id=\"p2\">**</bpt>VirtualKey.Menu<ept id=\"p2\">**</ept> value."},{"content":"Shortcut keys example","pos":[31283,31304]},{"content":"The following example demonstrates how to implement shortcut keys.","pos":[31307,31373]},{"content":"In this example, users can control media playback using Play, Pause, and Stop buttons or Ctrl+P, Ctrl+A, and Ctrl+S keyboard shortcuts.","pos":[31374,31509]},{"content":"The button XAML shows the shortcuts by using tooltips and <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>AutomationProperties<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209081)</ept> properties in the button labels.","pos":[31510,31685]},{"content":"This self-documentation is important to increase the usability and accessibility of your app.","pos":[31686,31779]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Keyboard accessibility<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt244347)</ept>.","pos":[31780,31882]},{"content":"Note also that the page sets input focus to itself when it is loaded.","pos":[31884,31953]},{"content":"Without this step, no control has initial input focus, and the app does not raise input events until the user sets the input focus manually (for example, by tabbing to or clicking a control).","pos":[31954,32145]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Setting <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>AutomationProperties.AcceleratorKey<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh759762)</ept> or <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>AutomationProperties.AccessKey<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/hh759763)</ept> in XAML provides string information, which documents the shortcut key for invoking that particular action.","pos":[36709,37031]},{"content":"The information is captured by Microsoft UI Automation clients such as Narrator, and is typically provided directly to the user.","pos":[37032,37160]},{"content":"Setting <bpt id=\"p1\">**</bpt>AutomationProperties.AcceleratorKey<ept id=\"p1\">**</ept> or <bpt id=\"p2\">**</bpt>AutomationProperties.AccessKey<ept id=\"p2\">**</ept> does not have any action on its own.","pos":[37161,37283]},{"content":"You will still need to attach handlers for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>KeyUp<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> events in order to actually implement the keyboard shortcut behavior in your app.","pos":[37284,37553]},{"content":"Also, the underline text decoration for an access key is not provided automatically.","pos":[37554,37638]},{"content":"You must explicitly underline the text for the specific key in your mnemonic as inline <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Underline<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209982)</ept> formatting if you wish to show underlined text in the UI.","pos":[37639,37857]},{"content":"Keyboard routed events","pos":[37865,37887]},{"content":"Certain events are routed events, including <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>KeyUp<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept>.","pos":[37890,38080]},{"content":"Routed events use the bubbling routing strategy.","pos":[38081,38129]},{"content":"The bubbling routing strategy means that an event originates from a child object and is then routed up to successive parent objects in the object tree.","pos":[38130,38281]},{"content":"This presents another opportunity to handle the same event and interact with the same event data.","pos":[38282,38379]},{"content":"Consider the following XAML example, which handles <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyUp<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> events for a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Canvas<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> and two <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Button<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> objects.","pos":[38381,38673]},{"content":"In this case, if you release a key while focus is held by either <bpt id=\"p1\">**</bpt>Button<ept id=\"p1\">**</ept> object, it raises the <bpt id=\"p2\">**</bpt>KeyUp<ept id=\"p2\">**</ept> event.","pos":[38674,38788]},{"content":"The event is then bubbled up to the parent <bpt id=\"p1\">**</bpt>Canvas<ept id=\"p1\">**</ept>.","pos":[38789,38843]},{"pos":[39040,39233],"content":"The following example shows how to implement the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyUp<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> event handler for the corresponding XAML content in the preceding example."},{"content":"Notice the use of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>OriginalSource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208810)</ept> property in the preceding handler.","pos":[39485,39620]},{"content":"Here, <bpt id=\"p1\">**</bpt>OriginalSource<ept id=\"p1\">**</ept> reports the object that raised the event.","pos":[39621,39687]},{"content":"The object could not be the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StackPanel<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209635)</ept> because the <bpt id=\"p3\">**</bpt>StackPanel<ept id=\"p3\">**</ept> is not a control and cannot have focus.","pos":[39688,39857]},{"content":"Only one of the two buttons within the <bpt id=\"p1\">**</bpt>StackPanel<ept id=\"p1\">**</ept> could possibly have raised the event, but which one?","pos":[39858,39964]},{"content":"You use <bpt id=\"p1\">**</bpt>OriginalSource<ept id=\"p1\">**</ept> to distinguish the actual event source object, if you are handling the event on a parent object.","pos":[39965,40088]},{"content":"The Handled property in event data","pos":[40094,40128]},{"content":"Depending on your event handling strategy, you might want only one event handler to react to a bubbling event.","pos":[40130,40240]},{"content":"For instance, if you have a specific <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyUp<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> handler attached to one of the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Button<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> controls, it would have the first opportunity to handle that event.","pos":[40241,40517]},{"content":"In this case, you might not want the parent panel to also handle the event.","pos":[40518,40593]},{"content":"For this scenario, you can use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Handled<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh943073)</ept> property in the event data.","pos":[40594,40728]},{"content":"The purpose of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Handled<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh943073)</ept> property in a routed event data class is to report that another handler you registered earlier on the event route has already acted.","pos":[40730,40953]},{"content":"This influences the behavior of the routed event system.","pos":[40954,41010]},{"content":"When you set <bpt id=\"p1\">**</bpt>Handled<ept id=\"p1\">**</ept> to <bpt id=\"p2\">**</bpt>true<ept id=\"p2\">**</ept> in an event handler, that event stops routing and is not sent to successive parent elements.","pos":[41011,41140]},{"content":"AddHandler and already-handled keyboard events","pos":[41146,41192]},{"content":"You can use a special technique for attaching handlers that can act on events that you already marked as handled.","pos":[41194,41307]},{"content":"This technique uses the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>AddHandler<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh702399)</ept> method to register a handler, rather than using XAML attributes or language-specific syntax for adding handlers, such as += in C<ph id=\"ph1\">\\#</ph>. A limitation of this technique in general is that the <bpt id=\"p3\">**</bpt>AddHandler<ept id=\"p3\">**</ept> API takes a parameter of type <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>RoutedEvent<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br208808)</ept> that identifies the routed event in question.","pos":[41308,41759]},{"content":"Not all routed events provide a <bpt id=\"p1\">**</bpt>RoutedEvent<ept id=\"p1\">**</ept> identifier, and this consideration thus affects which routed events can still be handled in the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Handled<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh943073)</ept> case.","pos":[41760,41981]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>KeyUp<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> events have routed event identifiers (<bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>KeyDownEvent<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh702416)</ept> and <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>KeyUpEvent<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/hh702418)</ept>) on <bpt id=\"p9\">[</bpt><bpt id=\"p10\">**</bpt>UIElement<ept id=\"p10\">**</ept><ept id=\"p9\">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept>.","pos":[41982,42404]},{"content":"However, other events such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TextBox.TextChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209706)</ept> do not have routed event identifiers and thus cannot be used with the <bpt id=\"p3\">**</bpt>AddHandler<ept id=\"p3\">**</ept> technique.","pos":[42405,42614]},{"content":"Commanding","pos":[42619,42629]},{"content":"A small number of UI elements provide built-in support for commanding.","pos":[42632,42702]},{"content":"Commanding uses input-related routed events in its underlying implementation.","pos":[42703,42780]},{"content":"It enables processing of related UI input, such as a certain pointer action or a specific accelerator key, by invoking a single command handler.","pos":[42781,42925]},{"content":"If commanding is available for a UI element, consider using its commanding APIs instead of any discrete input events.","pos":[42927,43044]},{"content":"For more info, see <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ButtonBase.Command<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227740)</ept>.","pos":[43045,43147]},{"content":"You can also implement <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ICommand<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227885)</ept> to encapsulate command functionality that you invoke from ordinary event handlers.","pos":[43149,43327]},{"content":"This enables you to use commanding even when there is no <bpt id=\"p1\">**</bpt>Command<ept id=\"p1\">**</ept> property available.","pos":[43328,43416]},{"content":"Text input and controls","pos":[43421,43444]},{"content":"Certain controls react to keyboard events with their own handling.","pos":[43447,43513]},{"content":"For instance, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TextBox<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209683)</ept> is a control that is designed to capture and then visually represent text that was entered by using the keyboard.","pos":[43514,43713]},{"content":"It uses <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyUp<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>KeyDown<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> in its own logic to capture keystrokes, then also raises its own <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>TextChanged<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br209706)</ept> event if the text actually changed.","pos":[43714,44044]},{"content":"You can still generally add handlers for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyUp<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>KeyDown<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> to a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>TextBox<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br209683)</ept>, or any related control that is intended to process text input.","pos":[44046,44373]},{"content":"However, as part of its intended design, a control might not respond to all key values that are directed to it through key events.","pos":[44374,44504]},{"content":"Behavior is specific to each control.","pos":[44505,44542]},{"content":"As an example, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ButtonBase<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227736)</ept> (the base class for <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Button<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept>) processes <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>KeyUp<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> so that it can check for the Spacebar or Enter key.","pos":[44544,44857]},{"content":"<bpt id=\"p1\">**</bpt>ButtonBase<ept id=\"p1\">**</ept> considers <bpt id=\"p2\">**</bpt>KeyUp<ept id=\"p2\">**</ept> equivalent to a mouse left button down for purposes of raising a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Click<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227737)</ept> event.","pos":[44858,45034]},{"content":"This processing of the event is accomplished when <bpt id=\"p1\">**</bpt>ButtonBase<ept id=\"p1\">**</ept> overrides the virtual method <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>OnKeyUp<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/hh967983)</ept>.","pos":[45035,45201]},{"content":"In its implementation, it sets <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Handled<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh943073)</ept> to <bpt id=\"p3\">**</bpt>true<ept id=\"p3\">**</ept>.","pos":[45202,45317]},{"content":"The result is that any parent of a button that is listening for a key event, in the case of a Spacebar, would not receive the already-handled event for its own handlers.","pos":[45318,45487]},{"content":"Another example is <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TextBox<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209683)</ept>.","pos":[45489,45580]},{"content":"Some keys, such as the ARROW keys, are not considered text by <bpt id=\"p1\">**</bpt>TextBox<ept id=\"p1\">**</ept> and are instead considered specific to the control UI behavior.","pos":[45581,45718]},{"content":"The <bpt id=\"p1\">**</bpt>TextBox<ept id=\"p1\">**</ept> marks these event cases as handled.","pos":[45719,45770]},{"content":"Custom controls can implement their own similar override behavior for key events by overriding <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>OnKeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh967982)</ept><ph id=\"ph1\"> / </ph><bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>OnKeyUp<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh967983)</ept>.","pos":[45772,46015]},{"content":"If your custom control processes specific accelerator keys, or has control or focus behavior that is similar to the scenario described for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TextBox<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209683)</ept>, you should place this logic in your own <bpt id=\"p3\">**</bpt>OnKeyDown<ept id=\"p3\">**</ept><ph id=\"ph1\"> / </ph><bpt id=\"p4\">**</bpt>OnKeyUp<ept id=\"p4\">**</ept> overrides.","pos":[46016,46306]},{"content":"The touch keyboard","pos":[46311,46329]},{"content":"Text input controls provide automatic support for the touch keyboard.","pos":[46332,46401]},{"content":"When the user sets the input focus to a text control by using touch input, the touch keyboard appears automatically.","pos":[46402,46518]},{"content":"When the input focus is not on a text control, the touch keyboard is hidden.","pos":[46519,46595]},{"content":"When the touch keyboard appears, it automatically repositions your UI to ensure that the focused element remains visible.","pos":[46597,46718]},{"content":"This can cause other important areas of your UI to move off screen.","pos":[46719,46786]},{"content":"However, you can disable the default behavior and make your own UI adjustments when the touch keyboard appears.","pos":[46787,46898]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Responding to the appearance of the on-screen keyboard sample<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=231633)</ept>.","pos":[46899,47031]},{"content":"If you create a custom control that requires text input, but does not derive from a standard text input control, you can add touch keyboard support by implementing the correct UI Automation control patterns.","pos":[47033,47240]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Respond to the presence of the touch keyboard<ept id=\"p1\">](respond-to-the-presence-of-the-touch-keyboard.md)</ept> and the <bpt id=\"p2\">[</bpt>Touch keyboard sample<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?linkid=246019)</ept>.","pos":[47241,47439]},{"content":"Key presses on the touch keyboard raise <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>KeyDown<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>KeyUp<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> events just like key presses on hardware keyboards.","pos":[47441,47678]},{"content":"However, the touch keyboard will not raise input events for Ctrl+A, Ctrl+Z, Ctrl+X, Ctrl+C, and Ctrl+V, which are reserved for text manipulation in the input control.","pos":[47679,47845]},{"content":"You can make it much faster and easier for users to enter data in your app by setting the input scope of the text control to match the kind of data you expect the user to enter.","pos":[47847,48024]},{"content":"The input scope provides a hint at the type of text input expected by the control so the system can provide a specialized touch keyboard layout for the input type.","pos":[48025,48188]},{"content":"For example, if a text box is used only to enter a 4-digit PIN, set the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>InputScope<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh702632)</ept> property to <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Number<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh702028)</ept>.","pos":[48189,48419]},{"content":"This tells the system to show the numeric keypad layout, which makes it easier for the user to enter the PIN.","pos":[48420,48529]},{"content":"For more detail, see <bpt id=\"p1\">[</bpt>Use input scope to change the touch keyboard<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt280229)</ept>.","pos":[48530,48656]},{"content":"Additional articles in this section","pos":[48662,48697]},{"content":"Topic","pos":[48814,48819]},{"content":"Description","pos":[48842,48853]},{"content":"Respond to the presence of the touch keyboard","pos":[48920,48965]},{"content":"Learn how to tailor the UI of your app when showing or hiding the touch keyboard.","pos":[49046,49127]},{"content":"Related articles","pos":[49169,49185]},{"content":"Developers","pos":[49190,49200]},{"content":"Identify input devices","pos":[49206,49228]},{"content":"Respond to the presence of the touch keyboard","pos":[49260,49305]},{"content":"Designers","pos":[49360,49369]},{"content":"Keyboard design guidelines","pos":[49375,49401]},{"content":"Samples","pos":[49464,49471]},{"content":"Basic input sample","pos":[49477,49495]},{"content":"Low latency input sample","pos":[49549,49573]},{"content":"Focus visuals sample","pos":[49627,49647]},{"content":"Archive Samples","pos":[49701,49716]},{"content":"Input sample","pos":[49722,49734]},{"content":"Input: Device capabilities sample","pos":[49788,49821]},{"content":"Input: Touch keyboard sample","pos":[49875,49903]},{"content":"Responding to the appearance of the on-screen keyboard sample","pos":[49957,50018]},{"content":"XAML text editing sample","pos":[50072,50096]}],"content":"---\nauthor: Karl-Bridge-Microsoft\nDescription: Respond to keystroke actions from hardware or software keyboards in your apps using both keyboard and class event handlers.\ntitle: Keyboard interactions\nms.assetid: FF819BAC-67C0-4EC9-8921-F087BE188138\nlabel: Keyboard interactions\ntemplate: detail.hbs\n---\n\n# Keyboard interactions\n\n\nKeyboard input is an important part of the overall user interaction experience for apps. The keyboard is indispensable to people with certain disabilities or users who just consider it a more efficient way to interact with an app. For example, users should be able to navigate your app by using Tab and arrow keys, activate UI elements by using Spacebar and Enter, and access commands by using keyboard shortcuts.\n![keyboard hero image](images/input-patterns/input-keyboard-small.jpg)\n\n\n\n**Important APIs**\n\n-   [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941)\n-   [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942)\n-   [**KeyRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943072)\n\n\nA well-designed keyboard UI is an important aspect of software accessibility. It enables users with vision impairments or who have certain motor disabilities to navigate an app and interact with its features. Such users might not be able to operate a mouse and instead rely on various assistive technologies such as keyboard enhancement tools, on-screen keyboards, screen enlargers, screen readers, and voice input utilities.\n\nUsers can interact with universal apps through a hardware keyboard and two software keyboards: the On-Screen Keyboard (OSK) and the touch keyboard.\n\nOn-Screen Keyboard  \nThe On-Screen Keyboard is a visual, software keyboard that you can use instead of the physical keyboard to type and enter data using touch, mouse, pen/stylus or other pointing device (a touch screen is not required). The On-Screen Keyboard is provided for systems that don't have a physical keyboard, or for users whose mobility impairments prevent them from using traditional physical input devices. The On-Screen Keyboard emulates most, if not all, the functionality of a hardware keyboard.\n\nThe On-Screen Keyboard can be turned on from the Keyboard page in Settings &gt; Ease of access.\n\n**Note**  The On-Screen Keyboard has priority over the touch keyboard, which won't be shown if the On-Screen Keyboard is present.\n\n \n\n![the on-screen keyboard](images/input-patterns/osk.png)\n\n<sup>On-Screen Keyboard</sup>\n\nTouch keyboard  \nThe touch keyboard is a visual, software keyboard used for text entry with touch input. It is not a replacement for the On-Screen Keyboard as it's used for text input only (it doesn't emulate the hardware keyboard).\n\nDepending on the device, the touch keyboard appears when a text field or other editable text control gets focus, or when the user manually enables it through the **Notification Center**:\n\n![touch keyboard icon in the notification center](images/input-patterns/touch-keyboard-notificationcenter.png)\n\n**Note**  The user might have to go to the **Tablet mode** screen in Settings &gt; System and turn on \"Make Windows more touch-friendly when using your device as a tablet\" to enable the automatic appearance of the touch keyboard.\n\n \n\nIf your app sets focus programmatically to a text input control, the touch keyboard is not invoked. This eliminates unexpected behaviors not instigated directly by the user. However, the keyboard does automatically hide when focus is moved programmatically to a non-text input control.\n\nThe touch keyboard typically remains visible while the user navigates between controls in a form. This behavior can vary based on the other control types within the form.\n\nThe following is a list of non-edit controls that can receive focus during a text entry session using the touch keyboard without dismissing the keyboard. Rather than needlessly churn the UI and potentially disorient the user, the touch keyboard remains in view because the user is likely to go back and forth between these controls and text entry with the touch keyboard.\n\n-   Check box\n-   Combo box\n-   Radio button\n-   Scroll bar\n-   Tree\n-   Tree item\n-   Menu\n-   Menu bar\n-   Menu item\n-   Toolbar\n-   List\n-   List item\n\nHere are examples of different modes for the touch keyboard. The first image is the default layout, the second is the thumb layout (which might not be available in all languages).\n\nHere are examples of different modes for the touch keyboard. The first image is the default layout, the second is the thumb layout (which might not be available in all languages).\n<table>\n<tr>\n    <td>**The touch keyboard in default layout mode:  **</td>\n    <td>![the touch keyboard in default layout mode](images/touchkeyboard-standard.png)</td>\n</tr>\n<tr>\n    <td>**The touch keyboard in expanded layout mode:  **</td>\n    <td>![the touch keyboard in expanded layout mode](images/touchkeyboard-expanded.png)</td>\n</tr>\n<tr>\n    <td>**The touch keyboard in default thumb layout mode:  **</td>\n    <td>![the touch keyboard in thumb layout mode](images/touchkeyboard-thumb.png)</td>\n</tr>\n<tr>\n    <td>**The touch keyboard in numeric thumb layout mode:  **</td>\n    <td>![the touch keyboard in numeric thumb layout mode](images/touchkeyboard-numeric-thumb.png)</td>\n</tr>\n</table>\n\n\nSuccessful keyboard interactions enable users to accomplish basic app scenarios using only the keyboard; that is, users can reach all interactive elements and activate default functionality. A number of factors can affect the degree of success, including keyboard navigation, access keys for accessibility, and accelerator (or shortcut) keys for advanced users.\n\n**Note**  The touch keyboard does not support toggle and most system commands (see [Patterns](#keyboard_command_patterns)).\n\n## Navigation\n\n\nTo use a control (including navigation elements) with the keyboard, the control must have focus. One way for a control to receive keyboard focus is to make it accessible via tab navigation. A well designed keyboard navigation model provides a logical and predictable tab order that enables a user to explore and use your app quickly and efficiently.\n\nAll interactive controls should have tab stops (unless they are in a group), whereas non-interactive controls, such as labels, should not.\n\nA set of related controls can be made into a control group and assigned a single tab stop. Control groups are used for sets of controls that behave like a single control, such as radio buttons. They can also be used when there too many controls to navigate efficiently with the Tab key alone. The arrow keys, Home, End, Page Up, and Page Down move input focus among the controls within a group (it is not possible to navigate out of a control group using these keys).\n\nYou should set initial keyboard focus on the element that users will intuitively (or most likely) interact with first when your app starts. Often, this is the main content view of the app so that a user can immediately start using the arrow keys to scroll the app content.\n\nDon’t set initial keyboard focus on an element with potentially negative, or even disastrous, results. This can prevent loss of data or system access.\n\nTry to rank and present the most important commands, controls, and content first in both the tab order and the display order (or visual hierarchy). However, the actual display position can depend on the parent layout container and certain properties of the child elements that influence the layout. In particular, layouts that use a grid metaphor or a table metaphor can have a reading order quite different from the tab order. This is not always a problem, but you should test your app's functionality, both as a touchable UI and as a keyboard-accessible UI.\n\nTab order should follow reading order, whenever possible. This can reduce confusion and is dependent on locale and language.\n\nAssociate keyboard buttons with appropriate UI (back and forward buttons) in your app.\n\nTry to make navigating back to the start screen of your app and between key content as easy and straightforward as possible.\n\nUse the arrow keys as keyboard shortcuts for proper inner navigation among child elements of composite elements. If tree view nodes have separate child elements for handling expand–collapse and node activation, use the left and right arrow keys to provide keyboard expand–collapse functionality. This is consistent with the platform controls.\n\nBecause the touch keyboard occludes a large portion of the screen, the Universal Windows Platform (UWP) ensures that the input field with focus scrolls into view as a user navigates through the controls on the form, including controls that are not currently in view. Custom controls should emulate this behavior.\n\n![a form with and without the touch keyboard showing](images/input-patterns/touch-keyboard-pan1.png)\n\nIn some cases, there are UI elements that should stay on the screen the entire time. Design the UI so that the form controls are contained in a panning region and the important UI elements are static. For example:\n\n![a form that contains areas that should always stay in view](images/input-patterns/touch-keyboard-pan2.png)\n## Activation\n\n\nA control can be activated in a number of different ways, whether it currently has focus or not.\n\nSpacebar, Enter, and Esc  \nThe spacebar should activate the control with input focus. The Enter key should activate a default control or the control with input focus. A default control is the control with initial focus or one that responds exclusively to the Enter key (typically it changes with input focus). In addition, the Esc key should close or exit transitory UI, such as menus and dialogs.\n\nThe Calculator app shown here uses the spacebar to activate the button with focus, locks the Enter key to the “=” button, and locks the Esc key to the “C” button.\n\n![the calculator app](images/input-patterns/calculator.png)\n\nKeyboard modifiers  \nKeyboard modifiers fall into the following categories:\n\n\n| Category | Description |\n|----------|-------------|\n| Shortcut key | Perform a common action without UI such as \"Ctrl-S\" for **Save**. Implement keyboard shortcuts for key app functionality. Not every command has, or requires, a shortcut. |   \n| Access key/Hot key | Assigned to every visible, top-level control such as \"Alt-F\" for the **File** menu. An access key does not invoke or activate a command. |\n| Accelerator key | Perform default system or app-defined commands such as \"Alt-PrtScrn\" for screen capture, \"Alt-Tab\" to switch apps, or \"F1\" for help. A command associated with an accelerator key does not have to be a menu item. |\n| Application key/Menu key | Show context menu. |\n| Window key/Command key | Activate system commands such as **System Menu**, **Lock Screen**, or **Show Desktop**. |\n\nAccess keys and accelerator keys support interaction with controls directly instead of navigating to them using the Tab key.\n> While some controls have intrinsic labels, such as command buttons, check boxes, and radio buttons, other controls have external labels, such as list views. For controls with external labels, the access key is assigned to the label, which, when invoked, sets focus to an element or value within the associated control.\n\n\nThe example here, shows the access keys for the **Page Layout** tab in **Word**.\n\n![the access keys for the page layout tab in word](images/input-patterns/accesskeys-show.png)\n\nHere, the Indent Left text field value is highlighted after entering the access key identified in the associated label.\n\n![the indent left text field value is highlighted after entering the access key identified in the associated label](images/input-patterns/accesskeys-entered.png)\n\n## Usability and accessibility\n\n\nA well-designed keyboard interaction experience is an important aspect of software accessibility. It enables users with vision impairments or who have certain motor disabilities to navigate an app and interact with its features. Such users might be unable to operate a mouse and must, instead, rely on various assistive technologies that include keyboard enhancement tools and on-screen keyboards (along with screen enlargers, screen readers, and voice input utilities). For these users, comprehensiveness is more important than consistency.\n\nExperienced users often have a strong preference for using the keyboard, because keyboard-based commands can be entered more quickly and don't require removing their hands from the keyboard. For these users, efficiency and consistency are crucial; comprehensiveness is important only for the most frequently used commands.\n\nThere are subtle distinctions when designing for usability and accessibility, which is why two different keyboard access mechanisms are supported.\n\nAccess keys have the following characteristics:\n\n-   An access key is a shortcut to a UI element in your app.\n-   They use the Alt key plus an alphanumeric key.\n-   They are primarily for accessibility.\n-   They are assigned to all menus and most dialog box controls.\n-   They aren't intended to be memorized, so they are documented directly in the UI by underlining the corresponding control label character.\n-   They have effect only in the current window, and navigate to the corresponding menu item or control.\n-   They aren't assigned consistently because they can't always be. However, access keys should be assigned consistently for commonly used commands, especially commit buttons.\n-   They are localized.\n\nBecause access keys aren't intended to be memorized, they are assigned to a character that is early in the label to make them easy to find, even if there is a keyword that appears later in the label.\n\nIn contrast, accelerator keys have the following characteristics:\n\n-   An accelerator key is a shortcut to an app command.\n-   They primarily use Ctrl and Function key sequences (Windows system shortcut keys also use Alt+non-alphanumeric keys and the Windows logo key).\n-   They are primarily for efficiency for advanced users.\n-   They are assigned only to the most commonly used commands.\n-   They are intended to be memorized, and are documented only in menus, tooltips, and Help.\n-   They have effect throughout the entire program, but have no effect if they don't apply.\n-   They must be assigned consistently because they are memorized and not directly documented.\n-   They aren't localized.\n\nBecause accelerator keys are intended to be memorized, the most frequently used accelerator keys ideally use letters from the first or most memorable characters within the command's keywords, such as Ctrl+C for Copy and Ctrl+Q for Request.\n\nUsers should be able to accomplish all tasks supported by your app using only the hardware keyboard or the On-Screen Keyboard.\n\nYou should provide an easy way for users who rely on screen readers and other assistive technology to discover your app's accelerator keys. Communicate accelerator keys by using tooltips, accessible names, accessible descriptions, or some other form of on-screen communication. At a minimum, access and accelerator keys should be well documented in your app's Help content.\n\nDon’t assign well-known or standard accelerator keys to other functionality. For example, Ctrl+F is typically used for find or search.\n\nDon’t bother trying to assign access keys to all interactive controls in a dense UI. Just ensure the most important and the most used have access keys, or use control groups and assign an access key to the control group label.\n\nDon't change commands using keyboard modifiers. Doing so is undiscoverable and can cause confusion.\n\nDon't disable a control while it has input focus. This can interfere with keyboard input.\n\nTo ensure successful keyboard interaction experiences, it is critical to test your app thoroughly and exclusively with the keyboard.\n\n## Text input\n\n\nAlways query the device capabilities when relying on keyboard input. On some devices (such as phone), the touch keyboard can only be used for text input as it does not provide many of the accelerators or command keys found on a hardware keyboard (such as alt, the function keys, or the Windows Logo key).\n\nDon't make users navigate the app using the touch keyboard. Depending on the control getting focus, the touch keyboard might get dismissed.\n\nTry to display the keyboard throughout the entire interaction with your form. This eliminates UI churn that can disorient the user in the middle of a form or text entry flow.\n\nEnsure that users can always see the input field that they're typing into. The touch keyboard occludes half of the screen, so the input field with focus should scroll into view as the user traverses the form.\n\nA standard hardware keyboard or OSK consists of seven types of keys, each supporting unique functionality:\n\n-   Character key: sends a literal character to the window with input focus.\n-   Modifier key: alters the function of a primary key when pressed simultaneously, such as Ctrl, Alt, Shift, and the Windows logo key.\n-   Navigation key: moves input focus or text input location, such as the Tab, Home, End, Page Up, Page Down, and directional arrow keys.\n-   Editing key: manipulates text, such as the Shift, Tab, Enter, Insert, Backspace, and Delete keys.\n-   Function key: performs a special function, such as F1 through F12 keys.\n-   Toggle key: puts the system into a mode, such as Caps Lock, ScrLk, and Num Lock keys.\n-   Command key: performs a system task or command activation, such as Spacebar, Enter, Esc, Pause/Break, and Print Screen keys.\n\nIn addition to these categories, a secondary class of keys and key combinations exist that can be used as shortcuts to app functionality:\n\n-   Access key: exposes controls or menu items by pressing the Alt key with a character key, indicated by underlining of the access key character assignment in a menu, or displaying of the access key character(s) in an overlay.\n-   Accelerator key: exposes app commands by pressing a function key or the Ctrl key with a character key. Your app might or might not have UI that corresponds to the command.\n\nAnother class of key combinations, known as secure attention sequence (SAS), cannot be intercepted by an app. This is a security feature intended to protect the user's system during login, and include Ctrl-Alt-Del and Win-L.\n\nThe Notepad app is shown here with the expanded File menu that includes both access keys and accelerator keys.\n\n![the notepad app with expanded file menu that includes both access keys and accelerator keys.](images/input-patterns/notepad.png)\n\n## Keyboard commands\n\n\nThe following is a comprehensive list of the keyboard interactions provided across the various devices that support keyboard input. Some devices and platforms require native keystrokes and interactions, these are noted.\n\nWhen designing custom controls and interactions, use this keyboard language consistently to make your app feel familiar, dependable, and easy to learn.\n\nDon't redefine the default keyboard shortcuts.\n\nThe following tables list frequently used keyboard commands. For a complete list of keyboard commands, see [Windows Keyboard Shortcut Keys](http://go.microsoft.com/fwlink/p/?linkid=325424).\n\n**Navigation commands**\n\n| Action                               | Key command                                      |\n|--------------------------------------|--------------------------------------------------|\n| Back                                 | Alt+Left or the back button on special keyboards |\n| Forward                              | Alt+Right                                        |\n| Up                                   | Alt+Up                                           |\n| Cancel or Escape from current mode   | Esc                                              |\n| Move through items in a list         | Arrow key (Left, Right, Up, Down)                |\n| Jump to next list of items           | Ctrl+Left                                        |\n| Semantic zoom                        | Ctrl++ or Ctrl+-                                 |\n| Jump to a named item in a collection | Start typing item name                           |\n| Next page                            | Page Up, Page Down or Spacebar                   |\n| Next tab                             | Ctrl+Tab                                         |\n| Previous tab                         | Ctrl+Shift+Tab                                   |\n| Open app bar                         | Windows+Z                                        |\n| Activate or Navigate into an item    | Enter                                            |\n| Select                               | Spacebar                                         |\n| Continuously select                  | Shift+Arrow key                                  |\n| Select all                           | Ctrl+A                                           |\n\n \n\n**Common commands**\n\n| Action                                                 | Key command     |\n|--------------------------------------------------------|-----------------|\n| Pin an item                                            | Ctrl+Shift+1    |\n| Save                                                   | Ctrl+S          |\n| Find                                                   | Ctrl+F          |\n| Print                                                  | Ctrl+P          |\n| Copy                                                   | Ctrl+C          |\n| Cut                                                    | Ctrl+X          |\n| New item                                               | Ctrl+N          |\n| Paste                                                  | Ctrl+V          |\n| Open                                                   | Ctrl+O          |\n| Open address (for example, a URL in Internet Explorer) | Ctrl+L or Alt+D |\n\n \n\n**Media navigation commands**\n\n| Action       | Key command |\n|--------------|-------------|\n| Play/Pause   | Ctrl+P      |\n| Next item    | Ctrl+F      |\n| Preview item | Ctrl+B      |\n\n \n\nNote: The media navigation key commands for Play/Pause and Next item are the same as the key commands for Print and Find, respectively. Common commands should take priority over media navigation commands. For example, if an app supports both plays media and prints, the key command Ctrl+P should print.\n## Visual feedback\n\n\nUse focus rectangles only with keyboard interactions. If the user initiates a touch interaction, make the keyboard UI gradually fade away. This keeps the UI clean and uncluttered.\n\nDon't display visual feedback if an element doesn't support interaction (such as static text). Again, this keeps the UI clean and uncluttered.\n\nTry to display visual feedback concurrently for all elements that represent the same input target.\n\nTry to provide on-screen buttons (such as + and -) as hints for emulating touch-based manipulations such as panning, rotating, zooming, and so on.\n\nFor more general guidance on visual feedback, see [Guidelines for visual feedback](guidelines-for-visualfeedback.md).\n\n\n## Keyboard events and focus\n\n\nThe following keyboard events can occur for both hardware and touch keyboards.\n\n| Event                                      | Description                    |\n|--------------------------------------------|--------------------------------|\n| [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) | Occurs when a key is pressed.  |\n| [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942)     | Occurs when a key is released. |\n\n\n**Important**  \nSome Windows Runtime controls handle input events internally. In these cases, it might appear that an input event doesn't occur because your event listener doesn't invoke the associated handler. Typically, this subset of keys is processed by the class handler to provide built in support of basic keyboard accessibility. For example, the [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) class overrides the [**OnKeyDown**](https://msdn.microsoft.com/library/windows/apps/hh967982) events for both the Space key and the Enter key (as well as [**OnPointerPressed**](https://msdn.microsoft.com/library/windows/apps/hh967989)) and routes them to the [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737) event of the control. When a key press is handled by the control class, the [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) and [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) events are not raised.\n\nThis provides a built-in keyboard equivalent for invoking the button, similar to tapping it with a finger or clicking it with a mouse. Keys other than Space or Enter still fire [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) and [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) events. For more info about how class-based handling of events works (specifically, the \"Input event handlers in controls\" section), see [Events and routed events overview](https://msdn.microsoft.com/library/windows/apps/mt185584).\n\n\nControls in your UI generate keyboard events only when they have input focus. An individual control gains focus when the user clicks or taps directly on that control in the layout, or uses the Tab key to step into a tab sequence within the content area.\n\nYou can also call a control's [**Focus**](https://msdn.microsoft.com/library/windows/apps/hh702161) method to force focus. This is necessary when you implement shortcut keys, because keyboard focus is not set by default when your UI loads. For more info, see the [Shortcut keys example](#shortcut_keys_example) later in this topic.\n\nFor a control to receive input focus, it must be enabled, visible, and have [**IsTabStop**](https://msdn.microsoft.com/library/windows/apps/br209422) and [**HitTestVisible**](https://msdn.microsoft.com/library/windows/apps/br208933) property values of **true**. This is the default state for most controls. When a control has input focus, it can raise and respond to keyboard input events as described later in this topic. You can also respond to a control that is receiving or losing focus by handling the [**GotFocus**](https://msdn.microsoft.com/library/windows/apps/br208927) and [**LostFocus**](https://msdn.microsoft.com/library/windows/apps/br208943) events.\n\nBy default, the tab sequence of controls is the order in which they appear in the Extensible Application Markup Language (XAML). However, you can modify this order by using the [**TabIndex**](https://msdn.microsoft.com/library/windows/apps/br209461) property. For more info, see [Implementing keyboard accessibility](https://msdn.microsoft.com/library/windows/apps/hh868161).\n\n## Keyboard event handlers\n\n\nAn input event handler implements a delegate that provides the following information:\n\n-   The sender of the event. The sender reports the object where the event handler is attached.\n-   Event data. For keyboard events, that data will be an instance of [**KeyRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943072). The delegate for handlers is [**KeyEventHandler**](https://msdn.microsoft.com/library/windows/apps/br227904). The most relevant properties of **KeyRoutedEventArgs** for most handler scenarios are [**Key**](https://msdn.microsoft.com/library/windows/apps/hh943074) and possibly [**KeyStatus**](https://msdn.microsoft.com/library/windows/apps/hh943075).\n-   [**OriginalSource**](https://msdn.microsoft.com/library/windows/apps/br208810). Because the keyboard events are routed events, the event data provides **OriginalSource**. If you deliberately allow events to bubble up through an object tree, **OriginalSource** is sometimes the object of concern rather than sender. However, that depends on your design. For more information about how you might use **OriginalSource** rather than sender, see the \"Keyboard Routed Events\" section of this topic, or [Events and routed events overview](https://msdn.microsoft.com/library/windows/apps/mt185584).\n\n### Attaching a keyboard event handler\n\nYou can attach keyboard event-handler functions for any object that includes the event as a member. This includes any [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911) derived class. The following XAML example shows how to attach handlers for the [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) event for a [**Grid**](https://msdn.microsoft.com/library/windows/apps/br242704).\n\n```XAML\n<Grid KeyUp=\"Grid_KeyUp\">\n  ...\n</Grid>\n```\n\nYou can also attach an event handler in code. For more info, see [Events and routed events overview](https://msdn.microsoft.com/library/windows/apps/mt185584).\n\n### Defining a keyboard event handler\n\nThe following example shows the incomplete event handler definition for the [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) event handler that was attached in the preceding example.\n\n```CSharp\nvoid Grid_KeyUp(object sender, KeyRoutedEventArgs e)\n{\n    //handling code here\n}\n```\n\n```VisualBasic\nPrivate Sub Grid_KeyUp(ByVal sender As Object, ByVal e As KeyRoutedEventArgs)\n    &#39;handling code here\nEnd Sub\n```\n\n```ManagedCPlusPlus\nvoid MyProject::MainPage::Grid_KeyUp(\n  Platform::Object^ sender,\n  Windows::UI::Xaml::Input::KeyRoutedEventArgs^ e)\n{//handling code here}\n```\n\n### Using KeyRoutedEventArgs\n\nAll keyboard events use [**KeyRoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/hh943072) for event data, and **KeyRoutedEventArgs** contains the following properties:\n\n-   [**Key**](https://msdn.microsoft.com/library/windows/apps/hh943074)\n-   [**KeyStatus**](https://msdn.microsoft.com/library/windows/apps/hh943075)\n-   [**Handled**](https://msdn.microsoft.com/library/windows/apps/hh943073)\n-   [**OriginalSource**](https://msdn.microsoft.com/library/windows/apps/br208810) (inherited from [**RoutedEventArgs**](https://msdn.microsoft.com/library/windows/apps/br208809))\n\n### Key\n\nThe [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) event is raised if a key is pressed. Likewise, [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) is raised if a key is released. Usually, you listen to the events to process a specific key value. To determine which key is pressed or released, check the [**Key**](https://msdn.microsoft.com/library/windows/apps/hh943074) value in the event data. **Key** returns a [**VirtualKey**](https://msdn.microsoft.com/library/windows/apps/br241812) value. The **VirtualKey** enumeration includes all the supported keys.\n\n### Modifier keys\n\nModifier keys are keys such as Ctrl or Shift that users typically press in combination with other keys. Your app can use these combinations as keyboard shortcuts to invoke app commands.\n\nYou detect shortcut key combinations by using code in your [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) and [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) event handlers. You can then track the pressed state of the modifier keys you are interested in. When a keyboard event occurs for a non-modifier key, you can check whether a modifier key is in the pressed state at the same time.\n\n**Note**  The Alt key is represented by the **VirtualKey.Menu** value.\n\n \n\n## Shortcut keys example\n\n\nThe following example demonstrates how to implement shortcut keys. In this example, users can control media playback using Play, Pause, and Stop buttons or Ctrl+P, Ctrl+A, and Ctrl+S keyboard shortcuts. The button XAML shows the shortcuts by using tooltips and [**AutomationProperties**](https://msdn.microsoft.com/library/windows/apps/br209081) properties in the button labels. This self-documentation is important to increase the usability and accessibility of your app. For more info, see [Keyboard accessibility](https://msdn.microsoft.com/library/windows/apps/mt244347).\n\nNote also that the page sets input focus to itself when it is loaded. Without this step, no control has initial input focus, and the app does not raise input events until the user sets the input focus manually (for example, by tabbing to or clicking a control).\n\n```XAML\n<Grid KeyDown=\"Grid_KeyDown\">\n\n  <Grid.RowDefinitions>\n    <RowDefinition Height=\"Auto\" />\n    <RowDefinition Height=\"Auto\" />\n  </Grid.RowDefinitions>\n\n  <MediaElement x:Name=\"DemoMovie\" Source=\"xbox.wmv\"\n    Width=\"500\" Height=\"500\" Margin=\"20\" HorizontalAlignment=\"Center\" />\n\n  <StackPanel Grid.Row=\"1\" Margin=\"10\"\n    Orientation=\"Horizontal\" HorizontalAlignment=\"Center\">\n\n    <Button x:Name=\"PlayButton\" Click=\"MediaButton_Click\"\n      ToolTipService.ToolTip=\"Shortcut key: Ctrl+P\"\n      AutomationProperties.AcceleratorKey=\"Control P\">\n      <TextBlock>Play</TextBlock>\n    </Button>\n\n    <Button x:Name=\"PauseButton\" Click=\"MediaButton_Click\"\n      ToolTipService.ToolTip=\"Shortcut key: Ctrl+A\"\n      AutomationProperties.AcceleratorKey=\"Control A\">\n      <TextBlock>Pause</TextBlock>\n    </Button>\n\n    <Button x:Name=\"StopButton\" Click=\"MediaButton_Click\"\n      ToolTipService.ToolTip=\"Shortcut key: Ctrl+S\"\n      AutomationProperties.AcceleratorKey=\"Control S\">\n      <TextBlock>Stop</TextBlock>\n    </Button>\n\n  </StackPanel>\n\n</Grid>\n```\n\n```ManagedCPlusPlus\n//showing implementations but not header definitions\nvoid MainPage::OnNavigatedTo(NavigationEventArgs^ e)\n{\n    (void) e;    // Unused parameter\n    this->Loaded+=ref new RoutedEventHandler(this,&amp;MainPage::ProgrammaticFocus);\n}\nvoid MainPage::ProgrammaticFocus(Object^ sender, RoutedEventArgs^ e) {\n    this->Focus(Windows::UI::Xaml::FocusState::Programmatic);\n}\n\nvoid KeyboardSupport::MainPage::MediaButton_Click(Platform::Object^ sender, Windows::UI::Xaml::RoutedEventArgs^ e)\n{\n    FrameworkElement^ fe = safe_cast<FrameworkElement^>(sender);\n    if (fe->Name == \"PlayButton\") {DemoMovie->Play();}\n    if (fe->Name == \"PauseButton\") {DemoMovie->Pause();}\n    if (fe->Name == \"StopButton\") {DemoMovie->Stop();}\n}\n\n\nvoid KeyboardSupport::MainPage::Grid_KeyDown(Platform::Object^ sender, Windows::UI::Xaml::Input::KeyRoutedEventArgs^ e)\n{\n    if (e->Key == VirtualKey::Control) isCtrlKeyPressed = true;\n}\n\n\nvoid KeyboardSupport::MainPage::Grid_KeyUp(Platform::Object^ sender, Windows::UI::Xaml::Input::KeyRoutedEventArgs^ e)\n{\n    if (e->Key == VirtualKey::Control) isCtrlKeyPressed = true;\n    else if (isCtrlKeyPressed) {\n        if (e->Key==VirtualKey::P) {\n            DemoMovie->Play();\n        }\n        if (e->Key==VirtualKey::A) {DemoMovie->Pause();}\n        if (e->Key==VirtualKey::S) {DemoMovie->Stop();}\n    }\n}\n```\n\n```CSharp\nprotected override void OnNavigatedTo(NavigationEventArgs e)\n{\n    // Set the input focus to ensure that keyboard events are raised.\n    this.Loaded += delegate { this.Focus(FocusState.Programmatic); };\n}\n\nprivate void Grid_KeyUp(object sender, KeyRoutedEventArgs e)\n{\n    if (e.Key == VirtualKey.Control) isCtrlKeyPressed = false;\n}\n\nprivate void Grid_KeyDown(object sender, KeyRoutedEventArgs e)\n{\n    if (e.Key == VirtualKey.Control) isCtrlKeyPressed = true;\n    else if (isCtrlKeyPressed)\n    {\n        switch (e.Key)\n        {\n            case VirtualKey.P: DemoMovie.Play(); break;\n            case VirtualKey.A: DemoMovie.Pause(); break;\n            case VirtualKey.S: DemoMovie.Stop(); break;\n        }\n    }\n}\n\nprivate void MediaButton_Click(object sender, RoutedEventArgs e)\n{\n    switch ((sender as Button).Name)\n    {\n        case \"PlayButton\": DemoMovie.Play(); break;\n        case \"PauseButton\": DemoMovie.Pause(); break;\n        case \"StopButton\": DemoMovie.Stop(); break;\n    }\n}\n```\n\n```VisualBasic\nPrivate isCtrlKeyPressed As Boolean\nProtected Overrides Sub OnNavigatedTo(e As Navigation.NavigationEventArgs)\n\nEnd Sub\n\nPrivate Sub Grid_KeyUp(sender As Object, e As KeyRoutedEventArgs)\n    If e.Key = Windows.System.VirtualKey.Control Then\n        isCtrlKeyPressed = False\n    End If\nEnd Sub\n\nPrivate Sub Grid_KeyDown(sender As Object, e As KeyRoutedEventArgs)\n    If e.Key = Windows.System.VirtualKey.Control Then isCtrlKeyPressed = True\n    If isCtrlKeyPressed Then\n        Select Case e.Key\n            Case Windows.System.VirtualKey.P\n                DemoMovie.Play()\n            Case Windows.System.VirtualKey.A\n                DemoMovie.Pause()\n            Case Windows.System.VirtualKey.S\n                DemoMovie.Stop()\n        End Select\n    End If\nEnd Sub\n\nPrivate Sub MediaButton_Click(sender As Object, e As RoutedEventArgs)\n    Dim fe As FrameworkElement = CType(sender, FrameworkElement)\n    Select Case fe.Name\n        Case \"PlayButton\"\n            DemoMovie.Play()\n        Case \"PauseButton\"\n            DemoMovie.Pause()\n        Case \"StopButton\"\n            DemoMovie.Stop()\n    End Select\nEnd Sub\n```\n\n**Note**  Setting [**AutomationProperties.AcceleratorKey**](https://msdn.microsoft.com/library/windows/apps/hh759762) or [**AutomationProperties.AccessKey**](https://msdn.microsoft.com/library/windows/apps/hh759763) in XAML provides string information, which documents the shortcut key for invoking that particular action. The information is captured by Microsoft UI Automation clients such as Narrator, and is typically provided directly to the user. Setting **AutomationProperties.AcceleratorKey** or **AutomationProperties.AccessKey** does not have any action on its own. You will still need to attach handlers for [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) or [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) events in order to actually implement the keyboard shortcut behavior in your app. Also, the underline text decoration for an access key is not provided automatically. You must explicitly underline the text for the specific key in your mnemonic as inline [**Underline**](https://msdn.microsoft.com/library/windows/apps/br209982) formatting if you wish to show underlined text in the UI.\n\n \n\n## Keyboard routed events\n\n\nCertain events are routed events, including [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) and [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942). Routed events use the bubbling routing strategy. The bubbling routing strategy means that an event originates from a child object and is then routed up to successive parent objects in the object tree. This presents another opportunity to handle the same event and interact with the same event data.\n\nConsider the following XAML example, which handles [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) events for a [**Canvas**](https://msdn.microsoft.com/library/windows/apps/br209267) and two [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) objects. In this case, if you release a key while focus is held by either **Button** object, it raises the **KeyUp** event. The event is then bubbled up to the parent **Canvas**.\n\n```XAML\n<StackPanel KeyUp=\"StackPanel_KeyUp\">\n  <Button Name=\"ButtonA\" Content=\"Button A\"/>\n  <Button Name=\"ButtonB\" Content=\"Button B\"/>\n  <TextBlock Name=\"statusTextBlock\"/>\n</StackPanel>\n```\n\nThe following example shows how to implement the [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) event handler for the corresponding XAML content in the preceding example.\n\n```CSharp\nvoid StackPanel_KeyUp(object sender, KeyRoutedEventArgs e)\n{\n    statusTextBlock.Text = String.Format(\n        \"The key {0} was pressed while focus was on {1}\",\n        e.Key.ToString(), (e.OriginalSource as FrameworkElement).Name);\n}\n```\n\nNotice the use of the [**OriginalSource**](https://msdn.microsoft.com/library/windows/apps/br208810) property in the preceding handler. Here, **OriginalSource** reports the object that raised the event. The object could not be the [**StackPanel**](https://msdn.microsoft.com/library/windows/apps/br209635) because the **StackPanel** is not a control and cannot have focus. Only one of the two buttons within the **StackPanel** could possibly have raised the event, but which one? You use **OriginalSource** to distinguish the actual event source object, if you are handling the event on a parent object.\n\n### The Handled property in event data\n\nDepending on your event handling strategy, you might want only one event handler to react to a bubbling event. For instance, if you have a specific [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) handler attached to one of the [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265) controls, it would have the first opportunity to handle that event. In this case, you might not want the parent panel to also handle the event. For this scenario, you can use the [**Handled**](https://msdn.microsoft.com/library/windows/apps/hh943073) property in the event data.\n\nThe purpose of the [**Handled**](https://msdn.microsoft.com/library/windows/apps/hh943073) property in a routed event data class is to report that another handler you registered earlier on the event route has already acted. This influences the behavior of the routed event system. When you set **Handled** to **true** in an event handler, that event stops routing and is not sent to successive parent elements.\n\n### AddHandler and already-handled keyboard events\n\nYou can use a special technique for attaching handlers that can act on events that you already marked as handled. This technique uses the [**AddHandler**](https://msdn.microsoft.com/library/windows/apps/hh702399) method to register a handler, rather than using XAML attributes or language-specific syntax for adding handlers, such as += in C\\#. A limitation of this technique in general is that the **AddHandler** API takes a parameter of type [**RoutedEvent**](https://msdn.microsoft.com/library/windows/apps/br208808) that identifies the routed event in question. Not all routed events provide a **RoutedEvent** identifier, and this consideration thus affects which routed events can still be handled in the [**Handled**](https://msdn.microsoft.com/library/windows/apps/hh943073) case. The [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) and [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) events have routed event identifiers ([**KeyDownEvent**](https://msdn.microsoft.com/library/windows/apps/hh702416) and [**KeyUpEvent**](https://msdn.microsoft.com/library/windows/apps/hh702418)) on [**UIElement**](https://msdn.microsoft.com/library/windows/apps/br208911). However, other events such as [**TextBox.TextChanged**](https://msdn.microsoft.com/library/windows/apps/br209706) do not have routed event identifiers and thus cannot be used with the **AddHandler** technique.\n\n## Commanding\n\n\nA small number of UI elements provide built-in support for commanding. Commanding uses input-related routed events in its underlying implementation. It enables processing of related UI input, such as a certain pointer action or a specific accelerator key, by invoking a single command handler.\n\nIf commanding is available for a UI element, consider using its commanding APIs instead of any discrete input events. For more info, see [**ButtonBase.Command**](https://msdn.microsoft.com/library/windows/apps/br227740).\n\nYou can also implement [**ICommand**](https://msdn.microsoft.com/library/windows/apps/br227885) to encapsulate command functionality that you invoke from ordinary event handlers. This enables you to use commanding even when there is no **Command** property available.\n\n## Text input and controls\n\n\nCertain controls react to keyboard events with their own handling. For instance, [**TextBox**](https://msdn.microsoft.com/library/windows/apps/br209683) is a control that is designed to capture and then visually represent text that was entered by using the keyboard. It uses [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) and [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) in its own logic to capture keystrokes, then also raises its own [**TextChanged**](https://msdn.microsoft.com/library/windows/apps/br209706) event if the text actually changed.\n\nYou can still generally add handlers for [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) and [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) to a [**TextBox**](https://msdn.microsoft.com/library/windows/apps/br209683), or any related control that is intended to process text input. However, as part of its intended design, a control might not respond to all key values that are directed to it through key events. Behavior is specific to each control.\n\nAs an example, [**ButtonBase**](https://msdn.microsoft.com/library/windows/apps/br227736) (the base class for [**Button**](https://msdn.microsoft.com/library/windows/apps/br209265)) processes [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) so that it can check for the Spacebar or Enter key. **ButtonBase** considers **KeyUp** equivalent to a mouse left button down for purposes of raising a [**Click**](https://msdn.microsoft.com/library/windows/apps/br227737) event. This processing of the event is accomplished when **ButtonBase** overrides the virtual method [**OnKeyUp**](https://msdn.microsoft.com/library/windows/apps/hh967983). In its implementation, it sets [**Handled**](https://msdn.microsoft.com/library/windows/apps/hh943073) to **true**. The result is that any parent of a button that is listening for a key event, in the case of a Spacebar, would not receive the already-handled event for its own handlers.\n\nAnother example is [**TextBox**](https://msdn.microsoft.com/library/windows/apps/br209683). Some keys, such as the ARROW keys, are not considered text by **TextBox** and are instead considered specific to the control UI behavior. The **TextBox** marks these event cases as handled.\n\nCustom controls can implement their own similar override behavior for key events by overriding [**OnKeyDown**](https://msdn.microsoft.com/library/windows/apps/hh967982) / [**OnKeyUp**](https://msdn.microsoft.com/library/windows/apps/hh967983). If your custom control processes specific accelerator keys, or has control or focus behavior that is similar to the scenario described for [**TextBox**](https://msdn.microsoft.com/library/windows/apps/br209683), you should place this logic in your own **OnKeyDown** / **OnKeyUp** overrides.\n\n## The touch keyboard\n\n\nText input controls provide automatic support for the touch keyboard. When the user sets the input focus to a text control by using touch input, the touch keyboard appears automatically. When the input focus is not on a text control, the touch keyboard is hidden.\n\nWhen the touch keyboard appears, it automatically repositions your UI to ensure that the focused element remains visible. This can cause other important areas of your UI to move off screen. However, you can disable the default behavior and make your own UI adjustments when the touch keyboard appears. For more info, see [Responding to the appearance of the on-screen keyboard sample](http://go.microsoft.com/fwlink/p/?linkid=231633).\n\nIf you create a custom control that requires text input, but does not derive from a standard text input control, you can add touch keyboard support by implementing the correct UI Automation control patterns. For more info, see [Respond to the presence of the touch keyboard](respond-to-the-presence-of-the-touch-keyboard.md) and the [Touch keyboard sample](http://go.microsoft.com/fwlink/p/?linkid=246019).\n\nKey presses on the touch keyboard raise [**KeyDown**](https://msdn.microsoft.com/library/windows/apps/br208941) and [**KeyUp**](https://msdn.microsoft.com/library/windows/apps/br208942) events just like key presses on hardware keyboards. However, the touch keyboard will not raise input events for Ctrl+A, Ctrl+Z, Ctrl+X, Ctrl+C, and Ctrl+V, which are reserved for text manipulation in the input control.\n\nYou can make it much faster and easier for users to enter data in your app by setting the input scope of the text control to match the kind of data you expect the user to enter. The input scope provides a hint at the type of text input expected by the control so the system can provide a specialized touch keyboard layout for the input type. For example, if a text box is used only to enter a 4-digit PIN, set the [**InputScope**](https://msdn.microsoft.com/library/windows/apps/hh702632) property to [**Number**](https://msdn.microsoft.com/library/windows/apps/hh702028). This tells the system to show the numeric keypad layout, which makes it easier for the user to enter the PIN. For more detail, see [Use input scope to change the touch keyboard](https://msdn.microsoft.com/library/windows/apps/mt280229).\n\n\n## Additional articles in this section\n<table>\n<colgroup>\n<col width=\"50%\" />\n<col width=\"50%\" />\n</colgroup>\n<thead>\n<tr class=\"header\">\n<th align=\"left\">Topic</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr class=\"odd\">\n<td align=\"left\"><p>[Respond to the presence of the touch keyboard](respond-to-the-presence-of-the-touch-keyboard.md)</p></td>\n<td align=\"left\"><p>Learn how to tailor the UI of your app when showing or hiding the touch keyboard.</p></td>\n</tr>\n</tbody>\n</table>\n\n \n\n\n## Related articles\n\n\n**Developers**\n* [Identify input devices](identify-input-devices.md)\n* [Respond to the presence of the touch keyboard](respond-to-the-presence-of-the-touch-keyboard.md)\n\n**Designers**\n* [Keyboard design guidelines](https://msdn.microsoft.com/library/windows/apps/hh972345)\n\n**Samples**\n* [Basic input sample](http://go.microsoft.com/fwlink/p/?LinkID=620302)\n* [Low latency input sample](http://go.microsoft.com/fwlink/p/?LinkID=620304)\n* [Focus visuals sample](http://go.microsoft.com/fwlink/p/?LinkID=619895)\n\n**Archive Samples**\n* [Input sample](http://go.microsoft.com/fwlink/p/?linkid=226855)\n* [Input: Device capabilities sample](http://go.microsoft.com/fwlink/p/?linkid=231530)\n* [Input: Touch keyboard sample](http://go.microsoft.com/fwlink/p/?linkid=246019)\n* [Responding to the appearance of the on-screen keyboard sample](http://go.microsoft.com/fwlink/p/?linkid=231633)\n* [XAML text editing sample](http://go.microsoft.com/fwlink/p/?LinkID=251417)\n \n\n \n"}