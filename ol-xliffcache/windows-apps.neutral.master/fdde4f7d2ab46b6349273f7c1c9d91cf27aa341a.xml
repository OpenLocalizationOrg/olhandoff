{"nodes":[{"content":"This topic shows examples of the coding tasks needed to achieve some of the most common stream- and buffer-related enterprise data protection (EDP) scenarios.","pos":[36,194]},{"content":"Use enterprise data protection (EDP) to protect streams and buffers","pos":[354,421]},{"content":"Use enterprise data protection (EDP) to protect streams and buffers","pos":[430,497]},{"pos":[499,619],"content":"<bpt id=\"p1\">__</bpt>Note<ept id=\"p1\">__</ept> Enterprise data protection (EDP) policy cannot be applied on Windows 10, Version 1511 (build 10586) or earlier."},{"content":"This topic shows examples of the coding tasks needed to achieve some of the most common stream- and buffer-related enterprise data protection (EDP) scenarios.","pos":[621,779]},{"content":"For the full developer picture of how EDP relates to files, streams, the clipboard, networking, background tasks, and data protection under lock, see <bpt id=\"p1\">[</bpt>enterprise data protection (EDP)<ept id=\"p1\">](../enterprise/edp-hub.md)</ept>.","pos":[780,991]},{"pos":[993,1171],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  The <bpt id=\"p2\">[</bpt>enterprise data protection (EDP) sample<ept id=\"p2\">](http://go.microsoft.com/fwlink/p/?LinkId=620031&amp;clcid=0x409)</ept> covers many of the same scenarios demonstrated in this topic."},{"content":"Prerequisites","pos":[1176,1189]},{"content":"Get set up for EDP","pos":[1198,1216]},{"pos":[1224,1314],"content":"See <bpt id=\"p1\">[</bpt>Set up your computer for EDP<ept id=\"p1\">](../enterprise/edp-hub.md#set-up-your-computer-for-EDP)</ept>."},{"content":"Commit to building an enterprise-enlightened app","pos":[1322,1370]},{"content":"An app that autonomously ensures that enterprise data stays under the managing enterprise’s control is known as an enterprise-enlightened app.","pos":[1378,1520]},{"content":"An enlightened app is more powerful, smart, flexible, and trusted than an unenlightened one.","pos":[1521,1613]},{"content":"Your app announces to the system that it is enlightened by declaring the restricted <bpt id=\"p1\">**</bpt>enterpriseDataPolicy<ept id=\"p1\">**</ept> capability.","pos":[1614,1734]},{"content":"There's more to being enlightened than setting a capability, though.","pos":[1735,1803]},{"content":"To learn more, see <bpt id=\"p1\">[</bpt>Enterprise-enlightened apps<ept id=\"p1\">](../enterprise/edp-hub.md#enterprise-enlightened-apps)</ept>.","pos":[1804,1907]},{"content":"Understand async programming for Universal Windows Platform (UWP) apps","pos":[1915,1985]},{"content":"To learn about how to write asynchronous apps in C<ph id=\"ph1\">\\#</ph> or Visual Basic, see <bpt id=\"p1\">[</bpt>Call asynchronous APIs in C<ph id=\"ph2\">\\#</ph> or Visual Basic<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt187337)</ept>.","pos":[1993,2173]},{"content":"To learn about how to write asynchronous apps in C++, see <bpt id=\"p1\">[</bpt>Asynchronous programming in C++<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt187334)</ept>.","pos":[2174,2324]},{"content":"Protect a stream of data to an enterprise identity","pos":[2329,2379]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Whenever you protect a stream or a buffer, it's highly recommended that you subscribe to the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ProtectionPolicyManager.PolicyChanged<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/mt608411)</ept> event so that your app is aware in the event that EDP becomes disabled on the device.","pos":[2382,2672]},{"content":"When this happens, you should unprotect any streams and buffers.","pos":[2673,2737]},{"content":"Any stream or buffer that you leave protected becomes eligible to be revoked should the user un-enroll the device from mobile device management (MDM).","pos":[2738,2888]},{"content":"And, if EDP was disabled when the resource was created, then that revocation is inappropriate.","pos":[2889,2983]},{"content":"Unprotecting the resources when EDP is disabled prevents that.","pos":[2984,3046]},{"content":"In this scenario, your app has access to an unprotected stream that contains enterprise data.","pos":[3050,3143]},{"content":"In order to ensure that this stream is protected when transferring it within and outside the device, your app protects the data to the enterprise identity that it belongs to.","pos":[3144,3318]},{"content":"This allows wiping the data, when required, by the enterprise.","pos":[3319,3381]},{"content":"In order to later determine whether or not to call an \"unprotect\" method on a stream, the app must maintain state that indicates whether the stream was protected, which is why the function in this code example returns that state.","pos":[3382,3611]},{"content":"If the identity passed is not managed, or if the app is not allowed for the identity, the stream will not be protected and an ‘Unprotected’ status will be returned from the call to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataProtectionManager.ProtectStreamAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn706021)</ept>.","pos":[3612,3898]},{"content":"To show how you might use a method like the one in the code example above, here's a helper method that uses it to convert a string into an unprotected stream, and then protect the stream.","pos":[4969,5156]},{"content":"Retrieve the status of a stream","pos":[5917,5948]},{"content":"In this scenario, your app has previously protected a stream to which you must prevent unauthorized access.","pos":[5951,6058]},{"content":"In order to retrieve the stream's contents back when needed, your app can check the status of the stream.","pos":[6059,6164]},{"content":"Note that the status of a stream is also returned from <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataProtectionManager.UnprotectStreamAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn706023)</ept>.","pos":[6166,6328]},{"content":"This API will never return a status of ‘Unprotected’, since it requires that the input resource be protected (it is not possible to reliably verify that a resource is unprotected).","pos":[6329,6509]},{"content":"Be aware if you have code that compares the result with 'Unprotected', then that suggests the presence of a design flaw.","pos":[6510,6630]},{"content":"It's an indication that your code has lost track of whether the stream is protected.","pos":[6631,6715]},{"content":"Unprotect a stream of data","pos":[7376,7402]},{"content":"In this scenario, your app wishes to unprotected a stream that it previously protected.","pos":[7405,7492]},{"content":"This code example takes a protected stream (note that the stream must be protected for this process to work) and unprotects it with a call to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataProtectionManager.UnprotectStreamAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn706023)</ept>.","pos":[7493,7742]},{"content":"It then reads a string out of the stream and returns it.","pos":[7743,7799]},{"content":"To show how you might use the helper methods given so far, here's an event handler that takes a string from a text box, writes the string into a stream, protects the stream, unprotects the stream (if it was successfully protected), and finally reads the string back from the unprotected stream and displays it in the UI.","pos":[8699,9019]},{"content":"Retrieve the status of a static data buffer","pos":[9670,9713]},{"content":"In this scenario, your app has previously protected a buffer to which you must prevent unauthorized access.","pos":[9716,9823]},{"content":"In order to retrieve the buffer's contents back when needed, your app can check the status of the buffer.","pos":[9824,9929]},{"content":"Note that the status of a buffer is also returned from <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataProtectionManager.UnprotectAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn706022)</ept>.","pos":[9931,10087]},{"content":"This API will never return a status of ‘Unprotected’, since it requires that the input resource be protected.","pos":[10088,10197]},{"content":"Protect static data retrieved from an enterprise resource","pos":[10842,10899]},{"content":"This scenario covers the same ground as the stream code examples, except it works with a buffer of data.","pos":[10902,11006]},{"content":"Again, you need to maintain state that indicates whether the buffer was protected, as shown.","pos":[11007,11099]},{"content":"If the identity passed is not managed, or if the app is not allowed for the identity, the buffer will not be protected and an ‘Unprotected’ status will be returned from the call to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataProtectionManager.ProtectAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn706020)</ept>.","pos":[11100,11380]},{"content":"Enable UI-policy enforcement based on a stream's or buffer’s protected identity","pos":[13386,13465]},{"content":"When your app is about to display the contents of a protected stream or buffer on its UI, it must enable UI-policy enforcement based on the identity the resource is protected to.","pos":[13468,13646]},{"content":"You should query the protection information of the resource and enable the system's UI-policy enforcement from the retrieved identity.","pos":[13647,13781]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.","pos":[14436,14534]},{"content":"If you’re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id=\"p1\">[</bpt>archived documentation<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.","pos":[14535,14676]},{"content":"Related topics","pos":[14684,14698]},{"content":"enterprise data protection (EDP) sample","pos":[14702,14741]},{"content":"Windows.Security.EnterpriseData namespace","pos":[14808,14849]}],"content":"---\nauthor: TylerMSFT\nDescription: 'This topic shows examples of the coding tasks needed to achieve some of the most common stream- and buffer-related enterprise data protection (EDP) scenarios.'\nMS-HAID: 'dev\\_files.use\\_edp\\_to\\_protect\\_streams\\_and\\_buffers'\nMSHAttr: 'PreferredLib:/library/windows/apps'\nSearch.Product: eADQiWindows 10XVcnh\ntitle: 'Use enterprise data protection (EDP) to protect streams and buffers'\n---\n\n# Use enterprise data protection (EDP) to protect streams and buffers\n\n__Note__ Enterprise data protection (EDP) policy cannot be applied on Windows 10, Version 1511 (build 10586) or earlier.\n\nThis topic shows examples of the coding tasks needed to achieve some of the most common stream- and buffer-related enterprise data protection (EDP) scenarios. For the full developer picture of how EDP relates to files, streams, the clipboard, networking, background tasks, and data protection under lock, see [enterprise data protection (EDP)](../enterprise/edp-hub.md).\n\n**Note**  The [enterprise data protection (EDP) sample](http://go.microsoft.com/fwlink/p/?LinkId=620031&clcid=0x409) covers many of the same scenarios demonstrated in this topic.\n\n## Prerequisites\n\n\n-   **Get set up for EDP**\n\n    See [Set up your computer for EDP](../enterprise/edp-hub.md#set-up-your-computer-for-EDP).\n\n-   **Commit to building an enterprise-enlightened app**\n\n    An app that autonomously ensures that enterprise data stays under the managing enterprise’s control is known as an enterprise-enlightened app. An enlightened app is more powerful, smart, flexible, and trusted than an unenlightened one. Your app announces to the system that it is enlightened by declaring the restricted **enterpriseDataPolicy** capability. There's more to being enlightened than setting a capability, though. To learn more, see [Enterprise-enlightened apps](../enterprise/edp-hub.md#enterprise-enlightened-apps).\n\n-   **Understand async programming for Universal Windows Platform (UWP) apps**\n\n    To learn about how to write asynchronous apps in C\\# or Visual Basic, see [Call asynchronous APIs in C\\# or Visual Basic](https://msdn.microsoft.com/library/windows/apps/mt187337). To learn about how to write asynchronous apps in C++, see [Asynchronous programming in C++](https://msdn.microsoft.com/library/windows/apps/mt187334).\n\n## Protect a stream of data to an enterprise identity\n\n\n**Note**  Whenever you protect a stream or a buffer, it's highly recommended that you subscribe to the [**ProtectionPolicyManager.PolicyChanged**](https://msdn.microsoft.com/library/windows/apps/mt608411) event so that your app is aware in the event that EDP becomes disabled on the device. When this happens, you should unprotect any streams and buffers. Any stream or buffer that you leave protected becomes eligible to be revoked should the user un-enroll the device from mobile device management (MDM). And, if EDP was disabled when the resource was created, then that revocation is inappropriate. Unprotecting the resources when EDP is disabled prevents that.\n\n\n\nIn this scenario, your app has access to an unprotected stream that contains enterprise data. In order to ensure that this stream is protected when transferring it within and outside the device, your app protects the data to the enterprise identity that it belongs to. This allows wiping the data, when required, by the enterprise. In order to later determine whether or not to call an \"unprotect\" method on a stream, the app must maintain state that indicates whether the stream was protected, which is why the function in this code example returns that state. If the identity passed is not managed, or if the app is not allowed for the identity, the stream will not be protected and an ‘Unprotected’ status will be returned from the call to [**DataProtectionManager.ProtectStreamAsync**](https://msdn.microsoft.com/library/windows/apps/dn706021).\n\n```CSharp\nusing Windows.Storage.Streams;\nusing Windows.Security.EnterpriseData;\n\nprivate async System.Threading.Tasks.Task<bool> ProtectAStream\n    (InMemoryRandomAccessStream unprotectedInMemoryRandomAccessStream, string identity,\n    InMemoryRandomAccessStream protectedInMemoryRandomAccessStream)\n{\n    IInputStream unprotectedStream = unprotectedInMemoryRandomAccessStream.GetInputStreamAt(0);\n    IOutputStream protectedStream = protectedInMemoryRandomAccessStream.GetOutputStreamAt(0);\n\n    // Protect \"inputStream\".\n    DataProtectionInfo info = \n        await DataProtectionManager.ProtectStreamAsync(unprotectedStream, identity, protectedStream);\n\n    // Indicate to the caller whether the stream was protected successfully. It will only be protected if\n    // the identity is managed AND this app is allowed for this identity. Similar to buffers, this status\n    // must be stored by the app. UnprotectStreamAsync must only be called if the stream was protected\n    // successfully earlier.\n\n    return (info.Status == DataProtectionStatus.Protected);\n}\n```\n\nTo show how you might use a method like the one in the code example above, here's a helper method that uses it to convert a string into an unprotected stream, and then protect the stream.\n\n```CSharp\nusing Windows.Storage.Streams;\n\nprivate async System.Threading.Tasks.Task<bool> ProtectStringAsStreamAsync\n    (string unprotectedEnterpriseData, string identity, \n    InMemoryRandomAccessStream protectedInMemoryRandomAccessStream)\n{\n    using (var unprotectedInMemoryRandomAccessStream = new InMemoryRandomAccessStream())\n    {\n        using (var dataWriter = new DataWriter(unprotectedInMemoryRandomAccessStream))\n        {\n            dataWriter.WriteString(unprotectedEnterpriseData);\n            await dataWriter.StoreAsync();\n            await dataWriter.FlushAsync();\n            return await this.ProtectAStream(unprotectedInMemoryRandomAccessStream,\n                identity, protectedInMemoryRandomAccessStream);\n        }\n    }\n}\n```\n\n## Retrieve the status of a stream\n\n\nIn this scenario, your app has previously protected a stream to which you must prevent unauthorized access. In order to retrieve the stream's contents back when needed, your app can check the status of the stream.\n\nNote that the status of a stream is also returned from [**DataProtectionManager.UnprotectStreamAsync**](https://msdn.microsoft.com/library/windows/apps/dn706023). This API will never return a status of ‘Unprotected’, since it requires that the input resource be protected (it is not possible to reliably verify that a resource is unprotected). Be aware if you have code that compares the result with 'Unprotected', then that suggests the presence of a design flaw. It's an indication that your code has lost track of whether the stream is protected.\n\n```CSharp\nusing Windows.Storage.Streams;\nusing Windows.Security.EnterpriseData;\n\nprivate async void CheckProtectedStreamStatus(IInputStream protectedStream)\n{\n    DataProtectionInfo dataProtectionInfo = \n        await DataProtectionManager.GetStreamProtectionInfoAsync(protectedStream);\n\n    if (dataProtectionInfo.Status == DataProtectionStatus.Revoked)\n    {\n        // Code goes here to handle this situation. Perhaps, show UI\n        // saying that the user's data has been revoked.\n    }\n    else if (dataProtectionInfo.Status != DataProtectionStatus.Protected)\n    {\n        // Code goes here to handle the unexpected protection status.\n    }\n}\n```\n\n## Unprotect a stream of data\n\n\nIn this scenario, your app wishes to unprotected a stream that it previously protected. This code example takes a protected stream (note that the stream must be protected for this process to work) and unprotects it with a call to [**DataProtectionManager.UnprotectStreamAsync**](https://msdn.microsoft.com/library/windows/apps/dn706023). It then reads a string out of the stream and returns it.\n\n```CSharp\nusing Windows.Storage.Streams;\n\nprivate async System.Threading.Tasks.Task<string> UnprotectStreamIntoStringAsync\n    (InMemoryRandomAccessStream protectedInMemoryRandomAccessStream)\n{\n    using (var unprotectedInMemoryRandomAccessStream = new InMemoryRandomAccessStream())\n    {\n        DataProtectionInfo dataProtectionInfo = \n            await DataProtectionManager.UnprotectStreamAsync(protectedInMemoryRandomAccessStream, \n            unprotectedInMemoryRandomAccessStream);\n\n        using (var inputStream = unprotectedInMemoryRandomAccessStream.GetInputStreamAt(0))\n        {\n            using (var dataReader = new DataReader(inputStream))\n            {\n                await dataReader.LoadAsync((uint)unprotectedInMemoryRandomAccessStream.Size);\n                return dataReader.ReadString((uint)unprotectedInMemoryRandomAccessStream.Size);\n            }\n        }\n    }\n}\n```\n\nTo show how you might use the helper methods given so far, here's an event handler that takes a string from a text box, writes the string into a stream, protects the stream, unprotects the stream (if it was successfully protected), and finally reads the string back from the unprotected stream and displays it in the UI.\n\n```CSharp\nusing Windows.Storage.Streams;\n\nprivate async void ProtectAndThenUnprotectStream_Click(object sender, RoutedEventArgs e)\n{\n    var protectedInMemoryRandomAccessStream = new InMemoryRandomAccessStream();\n    bool isStreamProtected = await this.ProtectStringAsStreamAsync\n        (this.enterpriseDataTextBox.Text, MainPage.IDENTITY, protectedInMemoryRandomAccessStream);\n\n    // Only unprotect the stream if we're sure that the stream actually was protected.\n    if (isStreamProtected)\n    {\n        this.resultDataTextBlock.Text = \n            await this.UnprotectStreamIntoStringAsync(protectedInMemoryRandomAccessStream);\n    }\n}\n```\n\n## Retrieve the status of a static data buffer\n\n\nIn this scenario, your app has previously protected a buffer to which you must prevent unauthorized access. In order to retrieve the buffer's contents back when needed, your app can check the status of the buffer.\n\nNote that the status of a buffer is also returned from [**DataProtectionManager.UnprotectAsync**](https://msdn.microsoft.com/library/windows/apps/dn706022). This API will never return a status of ‘Unprotected’, since it requires that the input resource be protected.\n\n```CSharp\nusing Windows.Security.EnterpriseData;\nusing Windows.Storage.Streams;\n\nprivate async void CheckProtectedBufferStatus(IBuffer protectedData)\n{\n    DataProtectionInfo dataProtectionInfo = \n        await DataProtectionManager.GetProtectionInfoAsync(protectedData);\n\n    if (dataProtectionInfo.Status == DataProtectionStatus.Revoked)\n    {\n        // Code goes here to handle this situation, perhaps show UI\n        // saying that the user's data has been revoked.\n    }\n    else if (dataProtectionInfo.Status != DataProtectionStatus.Protected)\n    {\n        // Code goes here to handle the unexpected protection status.\n    }\n}\n```\n\n## Protect static data retrieved from an enterprise resource\n\n\nThis scenario covers the same ground as the stream code examples, except it works with a buffer of data. Again, you need to maintain state that indicates whether the buffer was protected, as shown. If the identity passed is not managed, or if the app is not allowed for the identity, the buffer will not be protected and an ‘Unprotected’ status will be returned from the call to [**DataProtectionManager.ProtectAsync**](https://msdn.microsoft.com/library/windows/apps/dn706020).\n\n```CSharp\nusing Windows.Security.Cryptography;\nusing Windows.Security.EnterpriseData;\nusing Windows.Storage.Streams;\n\n...\n\nprivate IBuffer data = null;\nprivate bool isProtected = false;\n\nvoid StoreBuffer(IBuffer data, bool isProtected)\n{\n    this.data = data;\n    this.isProtected = isProtected;\n}\n\nIBuffer GetStoredBuffer(out bool isProtected)\n{\n    isProtected = this.isProtected;\n    return this.data;\n}\n\nprivate string identity = \"contoso.com\";\n\nprivate async void ProtectAndThenUnprotectBuffer_Click(object sender, RoutedEventArgs e)\n{\n    BinaryStringEncoding encoding = BinaryStringEncoding.Utf8;\n    IBuffer inputData = CryptographicBuffer.ConvertStringToBinary\n        (this.enterpriseDataTextBox.Text, encoding);\n    BufferProtectUnprotectResult result =\n        await DataProtectionManager.ProtectAsync(inputData, this.identity);\n\n    // Record whether the buffer was protected successfully. It will only be protected if\n    // the identity is managed AND this app is allowed for this identity. This status\n    // must be stored by the app. UnprotectAsync must only be called if the buffer was\n    // protected successfully earlier.\n    bool isBufferProtected = \n        (result.ProtectionInfo.Status == DataProtectionStatus.Protected);\n    IBuffer outputData = result.Buffer;\n\n    // Store the data away...\n    this.StoreBuffer(outputData, isBufferProtected);\n\n    // ...and then later retrieve it.\n    outputData = this.GetStoredBuffer(out isBufferProtected);\n\n    string storedString = string.Empty;\n\n    if (isBufferProtected)\n    {\n        result = await DataProtectionManager.UnprotectAsync(outputData);\n\n        if (result.ProtectionInfo.Status != DataProtectionStatus.Unprotected)\n        {\n            // Code goes here to handle the situation where the buffer\n            // is no longer accessible.\n            return;\n        }\n        outputData = result.Buffer;\n    }\n    this.resultDataTextBlock.Text = CryptographicBuffer.ConvertBinaryToString(encoding, outputData);\n}\n```\n\n## Enable UI-policy enforcement based on a stream's or buffer’s protected identity\n\n\nWhen your app is about to display the contents of a protected stream or buffer on its UI, it must enable UI-policy enforcement based on the identity the resource is protected to. You should query the protection information of the resource and enable the system's UI-policy enforcement from the retrieved identity.\n\n```CSharp\nusing Windows.Security.EnterpriseData;\nusing Windows.Storage.Streams;\n\n...\n\nprivate async void EnableUIPolicyFromProtectedBuffer(IBuffer buffer)\n{\n    DataProtectionInfo protectionInfo = \n        await DataProtectionManager.GetProtectionInfoAsync(buffer);\n\n    if (protectionInfo.Status != DataProtectionStatus.Protected)\n    {\n        // In this case, the app has lost access to the buffer\n        // (ProtectedToOtherIdentity, Revoked). This must be handled.\n        // 'Unprotected' is never returned for GetProtectionInfoAsync().\n        return;\n    }\n\n    ProtectionPolicyManager.TryApplyProcessUIPolicy(protectionInfo.Identity);\n}\n\n```\n\n**Note**  This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps. If you’re developing for Windows 8.x or Windows Phone 8.x, see the [archived documentation](http://go.microsoft.com/fwlink/p/?linkid=619132).\n\n \n\n## Related topics\n\n\n[enterprise data protection (EDP) sample](http://go.microsoft.com/fwlink/p/?LinkId=620031&clcid=0x409)\n\n[**Windows.Security.EnterpriseData namespace**](https://msdn.microsoft.com/library/windows/apps/dn279153)\n\n \n\n \n\n\n\n"}