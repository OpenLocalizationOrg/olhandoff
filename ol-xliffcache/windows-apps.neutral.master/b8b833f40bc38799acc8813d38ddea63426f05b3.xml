{"nodes":[{"content":"A XAML namescope stores relationships between the XAML-defined names of objects and their instance equivalents.","pos":[32,143]},{"content":"This concept is similar to the wider meaning of the term namescope in other programming languages and technologies.","pos":[144,259]},{"content":"XAML namescopes","pos":[267,282]},{"content":"XAML namescopes","pos":[339,354]},{"content":"Updated for UWP apps on Windows 10.","pos":[359,394]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[395,487]},{"content":"A <bpt id=\"p1\">*</bpt>XAML namescope<ept id=\"p1\">*</ept> stores relationships between the XAML-defined names of objects and their instance equivalents.","pos":[492,605]},{"content":"This concept is similar to the wider meaning of the term <bpt id=\"p1\">*</bpt>namescope<ept id=\"p1\">*</ept> in other programming languages and technologies.","pos":[606,723]},{"content":"How XAML namescopes are defined","pos":[728,759]},{"content":"Names in XAML namescopes enable user code to reference the objects that were initially declared in XAML.","pos":[761,865]},{"content":"The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations.","pos":[866,1035]},{"content":"These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.","pos":[1036,1189]},{"pos":[1191,1449],"content":"The most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated <bpt id=\"p1\">**</bpt>InitializeComponent<ept id=\"p1\">**</ept> method in the partial class templates."},{"pos":[1451,1663],"content":"You can also use the utility method <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FindName<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> yourself at run time to return a reference to objects that were defined with a name in the XAML markup."},{"content":"More about build actions and XAML","pos":[1669,1702]},{"content":"What happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together.","pos":[1704,1888]},{"content":"Each object element with a <bpt id=\"p1\">**</bpt>Name<ept id=\"p1\">**</ept> or <bpt id=\"p2\">[</bpt>x:Name attribute<ept id=\"p2\">](x-name-attribute.md)</ept> defined in the markup generates an internal field with a name that matches the XAML name.","pos":[1889,2057]},{"content":"This field is initially empty.","pos":[2058,2088]},{"content":"Then the class generates an <bpt id=\"p1\">**</bpt>InitializeComponent<ept id=\"p1\">**</ept> method that is called only after all the XAML is loaded.","pos":[2089,2197]},{"content":"Within the <bpt id=\"p1\">**</bpt>InitializeComponent<ept id=\"p1\">**</ept> logic, each internal field is then populated with the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>FindName<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> return value for the equivalent name string.","pos":[2198,2404]},{"content":"You can observe this infrastructure for yourself by looking at the \".g\" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation.","pos":[2405,2604]},{"content":"You can also see the fields and <bpt id=\"p1\">**</bpt>InitializeComponent<ept id=\"p1\">**</ept> method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.","pos":[2605,2788]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Specifically for Visual C++ component extensions (C++/CX) apps, a backing field for an <bpt id=\"p2\">**</bpt>x:Name<ept id=\"p2\">**</ept> reference is not created for the root element of a XAML file.","pos":[2790,2959]},{"content":"If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal.","pos":[2960,3059]},{"content":"For example you can call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FindName<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> for a known named child element and then call <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Parent<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208739)</ept>.","pos":[3060,3275]},{"content":"Creating objects at run time with XamlReader.Load","pos":[3280,3329]},{"content":"XAML can be also be used as the string input for the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>XamlReader.Load<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept> method, which acts analogously to the initial XAML source parse operation.","pos":[3331,3538]},{"content":"<bpt id=\"p1\">**</bpt>XamlReader.Load<ept id=\"p1\">**</ept> creates a new disconnected tree of objects at run time.","pos":[3539,3614]},{"content":"The disconnected tree can then be attached to some point on the main object tree.","pos":[3615,3696]},{"content":"You must explicitly connect your created object tree, either by adding it to a content property collection such as <bpt id=\"p1\">**</bpt>Children<ept id=\"p1\">**</ept>, or by setting some other property that takes an object value (for example, loading a new <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ImageBrush<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br210101)</ept> for a <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>Fill<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br243378)</ept> property value).","pos":[3697,4081]},{"content":"XAML namescope implications of XamlReader.Load","pos":[4087,4133]},{"content":"The preliminary XAML namescope defined by the new object tree created by <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>XamlReader.Load<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept> evaluates any defined names in the provided XAML for uniqueness.","pos":[4135,4352]},{"content":"If names in the provided XAML are not internally unique at this point, <bpt id=\"p1\">**</bpt>XamlReader.Load<ept id=\"p1\">**</ept> throws an exception.","pos":[4353,4464]},{"content":"The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree.","pos":[4465,4644]},{"content":"After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it.","pos":[4645,4763]},{"content":"The divisions occur at the connection points between objects, where you set some property to be the value returned from a <bpt id=\"p1\">**</bpt>XamlReader.Load<ept id=\"p1\">**</ept> call.","pos":[4764,4911]},{"content":"The complication of having discrete and disconnected XAML namescopes is that calls to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FindName<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> method as well as direct managed object references no longer operate against a unified XAML namescope.","pos":[4913,5178]},{"content":"Instead, the particular object that <bpt id=\"p1\">**</bpt>FindName<ept id=\"p1\">**</ept> is called on implies the scope, with the scope being the XAML namescope that the calling object is within.","pos":[5179,5334]},{"content":"In the direct managed object reference case, the scope is implied by the class where the code exists.","pos":[5335,5436]},{"content":"Typically, the code-behind for run-time interaction of a \"page\" of app content exists in the partial class that backs the root \"page\", and therefore the XAML namescope is the root XAML namescope.","pos":[5437,5632]},{"content":"If you call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FindName<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>XamlReader.Load<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept>.","pos":[5634,5928]},{"content":"Conversely, if you call <bpt id=\"p1\">**</bpt>FindName<ept id=\"p1\">**</ept> from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.","pos":[5929,6097]},{"pos":[6099,6283],"content":"This discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FindName<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> call."},{"content":"To get references to objects that are defined in a different XAML namescope, you can use several techniques:","pos":[6285,6393]},{"pos":[6399,6713],"content":"Walk the entire tree in discrete steps with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Parent<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208739)</ept> and/or collection properties that are known to exist in your object tree structure (such as the collection returned by <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Panel.Children<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>)."},{"content":"If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed.","pos":[6718,6878]},{"content":"You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call <ph id=\"ph1\">`Window.Current.Content`</ph>.","pos":[6879,7060]},{"content":"You can then cast to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FrameworkElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept> and call <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>FindName<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> from this scope.","pos":[7061,7261]},{"content":"If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>XamlReader.Load<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept> and then added to the main object tree.","pos":[7266,7595]},{"content":"This object is now a valid object for calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FindName<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> within the discrete XAML namescope.","pos":[7596,7750]},{"content":"You could keep this object available as a global variable or otherwise pass it by using method parameters.","pos":[7751,7857]},{"content":"You can avoid names and XAML namescope considerations entirely by examining the visual tree.","pos":[7862,7954]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>VisualTreeHelper<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br243038)</ept> API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.","pos":[7955,8169]},{"content":"XAML namescopes in templates","pos":[8174,8202]},{"content":"Templates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level.","pos":[8204,8380]},{"content":"That same template might be used multiple times in a page.","pos":[8381,8439]},{"content":"For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied.","pos":[8440,8575]},{"content":"Consider this example:","pos":[8576,8598]},{"content":"Here, the same template is applied to two different controls.","pos":[9059,9120]},{"content":"If templates did not have discrete XAML namescopes, the \"MyTextBlock\" name used in the template would cause a name collision.","pos":[9121,9246]},{"content":"Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.","pos":[9247,9404]},{"content":"However, the root XAML namescope does not contain the name from either template.","pos":[9405,9485]},{"content":"Because of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique.","pos":[9487,9657]},{"content":"Rather than calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>FindName<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> on some object in the object tree, you first obtain the object that has the template applied, and then call <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>GetTemplateChild<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br209416)</ept>.","pos":[9658,9940]},{"content":"If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <bpt id=\"p1\">**</bpt>GetTemplateChild<ept id=\"p1\">**</ept> method from your control implementation code.","pos":[9941,10211]},{"content":"The <bpt id=\"p1\">**</bpt>GetTemplateChild<ept id=\"p1\">**</ept> method is protected, so only the control author has access to it.","pos":[10212,10302]},{"content":"Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class.","pos":[10303,10474]},{"content":"This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.","pos":[10475,10688]},{"content":"Related topics","pos":[10693,10707]},{"content":"XAML overview","pos":[10712,10725]},{"content":"x:Name attribute","pos":[10748,10764]},{"content":"Quickstart: Control templates","pos":[10790,10819]},{"content":"XamlReader.Load","pos":[10889,10904]},{"content":"FindName","pos":[10971,10979]}],"content":"---\nauthor: jwmsft\ndescription: A XAML namescope stores relationships between the XAML-defined names of objects and their instance equivalents. This concept is similar to the wider meaning of the term namescope in other programming languages and technologies.\ntitle: XAML namescopes\nms.assetid: EB060CBD-A589-475E-B83D-B24068B54C21\n---\n\n# XAML namescopes\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nA *XAML namescope* stores relationships between the XAML-defined names of objects and their instance equivalents. This concept is similar to the wider meaning of the term *namescope* in other programming languages and technologies.\n\n## How XAML namescopes are defined\n\nNames in XAML namescopes enable user code to reference the objects that were initially declared in XAML. The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations. These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.\n\nThe most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated **InitializeComponent** method in the partial class templates.\n\nYou can also use the utility method [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) yourself at run time to return a reference to objects that were defined with a name in the XAML markup.\n\n### More about build actions and XAML\n\nWhat happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together. Each object element with a **Name** or [x:Name attribute](x-name-attribute.md) defined in the markup generates an internal field with a name that matches the XAML name. This field is initially empty. Then the class generates an **InitializeComponent** method that is called only after all the XAML is loaded. Within the **InitializeComponent** logic, each internal field is then populated with the [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) return value for the equivalent name string. You can observe this infrastructure for yourself by looking at the \".g\" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation. You can also see the fields and **InitializeComponent** method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.\n\n**Note**  Specifically for Visual C++ component extensions (C++/CX) apps, a backing field for an **x:Name** reference is not created for the root element of a XAML file. If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal. For example you can call [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) for a known named child element and then call [**Parent**](https://msdn.microsoft.com/library/windows/apps/br208739).\n\n## Creating objects at run time with XamlReader.Load\n\nXAML can be also be used as the string input for the [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048) method, which acts analogously to the initial XAML source parse operation. **XamlReader.Load** creates a new disconnected tree of objects at run time. The disconnected tree can then be attached to some point on the main object tree. You must explicitly connect your created object tree, either by adding it to a content property collection such as **Children**, or by setting some other property that takes an object value (for example, loading a new [**ImageBrush**](https://msdn.microsoft.com/library/windows/apps/br210101) for a [**Fill**](https://msdn.microsoft.com/library/windows/apps/br243378) property value).\n\n### XAML namescope implications of XamlReader.Load\n\nThe preliminary XAML namescope defined by the new object tree created by [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048) evaluates any defined names in the provided XAML for uniqueness. If names in the provided XAML are not internally unique at this point, **XamlReader.Load** throws an exception. The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree. After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it. The divisions occur at the connection points between objects, where you set some property to be the value returned from a **XamlReader.Load** call.\n\nThe complication of having discrete and disconnected XAML namescopes is that calls to the [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) method as well as direct managed object references no longer operate against a unified XAML namescope. Instead, the particular object that **FindName** is called on implies the scope, with the scope being the XAML namescope that the calling object is within. In the direct managed object reference case, the scope is implied by the class where the code exists. Typically, the code-behind for run-time interaction of a \"page\" of app content exists in the partial class that backs the root \"page\", and therefore the XAML namescope is the root XAML namescope.\n\nIf you call [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048). Conversely, if you call **FindName** from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.\n\nThis discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) call.\n\nTo get references to objects that are defined in a different XAML namescope, you can use several techniques:\n\n-   Walk the entire tree in discrete steps with [**Parent**](https://msdn.microsoft.com/library/windows/apps/br208739) and/or collection properties that are known to exist in your object tree structure (such as the collection returned by [**Panel.Children**](https://msdn.microsoft.com/library/windows/apps/br227514)).\n-   If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed. You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call `Window.Current.Content`. You can then cast to [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) and call [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) from this scope.\n-   If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048) and then added to the main object tree. This object is now a valid object for calling [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) within the discrete XAML namescope. You could keep this object available as a global variable or otherwise pass it by using method parameters.\n-   You can avoid names and XAML namescope considerations entirely by examining the visual tree. The [**VisualTreeHelper**](https://msdn.microsoft.com/library/windows/apps/br243038) API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.\n\n## XAML namescopes in templates\n\nTemplates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level. That same template might be used multiple times in a page. For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied. Consider this example:\n\n```xml\n<Page\n  xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" \n  xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"  >\n  <Page.Resources>\n    <ControlTemplate x:Key=\"MyTemplate\">\n      ....\n      <TextBlock x:Name=\"MyTextBlock\" />\n    </ControlTemplate>\n  </Page.Resources>\n  <StackPanel>\n    <SomeControl Template=\"{StaticResource MyTemplate}\" />\n    <SomeControl Template=\"{StaticResource MyTemplate}\" />\n  </StackPanel>\n</Page>\n```\n\nHere, the same template is applied to two different controls. If templates did not have discrete XAML namescopes, the \"MyTextBlock\" name used in the template would cause a name collision. Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name. However, the root XAML namescope does not contain the name from either template.\n\nBecause of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique. Rather than calling [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715) on some object in the object tree, you first obtain the object that has the template applied, and then call [**GetTemplateChild**](https://msdn.microsoft.com/library/windows/apps/br209416). If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the **GetTemplateChild** method from your control implementation code. The **GetTemplateChild** method is protected, so only the control author has access to it. Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class. This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.\n\n## Related topics\n\n* [XAML overview](xaml-overview.md)\n* [x:Name attribute](x-name-attribute.md)\n* [Quickstart: Control templates](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374)\n* [**XamlReader.Load**](https://msdn.microsoft.com/library/windows/apps/br228048)\n* [**FindName**](https://msdn.microsoft.com/library/windows/apps/br208715)\n \n\n"}