{"nodes":[{"content":"Transforms overview","pos":[75,94]},{"content":"Learn how to use transforms in the Windows Runtime&amp;<ph id=\"ph1\">\\#</ph>160;API, by changing the relative coordinate systems of elements in the UI.","pos":[108,236]},{"content":"Transforms overview","pos":[244,263]},{"content":"Updated for UWP apps on Windows 10.","pos":[268,303]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[304,396]},{"content":"Learn how to use transforms in the Windows Runtime API, by changing the relative coordinate systems of elements in the UI.","pos":[402,524]},{"content":"This can be used to adjust the appearance of individual XAML elements, such as scaling, rotating, or transforming the position in x-y space.","pos":[525,665]},{"pos":[787,807],"content":"What is a transform?"},{"content":"A <bpt id=\"p1\">*</bpt>transform<ept id=\"p1\">*</ept> defines how to map, or transform, points from one coordinate space to another coordinate space.","pos":[809,918]},{"content":"When a transform is applied to a UI element, it changes how that UI element is rendered to the screen as part of the UI.","pos":[919,1039]},{"content":"Think of transforms in four broad classifications: translation, rotation, scaling and skew (or shear).","pos":[1041,1143]},{"content":"For the purposes of using graphics APIs to change the appearance of UI elements, it's usually easiest to create transforms that define only one operation at a time.","pos":[1144,1308]},{"content":"So the Windows Runtime defines a discrete class for each of these transform classifications:","pos":[1309,1401]},{"pos":[1407,1764],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TranslateTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243027)</ept>: translates an element in x-y space, by setting values for <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>X<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.translatetransform.x.aspx)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Y<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.translatetransform.y)</ept>."},{"pos":[1769,2392],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ScaleTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242940)</ept>: scales the transform based on a center point, by setting values for <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>CenterX<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.scaletransform.centerx.aspx)</ept>, <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>CenterY<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.scaletransform.centery.aspx)</ept>, <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>ScaleX<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.scaletransform.scalex.aspx)</ept> and <bpt id=\"p9\">[</bpt><bpt id=\"p10\">**</bpt>ScaleY<ept id=\"p10\">**</ept><ept id=\"p9\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.scaletransform.scaleyproperty)</ept>."},{"pos":[2397,2872],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RotateTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242932)</ept>: rotates in x-y space, by setting values for <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Angle<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.rotatetransform.angle.aspx)</ept>, <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>CenterX<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.rotatetransform.centerx.aspx)</ept> and <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>CenterY<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.rotatetransform.centery)</ept>."},{"pos":[2877,3480],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SkewTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242950)</ept>: skews or shears in x-y space, by setting values for <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>AngleX<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.skewtransform.anglex.aspx)</ept>, <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>AngleY<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.skewtransform.angley.aspx)</ept>, <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>CenterX<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.skewtransform.centerx.aspx)</ept> and <bpt id=\"p9\">[</bpt><bpt id=\"p10\">**</bpt>CenterY<ept id=\"p10\">**</ept><ept id=\"p9\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.scaletransform.centeryproperty)</ept>."},{"pos":[3482,3707],"content":"Of these, you're likely to use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TranslateTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243027)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ScaleTransform<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242940)</ept> most often for UI scenarios."},{"content":"You can combine transforms, and there are two Windows Runtime classes that support this: <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CompositeTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR228105)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>TransformGroup<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR243022)</ept>.","pos":[3709,3964]},{"content":"In a <bpt id=\"p1\">**</bpt>CompositeTransform<ept id=\"p1\">**</ept>, transforms are applied in this order: scale, skew, rotate, translate.","pos":[3965,4063]},{"content":"Use <bpt id=\"p1\">**</bpt>TransformGroup<ept id=\"p1\">**</ept> instead of <bpt id=\"p2\">**</bpt>CompositeTransform<ept id=\"p2\">**</ept> if you want the transforms applied in a different order.","pos":[4064,4177]},{"content":"For more info, see <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CompositeTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR228105)</ept>.","pos":[4178,4280]},{"pos":[4405,4426],"content":"Transforms and layout"},{"content":"In XAML layout, transforms are applied after the layout pass is complete, so available space calculations and other layout decisions have been made before the transforms are applied.","pos":[4428,4610]},{"content":"Because layout comes first, you'll sometimes get unexpected results if you transform elements that are in a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Grid<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242704)</ept> cell or similar layout container that allocates space during layout.","pos":[4611,4856]},{"content":"The transformed element may appear truncated or obscured because it's trying to draw into an area that didn't calculate the post-transform dimensions when dividing space within its parent container.","pos":[4857,5055]},{"content":"You may need to experiment with the transform results and adjust some settings.","pos":[5056,5135]},{"content":"For example, instead of relying on adaptive layout and star sizing, you may need to change the <bpt id=\"p1\">**</bpt>Center<ept id=\"p1\">**</ept> properties or declare fixed pixel measurements for layout space to make sure the parent allots enough space.","pos":[5136,5350]},{"content":"<bpt id=\"p1\">**</bpt>Migration note:<ept id=\"p1\">**</ept>  Windows Presentation Foundation (WPF) had a <bpt id=\"p2\">**</bpt>LayoutTransform<ept id=\"p2\">**</ept> property that applied transforms prior to the layout pass.","pos":[5352,5495]},{"content":"But Windows Runtime XAML doesn't support a <bpt id=\"p1\">**</bpt>LayoutTransform<ept id=\"p1\">**</ept> property.","pos":[5496,5568]},{"content":"(Microsoft Silverlight didn't have this property either.)","pos":[5569,5626]},{"pos":[5796,5832],"content":"Applying a transform to a UI element"},{"content":"When you apply a transform to an object, you typically do so to set the property <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement.RenderTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208980)</ept>.","pos":[5834,6005]},{"content":"Setting this property does not literally change the object pixel by pixel.","pos":[6006,6080]},{"content":"What the property really does is apply the transform within the local coordinate space in which that object exists.","pos":[6081,6196]},{"content":"Then the rendering logic and operation (post-layout) renders the combined coordinate spaces, making it look like the object has changed appearance and also potentially its layout position (if <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TranslateTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243027)</ept> was applied).","pos":[6197,6485]},{"content":"By default, each render transform is centered at the origin of the target object's local coordinate system—its (0,0).","pos":[6487,6604]},{"content":"The only exception is a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TranslateTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243027)</ept>, which has no center properties to set because the translation effect is the same regardless of where it is centered.","pos":[6605,6829]},{"content":"But the other transforms each have properties that set <bpt id=\"p1\">**</bpt>CenterX<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>CenterY<ept id=\"p2\">**</ept> values.","pos":[6830,6920]},{"content":"Whenever you use transforms with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement.RenderTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208980)</ept>, remember that there's another property on <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>UIElement<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR208911)</ept> that affects how the transform behaves: <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>RenderTransformOrigin<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.rendertransformorigin.aspx)</ept>.","pos":[6922,7337]},{"content":"What <bpt id=\"p1\">**</bpt>RenderTransformOrigin<ept id=\"p1\">**</ept> declares is whether the whole transform should apply to the default (0,0) point of an element or to some other origin point within the relative coordinate space of that element.","pos":[7338,7546]},{"content":"For typical elements, (0,0) places the transform to the top left corner.","pos":[7547,7619]},{"content":"Depending on what effect you want, you might choose to change <bpt id=\"p1\">**</bpt>RenderTransformOrigin<ept id=\"p1\">**</ept> rather than adjusting the <bpt id=\"p2\">**</bpt>CenterX<ept id=\"p2\">**</ept> and <bpt id=\"p3\">**</bpt>CenterY<ept id=\"p3\">**</ept> values on transforms.","pos":[7620,7783]},{"content":"Note that if you apply both <bpt id=\"p1\">**</bpt>RenderTransformOrigin<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>CenterX<ept id=\"p2\">**</ept><ph id=\"ph1\"> / </ph><bpt id=\"p3\">**</bpt>CenterY<ept id=\"p3\">**</ept> values, the results can be pretty confusing, especially if you're animating any of the values.","pos":[7784,7962]},{"content":"For hit-testing purposes, an object to which a transform is applied continues to respond to input in an expected way that's consistent to its visual appearance in x-y space.","pos":[7964,8137]},{"content":"For example, if you've used a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TranslateTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243027)</ept> to move a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Rectangle<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR243371)</ept> 400 pixels laterally in the UI, that <bpt id=\"p5\">**</bpt>Rectangle<ept id=\"p5\">**</ept> responds to <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>PointerPressed<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.pointerpressed.aspx)</ept> events when the user presses the point where the <bpt id=\"p8\">**</bpt>Rectangle<ept id=\"p8\">**</ept> appears visually.","pos":[8138,8599]},{"content":"You won't get false events if the user presses the area where the <bpt id=\"p1\">**</bpt>Rectangle<ept id=\"p1\">**</ept> was before being translated.","pos":[8600,8708]},{"content":"For any z-index considerations that affect hit testing, applying a transform makes no difference; the z-index that governs which element handles input events for a point in x-y space is still evaluated using the child order as declared in a container.","pos":[8709,8960]},{"content":"That order is usually the same as the order in which you declare the elements in XAML, although for child elements of a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Canvas<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR209267)</ept> object you can adjust the order by applying the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Canvas.ZIndex<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.canvas.zindex.aspx)</ept> attached property to child elements.","pos":[8961,9354]},{"pos":[9494,9520],"content":"Other transform properties"},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Brush.Transform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR228082)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Brush.RelativeTransform<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR228080)</ept>: These influence how a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Brush<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR228076)</ept> uses coordinate space within the area that the <bpt id=\"p7\">**</bpt>Brush<ept id=\"p7\">**</ept> is applied to set visual properties such as foregrounds and backgrounds.","pos":[9526,9917]},{"content":"These transforms aren't relevant for the most common brushes (which are typically setting solid colors with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SolidColorBrush<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242962)</ept>) but might be occasionally useful when painting areas with an <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ImageBrush<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR210101)</ept> or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>LinearGradientBrush<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR210108)</ept>.","pos":[9918,10330]},{"pos":[10335,10606],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Geometry.Transform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR210066)</ept>: You might use this property to apply a transform to a geometry prior to using that geometry for a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Path.Data<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR243356)</ept> property value."},{"pos":[10731,10752],"content":"Animating a transform"},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Transform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243006)</ept> objects can be animated.","pos":[10754,10852]},{"content":"To animate a <bpt id=\"p1\">**</bpt>Transform<ept id=\"p1\">**</ept>, apply an animation of a compatible type to the property you want to animate.","pos":[10853,10957]},{"content":"This typically means you're using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DoubleAnimation<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243136)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DoubleAnimationUsingKeyFrames<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR243136usingkeyframes)</ept> objects to define the animation, because all of the transform properties are of type <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Double<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/xaml/system.double.aspx)</ept>.","pos":[10958,11354]},{"content":"Animations that affect a transform that's used for a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement.RenderTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208980)</ept> value are not considered to be dependent animations, even if they have a nonzero duration.","pos":[11355,11588]},{"content":"For more info about dependent animations, see <bpt id=\"p1\">[</bpt>Storyboarded animations<ept id=\"p1\">](storyboarded-animations.md)</ept>.","pos":[11589,11689]},{"content":"If you animate properties to produce an effect similar to a transform in terms of the net visual appearance—for example, animating the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Width<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208751)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Height<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR208718)</ept> of a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>FrameworkElement<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR208706)</ept> rather than applying a <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>TranslateTransform<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/BR243027)</ept>—such animations are almost always treated as dependent animations.","pos":[11691,12229]},{"content":"You'd have to enable the animations and there could be significant performance issues with the animation, especially if you're trying to support user interaction while that object is being animated.","pos":[12230,12428]},{"content":"For that reason it's preferable to use a transform and animate it rather than animating any other property where the animation would be treated as a dependent animation.","pos":[12429,12598]},{"content":"To target the transform, there must be an existing <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Transform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243006)</ept> as the value for <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>RenderTransform<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR208980)</ept>.","pos":[12600,12822]},{"content":"You typically put an element for the appropriate transform type in the initial XAML, sometimes with no properties set on that transform.","pos":[12823,12959]},{"content":"You typically use an indirect targeting technique to apply animations to the properties of a transform.","pos":[12961,13064]},{"content":"For more info about indirect targeting syntax, see <bpt id=\"p1\">[</bpt>Storyboarded animations<ept id=\"p1\">](storyboarded-animations.md)</ept> and <bpt id=\"p2\">[</bpt>Property-path syntax<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/Mt185586)</ept>.","pos":[13065,13255]},{"content":"Default styles for controls sometimes define animations of transforms as part of their visual-state behavior.","pos":[13257,13366]},{"content":"For example, the visual states for <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ProgressRing<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR227538)</ept> use animated <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>RotateTransform<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242932)</ept> values to \"spin\" the dots in the ring.","pos":[13367,13610]},{"content":"Here's a simple example of how to animate a transform.","pos":[13612,13666]},{"content":"In this case, it's animating the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Angle<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.media.rotatetransform.angle.aspx)</ept> of a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>RotateTransform<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242932)</ept> to spin a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Rectangle<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR243371)</ept> in place around its visual center.","pos":[13667,14018]},{"content":"This example names the <bpt id=\"p1\">**</bpt>RotateTransform<ept id=\"p1\">**</ept> so doesn't need indirect animation targeting, but you could alternatively leave the transform unnamed, name the element that the transform's applied to, and use indirect targeting such as <ph id=\"ph1\">`(UIElement.RenderTransform).(RotateTransform.Angle)`</ph>.","pos":[14019,14304]},{"pos":[15231,15288],"content":"Accounting for coordinate frames of reference at run time"},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208911)</ept> has a method named <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>TransformToVisual<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.transformtovisual.aspx)</ept>, which can generate a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Transform<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR243006)</ept> that correlates the coordinate frames of reference for two UI elements.","pos":[15290,15677]},{"content":"You can use this to compare an element to the app's default coordinate frame of reference if you pass the root visual as the first parameter.","pos":[15678,15819]},{"content":"This can be useful if you've captured an input event from a different element, or if you are trying to predict layout behavior without actually requesting a layout pass.","pos":[15820,15989]},{"content":"Event data obtained from pointer events provides access to a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GetCurrentPoint<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR212141)</ept> method, where you can specify a <bpt id=\"p3\">*</bpt>relativeTo<ept id=\"p3\">*</ept> parameter to change the coordinate frame of reference to a specific element rather than the app default.","pos":[15991,16281]},{"content":"This approach simply applies a translate transform internally and transforms the x-y coordinate data for you when it creates the returned <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PointerPoint<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR242038)</ept> object.","pos":[16282,16504]},{"pos":[16677,16714],"content":"Describing a transform mathematically"},{"content":"A transform can be described in terms of a transformation matrix.","pos":[16716,16781]},{"content":"A 3×3 matrix is used to describe the transformations in a two-dimensional, x-y plane.","pos":[16782,16867]},{"content":"Affine transformation matrices can be multiplied to form any number of linear transformations, such as rotation and skew (shear), followed by translation.","pos":[16868,17022]},{"content":"The final column of an affine transformation matrix is equal to (0, 0, 1), so you need to specify only the members of the first two columns in the mathematical description.","pos":[17023,17195]},{"content":"The mathematical description of a transform might be useful to you if you have a mathematical background or a familiarity with graphics-programming techniques that also use matrices to describe transformations of coordinate space.","pos":[17197,17427]},{"content":"There's a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Transform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243006)</ept>-derived class that enables you to express a transformation directly in terms of its 3×3 matrix: <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>MatrixTransform<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR210137)</ept>.","pos":[17428,17688]},{"content":"<bpt id=\"p1\">**</bpt>MatrixTransform<ept id=\"p1\">**</ept> has a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Matrix<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.media.matrixtransform.matrix.aspx)</ept> property, which holds a structure that has six properties: <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>M11<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/Hh673847)</ept>, <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>M12<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/Hh673853)</ept>, <bpt id=\"p8\">[</bpt><bpt id=\"p9\">**</bpt>M21<ept id=\"p9\">**</ept><ept id=\"p8\">](https://msdn.microsoft.com/library/windows/apps/Hh673851)</ept>, <bpt id=\"p10\">[</bpt><bpt id=\"p11\">**</bpt>M22<ept id=\"p11\">**</ept><ept id=\"p10\">](https://msdn.microsoft.com/library/windows/apps/Hh673849)</ept>, <bpt id=\"p12\">[</bpt><bpt id=\"p13\">**</bpt>OffsetX<ept id=\"p13\">**</ept><ept id=\"p12\">](https://msdn.microsoft.com/library/windows/apps/Hh673810)</ept> and <bpt id=\"p14\">[</bpt><bpt id=\"p15\">**</bpt>OffsetY<ept id=\"p15\">**</ept><ept id=\"p14\">](https://msdn.microsoft.com/library/windows/apps/Hh673816)</ept>.","pos":[17689,18315]},{"content":"Each <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Matrix<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR210127)</ept> property uses a <bpt id=\"p3\">**</bpt>Double<ept id=\"p3\">**</ept> value and corresponds to the six relevant values (columns 1 and 2) of an affine transformation matrix.","pos":[18316,18521]},{"content":"M11","pos":[18728,18731]},{"content":"M21","pos":[18806,18809]},{"content":"0","pos":[18881,18882]},{"content":"M12","pos":[18892,18895]},{"content":"M22","pos":[18970,18973]},{"content":"0","pos":[19045,19046]},{"content":"OffsetX","pos":[19056,19063]},{"content":"OffsetY","pos":[19130,19137]},{"content":"1","pos":[19201,19202]},{"content":"Any transform that you could describe with a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TranslateTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR243027)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ScaleTransform<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR242940)</ept>, <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>RotateTransform<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR242932)</ept>, or <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>SkewTransform<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/BR242950)</ept> object could be described equally by a <bpt id=\"p9\">[</bpt><bpt id=\"p10\">**</bpt>MatrixTransform<ept id=\"p10\">**</ept><ept id=\"p9\">](https://msdn.microsoft.com/library/windows/apps/BR210137)</ept> with a <bpt id=\"p11\">[</bpt><bpt id=\"p12\">**</bpt>Matrix<ept id=\"p12\">**</ept><ept id=\"p11\">](https://msdn.microsoft.com/library/windows/apps/BR210127)</ept> value.","pos":[19211,19785]},{"content":"But you typically just use <bpt id=\"p1\">**</bpt>TranslateTransform<ept id=\"p1\">**</ept> and the others because the properties on those transform classes are easier to conceptualize than setting the vector components in a <bpt id=\"p2\">**</bpt>Matrix<ept id=\"p2\">**</ept>.","pos":[19786,19980]},{"content":"It's also easier to animate the discrete properties of transforms; a <bpt id=\"p1\">**</bpt>Matrix<ept id=\"p1\">**</ept> is actually a structure and not a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>DependencyObject<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/BR242356)</ept>, so it can't support animated individual values.","pos":[19981,20224]},{"content":"Some XAML design tools that enable you to apply transformation operations will serialize the results as a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MatrixTransform<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR210137)</ept>.","pos":[20226,20412]},{"content":"In this case it may be best to use the same design tool again to change the transformation effect and serialize the XAML again, rather than trying to manipulate the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Matrix<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR210127)</ept> values yourself directly in the XAML.","pos":[20413,20686]},{"pos":[20790,20804],"content":"3-D transforms"},{"content":"In Windows 10, XAML introduced a new property, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement.Transform3D<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d.aspx)</ept>, that can be used to create 3D effects with UI.","pos":[20806,21020]},{"content":"To do this, use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PerspectiveTransform3D<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.media3d.perspectivetransform3d.aspx)</ept> to add a shared 3D perspective or \"camera\" to your scene, and then use <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>CompositeTransform3D<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.media3d.compositetransform3d.aspx)</ept> to transform an element in 3D space, like you would use <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>CompositeTransform<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR228105)</ept>.","pos":[21021,21527]},{"content":"See <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement.Transform3D<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d.aspx)</ept> for a discussion of how to implement 3D transforms.","pos":[21528,21703]},{"content":"For simpler 3D effects that only apply to a single object, the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UIElement.Projection<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.uielement.projection)</ept> property can be used.","pos":[21706,21909]},{"content":"Using a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PlaneProjection<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br210192)</ept> as the value for this property is equivalent to applying a fixed perspective transform and one or more 3D transforms to the element.","pos":[21910,22130]},{"content":"This type of transform is described in more detail in <bpt id=\"p1\">[</bpt>3-D perspective effects for XAML UI<ept id=\"p1\">](3-d-perspective-effects.md)</ept>.","pos":[22131,22251]},{"pos":[22289,22303],"content":"Related topics"},{"content":"Drawing shapes","pos":[22308,22322]},{"content":"UIElement.Transform3D","pos":[22348,22369]},{"content":"3-D perspective effects for XAML UI","pos":[22468,22503]},{"content":"Transform","pos":[22538,22547]}],"content":"---\nauthor: Jwmsft\nms.assetid: F46D5E18-10A3-4F7B-AD67-76437C77E4BC\ntitle: Transforms overview\ndescription: Learn how to use transforms in the Windows Runtime&\\#160;API, by changing the relative coordinate systems of elements in the UI.\n---\n\n# Transforms overview\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\nLearn how to use transforms in the Windows Runtime API, by changing the relative coordinate systems of elements in the UI. This can be used to adjust the appearance of individual XAML elements, such as scaling, rotating, or transforming the position in x-y space.\n\n## <span id=\"What_is_a_transform_\"></span><span id=\"what_is_a_transform_\"></span><span id=\"WHAT_IS_A_TRANSFORM_\"></span>What is a transform?\n\nA *transform* defines how to map, or transform, points from one coordinate space to another coordinate space. When a transform is applied to a UI element, it changes how that UI element is rendered to the screen as part of the UI.\n\nThink of transforms in four broad classifications: translation, rotation, scaling and skew (or shear). For the purposes of using graphics APIs to change the appearance of UI elements, it's usually easiest to create transforms that define only one operation at a time. So the Windows Runtime defines a discrete class for each of these transform classifications:\n\n-   [**TranslateTransform**](https://msdn.microsoft.com/library/windows/apps/BR243027): translates an element in x-y space, by setting values for [**X**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.translatetransform.x.aspx) and [**Y**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.translatetransform.y).\n-   [**ScaleTransform**](https://msdn.microsoft.com/library/windows/apps/BR242940): scales the transform based on a center point, by setting values for [**CenterX**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.scaletransform.centerx.aspx), [**CenterY**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.scaletransform.centery.aspx), [**ScaleX**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.scaletransform.scalex.aspx) and [**ScaleY**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.scaletransform.scaleyproperty).\n-   [**RotateTransform**](https://msdn.microsoft.com/library/windows/apps/BR242932): rotates in x-y space, by setting values for [**Angle**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.rotatetransform.angle.aspx), [**CenterX**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.rotatetransform.centerx.aspx) and [**CenterY**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.rotatetransform.centery).\n-   [**SkewTransform**](https://msdn.microsoft.com/library/windows/apps/BR242950): skews or shears in x-y space, by setting values for [**AngleX**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.skewtransform.anglex.aspx), [**AngleY**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.skewtransform.angley.aspx), [**CenterX**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.skewtransform.centerx.aspx) and [**CenterY**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.scaletransform.centeryproperty).\n\nOf these, you're likely to use [**TranslateTransform**](https://msdn.microsoft.com/library/windows/apps/BR243027) and [**ScaleTransform**](https://msdn.microsoft.com/library/windows/apps/BR242940) most often for UI scenarios.\n\nYou can combine transforms, and there are two Windows Runtime classes that support this: [**CompositeTransform**](https://msdn.microsoft.com/library/windows/apps/BR228105) and [**TransformGroup**](https://msdn.microsoft.com/library/windows/apps/BR243022). In a **CompositeTransform**, transforms are applied in this order: scale, skew, rotate, translate. Use **TransformGroup** instead of **CompositeTransform** if you want the transforms applied in a different order. For more info, see [**CompositeTransform**](https://msdn.microsoft.com/library/windows/apps/BR228105).\n\n## <span id=\"Transforms_and_layout\"></span><span id=\"transforms_and_layout\"></span><span id=\"TRANSFORMS_AND_LAYOUT\"></span>Transforms and layout\n\nIn XAML layout, transforms are applied after the layout pass is complete, so available space calculations and other layout decisions have been made before the transforms are applied. Because layout comes first, you'll sometimes get unexpected results if you transform elements that are in a [**Grid**](https://msdn.microsoft.com/library/windows/apps/BR242704) cell or similar layout container that allocates space during layout. The transformed element may appear truncated or obscured because it's trying to draw into an area that didn't calculate the post-transform dimensions when dividing space within its parent container. You may need to experiment with the transform results and adjust some settings. For example, instead of relying on adaptive layout and star sizing, you may need to change the **Center** properties or declare fixed pixel measurements for layout space to make sure the parent allots enough space.\n\n**Migration note:**  Windows Presentation Foundation (WPF) had a **LayoutTransform** property that applied transforms prior to the layout pass. But Windows Runtime XAML doesn't support a **LayoutTransform** property. (Microsoft Silverlight didn't have this property either.)\n\n## <span id=\"Applying_a_transform_to_a_UI_element\"></span><span id=\"applying_a_transform_to_a_ui_element\"></span><span id=\"APPLYING_A_TRANSFORM_TO_A_UI_ELEMENT\"></span>Applying a transform to a UI element\n\nWhen you apply a transform to an object, you typically do so to set the property [**UIElement.RenderTransform**](https://msdn.microsoft.com/library/windows/apps/BR208980). Setting this property does not literally change the object pixel by pixel. What the property really does is apply the transform within the local coordinate space in which that object exists. Then the rendering logic and operation (post-layout) renders the combined coordinate spaces, making it look like the object has changed appearance and also potentially its layout position (if [**TranslateTransform**](https://msdn.microsoft.com/library/windows/apps/BR243027) was applied).\n\nBy default, each render transform is centered at the origin of the target object's local coordinate system—its (0,0). The only exception is a [**TranslateTransform**](https://msdn.microsoft.com/library/windows/apps/BR243027), which has no center properties to set because the translation effect is the same regardless of where it is centered. But the other transforms each have properties that set **CenterX** and **CenterY** values.\n\nWhenever you use transforms with [**UIElement.RenderTransform**](https://msdn.microsoft.com/library/windows/apps/BR208980), remember that there's another property on [**UIElement**](https://msdn.microsoft.com/library/windows/apps/BR208911) that affects how the transform behaves: [**RenderTransformOrigin**](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.rendertransformorigin.aspx). What **RenderTransformOrigin** declares is whether the whole transform should apply to the default (0,0) point of an element or to some other origin point within the relative coordinate space of that element. For typical elements, (0,0) places the transform to the top left corner. Depending on what effect you want, you might choose to change **RenderTransformOrigin** rather than adjusting the **CenterX** and **CenterY** values on transforms. Note that if you apply both **RenderTransformOrigin** and **CenterX** / **CenterY** values, the results can be pretty confusing, especially if you're animating any of the values.\n\nFor hit-testing purposes, an object to which a transform is applied continues to respond to input in an expected way that's consistent to its visual appearance in x-y space. For example, if you've used a [**TranslateTransform**](https://msdn.microsoft.com/library/windows/apps/BR243027) to move a [**Rectangle**](https://msdn.microsoft.com/library/windows/apps/BR243371) 400 pixels laterally in the UI, that **Rectangle** responds to [**PointerPressed**](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.pointerpressed.aspx) events when the user presses the point where the **Rectangle** appears visually. You won't get false events if the user presses the area where the **Rectangle** was before being translated. For any z-index considerations that affect hit testing, applying a transform makes no difference; the z-index that governs which element handles input events for a point in x-y space is still evaluated using the child order as declared in a container. That order is usually the same as the order in which you declare the elements in XAML, although for child elements of a [**Canvas**](https://msdn.microsoft.com/library/windows/apps/BR209267) object you can adjust the order by applying the [**Canvas.ZIndex**](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.canvas.zindex.aspx) attached property to child elements.\n\n## <span id=\"Other_transform_properties\"></span><span id=\"other_transform_properties\"></span><span id=\"OTHER_TRANSFORM_PROPERTIES\"></span>Other transform properties\n\n-   [**Brush.Transform**](https://msdn.microsoft.com/library/windows/apps/BR228082), [**Brush.RelativeTransform**](https://msdn.microsoft.com/library/windows/apps/BR228080): These influence how a [**Brush**](https://msdn.microsoft.com/library/windows/apps/BR228076) uses coordinate space within the area that the **Brush** is applied to set visual properties such as foregrounds and backgrounds. These transforms aren't relevant for the most common brushes (which are typically setting solid colors with [**SolidColorBrush**](https://msdn.microsoft.com/library/windows/apps/BR242962)) but might be occasionally useful when painting areas with an [**ImageBrush**](https://msdn.microsoft.com/library/windows/apps/BR210101) or [**LinearGradientBrush**](https://msdn.microsoft.com/library/windows/apps/BR210108).\n-   [**Geometry.Transform**](https://msdn.microsoft.com/library/windows/apps/BR210066): You might use this property to apply a transform to a geometry prior to using that geometry for a [**Path.Data**](https://msdn.microsoft.com/library/windows/apps/BR243356) property value.\n\n## <span id=\"Animating_a_transform\"></span><span id=\"animating_a_transform\"></span><span id=\"ANIMATING_A_TRANSFORM\"></span>Animating a transform\n\n[**Transform**](https://msdn.microsoft.com/library/windows/apps/BR243006) objects can be animated. To animate a **Transform**, apply an animation of a compatible type to the property you want to animate. This typically means you're using [**DoubleAnimation**](https://msdn.microsoft.com/library/windows/apps/BR243136) or [**DoubleAnimationUsingKeyFrames**](https://msdn.microsoft.com/library/windows/apps/BR243136usingkeyframes) objects to define the animation, because all of the transform properties are of type [**Double**](https://msdn.microsoft.com/library/windows/apps/xaml/system.double.aspx). Animations that affect a transform that's used for a [**UIElement.RenderTransform**](https://msdn.microsoft.com/library/windows/apps/BR208980) value are not considered to be dependent animations, even if they have a nonzero duration. For more info about dependent animations, see [Storyboarded animations](storyboarded-animations.md).\n\nIf you animate properties to produce an effect similar to a transform in terms of the net visual appearance—for example, animating the [**Width**](https://msdn.microsoft.com/library/windows/apps/BR208751) and [**Height**](https://msdn.microsoft.com/library/windows/apps/BR208718) of a [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/BR208706) rather than applying a [**TranslateTransform**](https://msdn.microsoft.com/library/windows/apps/BR243027)—such animations are almost always treated as dependent animations. You'd have to enable the animations and there could be significant performance issues with the animation, especially if you're trying to support user interaction while that object is being animated. For that reason it's preferable to use a transform and animate it rather than animating any other property where the animation would be treated as a dependent animation.\n\nTo target the transform, there must be an existing [**Transform**](https://msdn.microsoft.com/library/windows/apps/BR243006) as the value for [**RenderTransform**](https://msdn.microsoft.com/library/windows/apps/BR208980). You typically put an element for the appropriate transform type in the initial XAML, sometimes with no properties set on that transform.\n\nYou typically use an indirect targeting technique to apply animations to the properties of a transform. For more info about indirect targeting syntax, see [Storyboarded animations](storyboarded-animations.md) and [Property-path syntax](https://msdn.microsoft.com/library/windows/apps/Mt185586).\n\nDefault styles for controls sometimes define animations of transforms as part of their visual-state behavior. For example, the visual states for [**ProgressRing**](https://msdn.microsoft.com/library/windows/apps/BR227538) use animated [**RotateTransform**](https://msdn.microsoft.com/library/windows/apps/BR242932) values to \"spin\" the dots in the ring.\n\nHere's a simple example of how to animate a transform. In this case, it's animating the [**Angle**](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.media.rotatetransform.angle.aspx) of a [**RotateTransform**](https://msdn.microsoft.com/library/windows/apps/BR242932) to spin a [**Rectangle**](https://msdn.microsoft.com/library/windows/apps/BR243371) in place around its visual center. This example names the **RotateTransform** so doesn't need indirect animation targeting, but you could alternatively leave the transform unnamed, name the element that the transform's applied to, and use indirect targeting such as `(UIElement.RenderTransform).(RotateTransform.Angle)`.\n\n```xml\n<StackPanel Margin=\"15\">\n  <StackPanel.Resources>\n    <Storyboard x:Name=\"myStoryboard\">\n      <DoubleAnimation\n       Storyboard.TargetName=\"myTransform\"\n       Storyboard.TargetProperty=\"Angle\"\n       From=\"0\" To=\"360\" Duration=\"0:0:5\" \n       RepeatBehavior=\"Forever\" />\n    </Storyboard>\n  </StackPanel.Resources>\n  <Rectangle Width=\"50\" Height=\"50\" Fill=\"RoyalBlue\"\n   PointerPressed=\"StartAnimation\">\n    <Rectangle.RenderTransform>\n      <RotateTransform x:Name=\"myTransform\" Angle=\"45\" CenterX=\"25\" CenterY=\"25\" />\n    </Rectangle.RenderTransform>\n  </Rectangle>\n</StackPanel>\n```\n\n```xml\nvoid StartAnimation (object sender, RoutedEventArgs e) {\n    myStoryboard.Begin();\n}\n```\n\n## <span id=\"Accounting_for_coordinate_frames_of_reference_at_run_time\"></span><span id=\"accounting_for_coordinate_frames_of_reference_at_run_time\"></span><span id=\"ACCOUNTING_FOR_COORDINATE_FRAMES_OF_REFERENCE_AT_RUN_TIME\"></span>Accounting for coordinate frames of reference at run time\n\n[**UIElement**](https://msdn.microsoft.com/library/windows/apps/BR208911) has a method named [**TransformToVisual**](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.transformtovisual.aspx), which can generate a [**Transform**](https://msdn.microsoft.com/library/windows/apps/BR243006) that correlates the coordinate frames of reference for two UI elements. You can use this to compare an element to the app's default coordinate frame of reference if you pass the root visual as the first parameter. This can be useful if you've captured an input event from a different element, or if you are trying to predict layout behavior without actually requesting a layout pass.\n\nEvent data obtained from pointer events provides access to a [**GetCurrentPoint**](https://msdn.microsoft.com/library/windows/apps/BR212141) method, where you can specify a *relativeTo* parameter to change the coordinate frame of reference to a specific element rather than the app default. This approach simply applies a translate transform internally and transforms the x-y coordinate data for you when it creates the returned [**PointerPoint**](https://msdn.microsoft.com/library/windows/apps/BR242038) object.\n\n## <span id=\"Describing_a_transform_mathematically\"></span><span id=\"describing_a_transform_mathematically\"></span><span id=\"DESCRIBING_A_TRANSFORM_MATHEMATICALLY\"></span>Describing a transform mathematically\n\nA transform can be described in terms of a transformation matrix. A 3×3 matrix is used to describe the transformations in a two-dimensional, x-y plane. Affine transformation matrices can be multiplied to form any number of linear transformations, such as rotation and skew (shear), followed by translation. The final column of an affine transformation matrix is equal to (0, 0, 1), so you need to specify only the members of the first two columns in the mathematical description.\n\nThe mathematical description of a transform might be useful to you if you have a mathematical background or a familiarity with graphics-programming techniques that also use matrices to describe transformations of coordinate space. There's a [**Transform**](https://msdn.microsoft.com/library/windows/apps/BR243006)-derived class that enables you to express a transformation directly in terms of its 3×3 matrix: [**MatrixTransform**](https://msdn.microsoft.com/library/windows/apps/BR210137). **MatrixTransform** has a [**Matrix**](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.media.matrixtransform.matrix.aspx) property, which holds a structure that has six properties: [**M11**](https://msdn.microsoft.com/library/windows/apps/Hh673847), [**M12**](https://msdn.microsoft.com/library/windows/apps/Hh673853), [**M21**](https://msdn.microsoft.com/library/windows/apps/Hh673851), [**M22**](https://msdn.microsoft.com/library/windows/apps/Hh673849), [**OffsetX**](https://msdn.microsoft.com/library/windows/apps/Hh673810) and [**OffsetY**](https://msdn.microsoft.com/library/windows/apps/Hh673816). Each [**Matrix**](https://msdn.microsoft.com/library/windows/apps/BR210127) property uses a **Double** value and corresponds to the six relevant values (columns 1 and 2) of an affine transformation matrix.\n\n|                                             |                                             |     |\n|---------------------------------------------|---------------------------------------------|-----|\n| [**M11**](https://msdn.microsoft.com/library/windows/apps/Hh673847)         | [**M21**](https://msdn.microsoft.com/library/windows/apps/Hh673851)         | 0   |\n| [**M12**](https://msdn.microsoft.com/library/windows/apps/Hh673853)         | [**M22**](https://msdn.microsoft.com/library/windows/apps/Hh673849)         | 0   |\n| [**OffsetX**](https://msdn.microsoft.com/library/windows/apps/Hh673810) | [**OffsetY**](https://msdn.microsoft.com/library/windows/apps/Hh673816) | 1   |\n\n \n\nAny transform that you could describe with a [**TranslateTransform**](https://msdn.microsoft.com/library/windows/apps/BR243027), [**ScaleTransform**](https://msdn.microsoft.com/library/windows/apps/BR242940), [**RotateTransform**](https://msdn.microsoft.com/library/windows/apps/BR242932), or [**SkewTransform**](https://msdn.microsoft.com/library/windows/apps/BR242950) object could be described equally by a [**MatrixTransform**](https://msdn.microsoft.com/library/windows/apps/BR210137) with a [**Matrix**](https://msdn.microsoft.com/library/windows/apps/BR210127) value. But you typically just use **TranslateTransform** and the others because the properties on those transform classes are easier to conceptualize than setting the vector components in a **Matrix**. It's also easier to animate the discrete properties of transforms; a **Matrix** is actually a structure and not a [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/BR242356), so it can't support animated individual values.\n\nSome XAML design tools that enable you to apply transformation operations will serialize the results as a [**MatrixTransform**](https://msdn.microsoft.com/library/windows/apps/BR210137). In this case it may be best to use the same design tool again to change the transformation effect and serialize the XAML again, rather than trying to manipulate the [**Matrix**](https://msdn.microsoft.com/library/windows/apps/BR210127) values yourself directly in the XAML.\n\n## <span id=\"3-D_transforms\"></span><span id=\"3-d_transforms\"></span><span id=\"3-D_TRANSFORMS\"></span>3-D transforms\n\nIn Windows 10, XAML introduced a new property, [**UIElement.Transform3D**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d.aspx), that can be used to create 3D effects with UI. To do this, use [**PerspectiveTransform3D**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.media3d.perspectivetransform3d.aspx) to add a shared 3D perspective or \"camera\" to your scene, and then use [**CompositeTransform3D**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.media3d.compositetransform3d.aspx) to transform an element in 3D space, like you would use [**CompositeTransform**](https://msdn.microsoft.com/library/windows/apps/BR228105). See [**UIElement.Transform3D**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d.aspx) for a discussion of how to implement 3D transforms.\n\n For simpler 3D effects that only apply to a single object, the [**UIElement.Projection**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.uielement.projection) property can be used. Using a [**PlaneProjection**](https://msdn.microsoft.com/library/windows/apps/br210192) as the value for this property is equivalent to applying a fixed perspective transform and one or more 3D transforms to the element. This type of transform is described in more detail in [3-D perspective effects for XAML UI](3-d-perspective-effects.md).\n\n## <span id=\"related_topics\"></span>Related topics\n\n* [Drawing shapes](drawing-shapes.md)\n* [**UIElement.Transform3D**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d.aspx)\n* [3-D perspective effects for XAML UI](3-d-perspective-effects.md)\n* [**Transform**](https://msdn.microsoft.com/library/windows/apps/BR243006)\n \n\n \n\n\n\n\n\n"}