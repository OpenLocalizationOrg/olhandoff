{"nodes":[{"content":"Version adaptive code","pos":[26,47]},{"content":"Learn how to take advantage of new APIs while maintaining compatibility with previous versions","pos":[61,155]},{"content":"Version adaptive code: Use new APIs while maintaining compatability with previous versions","pos":[163,253]},{"content":"Each release of the Windows 10 SDK adds exciting new functionality that you'll want to take advantage of.","pos":[255,360]},{"content":"However, not all your customers will update their devices to the latest version of Windows 10 at the same time, and you want to make sure your app works on the broadest possible range of devices.","pos":[361,556]},{"content":"Here, we show you how to design your app so that it runs on earlier versions of Windows 10, but also takes advantage of new features whenever your app runs on a device with the latest update installed.","pos":[557,758]},{"content":"There are 2 steps to take to make sure your app supports the broadest range of Windows 10 devices.","pos":[760,858]},{"content":"First, configure your Visual Studio project to target the latest APIs.","pos":[859,929]},{"content":"This affects what happens when you compile your app.","pos":[930,982]},{"content":"Second, perform runtime checks to ensure that you only call APIs that are present on the device your app is running on.","pos":[983,1102]},{"content":"This article uses examples from the Windows Insider Preview SDK for Windows 10, version 1607 (Anniversary Update).","pos":[1114,1228]},{"content":"The Preview SDK is a pre-release and cannot be used in a production environment.","pos":[1229,1309]},{"content":"Please only install the SDK on your test machine.","pos":[1310,1359]},{"content":"The Preview SDK contains bug fixes and under-development changes to the API surface area.","pos":[1360,1449]},{"content":"If you are working on an application that you need to submit to the store, you should not install the preview.","pos":[1450,1560]},{"content":"Configure your Visual Studio project","pos":[1565,1601]},{"pos":[1603,1758],"content":"The first step in supporting multiple Windows 10 versions is to specify the <bpt id=\"p1\">*</bpt>Target<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>Minimum<ept id=\"p2\">*</ept> supported OS/SDK versions in your Visual Studio project."},{"content":"<bpt id=\"p1\">*</bpt>Target<ept id=\"p1\">*</ept>: The SDK version that Visual Studio compiles your app code and run all tools against.","pos":[1761,1855]},{"content":"All APIs and resources in this SDK version are available in your app code at compile time.","pos":[1856,1946]},{"pos":[1949,2151],"content":"<bpt id=\"p1\">*</bpt>Minimum<ept id=\"p1\">*</ept>: The SDK version that supports the earliest OS version that your app can run on (and will be deployed to by the store) and the version that Visual Studio compiles your app markup code against."},{"content":"During runtime your app will run against the OS version that it is deployed to, so your app will throw exceptions if you use resources or call APIs that are not available in that version.","pos":[2154,2341]},{"content":"We show you how to use runtime checks to call the correct APIs later in this article.","pos":[2342,2427]},{"content":"The Target and Minimum settings specify the ends of a range of OS/SDK versions.","pos":[2429,2508]},{"content":"However, if you test your app on the minimum version, you can be sure it will run on any versions between the Minimum and Target.","pos":[2509,2638]},{"content":"Visual Studio does not warn you about API compatibility.","pos":[2648,2704]},{"content":"It is your responsibility to test and ensure that your app performs as expected on all OS versions between and including the Minimum and Target.","pos":[2705,2849]},{"content":"When you create a new project in Visual Studio 2015, Update 2 or later, you are prompted to set the Target and Minimum versions that your app supports.","pos":[2851,3002]},{"content":"By default, the Target Version is the highest installed SDK version, and the Minimum Version is the lowest installed SDK version.","pos":[3003,3132]},{"content":"You can choose Target and Minimum only from SDK versions that are installed on your machine.","pos":[3133,3225]},{"content":"Set the target SDK in Visual Studio","pos":[3230,3265]},{"content":"We typically recommend that you leave the defaults.","pos":[3296,3347]},{"content":"However, if you have a Preview version of the SDK installed and you are writing production code, you should change the Target Version from the Preview SDK to the latest official SDK version.","pos":[3348,3538]},{"content":"To change the Minimum and Target version for a project that has already been created in Visual Studio, go to Project -&gt; Properties -&gt; Application tab -&gt; Targeting.","pos":[3541,3704]},{"content":"Change the target SDK in Visual Studio","pos":[3708,3746]},{"content":"For reference these are the build numbers for each SDK:","pos":[3778,3833]},{"content":"Windows 10, version 1506: SDK version 10240","pos":[3836,3879]},{"content":"Windows 10, version 1511 (November Update): SDK version 10586","pos":[3882,3943]},{"pos":[3946,4187],"content":"Windows 10, version 1607 Insider Preview (Anniversary Update): As of this writing, <bpt id=\"p1\">[</bpt>the latest Insider Preview SDK version is 14332<ept id=\"p1\">](https://blogs.windows.com/buildingapps/2016/04/28/windows-10-anniversary-sdk-preview-build-14332-released/)</ept>."},{"content":"You can download any released version of the SDK from the <bpt id=\"p1\">[</bpt>Windows SDK and emulator archive<ept id=\"p1\">](https://developer.microsoft.com/downloads/sdk-archive)</ept>.","pos":[4189,4337]},{"content":"You can download the latest Windows Insider Preview SDK from the developer section of the <bpt id=\"p1\">[</bpt>Windows Insider<ept id=\"p1\">](https://insider.windows.com/)</ept> site.","pos":[4338,4481]},{"content":"Write adaptive code","pos":[4486,4505]},{"content":"You can think about writing adaptive code similarly to how you think about <bpt id=\"p1\">[</bpt>creating an adaptive UI<ept id=\"p1\">](https://msdn.microsoft.com/windows/uwp/layout/layouts-with-xaml)</ept>.","pos":[4507,4673]},{"content":"You might design your base UI to run on the smallest screen, and then move or add elements when you detect that your app is running on a larger screen.","pos":[4674,4825]},{"content":"With adaptive code, you write your base code to run on the lowest OS version, and you can add hand-selected features when you detect that your app is running on a higher version where the new feature is available.","pos":[4826,5039]},{"content":"Runtime API checks","pos":[5045,5063]},{"content":"You use the <bpt id=\"p1\">[</bpt>Windows.Foundation.Metadata.ApiInformation<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)</ept> class in a condition in your code to test for the presence of the API you want to call.","pos":[5065,5306]},{"content":"This condition is evaluated wherever your app runs, but it evaluates to <bpt id=\"p1\">**</bpt>true<ept id=\"p1\">**</ept> only on devices where the API is present and therefore available to call.","pos":[5307,5461]},{"content":"This lets you to write version adaptive code in order to create apps that use APIs that are available only on certain OS versions.","pos":[5462,5592]},{"content":"Here we look at specific examples for targeting new features in the Windows Insider Preview.","pos":[5594,5686]},{"content":"For a general overview of using <bpt id=\"p1\">**</bpt>ApiInformation<ept id=\"p1\">**</ept>, see <bpt id=\"p2\">[</bpt>Guide to UWP apps<ept id=\"p2\">](https://msdn.microsoft.com/windows/uwp/get-started/universal-application-platform-guide)</ept> and the blog post <bpt id=\"p3\">[</bpt>Dynamically detecting features with API contracts<ept id=\"p3\">](https://blogs.windows.com/buildingapps/2015/09/15/dynamically-detecting-features-with-api-contracts-10-by-10/)</ept>.","pos":[5687,6033]},{"content":"Numerous runtime API checks can affect the performance of your app.","pos":[6043,6110]},{"content":"We show the checks inline in these examples.","pos":[6111,6155]},{"content":"In production code, you should perform the check once and cache the result, then used the cached result throughout your app.","pos":[6156,6280]},{"content":"Unsupported scenarios","pos":[6287,6308]},{"content":"In most cases, you can keep your app's Minimum Version set to SDK version 10240 and use runtime checks to enable any new APIs when your app runs on later a version.","pos":[6310,6474]},{"content":"However, there are some cases where you must increase your app's Minimum Version in order to use new features.","pos":[6475,6585]},{"content":"You must increase your app's Minimum Version if you use:","pos":[6587,6643]},{"content":"a new API that requires a capability that isn't available in an earlier version.","pos":[6646,6726]},{"content":"You must increase the minimum supported version to one that includes that capability.","pos":[6727,6812]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>App capability declarations<ept id=\"p1\">](../packaging/app-capability-declarations.md)</ept>.","pos":[6813,6907]},{"content":"any new resource keys added to generic.xaml and not available in a previous version.","pos":[6910,6994]},{"content":"The version of generic.xaml used at runtime is determined by the OS version the device is running on.","pos":[6995,7096]},{"content":"You can't use runtime API checks to determine the presence of XAML resources.","pos":[7097,7174]},{"content":"So, you must only use resource keys that are available in the minimum version that your app supports or a <bpt id=\"p1\">[</bpt>XAMLParseException<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.markup.xamlparseexception.aspx)</ept> will cause your app to crash at runtime.","pos":[7175,7438]},{"content":"Adaptive code options","pos":[7444,7465]},{"content":"There are two ways to create adaptive code.","pos":[7467,7510]},{"content":"In most cases, you write your app markup to run on the Minimum version, then use your app code to tap into newer OS features when present.","pos":[7511,7649]},{"content":"However, if you need to update a property in a visual state, and there is only a property or enumeration value change between OS versions, you can create an extensible state trigger that’s activated based on the presence of an API.","pos":[7650,7881]},{"content":"Here, we compare these options.","pos":[7883,7914]},{"content":"App code","pos":[7918,7926]},{"content":"When to use:","pos":[7930,7942]},{"content":"Recommended for all adaptive code scenarios except for specific cases defined below for extensible triggers.","pos":[7945,8053]},{"content":"Benefits:","pos":[8055,8064]},{"content":"Avoids developer overhead/complexity of tying API differences into markup.","pos":[8067,8141]},{"content":"Drawbacks:","pos":[8143,8153]},{"content":"No Designer support.","pos":[8156,8176]},{"content":"State Triggers","pos":[8180,8194]},{"content":"When to use:","pos":[8198,8210]},{"content":"Use when there is only a property or enum change between OS versions that doesn’t require logic changes, and is connected to a visual state.","pos":[8213,8353]},{"content":"Benefits:","pos":[8355,8364]},{"content":"Lets you create specific visual states that are triggered based on the presence of an API.","pos":[8367,8457]},{"content":"Some designer support available.","pos":[8460,8492]},{"content":"Drawbacks:","pos":[8494,8504]},{"content":"Use of custom triggers is restricted to visual states, which doesn’t lend itself to complicated adaptive layouts.","pos":[8507,8620]},{"content":"Must use Setters to specify value changes, so only simple changes are possible.","pos":[8623,8702]},{"content":"Custom state triggers are fairly verbose to set up and use.","pos":[8705,8764]},{"content":"Adaptive code examples","pos":[8769,8791]},{"content":"In this section, we show several examples of adaptive code that use APIs that are new in Windows 10, version 1607 (Windows Insider Preview).","pos":[8793,8933]},{"content":"Example 1: New enum value","pos":[8939,8964]},{"content":"Windows 10, version 1607 adds a new value to the <bpt id=\"p1\">[</bpt>InputScopeNameValue<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.input.inputscopenamevalue.aspx)</ept> enumeration: <bpt id=\"p2\">**</bpt>ChatWithoutEmoji<ept id=\"p2\">**</ept>.","pos":[8966,9167]},{"content":"This new input scope has the same input behavior as the <bpt id=\"p1\">**</bpt>Chat<ept id=\"p1\">**</ept> input scope (spellchecking, auto-complete, auto-capitalization), but it maps to a touch keyboard without an emoji button.","pos":[9168,9354]},{"content":"This is useful if you create your own emoji picker and want to disable the built-in emoji button in the touch keyboard.","pos":[9355,9474]},{"content":"This example shows how to check if the <bpt id=\"p1\">**</bpt>ChatWithoutEmoji<ept id=\"p1\">**</ept> enum value is present and sets the <bpt id=\"p2\">[</bpt>InputScope<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textbox.inputscope.aspx)</ept> property of a <bpt id=\"p3\">**</bpt>TextBox<ept id=\"p3\">**</ept> if it is.","pos":[9477,9718]},{"content":"If it’s not present on the system the app is run on, the <bpt id=\"p1\">**</bpt>InputScope<ept id=\"p1\">**</ept> is set to <bpt id=\"p2\">**</bpt>Chat<ept id=\"p2\">**</ept> instead.","pos":[9719,9818]},{"content":"The code shown could be placed in a Page consructor or Page.Loaded event handler.","pos":[9819,9900]},{"pos":[9910,10084],"content":"When you check an API, use static strings instead of relying on .NET language features, otherwise your app might try to access a type that isn’t defined and crash at runtime."},{"content":"C","pos":[10088,10089]},{"content":"In the previous example, the TextBox is created and all properties are set in code.","pos":[11285,11368]},{"content":"However, if you have existing XAML, and just need to change the InputScope property on systems where the new value is supported, you can do that without changing your XAML, as shown here.","pos":[11369,11556]},{"content":"You set the default value to <bpt id=\"p1\">**</bpt>Chat<ept id=\"p1\">**</ept> in XAML, but you override it in code if the <bpt id=\"p2\">**</bpt>ChatWithoutEmoji<ept id=\"p2\">**</ept> value is present.","pos":[11557,11677]},{"content":"XAML","pos":[11681,11685]},{"content":"C","pos":[11847,11848]},{"content":"Now that we have a concrete example, let’s see how the Target and Minimum version settings apply to it.","pos":[12798,12901]},{"content":"In these examples, you can use the Chat enum value in XAML, or in code without a check, because it’s present in the minimum supported OS version.","pos":[12903,13048]},{"content":"If you use the ChatWithoutEmoji value in XAML, or in code without a check, it will compile without error because it's present in the Target OS version.","pos":[13051,13202]},{"content":"It will also run without error on a system with the Target OS version.","pos":[13203,13273]},{"content":"However, when the app runs on a system with an OS using the Minimum version, it will crash at runtime because the ChatWithoutEmoji enum value is not present.","pos":[13274,13431]},{"content":"Therefore, you must use this value only in code, and wrap it in a runtime API check so it’s called only if it’s supported on the current system.","pos":[13432,13576]},{"content":"Example 2: New control","pos":[13582,13604]},{"content":"A new version of Windows typically brings new controls to the UWP API surface that bring new functionality to the platform.","pos":[13606,13729]},{"content":"To leverage the presence of a new control, use the  <bpt id=\"p1\">[</bpt>ApiInformation.IsTypePresent<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.istypepresent.aspx)</ept> method.","pos":[13730,13931]},{"content":"Windows 10, version 1607 introduces a new media control called <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MediaPlayerElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx)</ept>.","pos":[13933,14119]},{"content":"This control builds on the <bpt id=\"p1\">[</bpt>MediaPlayer<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplayer.aspx)</ept> class, so it brings features like the ability to easily tie into background audio, and it makes use of architectural improvements in the media stack.","pos":[14120,14399]},{"content":"However, if the app runs on a device that’s running a version of Windows 10 older than version 1607, you must use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>MediaElement<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx)</ept> control instead of the new <bpt id=\"p3\">**</bpt>MediaPlayerElement<ept id=\"p3\">**</ept> control.","pos":[14401,14688]},{"content":"You can use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ApiInformation.IsTypePresent<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.istypepresent.aspx)</ept> method to check for the presence of the MediaPlayerElement control at runtime, and load whichever control is suitable for the system where the app is running.","pos":[14689,15009]},{"content":"This example shows how to create an app that uses either the new MediaPlayerElement or the old MediaElement depending on whether MediaPlayerElement type is present.","pos":[15011,15175]},{"content":"In this code, you use the <bpt id=\"p1\">[</bpt>UserControl<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.usercontrol.aspx)</ept> class to componentize the controls and their related UI and code so that you can switch them in and out based on the OS version.","pos":[15176,15436]},{"content":"As an alternative, you can use a custom control, which provides more functionality and custom behavior than what’s needed for this simple example.","pos":[15437,15583]},{"content":"MediaPlayerUserControl","pos":[15588,15610]},{"content":"The <ph id=\"ph1\">`MediaPlayerUserControl`</ph> encapsulates a <bpt id=\"p1\">**</bpt>MediaPlayerElement<ept id=\"p1\">**</ept> and several buttons that are used to skip through the media frame by frame.","pos":[15615,15757]},{"content":"The UserControl lets you treat these controls as a single entity and makes it easier to switch with a MediaElement on older systems.","pos":[15758,15890]},{"content":"This user control should be used only on systems where MediaPlayerElement is present, so you don’t use ApiInformation checks in the code inside this user control.","pos":[15891,16053]},{"content":"To keep this example simple and focused, the frame step buttons are placed outside of the media player.","pos":[16064,16167]},{"content":"For a better user experiance, you should customize the MediaTransportControls to include your custom buttons.","pos":[16168,16277]},{"content":"See <bpt id=\"p1\">[</bpt>Custom transport controls<ept id=\"p1\">](https://msdn.microsoft.com/windows/uwp/controls-and-patterns/custom-transport-controls)</ept> for more info.","pos":[16278,16412]},{"content":"XAML","pos":[16417,16421]},{"content":"C","pos":[17339,17340]},{"content":"MediaElementUserControl","pos":[18619,18642]},{"pos":[18647,18717],"content":"The <ph id=\"ph1\">`MediaElementUserControl`</ph> encapsulates a <bpt id=\"p1\">**</bpt>MediaElement<ept id=\"p1\">**</ept> control."},{"content":"XAML","pos":[18721,18725]},{"pos":[19334,19426],"content":"The code page for <ph id=\"ph1\">`MediaElementUserControl`</ph> contains only generated code, so it's not shown."},{"content":"Initialize a control based on IsTypePresent","pos":[19430,19473]},{"content":"At runtime, you call <bpt id=\"p1\">**</bpt>ApiInformation.IsTypePresent<ept id=\"p1\">**</ept> to check for MediaPlayerElement.","pos":[19477,19563]},{"content":"If it's present, you load <ph id=\"ph1\">`MediaPlayerUserControl`</ph>, if it's not, you load <ph id=\"ph2\">`MediaElementUserControl`</ph>.","pos":[19564,19664]},{"content":"C","pos":[19668,19669]},{"content":"Remember that this check only sets the <ph id=\"ph1\">`mediaControl`</ph> object to either <ph id=\"ph2\">`MediaPlayerUserControl`</ph> or <ph id=\"ph3\">`MediaElementUserControl`</ph>.","pos":[20185,20310]},{"content":"You need to perform these conditional checks anywhere else in your code that you need to determine whether to use MediaPlayerElement or MediaElement APIs.","pos":[20311,20465]},{"content":"You should perform the check once and cache the result, then used the cached result throughout your app.","pos":[20466,20570]},{"content":"State trigger examples","pos":[20575,20597]},{"content":"Extensible state triggers let you use markup and code together to trigger visual state changes based on a condition that you check in code; in this case, the presence of a specific API.","pos":[20599,20784]},{"content":"We don’t recommend state triggers for common adaptive code scenarios because of the overhead involved, and the restriction to only visual states.","pos":[20785,20930]},{"content":"You should use state triggers for adaptive code only when you have small UI changes between different OS versions that won’t impact the remaining UI, such as a property or enum value change on a control.","pos":[20933,21136]},{"content":"Example 1: New property","pos":[21142,21165]},{"content":"The first step in setting up an extensible state trigger is subclassing the <bpt id=\"p1\">[</bpt>StateTriggerBase<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.statetriggerbase.aspx)</ept> class to create a custom trigger that will be active based on the presence of an API.","pos":[21167,21434]},{"content":"This example shows a trigger that activates if the property presence matches the <ph id=\"ph1\">`_isPresent`</ph> variable set in XAML.","pos":[21435,21550]},{"content":"C","pos":[21554,21555]},{"content":"The next step is setting up the visual state trigger in XAML so that two different visual states result based on the presence of the API.","pos":[22357,22494]},{"content":"Windows 10, version 1607 introduces a new property on the <bpt id=\"p1\">[</bpt>FrameworkElement<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.frameworkelement.aspx)</ept> class called <bpt id=\"p2\">[</bpt>AllowFocusOnInteraction<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.frameworkelement.allowfocusoninteraction.aspx)</ept> that determines whether a control takes focus when  a user interacts with it.","pos":[22497,22888]},{"content":"This is useful if you want to keep focus on a text box for data entry (and keep the touch keyboard showing) while the user clicks a button.","pos":[22889,23028]},{"content":"The trigger in this example checks if the property is present.","pos":[23030,23092]},{"content":"If the property is present it sets the <bpt id=\"p1\">**</bpt>AllowFocusOnInteraction<ept id=\"p1\">**</ept> property on a Button to <bpt id=\"p2\">**</bpt>false<ept id=\"p2\">**</ept>; if the property isn’t present, the Button retains its original state.","pos":[23093,23264]},{"content":"The TextBox is included to make it easier to see the effect of this property when you run the code.","pos":[23265,23364]},{"content":"XAML","pos":[23368,23372]},{"content":"Example 2: New enum value","pos":[24485,24510]},{"content":"This example shows how to set different enumeration values based on whether a value is present.","pos":[24512,24607]},{"content":"It uses a custom state trigger to achieve the same result as the previous chat example.","pos":[24608,24695]},{"content":"In this example, you use the new ChatWithoutEmoji input scope if the device is running Windows 10, version 1607, otherwise the <bpt id=\"p1\">**</bpt>Chat<ept id=\"p1\">**</ept> input scope is used.","pos":[24696,24852]},{"content":"The visual states that use this trigger are set up in an <bpt id=\"p1\">*</bpt>if-else<ept id=\"p1\">*</ept> style where the input scope is chosen based on the presence of the new enum value.","pos":[24853,25002]},{"content":"C","pos":[25006,25007]},{"content":"XAML","pos":[25825,25829]},{"content":"Related articles","pos":[27280,27296]},{"content":"Guide to UWP apps","pos":[27301,27318]},{"content":"Dynamically detecting features with API contracts","pos":[27412,27461]}],"content":"---\nauthor: jwmsft\ntitle: Version adaptive code\ndescription: Learn how to take advantage of new APIs while maintaining compatibility with previous versions\n---\n\n# Version adaptive code: Use new APIs while maintaining compatability with previous versions\n\nEach release of the Windows 10 SDK adds exciting new functionality that you'll want to take advantage of. However, not all your customers will update their devices to the latest version of Windows 10 at the same time, and you want to make sure your app works on the broadest possible range of devices. Here, we show you how to design your app so that it runs on earlier versions of Windows 10, but also takes advantage of new features whenever your app runs on a device with the latest update installed.\n\nThere are 2 steps to take to make sure your app supports the broadest range of Windows 10 devices. First, configure your Visual Studio project to target the latest APIs. This affects what happens when you compile your app. Second, perform runtime checks to ensure that you only call APIs that are present on the device your app is running on.\n\n> [!NOTE] This article uses examples from the Windows Insider Preview SDK for Windows 10, version 1607 (Anniversary Update). The Preview SDK is a pre-release and cannot be used in a production environment. Please only install the SDK on your test machine. The Preview SDK contains bug fixes and under-development changes to the API surface area. If you are working on an application that you need to submit to the store, you should not install the preview.\n\n## Configure your Visual Studio project\n\nThe first step in supporting multiple Windows 10 versions is to specify the *Target* and *Minimum* supported OS/SDK versions in your Visual Studio project.\n- *Target*: The SDK version that Visual Studio compiles your app code and run all tools against. All APIs and resources in this SDK version are available in your app code at compile time.\n- *Minimum*: The SDK version that supports the earliest OS version that your app can run on (and will be deployed to by the store) and the version that Visual Studio compiles your app markup code against. \n\nDuring runtime your app will run against the OS version that it is deployed to, so your app will throw exceptions if you use resources or call APIs that are not available in that version. We show you how to use runtime checks to call the correct APIs later in this article.\n\nThe Target and Minimum settings specify the ends of a range of OS/SDK versions. However, if you test your app on the minimum version, you can be sure it will run on any versions between the Minimum and Target.\n\n> [!TIP]Visual Studio does not warn you about API compatibility. It is your responsibility to test and ensure that your app performs as expected on all OS versions between and including the Minimum and Target.\n\nWhen you create a new project in Visual Studio 2015, Update 2 or later, you are prompted to set the Target and Minimum versions that your app supports. By default, the Target Version is the highest installed SDK version, and the Minimum Version is the lowest installed SDK version. You can choose Target and Minimum only from SDK versions that are installed on your machine. \n\n![Set the target SDK in Visual Studio](images/vs-target-sdk-1.png)\n\nWe typically recommend that you leave the defaults. However, if you have a Preview version of the SDK installed and you are writing production code, you should change the Target Version from the Preview SDK to the latest official SDK version. \n\nTo change the Minimum and Target version for a project that has already been created in Visual Studio, go to Project -> Properties -> Application tab -> Targeting.\n\n![Change the target SDK in Visual Studio](images/vs-target-sdk-2.png) \n\nFor reference these are the build numbers for each SDK:\n- Windows 10, version 1506: SDK version 10240\n- Windows 10, version 1511 (November Update): SDK version 10586\n- Windows 10, version 1607 Insider Preview (Anniversary Update): As of this writing, [the latest Insider Preview SDK version is 14332](https://blogs.windows.com/buildingapps/2016/04/28/windows-10-anniversary-sdk-preview-build-14332-released/).\n\nYou can download any released version of the SDK from the [Windows SDK and emulator archive](https://developer.microsoft.com/downloads/sdk-archive). You can download the latest Windows Insider Preview SDK from the developer section of the [Windows Insider](https://insider.windows.com/) site.\n\n## Write adaptive code\n\nYou can think about writing adaptive code similarly to how you think about [creating an adaptive UI](https://msdn.microsoft.com/windows/uwp/layout/layouts-with-xaml). You might design your base UI to run on the smallest screen, and then move or add elements when you detect that your app is running on a larger screen. With adaptive code, you write your base code to run on the lowest OS version, and you can add hand-selected features when you detect that your app is running on a higher version where the new feature is available.\n\n### Runtime API checks\n\nYou use the [Windows.Foundation.Metadata.ApiInformation](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx) class in a condition in your code to test for the presence of the API you want to call. This condition is evaluated wherever your app runs, but it evaluates to **true** only on devices where the API is present and therefore available to call. This lets you to write version adaptive code in order to create apps that use APIs that are available only on certain OS versions.\n\nHere we look at specific examples for targeting new features in the Windows Insider Preview. For a general overview of using **ApiInformation**, see [Guide to UWP apps](https://msdn.microsoft.com/windows/uwp/get-started/universal-application-platform-guide) and the blog post [Dynamically detecting features with API contracts](https://blogs.windows.com/buildingapps/2015/09/15/dynamically-detecting-features-with-api-contracts-10-by-10/).\n\n> [!TIP]Numerous runtime API checks can affect the performance of your app. We show the checks inline in these examples. In production code, you should perform the check once and cache the result, then used the cached result throughout your app. \n\n### Unsupported scenarios\n\nIn most cases, you can keep your app's Minimum Version set to SDK version 10240 and use runtime checks to enable any new APIs when your app runs on later a version. However, there are some cases where you must increase your app's Minimum Version in order to use new features.\n\nYou must increase your app's Minimum Version if you use:\n- a new API that requires a capability that isn't available in an earlier version. You must increase the minimum supported version to one that includes that capability. For more info, see [App capability declarations](../packaging/app-capability-declarations.md).\n- any new resource keys added to generic.xaml and not available in a previous version. The version of generic.xaml used at runtime is determined by the OS version the device is running on. You can't use runtime API checks to determine the presence of XAML resources. So, you must only use resource keys that are available in the minimum version that your app supports or a [XAMLParseException](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.markup.xamlparseexception.aspx) will cause your app to crash at runtime.\n\n### Adaptive code options\n\nThere are two ways to create adaptive code. In most cases, you write your app markup to run on the Minimum version, then use your app code to tap into newer OS features when present. However, if you need to update a property in a visual state, and there is only a property or enumeration value change between OS versions, you can create an extensible state trigger that’s activated based on the presence of an API.\n\nHere, we compare these options.\n\n**App code**\n\nWhen to use:\n- Recommended for all adaptive code scenarios except for specific cases defined below for extensible triggers.\n\nBenefits:\n- Avoids developer overhead/complexity of tying API differences into markup.\n\nDrawbacks:\n- No Designer support.\n\n**State Triggers**\n\nWhen to use:\n- Use when there is only a property or enum change between OS versions that doesn’t require logic changes, and is connected to a visual state.\n\nBenefits:\n- Lets you create specific visual states that are triggered based on the presence of an API.\n- Some designer support available.\n\nDrawbacks:\n- Use of custom triggers is restricted to visual states, which doesn’t lend itself to complicated adaptive layouts.\n- Must use Setters to specify value changes, so only simple changes are possible.\n- Custom state triggers are fairly verbose to set up and use.\n\n## Adaptive code examples\n\nIn this section, we show several examples of adaptive code that use APIs that are new in Windows 10, version 1607 (Windows Insider Preview).\n\n### Example 1: New enum value\n\nWindows 10, version 1607 adds a new value to the [InputScopeNameValue](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.input.inputscopenamevalue.aspx) enumeration: **ChatWithoutEmoji**. This new input scope has the same input behavior as the **Chat** input scope (spellchecking, auto-complete, auto-capitalization), but it maps to a touch keyboard without an emoji button. This is useful if you create your own emoji picker and want to disable the built-in emoji button in the touch keyboard. \n\nThis example shows how to check if the **ChatWithoutEmoji** enum value is present and sets the [InputScope](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textbox.inputscope.aspx) property of a **TextBox** if it is. If it’s not present on the system the app is run on, the **InputScope** is set to **Chat** instead. The code shown could be placed in a Page consructor or Page.Loaded event handler.\n\n> [!TIP]When you check an API, use static strings instead of relying on .NET language features, otherwise your app might try to access a type that isn’t defined and crash at runtime.\n\n**C#**\n```csharp\n// Create a TextBox control for sending messages \n// and initialize an InputScope object.\nTextBox messageBox = new TextBox();\nmessageBox.AcceptsReturn = true;\nmessageBox.TextWrapping = TextWrapping.Wrap;\nInputScope scope = new InputScope();\nInputScopeName scopeName = new InputScopeName();\n\n// Check that the ChatWithEmoji value is present.\n// (It's present starting with Windows 10, version 1607,\n//  the Target version for the app. This check returns false on earlier versions.)         \nif (ApiInformation.IsEnumNamedValuePresent(\"Windows.UI.Xaml.Input.InputScopeNameValue\", \"ChatWithoutEmoji\"))\n{\n    // Set new ChatWithoutEmoji InputScope if present.\n    scopeName.NameValue = InputScopeNameValue.ChatWithoutEmoji;\n}\nelse\n{\n    // Fall back to Chat InputScope.\n    scopeName.NameValue = InputScopeNameValue.Chat;\n}\n\n// Set InputScope on messaging TextBox.\nscope.Names.Add(scopeName);\nmessageBox.InputScope = scope;\n\n// For this example, set the TextBox text to show the selected InputScope.\nmessageBox.Text = messageBox.InputScope.Names[0].NameValue.ToString();\n\n// Add the TextBox to the XAML visual tree (rootGrid is defined in XAML).\nrootGrid.Children.Add(messageBox);\n```\n\nIn the previous example, the TextBox is created and all properties are set in code. However, if you have existing XAML, and just need to change the InputScope property on systems where the new value is supported, you can do that without changing your XAML, as shown here. You set the default value to **Chat** in XAML, but you override it in code if the **ChatWithoutEmoji** value is present.\n\n**XAML**\n```xaml\n<TextBox x:Name=\"messageBox\"\n         AcceptsReturn=\"True\" TextWrapping=\"Wrap\"\n         InputScope=\"Chat\"\n         Loaded=\"messageBox_Loaded\"/>\n```\n\n**C#**\n```csharp\nprivate void messageBox_Loaded(object sender, RoutedEventArgs e)\n{\n    if (ApiInformation.IsEnumNamedValuePresent(\"Windows.UI.Xaml.Input.InputScopeNameValue\", \"ChatWithoutEmoji\"))\n    {\n        // Check that the ChatWithEmoji value is present.\n        // (It's present starting with Windows 10, version 1607,\n        //  the Target version for the app. This code is skipped on earlier versions.)\n        InputScope scope = new InputScope();\n        InputScopeName scopeName = new InputScopeName();\n        scopeName.NameValue = InputScopeNameValue.ChatWithoutEmoji;\n        // Set InputScope on messaging TextBox.\n        scope.Names.Add(scopeName);\n        messageBox.InputScope = scope;\n    }\n\n    // For this example, set the TextBox text to show the selected InputScope.\n    // This is outside of the API check, so it will happen on all OS versions.\n    messageBox.Text = messageBox.InputScope.Names[0].NameValue.ToString();\n}\n```\n\nNow that we have a concrete example, let’s see how the Target and Minimum version settings apply to it.\n\nIn these examples, you can use the Chat enum value in XAML, or in code without a check, because it’s present in the minimum supported OS version. \n\nIf you use the ChatWithoutEmoji value in XAML, or in code without a check, it will compile without error because it's present in the Target OS version. It will also run without error on a system with the Target OS version. However, when the app runs on a system with an OS using the Minimum version, it will crash at runtime because the ChatWithoutEmoji enum value is not present. Therefore, you must use this value only in code, and wrap it in a runtime API check so it’s called only if it’s supported on the current system.\n\n### Example 2: New control\n\nA new version of Windows typically brings new controls to the UWP API surface that bring new functionality to the platform. To leverage the presence of a new control, use the  [ApiInformation.IsTypePresent](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.istypepresent.aspx) method.\n\nWindows 10, version 1607 introduces a new media control called [**MediaPlayerElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx). This control builds on the [MediaPlayer](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplayer.aspx) class, so it brings features like the ability to easily tie into background audio, and it makes use of architectural improvements in the media stack.\n\nHowever, if the app runs on a device that’s running a version of Windows 10 older than version 1607, you must use the [**MediaElement**](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx) control instead of the new **MediaPlayerElement** control. You can use the [**ApiInformation.IsTypePresent**](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.istypepresent.aspx) method to check for the presence of the MediaPlayerElement control at runtime, and load whichever control is suitable for the system where the app is running.\n\nThis example shows how to create an app that uses either the new MediaPlayerElement or the old MediaElement depending on whether MediaPlayerElement type is present. \nIn this code, you use the [UserControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.usercontrol.aspx) class to componentize the controls and their related UI and code so that you can switch them in and out based on the OS version. As an alternative, you can use a custom control, which provides more functionality and custom behavior than what’s needed for this simple example.\n \n**MediaPlayerUserControl** \n\nThe `MediaPlayerUserControl` encapsulates a **MediaPlayerElement** and several buttons that are used to skip through the media frame by frame. The UserControl lets you treat these controls as a single entity and makes it easier to switch with a MediaElement on older systems. This user control should be used only on systems where MediaPlayerElement is present, so you don’t use ApiInformation checks in the code inside this user control.\n\n> [!NOTE]To keep this example simple and focused, the frame step buttons are placed outside of the media player. For a better user experiance, you should customize the MediaTransportControls to include your custom buttons. See [Custom transport controls](https://msdn.microsoft.com/windows/uwp/controls-and-patterns/custom-transport-controls) for more info. \n\n**XAML**\n```xaml\n<UserControl\n    x:Class=\"MediaApp.MediaPlayerUserControl\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:MediaApp\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\"\n    d:DesignHeight=\"300\"\n    d:DesignWidth=\"400\">\n\n    <Grid x:Name=\"MPE_grid>\n        <Grid.RowDefinitions>\n            <RowDefinition/>\n            <RowDefinition Height=\"Auto\"/>\n        </Grid.RowDefinitions>\n        <StackPanel Orientation=\"Horizontal\" \n                    HorizontalAlignment=\"Center\" Grid.Row=\"1\">\n            <RepeatButton Click=\"StepBack_Click\" Content=\"Step Back\"/>\n            <RepeatButton Click=\"StepForward_Click\" Content=\"Step Forward\"/>\n        </StackPanel>\n    </Grid>\n</UserControl>\n```\n\n**C#**\n```csharp\nusing System;\nusing Windows.Media.Core;\nusing Windows.UI.Xaml;\nusing Windows.UI.Xaml.Controls;\n\nnamespace MediaApp\n{\n    public sealed partial class MediaPlayerUserControl : UserControl\n    {\n        public MediaPlayerUserControl()\n        {\n            this.InitializeComponent();\n            \n            // The markup code compiler runs against the Minimum OS version so MediaPlayerElement must be created in app code\n            MPE = new MediaPlayerElement();\n            Uri videoSource = new Uri(\"ms-appx:///Assets/UWPDesign.mp4\");\n            MPE.Source = MediaSource.CreateFromUri(videoSource);\n            MPE.AreTransportControlsEnabled = true;\n            MPE.MediaPlayer.AutoPlay = true;\n\n            // Add MediaPlayerElement to the Grid\n            MPE_grid.Children.Add(MPE);\n\n        }\n\n        private void StepForward_Click(object sender, RoutedEventArgs e)\n        {\n            // Step forward one frame, only available using MediaPlayerElement.\n            MPE.MediaPlayer.StepForwardOneFrame();\n        }\n\n        private void StepBack_Click(object sender, RoutedEventArgs e)\n        {\n            // Step forward one frame, only available using MediaPlayerElement.\n            MPE.MediaPlayer.StepForwardOneFrame();\n        }\n    }\n}\n```\n\n**MediaElementUserControl**\n \nThe `MediaElementUserControl` encapsulates a **MediaElement** control.\n\n**XAML**\n```xaml\n<UserControl\n    x:Class=\"MediaApp.MediaElementUserControl\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:MediaApp\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\"\n    d:DesignHeight=\"300\"\n    d:DesignWidth=\"400\">\n\n    <Grid>\n        <MediaElement AreTransportControlsEnabled=\"True\" \n                      Source=\"Assets/UWPDesign.mp4\"/>\n    </Grid>\n</UserControl>\n```\n\n> [!NOTE]The code page for `MediaElementUserControl` contains only generated code, so it's not shown.\n\n**Initialize a control based on IsTypePresent**\n\nAt runtime, you call **ApiInformation.IsTypePresent** to check for MediaPlayerElement. If it's present, you load `MediaPlayerUserControl`, if it's not, you load `MediaElementUserControl`.\n\n**C#**\n```csharp\npublic MainPage()\n{\n    this.InitializeComponent();\n\n    UserControl mediaControl;\n\n    // Check for presence of type MediaPlayerElement.\n    if (ApiInformation.IsTypePresent(\"Windows.UI.Xaml.Controls.MediaPlayerElement\"))\n    {\n        mediaControl = new MediaPlayerUserControl();\n    }\n    else\n    {\n        mediaControl = new MediaElementUserControl();\n    }\n\n    // Add mediaControl to XAML visual tree (rootGrid is defined in XAML).\n    rootGrid.Children.Add(mediaControl);\n}\n```\n\n> [!IMPORTANT] Remember that this check only sets the `mediaControl` object to either `MediaPlayerUserControl` or `MediaElementUserControl`. You need to perform these conditional checks anywhere else in your code that you need to determine whether to use MediaPlayerElement or MediaElement APIs. You should perform the check once and cache the result, then used the cached result throughout your app.\n\n## State trigger examples\n\nExtensible state triggers let you use markup and code together to trigger visual state changes based on a condition that you check in code; in this case, the presence of a specific API. We don’t recommend state triggers for common adaptive code scenarios because of the overhead involved, and the restriction to only visual states. \n\nYou should use state triggers for adaptive code only when you have small UI changes between different OS versions that won’t impact the remaining UI, such as a property or enum value change on a control.\n\n### Example 1: New property\n\nThe first step in setting up an extensible state trigger is subclassing the [StateTriggerBase](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.statetriggerbase.aspx) class to create a custom trigger that will be active based on the presence of an API. This example shows a trigger that activates if the property presence matches the `_isPresent` variable set in XAML.\n\n**C#**\n```csharp\nclass IsPropertyPresentTrigger : StateTriggerBase\n{\n    public string TypeName { get; set; }\n    public string PropertyName { get; set; }\n\n    private Boolean _isPresent;\n    private bool? _isPropertyPresent = null;\n\n    public Boolean IsPresent\n    {\n        get { return _isPresent; }\n        set\n        {\n            _isPresent = value;\n            if (_isPropertyPresent == null)\n            {\n                // Call into ApiInformation method to determine if property is present.\n                _isPropertyPresent =\n                ApiInformation.IsPropertyPresent(TypeName, PropertyName);\n            }\n\n            // If the property presence matches _isPresent then the trigger will be activated;\n            SetActive(_isPresent == _isPropertyPresent);\n        }\n    }\n}\n```\n\nThe next step is setting up the visual state trigger in XAML so that two different visual states result based on the presence of the API. \n\nWindows 10, version 1607 introduces a new property on the [FrameworkElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.frameworkelement.aspx) class called [AllowFocusOnInteraction](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.frameworkelement.allowfocusoninteraction.aspx) that determines whether a control takes focus when  a user interacts with it. This is useful if you want to keep focus on a text box for data entry (and keep the touch keyboard showing) while the user clicks a button.\n\nThe trigger in this example checks if the property is present. If the property is present it sets the **AllowFocusOnInteraction** property on a Button to **false**; if the property isn’t present, the Button retains its original state. The TextBox is included to make it easier to see the effect of this property when you run the code.\n\n**XAML**\n```xaml\n<Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n    <StackPanel>\n        <TextBox Width=\"300\" Height=\"36\"/>\n        <!-- Button to set the new property on. -->\n        <Button x:Name=\"testButton\" Content=\"Test\" Margin=\"12\"/>\n    </StackPanel>\n\n    <VisualStateManager.VisualStateGroups>\n        <VisualStateGroup x:Name=\"propertyPresentStateGroup\">\n            <VisualState>\n                <VisualState.StateTriggers>\n                    <!--Trigger will activate if the AllowFocusOnInteraction property is present-->\n                    <local:IsPropertyPresentTrigger \n                        TypeName=\"Windows.UI.Xaml.FrameworkElement\" \n                        PropertyName=\"AllowFocusOnInteraction\" IsPresent=\"True\"/>\n                </VisualState.StateTriggers>\n                <VisualState.Setters>\n                    <Setter Target=\"testButton.AllowFocusOnInteraction\" \n                            Value=\"False\"/>\n                </VisualState.Setters>\n            </VisualState>\n        </VisualStateGroup>\n    </VisualStateManager.VisualStateGroups>\n</Grid>\n```\n\n### Example 2: New enum value\n\nThis example shows how to set different enumeration values based on whether a value is present. It uses a custom state trigger to achieve the same result as the previous chat example. In this example, you use the new ChatWithoutEmoji input scope if the device is running Windows 10, version 1607, otherwise the **Chat** input scope is used. The visual states that use this trigger are set up in an *if-else* style where the input scope is chosen based on the presence of the new enum value.\n\n**C#**\n```csharp\nclass IsEnumPresentTrigger : StateTriggerBase\n{\n    public string EnumTypeName { get; set; }\n    public string EnumValueName { get; set; }\n\n    private Boolean _isPresent;\n    private bool? _isEnumValuePresent = null;\n\n    public Boolean IsPresent\n    {\n        get { return _isPresent; }\n        set\n        {\n            _isPresent = value;\n\n            if (_isEnumValuePresent == null)\n            {\n                // Call into ApiInformation method to determine if value is present.\n                _isEnumValuePresent =\n                ApiInformation.IsEnumNamedValuePresent(EnumTypeName, EnumValueName);\n            }\n\n            // If the property presence matches _isPresent then the trigger will be activated;\n            SetActive(_isPresent == _isEnumValuePresent);\n        }\n    }\n}\n```\n\n**XAML**\n```xaml\n<Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n\n    <TextBox x:Name=\"messageBox\"\n     AcceptsReturn=\"True\" TextWrapping=\"Wrap\"/>\n\n\n    <VisualStateManager.VisualStateGroups>\n        <VisualStateGroup x:Name=\"EnumPresentStates\">\n            <!--if-->\n            <VisualState x:Name=\"isPresent\">\n                <VisualState.StateTriggers>\n                    <local:IsEnumPresentTrigger \n                        EnumTypeName=\"Windows.UI.Xaml.Input.InputScopeNameValue\" \n                        EnumValueName=\"ChatWithoutEmoji\" IsPresent=\"True\"/>\n                </VisualState.StateTriggers>\n                <VisualState.Setters>\n                    <Setter Target=\"messageBox.InputScope\" Value=\"ChatWithoutEmoji\"/>\n                </VisualState.Setters>\n            </VisualState>\n            <!--else-->\n            <VisualState x:Name=\"isNotPresent\">\n                <VisualState.StateTriggers>\n                    <local:IsEnumPresentTrigger \n                        EnumTypeName=\"Windows.UI.Xaml.Input.InputScopeNameValue\" \n                        EnumValueName=\"ChatWithoutEmoji\" IsPresent=\"False\"/>\n                </VisualState.StateTriggers>\n                <VisualState.Setters>\n                    <Setter Target=\"messageBox.InputScope\" Value=\"Chat\"/>\n                </VisualState.Setters>\n            </VisualState>\n        </VisualStateGroup>\n    </VisualStateManager.VisualStateGroups>\n</Grid>\n```\n## Related articles\n\n- [Guide to UWP apps](https://msdn.microsoft.com/windows/uwp/get-started/universal-application-platform-guide)\n- [Dynamically detecting features with API contracts](https://blogs.windows.com/buildingapps/2015/09/15/dynamically-detecting-features-with-api-contracts-10-by-10/)\n"}