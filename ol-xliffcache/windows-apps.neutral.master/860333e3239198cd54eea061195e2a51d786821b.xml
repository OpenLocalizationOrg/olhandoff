{"nodes":[{"content":"Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C","pos":[29,114]},{"content":"This walkthrough shows how to create a basic Windows Runtime Component DLL that's callable from JavaScript, C#, or Visual Basic.","pos":[129,257]},{"content":"Walkthrough: Creating a Windows Runtime component in C++ and calling it from JavaScript or C","pos":[316,408]},{"content":"Updated for UWP apps on Windows 10.","pos":[420,455]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[456,548]},{"content":"This walkthrough shows how to create a basic Windows Runtime Component DLL that's callable from JavaScript, C#, or Visual Basic.","pos":[553,681]},{"content":"Before you begin this walkthrough, make sure that you understand concepts such as the Abstract Binary Interface (ABI), ref classes, and the Visual C++ Component Extensions that make working with ref classes easier.","pos":[682,896]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Creating Windows Runtime Components in C++<ept id=\"p1\">](creating-windows-runtime-components-in-cpp.md)</ept> and <bpt id=\"p2\">[</bpt>Visual C++ Language Reference (C++/CX)<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh699871.aspx)</ept>.","pos":[897,1128]},{"content":"Creating the C++ component DLL","pos":[1133,1163]},{"content":"In this example, we create the component project first, but you could create the JavaScript project first.","pos":[1165,1271]},{"content":"The order doesn’t matter.","pos":[1272,1297]},{"content":"Notice that the main class of the component contains examples of property and method definitions, and an event declaration.","pos":[1299,1422]},{"content":"These are provided just to show you how it's done.","pos":[1423,1473]},{"content":"They are not required, and in this example, we'll replace all of the generated code with our own code.","pos":[1474,1576]},{"content":"To create the C++ component project","pos":[1583,1618]},{"pos":[1622,1683],"content":"On the Visual Studio menu bar, choose <bpt id=\"p1\">**</bpt>File, New, Project<ept id=\"p1\">**</ept>."},{"pos":[1685,1812],"content":"In the <bpt id=\"p1\">**</bpt>New Project<ept id=\"p1\">**</ept> dialog box, in the left pane, expand <bpt id=\"p2\">**</bpt>Visual C++<ept id=\"p2\">**</ept> and then select the node for Universal Windows apps."},{"pos":[1814,1908],"content":"In the center pane, select <bpt id=\"p1\">**</bpt>Windows Runtime Component<ept id=\"p1\">**</ept> and then name the project WinRT<ph id=\"ph1\">\\_</ph>CPP."},{"pos":[1910,1935],"content":"Choose the <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept> button."},{"content":"To add an activatable class to the component","pos":[1942,1986]},{"content":"An activatable class is one that client code can create by using a <bpt id=\"p1\">**</bpt>new<ept id=\"p1\">**</ept> expression (<bpt id=\"p2\">**</bpt>New<ept id=\"p2\">**</ept> in Visual Basic, or <bpt id=\"p3\">**</bpt>ref new<ept id=\"p3\">**</ept> in C++).","pos":[1990,2125]},{"content":"In your component, you declare it as <bpt id=\"p1\">**</bpt>public ref class sealed<ept id=\"p1\">**</ept>.","pos":[2126,2191]},{"content":"In fact, the Class1.h and .cpp files already have a ref class.","pos":[2192,2254]},{"content":"You can change the name, but in this example we’ll use the default name—Class1.","pos":[2255,2334]},{"content":"You can define additional ref classes or regular classes in your component if they are required.","pos":[2335,2431]},{"content":"For more information about ref classes, see <bpt id=\"p1\">[</bpt>Type System (C++/CX)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh755822.aspx)</ept>.","pos":[2432,2562]},{"content":"Add these <ph id=\"ph1\">\\#</ph>include directives to Class1.h:","pos":[2564,2607]},{"content":"collection.h is the header file for C++ concrete classes such as the Platform::Collections::Vector class and the Platform::Collections::Map class, which implement language-neutral interfaces that are defined by the Windows Runtime.","pos":[2701,2932]},{"content":"The amp headers are used to run computations on the GPU.","pos":[2933,2989]},{"content":"They have no Windows Runtime equivalents, and that’s fine because they are private.","pos":[2990,3073]},{"content":"In general, for performance reasons you should use ISO C++ code and standard libraries internally within the component; it’s just the Windows Runtime interface that must be expressed in Windows Runtime types.","pos":[3074,3282]},{"content":"To add a delegate at namespace scope","pos":[3287,3323]},{"content":"A delegate is a construct that defines the parameters and return type for methods.","pos":[3325,3407]},{"content":"An event is an instance of a particular delegate type, and any event handler method that subscribes to the event must have the signature that's specified in the delegate.","pos":[3408,3578]},{"content":"The following code defines a delegate type that takes an int and returns void.","pos":[3579,3657]},{"content":"Next the code declares a public event of this type; this enables client code to provide methods that are invoked when the event is fired.","pos":[3658,3795]},{"content":"Add the following delegate declaration at namespace scope in Class1.h, just before the Class1 declaration.","pos":[3797,3903]},{"content":"If the code isn’t lining up correctly when you paste it into Visual Studio, just press Ctrl+K+D to fix the indentation for the entire file.","pos":[3969,4108]},{"content":"To add the public members","pos":[4113,4138]},{"content":"The class exposes three public methods and one public event.","pos":[4140,4200]},{"content":"The first method is synchronous because it always executes very fast.","pos":[4201,4270]},{"content":"Because the other two methods might take some time, they are asynchronous so that they don’t block the UI thread.","pos":[4271,4384]},{"content":"These methods return IAsyncOperationWithProgress and IAsyncActionWithProgress.","pos":[4385,4463]},{"content":"The former defines an async method that returns a result, and the latter defines an async method that returns void.","pos":[4464,4579]},{"content":"These interfaces also enable client code to receive updates on the progress of the operation.","pos":[4580,4673]},{"content":"To add the private members","pos":[5223,5249]},{"content":"The class contains three private members: two helper methods for the numeric computations and a CoreDispatcher object that’s used to marshal the event invocations from worker threads back to the UI thread.","pos":[5251,5456]},{"content":"To add the header and namespace directives","pos":[5569,5611]},{"content":"In Class1.cpp, add these #include directives:","pos":[5613,5658]},{"content":"Now add these using statements to pull in the required namespaces:","pos":[5725,5791]},{"content":"To add the implementation for ComputeResult","pos":[5998,6041]},{"content":"In Class1.cpp, add the following method implementation.","pos":[6043,6098]},{"content":"This method executes synchronously on the calling thread, but it is very fast because it uses C++ AMP to parallelize the computation on the GPU.","pos":[6099,6243]},{"content":"For more information, see C++ AMP Overview.","pos":[6244,6287]},{"content":"The results are appended to a Platform::Collections::Vector<ph id=\"ph1\">&lt;T&gt;</ph> concrete type, which is implicitly converted to a Windows::Foundation::Collections::IVector<ph id=\"ph2\">&lt;T&gt;</ph> when it is returned.","pos":[6288,6466]},{"content":"To add the implementation for GetPrimesOrdered and its helper method","pos":[7306,7374]},{"content":"In Class1.cpp, add the implementations for GetPrimesOrdered and the is_prime helper method.","pos":[7376,7467]},{"content":"GetPrimesOrdered uses a concurrent_vector class and a parallel_for function loop to divide up the work and use the maximum resources of the computer on which the program is running to produce results.","pos":[7468,7668]},{"content":"After the results are computed, stored, and sorted, they are added to a Platform::Collections::Vector<ph id=\"ph1\">&lt;T&gt;</ph> and returned as Windows::Foundation::Collections::IVector<ph id=\"ph2\">&lt;T&gt;</ph> to client code.","pos":[7669,7850]},{"content":"Notice the code for the progress reporter, which enables the client to hook up a progress bar or other UI to show the user how much longer the operation is going to take.","pos":[7852,8022]},{"content":"Progress reporting has a cost.","pos":[8023,8053]},{"content":"An event must be fired on the component side and handled on the UI thread, and the progress value must be stored on each iteration.","pos":[8054,8185]},{"content":"One way to minimize the cost is by limiting the frequency at which a progress event is fired.","pos":[8186,8279]},{"content":"If the cost is still prohibitive, or if you can't estimate the length of the operation, then consider using a progress ring, which shows that an operation is in progress but doesn't show time remaining until completion.","pos":[8280,8499]},{"content":"To add the implementation for GetPrimesUnordered","pos":[10825,10873]},{"content":"The last step to create the C++ component is to add the implementation for the GetPrimesUnordered in Class1.cpp.","pos":[10875,10987]},{"content":"This method returns each result as it is found, without waiting until all results are found.","pos":[10988,11080]},{"content":"Each result is returned in the event handler and displayed on the UI in real time.","pos":[11081,11163]},{"content":"Again, notice that a progress reporter is used.","pos":[11164,11211]},{"content":"This method also uses the is_prime helper method.","pos":[11212,11261]},{"content":"Creating a JavaScript client app","pos":[13431,13463]},{"content":"If you just want to create a C# client, you can skip this section.","pos":[13465,13531]},{"content":"To create a JavaScript project","pos":[13536,13566]},{"pos":[13568,13667],"content":"In Solution Explorer, open the shortcut menu for the Solution node and choose <bpt id=\"p1\">**</bpt>Add, New Project<ept id=\"p1\">**</ept>."},{"pos":[13669,13779],"content":"Expand JavaScript (it might be nested under <bpt id=\"p1\">**</bpt>Other Languages<ept id=\"p1\">**</ept>) and choose <bpt id=\"p2\">**</bpt>Blank App (Universal Windows)<ept id=\"p2\">**</ept>."},{"pos":[13781,13840],"content":"Accept the default name—App1—by choosing the <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept> button."},{"pos":[13842,13929],"content":"Open the shortcut menu for the App1 project node and choose <bpt id=\"p1\">**</bpt>Set as Startup Project<ept id=\"p1\">**</ept>."},{"content":"Add a project reference to WinRT_CPP:","pos":[13931,13968]},{"pos":[13970,14046],"content":"Open the shortcut menu for the References node and choose <bpt id=\"p1\">**</bpt>Add Reference<ept id=\"p1\">**</ept>."},{"pos":[14048,14152],"content":"In the left pane of the References Manager dialog box, select <bpt id=\"p1\">**</bpt>Projects<ept id=\"p1\">**</ept> and then select <bpt id=\"p2\">**</bpt>Solution<ept id=\"p2\">**</ept>."},{"pos":[14154,14224],"content":"In the center pane, select WinRT_CPP and then choose the <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept> button"},{"content":"To add the HTML that invokes the JavaScript event handlers","pos":[14229,14287]},{"pos":[14289,14351],"content":"Paste this HTML into the <ph id=\"ph1\">&lt;body&gt;</ph> node of the default.html page:"},{"content":"To add styles","pos":[15302,15315]},{"content":"In default.css, remove the body style and then add these styles:","pos":[15317,15381]},{"content":"To add the JavaScript event handlers that call into the component DLL","pos":[16001,16070]},{"content":"Add the following functions at the end of the default.js file.","pos":[16072,16134]},{"content":"These functions are called when the buttons on the main page are chosen.","pos":[16135,16207]},{"content":"Notice how JavaScript activates the C++ class, and then calls its methods and uses the return values to populate the HTML labels.","pos":[16208,16337]},{"content":"Add code to add the event listeners by replacing the existing call to WinJS.UI.processAll in app.onactivated in default.js with the following code that implements event registration in a then block.","pos":[18290,18488]},{"content":"For a detailed explanation of this, see Create a \"Hello World\" app (JS).","pos":[18489,18561]},{"content":"Press F5 to run the app.","pos":[19210,19234]},{"content":"Creating a C# client app","pos":[19239,19263]},{"content":"To create a C# project","pos":[19268,19290]},{"pos":[19292,19396],"content":"In Solution Explorer, open the shortcut menu for the Solution node and then choose <bpt id=\"p1\">**</bpt>Add, New Project<ept id=\"p1\">**</ept>."},{"pos":[19398,19572],"content":"Expand Visual C# (it might be nested under <bpt id=\"p1\">**</bpt>Other Languages<ept id=\"p1\">**</ept>), select <bpt id=\"p2\">**</bpt>Windows<ept id=\"p2\">**</ept> and then <bpt id=\"p3\">**</bpt>Universal<ept id=\"p3\">**</ept> in the left pane, and then select <bpt id=\"p4\">**</bpt>Blank App<ept id=\"p4\">**</ept> in the middle pane."},{"pos":[19574,19632],"content":"Name this app CS_Client and then choose the <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept> button."},{"pos":[19634,19726],"content":"Open the shortcut menu for the CS_Client project node and choose <bpt id=\"p1\">**</bpt>Set as Startup Project<ept id=\"p1\">**</ept>."},{"content":"Add a project reference to WinRT_CPP:","pos":[19728,19765]},{"pos":[19767,19847],"content":"Open the shortcut menu for the <bpt id=\"p1\">**</bpt>References<ept id=\"p1\">**</ept> node and choose <bpt id=\"p2\">**</bpt>Add Reference<ept id=\"p2\">**</ept>."},{"pos":[19849,19957],"content":"In the left pane of the <bpt id=\"p1\">**</bpt>References Manager<ept id=\"p1\">**</ept> dialog box, select <bpt id=\"p2\">**</bpt>Projects<ept id=\"p2\">**</ept> and then select <bpt id=\"p3\">**</bpt>Solution<ept id=\"p3\">**</ept>."},{"pos":[19959,20030],"content":"In the center pane, select WinRT_CPP and then choose the <bpt id=\"p1\">**</bpt>OK<ept id=\"p1\">**</ept> button."},{"content":"To add the XAML that defines the user interface","pos":[20035,20082]},{"content":"Copy the following code into the Grid element in MainPage.xaml.","pos":[20084,20147]},{"content":"To add the event handlers for the buttons","pos":[21525,21566]},{"content":"In Solution Explorer, open MainPage.xaml.cs.","pos":[21568,21612]},{"content":"(The file might be nested under MainPage.xaml.) Add a using directive for System.Text, and then add the event handler for the Logarithm calculation in the MainPage class.","pos":[21613,21783]},{"content":"Add the event handler for the ordered result:","pos":[22262,22307]},{"content":"Add the event handler for the unordered result, and for the button that clears the results so that you can run the code again.","pos":[23308,23434]},{"content":"Running the app","pos":[24701,24716]},{"content":"Select either the C# project or JavaScript project as the startup project by opening the shortcut menu for the project node in Solution Explorer and choosing <bpt id=\"p1\">**</bpt>Set As Startup Project<ept id=\"p1\">**</ept>.","pos":[24718,24903]},{"content":"Then press F5 to run with debugging, or Ctrl+F5 to run without debugging.","pos":[24904,24977]},{"content":"Inspecting your component in Object Browser (optional)","pos":[24982,25036]},{"content":"In Object Browser, you can inspect all Windows Runtime types that are defined in .winmd files.","pos":[25038,25132]},{"content":"This includes the types in the Platform namespace and the default namespace.","pos":[25133,25209]},{"content":"However, because the types in the Platform::Collections namespace are defined in the header file collections.h, not in a winmd file, they don’t appear in Object Browser.","pos":[25210,25379]},{"content":"To inspect a component","pos":[25386,25408]},{"pos":[25412,25474],"content":"On the menu bar, choose <bpt id=\"p1\">**</bpt>View, Object Browser<ept id=\"p1\">**</ept> (Ctrl+Alt+J)."},{"content":"In the left pane of the Object Browser, expand the WinRT<ph id=\"ph1\">\\_</ph>CPP node to show the types and methods that are defined on your component.","pos":[25476,25608]},{"content":"Debugging tips","pos":[25613,25627]},{"content":"For a better debugging experience, download the debugging symbols from the public Microsoft symbol servers:","pos":[25629,25736]},{"content":"To download debugging symbols","pos":[25743,25772]},{"pos":[25776,25819],"content":"On the menu bar, choose <bpt id=\"p1\">**</bpt>Tools, Options<ept id=\"p1\">**</ept>."},{"pos":[25821,25896],"content":"In the <bpt id=\"p1\">**</bpt>Options<ept id=\"p1\">**</ept> dialog box, expand <bpt id=\"p2\">**</bpt>Debugging<ept id=\"p2\">**</ept> and select <bpt id=\"p3\">**</bpt>Symbols<ept id=\"p3\">**</ept>."},{"pos":[25898,25967],"content":"Select <bpt id=\"p1\">**</bpt>Microsoft Symbol Servers<ept id=\"p1\">**</ept> and the choose the <bpt id=\"p2\">**</bpt>OK<ept id=\"p2\">**</ept> button."},{"content":"It might take some time to download the symbols the first time.","pos":[25969,26032]},{"content":"For faster performance the next time you press F5, specify a local directory in which to cache the symbols.","pos":[26033,26140]},{"content":"When you debug a JavaScript solution that has a component DLL, you can set the debugger to enable either stepping through script or stepping through native code in the component, but not both at the same time.","pos":[26142,26351]},{"content":"To change the setting, open the shortcut menu for the JavaScript project node in Solution Explorer and choose <bpt id=\"p1\">**</bpt>Properties, Debugging, Debugger Type<ept id=\"p1\">**</ept>.","pos":[26352,26503]},{"content":"Be sure to select appropriate capabilities in the package designer.","pos":[26505,26572]},{"content":"You can open the package designer by opening the Package.appxmanifest file.","pos":[26573,26648]},{"content":"For example, if you are attempting to programmatically access files in the Pictures folder, be sure to select the <bpt id=\"p1\">**</bpt>Pictures Library<ept id=\"p1\">**</ept> check box in the <bpt id=\"p2\">**</bpt>Capabilities<ept id=\"p2\">**</ept> pane of the package designer.","pos":[26649,26847]},{"content":"If your JavaScript code doesn't recognize the public properties or methods in the component, make sure that in JavaScript you are using camel casing.","pos":[26849,26998]},{"content":"For example, the <ph id=\"ph1\">`ComputeResult`</ph> C++ method must be referenced as <ph id=\"ph2\">`computeResult`</ph> in JavaScript.","pos":[26999,27095]},{"content":"If you remove a C++ Windows Runtime Component project from a solution, you must also manually remove the project reference from the JavaScript project.","pos":[27097,27248]},{"content":"Failure to do so prevents subsequent debug or build operations.","pos":[27249,27312]},{"content":"If necessary, you can then add an assembly reference to the DLL.","pos":[27313,27377]},{"content":"Related topics","pos":[27382,27396]},{"content":"Creating Windows Runtime Components in C++","pos":[27401,27443]}],"content":"---\nauthor: msatranjr\ntitle: Creating a basic Windows Runtime component in C++ and calling it from JavaScript or C#\ndescription: This walkthrough shows how to create a basic Windows Runtime Component DLL that's callable from JavaScript, C#, or Visual Basic.\nms.assetid: 764CD9C6-3565-4DFF-88D7-D92185C7E452\n---\n\n<h1>Walkthrough: Creating a Windows Runtime component in C++ and calling it from JavaScript or C#</h1>\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nThis walkthrough shows how to create a basic Windows Runtime Component DLL that's callable from JavaScript, C#, or Visual Basic. Before you begin this walkthrough, make sure that you understand concepts such as the Abstract Binary Interface (ABI), ref classes, and the Visual C++ Component Extensions that make working with ref classes easier. For more information, see [Creating Windows Runtime Components in C++](creating-windows-runtime-components-in-cpp.md) and [Visual C++ Language Reference (C++/CX)](https://msdn.microsoft.com/library/windows/apps/xaml/hh699871.aspx).\n\n## Creating the C++ component DLL\n\nIn this example, we create the component project first, but you could create the JavaScript project first. The order doesn’t matter.\n\nNotice that the main class of the component contains examples of property and method definitions, and an event declaration. These are provided just to show you how it's done. They are not required, and in this example, we'll replace all of the generated code with our own code.\n\n## **To create the C++ component project**\n\nOn the Visual Studio menu bar, choose **File, New, Project**.\n\nIn the **New Project** dialog box, in the left pane, expand **Visual C++** and then select the node for Universal Windows apps.\n\nIn the center pane, select **Windows Runtime Component** and then name the project WinRT\\_CPP.\n\nChoose the **OK** button.\n\n## **To add an activatable class to the component**\n\nAn activatable class is one that client code can create by using a **new** expression (**New** in Visual Basic, or **ref new** in C++). In your component, you declare it as **public ref class sealed**. In fact, the Class1.h and .cpp files already have a ref class. You can change the name, but in this example we’ll use the default name—Class1. You can define additional ref classes or regular classes in your component if they are required. For more information about ref classes, see [Type System (C++/CX)](https://msdn.microsoft.com/library/windows/apps/hh755822.aspx).\n\nAdd these \\#include directives to Class1.h:\n\n```cpp\n#include <collection.h>\n#include <ppl.h>\n#include <amp.h>\n#include <amp_math.h>\n```\n\ncollection.h is the header file for C++ concrete classes such as the Platform::Collections::Vector class and the Platform::Collections::Map class, which implement language-neutral interfaces that are defined by the Windows Runtime. The amp headers are used to run computations on the GPU. They have no Windows Runtime equivalents, and that’s fine because they are private. In general, for performance reasons you should use ISO C++ code and standard libraries internally within the component; it’s just the Windows Runtime interface that must be expressed in Windows Runtime types.\n\n## To add a delegate at namespace scope\n\nA delegate is a construct that defines the parameters and return type for methods. An event is an instance of a particular delegate type, and any event handler method that subscribes to the event must have the signature that's specified in the delegate. The following code defines a delegate type that takes an int and returns void. Next the code declares a public event of this type; this enables client code to provide methods that are invoked when the event is fired.\n\nAdd the following delegate declaration at namespace scope in Class1.h, just before the Class1 declaration.\n\n```cpp\npublic delegate void PrimeFoundHandler(int result);\n```\n\nIf the code isn’t lining up correctly when you paste it into Visual Studio, just press Ctrl+K+D to fix the indentation for the entire file.\n\n## To add the public members\n\nThe class exposes three public methods and one public event. The first method is synchronous because it always executes very fast. Because the other two methods might take some time, they are asynchronous so that they don’t block the UI thread. These methods return IAsyncOperationWithProgress and IAsyncActionWithProgress. The former defines an async method that returns a result, and the latter defines an async method that returns void. These interfaces also enable client code to receive updates on the progress of the operation.\n\n```cpp\npublic:\n\n        // Synchronous method.\n        Windows::Foundation::Collections::IVector<double>^  ComputeResult(double input);\n\n        // Asynchronous methods\n        Windows::Foundation::IAsyncOperationWithProgress<Windows::Foundation::Collections::IVector<int>^, double>^\n            GetPrimesOrdered(int first, int last);\n        Windows::Foundation::IAsyncActionWithProgress<double>^ GetPrimesUnordered(int first, int last);\n\n        // Event whose type is a delegate \"class\"\n        event PrimeFoundHandler^ primeFoundEvent;\n\n```\n## To add the private members\n\nThe class contains three private members: two helper methods for the numeric computations and a CoreDispatcher object that’s used to marshal the event invocations from worker threads back to the UI thread.\n\n```cpp\nprivate:\n        bool is_prime(int n);\n        Windows::UI::Core::CoreDispatcher^ m_dispatcher;\n```\n\n## To add the header and namespace directives\n\nIn Class1.cpp, add these #include directives:\n\n```cpp\n#include <ppltasks.h>\n#include <concurrent_vector.h>\n```\n\nNow add these using statements to pull in the required namespaces:\n\n```cpp\nusing namespace concurrency;\nusing namespace Platform::Collections;\nusing namespace Windows::Foundation::Collections;\nusing namespace Windows::Foundation;\nusing namespace Windows::UI::Core;\n```\n\n## To add the implementation for ComputeResult\n\nIn Class1.cpp, add the following method implementation. This method executes synchronously on the calling thread, but it is very fast because it uses C++ AMP to parallelize the computation on the GPU. For more information, see C++ AMP Overview. The results are appended to a Platform::Collections::Vector<T> concrete type, which is implicitly converted to a Windows::Foundation::Collections::IVector<T> when it is returned.\n\n```cpp\n//Public API\nIVector<double>^ Class1::ComputeResult(double input)\n{\n    // Implement your function in ISO C++ or\n    // call into your C++ lib or DLL here. This example uses AMP.\n    float numbers[] = { 1.0, 10.0, 60.0, 100.0, 600.0, 10000.0 };\n    array_view<float, 1> logs(6, numbers);\n\n    // See http://msdn.microsoft.com/en-us/library/hh305254.aspx\n    parallel_for_each(\n        logs.extent,\n        [=] (index<1> idx) restrict(amp)\n    {\n        logs[idx] = concurrency::fast_math::log10(logs[idx]);\n    }\n    );\n\n    // Return a Windows Runtime-compatible type across the ABI\n    auto res = ref new Vector<double>();\n    int len = safe_cast<int>(logs.extent.size());\n    for(int i = 0; i < len; i++)\n    {      \n        res->Append(logs[i]);\n    }\n\n    // res is implicitly cast to IVector<double>\n    return res;\n}\n```\n## To add the implementation for GetPrimesOrdered and its helper method\n\nIn Class1.cpp, add the implementations for GetPrimesOrdered and the is_prime helper method. GetPrimesOrdered uses a concurrent_vector class and a parallel_for function loop to divide up the work and use the maximum resources of the computer on which the program is running to produce results. After the results are computed, stored, and sorted, they are added to a Platform::Collections::Vector<T> and returned as Windows::Foundation::Collections::IVector<T> to client code.\n\nNotice the code for the progress reporter, which enables the client to hook up a progress bar or other UI to show the user how much longer the operation is going to take. Progress reporting has a cost. An event must be fired on the component side and handled on the UI thread, and the progress value must be stored on each iteration. One way to minimize the cost is by limiting the frequency at which a progress event is fired. If the cost is still prohibitive, or if you can't estimate the length of the operation, then consider using a progress ring, which shows that an operation is in progress but doesn't show time remaining until completion.\n\n```cpp\n// Determines whether the input value is prime.\nbool Class1::is_prime(int n)\n{\n    if (n < 2)\n        return false;\n    for (int i = 2; i < n; ++i)\n    {\n        if ((n % i) == 0)\n            return false;\n    }\n    return true;\n}\n\n// This method computes all primes, orders them, then returns the ordered results.\nIAsyncOperationWithProgress<IVector<int>^, double>^ Class1::GetPrimesOrdered(int first, int last)\n{\n    return create_async([this, first, last]\n    (progress_reporter<double> reporter) -> IVector<int>^ {\n        // Ensure that the input values are in range.\n        if (first < 0 || last < 0) {\n            throw ref new InvalidArgumentException();\n        }\n        // Perform the computation in parallel.\n        concurrent_vector<int> primes;\n        long operation = 0;\n        long range = last - first + 1;\n        double lastPercent = 0.0;\n\n        parallel_for(first, last + 1, [this, &primes, &operation,\n            range, &lastPercent, reporter](int n) {\n\n                // Increment and store the number of times the parallel\n                // loop has been called on all threads combined. There\n                // is a performance cost to maintaining a count, and\n                // passing the delegate back to the UI thread, but it's\n                // necessary if we want to display a determinate progress\n                // bar that goes from 0 to 100%. We can avoid the cost by\n                // setting the ProgressBar IsDeterminate property to false\n                // or by using a ProgressRing.\n                if(InterlockedIncrement(&operation) % 100 == 0)\n                {\n                    reporter.report(100.0 * operation / range);\n                }\n\n                // If the value is prime, add it to the local vector.\n                if (is_prime(n)) {\n                    primes.push_back(n);\n                }\n        });\n\n        // Sort the results.\n        std::sort(begin(primes), end(primes), std::less<int>());        \n        reporter.report(100.0);\n\n        // Copy the results to a Vector object, which is\n        // implicitly converted to the IVector return type. IVector\n        // makes collections of data available to other\n        // Windows Runtime components.\n        return ref new Vector<int>(primes.begin(), primes.end());\n    });\n}\n```\n\n## To add the implementation for GetPrimesUnordered\n\nThe last step to create the C++ component is to add the implementation for the GetPrimesUnordered in Class1.cpp. This method returns each result as it is found, without waiting until all results are found. Each result is returned in the event handler and displayed on the UI in real time. Again, notice that a progress reporter is used. This method also uses the is_prime helper method.\n\n```cpp\n// This method returns no value. Instead, it fires an event each time a\n// prime is found, and passes the prime through the event.\n// It also passes progress info.\nIAsyncActionWithProgress<double>^ Class1::GetPrimesUnordered(int first, int last)\n{\n\n    auto window = Windows::UI::Core::CoreWindow::GetForCurrentThread();\n    m_dispatcher = window->Dispatcher;\n\n\n    return create_async([this, first, last](progress_reporter<double> reporter) {\n\n        // Ensure that the input values are in range.\n        if (first < 0 || last < 0) {\n            throw ref new InvalidArgumentException();\n        }\n\n        // In this particular example, we don't actually use this to store\n        // results since we pass results one at a time directly back to\n        // UI as they are found. However, we have to provide this variable\n        // as a parameter to parallel_for.\n        concurrent_vector<int> primes;\n        long operation = 0;\n        long range = last - first + 1;\n        double lastPercent = 0.0;\n\n        // Perform the computation in parallel.\n        parallel_for(first, last + 1,\n            [this, &primes, &operation, range, &lastPercent, reporter](int n)\n        {\n            // Store the number of times the parallel loop has been called  \n            // on all threads combined. See comment in previous method.\n            if(InterlockedIncrement(&operation) % 100 == 0)\n            {\n                reporter.report(100.0 * operation / range);\n            }\n\n            // If the value is prime, pass it immediately to the UI thread.\n            if (is_prime(n))\n            {                \n                // Since this code is probably running on a worker\n                // thread, and we are passing the data back to the\n                // UI thread, we have to use a CoreDispatcher object.\n                m_dispatcher->RunAsync( CoreDispatcherPriority::Normal,\n                    ref new DispatchedHandler([this, n, operation, range]()\n                {\n                    this->primeFoundEvent(n);\n\n                }, Platform::CallbackContext::Any));\n\n            }\n        });\n        reporter.report(100.0);\n    });\n}\n```\n\n## Creating a JavaScript client app\n\nIf you just want to create a C# client, you can skip this section.\n\n## To create a JavaScript project\n\nIn Solution Explorer, open the shortcut menu for the Solution node and choose **Add, New Project**.\n\nExpand JavaScript (it might be nested under **Other Languages**) and choose **Blank App (Universal Windows)**.\n\nAccept the default name—App1—by choosing the **OK** button.\n\nOpen the shortcut menu for the App1 project node and choose **Set as Startup Project**.\n\nAdd a project reference to WinRT_CPP:\n\nOpen the shortcut menu for the References node and choose **Add Reference**.\n\nIn the left pane of the References Manager dialog box, select **Projects** and then select **Solution**.\n\nIn the center pane, select WinRT_CPP and then choose the **OK** button\n\n## To add the HTML that invokes the JavaScript event handlers\n\nPaste this HTML into the <body> node of the default.html page:\n\n```HTML\n<div id=\"LogButtonDiv\">\n     <button id=\"logButton\">Logarithms using AMP</button>\n </div>\n <div id=\"LogResultDiv\">\n     <p id=\"logResult\"></p>\n </div>\n <div id=\"OrderedPrimeButtonDiv\">\n     <button id=\"orderedPrimeButton\">Primes using parallel_for with sort</button>\n </div>\n <div id=\"OrderedPrimeProgress\">\n     <progress id=\"OrderedPrimesProgressBar\" value=\"0\" max=\"100\"></progress>\n </div>\n <div id=\"OrderedPrimeResultDiv\">\n     <p id=\"orderedPrimes\">\n         Primes found (ordered):\n     </p>\n </div>\n <div id=\"UnorderedPrimeButtonDiv\">\n     <button id=\"ButtonUnordered\">Primes returned as they are produced.</button>\n </div>\n <div id=\"UnorderedPrimeDiv\">\n     <progress id=\"UnorderedPrimesProgressBar\" value=\"0\" max=\"100\"></progress>\n </div>\n <div id=\"UnorderedPrime\">\n     <p id=\"unorderedPrimes\">\n         Primes found (unordered):\n     </p>\n </div>\n <div id=\"ClearDiv\">\n     <button id=\"Button_Clear\">Clear</button>\n </div>\n```\n\n## To add styles\n\nIn default.css, remove the body style and then add these styles:\n\n```css\n#LogButtonDiv {\nborder: orange solid 1px;\n-ms-grid-row: 1; /* default is 1 */\n-ms-grid-column: 1; /* default is 1 */\n}\n#LogResultDiv {\nbackground: black;\nborder: red solid 1px;\n-ms-grid-row: 1;\n-ms-grid-column: 2;\n}\n#UnorderedPrimeButtonDiv, #OrderedPrimeButtonDiv {\nborder: orange solid 1px;\n-ms-grid-row: 2;   \n-ms-grid-column:1;\n}\n#UnorderedPrimeProgress, #OrderedPrimeProgress {\nborder: red solid 1px;\n-ms-grid-column-span: 2;\nheight: 40px;\n}\n#UnorderedPrimeResult, #OrderedPrimeResult {\nborder: red solid 1px;\nfont-size:smaller;\n-ms-grid-row: 2;\n-ms-grid-column: 3;\n-ms-overflow-style:scrollbar;\n}\n```\n\n## To add the JavaScript event handlers that call into the component DLL\n\nAdd the following functions at the end of the default.js file. These functions are called when the buttons on the main page are chosen. Notice how JavaScript activates the C++ class, and then calls its methods and uses the return values to populate the HTML labels.\n\n```JavaScript\nvar nativeObject = new WinRT_CPP.Class1();\n\nfunction LogButton_Click() {\n\n    var val = nativeObject.computeResult(0);\n    var result = \"\";\n\n    for (i = 0; i < val.length; i++) {\n        result += val[i] + \"<br/>\";\n    }\n\n    document.getElementById('logResult').innerHTML = result;\n}\n\nfunction ButtonOrdered_Click() {\n    document.getElementById('orderedPrimes').innerHTML = \"Primes found (ordered): \";\n\n    nativeObject.getPrimesOrdered(2, 10000).then(\n        function (v) {\n            for (var i = 0; i < v.length; i++)\n                document.getElementById('orderedPrimes').innerHTML += v[i] + \" \";\n        },\n        function (error) {\n            document.getElementById('orderedPrimes').innerHTML += \" \" + error.description;\n        },\n        function (p) {\n            var progressBar = document.getElementById(\"OrderedPrimesProgressBar\");\n            progressBar.value = p;\n        });\n}\n\nfunction ButtonUnordered_Click() {\n    document.getElementById('unorderedPrimes').innerHTML = \"Primes found (unordered): \";\n    nativeObject.onprimefoundevent = handler_unordered;\n\n    nativeObject.getPrimesUnordered(2, 10000).then(\n        function () { },\n        function (error) {\n            document.getElementById(\"unorderedPrimes\").innerHTML += \" \" + error.description;\n        },\n        function (p) {\n            var progressBar = document.getElementById(\"UnorderedPrimesProgressBar\");\n            progressBar.value = p;\n        });\n}\n\nvar handler_unordered = function (n) {\n    document.getElementById('unorderedPrimes').innerHTML += n.target.toString() + \" \";\n};\n\nfunction ButtonClear_Click() {\n\n    document.getElementById('logResult').innerHTML = \"\";\n    document.getElementById(\"unorderedPrimes\").innerHTML = \"\";\n    document.getElementById('orderedPrimes').innerHTML = \"\";\n    document.getElementById(\"UnorderedPrimesProgressBar\").value = 0;\n    document.getElementById(\"OrderedPrimesProgressBar\").value = 0;\n}\n```\n\nAdd code to add the event listeners by replacing the existing call to WinJS.UI.processAll in app.onactivated in default.js with the following code that implements event registration in a then block. For a detailed explanation of this, see Create a \"Hello World\" app (JS).\n\n```JavaScript\nargs.setPromise(WinJS.UI.processAll().then( function completed() {\n    var logButton = document.getElementById(\"logButton\");\n    logButton.addEventListener(\"click\", LogButton_Click, false);\n    var orderedPrimeButton = document.getElementById(\"orderedPrimeButton\");\n    orderedPrimeButton.addEventListener(\"click\", ButtonOrdered_Click, false);\n    var buttonUnordered = document.getElementById(\"ButtonUnordered\");\n    buttonUnordered.addEventListener(\"click\", ButtonUnordered_Click, false);\n    var buttonClear = document.getElementById(\"Button_Clear\");\n    buttonClear.addEventListener(\"click\", ButtonClear_Click, false);\n}));\n```\n\nPress F5 to run the app.\n\n## Creating a C# client app\n\n## To create a C# project\n\nIn Solution Explorer, open the shortcut menu for the Solution node and then choose **Add, New Project**.\n\nExpand Visual C# (it might be nested under **Other Languages**), select **Windows** and then **Universal** in the left pane, and then select **Blank App** in the middle pane.\n\nName this app CS_Client and then choose the **OK** button.\n\nOpen the shortcut menu for the CS_Client project node and choose **Set as Startup Project**.\n\nAdd a project reference to WinRT_CPP:\n\nOpen the shortcut menu for the **References** node and choose **Add Reference**.\n\nIn the left pane of the **References Manager** dialog box, select **Projects** and then select **Solution**.\n\nIn the center pane, select WinRT_CPP and then choose the **OK** button.\n\n## To add the XAML that defines the user interface\n\nCopy the following code into the Grid element in MainPage.xaml.\n\n```xaml\n<ScrollViewer>\n            <StackPanel Width=\"1400\">\n\n                <Button x:Name=\"Button1\" Width=\"340\" Height=\"50\"  Margin=\"0,20,20,20\" Content=\"Synchronous Logarithm Calculation\" FontSize=\"16\" Click=\"Button1_Click_1\"/>\n                <TextBlock x:Name=\"Result1\" Height=\"100\" FontSize=\"14\"></TextBlock>\n            <Button x:Name=\"PrimesOrderedButton\" Content=\"Prime Numbers Ordered\" FontSize=\"16\" Width=\"340\" Height=\"50\" Margin=\"0,20,20,20\" Click=\"PrimesOrderedButton_Click_1\"></Button>\n            <ProgressBar x:Name=\"PrimesOrderedProgress\" IsIndeterminate=\"false\" Height=\"40\"></ProgressBar>\n                <TextBlock x:Name=\"PrimesOrderedResult\" MinHeight=\"100\" FontSize=\"10\" TextWrapping=\"Wrap\"></TextBlock>\n            <Button x:Name=\"PrimesUnOrderedButton\" Width=\"340\" Height=\"50\" Margin=\"0,20,20,20\" Click=\"PrimesUnOrderedButton_Click_1\" Content=\"Prime Numbers Unordered\" FontSize=\"16\"></Button>\n            <ProgressBar x:Name=\"PrimesUnOrderedProgress\" IsIndeterminate=\"false\" Height=\"40\" ></ProgressBar>\n            <TextBlock x:Name=\"PrimesUnOrderedResult\" MinHeight=\"100\" FontSize=\"10\" TextWrapping=\"Wrap\"></TextBlock>\n\n            <Button x:Name=\"Clear_Button\" Content=\"Clear\" HorizontalAlignment=\"Left\" Margin=\"0,20,20,20\" VerticalAlignment=\"Top\" Width=\"341\" Click=\"Clear_Button_Click\" FontSize=\"16\"/>\n        </StackPanel>\n</ScrollViewer>\n```\n\n## To add the event handlers for the buttons\n\nIn Solution Explorer, open MainPage.xaml.cs. (The file might be nested under MainPage.xaml.) Add a using directive for System.Text, and then add the event handler for the Logarithm calculation in the MainPage class.\n\n```csharp\nprivate void Button1_Click_1(object sender, RoutedEventArgs e)\n{\n    // Create the object\n    var nativeObject = new WinRT_CPP.Class1();\n\n    // Call the synchronous method. val is an IList that\n    // contains the results.\n    var val = nativeObject.ComputeResult(0);\n    StringBuilder result = new StringBuilder();\n    foreach (var v in val)\n    {\n        result.Append(v).Append(System.Environment.NewLine);\n    }\n    this.Result1.Text = result.ToString();\n}\n```\n\nAdd the event handler for the ordered result:\n\n```csharp\nasync private void PrimesOrderedButton_Click_1(object sender, RoutedEventArgs e)\n{\n    var nativeObject = new WinRT_CPP.Class1();\n\n    StringBuilder sb = new StringBuilder();\n    sb.Append(\"Primes found (ordered): \");\n\n    PrimesOrderedResult.Text = sb.ToString();\n\n    // Call the asynchronous method\n    var asyncOp = nativeObject.GetPrimesOrdered(2, 100000);\n\n    // Before awaiting, provide a lambda or named method\n    // to handle the Progress event that is fired at regular\n    // intervals by the asyncOp object. This handler updates\n    // the progress bar in the UI.\n    asyncOp.Progress = (asyncInfo, progress) =>\n        {\n            PrimesOrderedProgress.Value = progress;\n        };\n\n    // Wait for the operation to complete\n    var asyncResult = await asyncOp;\n\n    // Convert the results to strings\n    foreach (var result in asyncResult)\n    {\n        sb.Append(result).Append(\" \");\n    }\n\n    // Display the results\n    PrimesOrderedResult.Text = sb.ToString();\n}\n```\n\nAdd the event handler for the unordered result, and for the button that clears the results so that you can run the code again.\n\n```csharp\nprivate void PrimesUnOrderedButton_Click_1(object sender, RoutedEventArgs e)\n{\n    var nativeObject = new WinRT_CPP.Class1();\n\n    StringBuilder sb = new StringBuilder();\n    sb.Append(\"Primes found (unordered): \");\n    PrimesUnOrderedResult.Text = sb.ToString();\n\n    // primeFoundEvent is a user-defined event in nativeObject\n    // It passes the results back to this thread as they are produced\n    // and the event handler that we define here immediately displays them.\n    nativeObject.primeFoundEvent += (n) =>\n    {\n        sb.Append(n.ToString()).Append(\" \");\n        PrimesUnOrderedResult.Text = sb.ToString();\n    };\n\n    // Call the async method.\n    var asyncResult = nativeObject.GetPrimesUnordered(2, 100000);\n\n    // Provide a handler for the Progress event that the asyncResult\n    // object fires at regular intervals. This handler updates the progress bar.\n    asyncResult.Progress += (asyncInfo, progress) =>\n        {\n            PrimesUnOrderedProgress.Value = progress;\n        };\n}\n\nprivate void Clear_Button_Click(object sender, RoutedEventArgs e)\n{\n    PrimesOrderedProgress.Value = 0;\n    PrimesUnOrderedProgress.Value = 0;\n    PrimesUnOrderedResult.Text = \"\";\n    PrimesOrderedResult.Text = \"\";\n    Result1.Text = \"\";\n}\n```\n\n## Running the app\n\nSelect either the C# project or JavaScript project as the startup project by opening the shortcut menu for the project node in Solution Explorer and choosing **Set As Startup Project**. Then press F5 to run with debugging, or Ctrl+F5 to run without debugging.\n\n## Inspecting your component in Object Browser (optional)\n\nIn Object Browser, you can inspect all Windows Runtime types that are defined in .winmd files. This includes the types in the Platform namespace and the default namespace. However, because the types in the Platform::Collections namespace are defined in the header file collections.h, not in a winmd file, they don’t appear in Object Browser.\n\n## **To inspect a component**\n\nOn the menu bar, choose **View, Object Browser** (Ctrl+Alt+J).\n\nIn the left pane of the Object Browser, expand the WinRT\\_CPP node to show the types and methods that are defined on your component.\n\n## Debugging tips\n\nFor a better debugging experience, download the debugging symbols from the public Microsoft symbol servers:\n\n## **To download debugging symbols**\n\nOn the menu bar, choose **Tools, Options**.\n\nIn the **Options** dialog box, expand **Debugging** and select **Symbols**.\n\nSelect **Microsoft Symbol Servers** and the choose the **OK** button.\n\nIt might take some time to download the symbols the first time. For faster performance the next time you press F5, specify a local directory in which to cache the symbols.\n\nWhen you debug a JavaScript solution that has a component DLL, you can set the debugger to enable either stepping through script or stepping through native code in the component, but not both at the same time. To change the setting, open the shortcut menu for the JavaScript project node in Solution Explorer and choose **Properties, Debugging, Debugger Type**.\n\nBe sure to select appropriate capabilities in the package designer. You can open the package designer by opening the Package.appxmanifest file. For example, if you are attempting to programmatically access files in the Pictures folder, be sure to select the **Pictures Library** check box in the **Capabilities** pane of the package designer.\n\nIf your JavaScript code doesn't recognize the public properties or methods in the component, make sure that in JavaScript you are using camel casing. For example, the `ComputeResult` C++ method must be referenced as `computeResult` in JavaScript.\n\nIf you remove a C++ Windows Runtime Component project from a solution, you must also manually remove the project reference from the JavaScript project. Failure to do so prevents subsequent debug or build operations. If necessary, you can then add an assembly reference to the DLL.\n\n## Related topics\n\n* [Creating Windows Runtime Components in C++](creating-windows-runtime-components-in-cpp.md)\n"}