{"nodes":[{"content":"Compare the OpenGL ES 2.0 shader pipeline to Direct3D","pos":[27,80]},{"content":"Conceptually, the Direct3D 11 shader pipeline is very similar to the one in OpenGL ES 2.0.","pos":[94,184]},{"content":"Compare the OpenGL ES 2.0 shader pipeline to Direct3D","pos":[241,294]},{"content":"Updated for UWP apps on Windows 10.","pos":[300,335]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[336,428]},{"content":"Important APIs","pos":[436,450]},{"content":"Input-Assembler Stage","pos":[459,480]},{"content":"Vertex-Shader Stage","pos":[548,567]},{"content":"Pixel-Shader Stage","pos":[655,673]},{"content":"Conceptually, the Direct3D 11 shader pipeline is very similar to the one in OpenGL ES 2.0.","pos":[756,846]},{"content":"In terms of API design, however, the major components for creating and managing the shader stages are parts of two primary interfaces, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept>.","pos":[847,1155]},{"content":"This topic attempts to map common OpenGL ES 2.0 shader pipeline API patterns to the Direct3D 11 equivalents in these interfaces.","pos":[1156,1284]},{"content":"Reviewing the Direct3D 11 shader pipeline","pos":[1289,1330]},{"pos":[1333,1689],"content":"The shader objects are created with methods on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> interface, such as <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device1::CreateVertexShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ID3D11Device1::CreatePixelShader<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</ept>."},{"pos":[1691,1884],"content":"The Direct3D 11 graphics pipeline is managed by instances of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> interface, and has the following stages:"},{"content":"<bpt id=\"p1\">[</bpt>Input-Assembler Stage<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205116)</ept>.","pos":[1890,1975]},{"content":"The input-assembler stage supplies data (triangles, lines and points) to the pipeline.","pos":[1976,2062]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> methods that support this stage are prefixed with \"IA\".","pos":[2063,2206]},{"content":"<bpt id=\"p1\">[</bpt>Vertex-Shader Stage<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205146#Vertex_Shader_Stage)</ept> - The vertex-shader stage processes vertices, typically performing operations such as transformations, skinning, and lighting.","pos":[2211,2440]},{"content":"A vertex shader always takes a single input vertex and produces a single output vertex.","pos":[2441,2528]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> methods that support this stage are prefixed with \"VS\".","pos":[2529,2672]},{"content":"<bpt id=\"p1\">[</bpt>Stream-Output Stage<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205121)</ept> - The stream-output stage streams primitive data from the pipeline to memory on its way to the rasterizer.","pos":[2677,2866]},{"content":"Data can be streamed out and/or passed into the rasterizer.","pos":[2867,2926]},{"content":"Data streamed out to memory can be recirculated back into the pipeline as input data or read-back from the CPU.","pos":[2927,3038]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> methods that support this stage are prefixed with \"SO\".","pos":[3039,3182]},{"content":"<bpt id=\"p1\">[</bpt>Rasterizer Stage<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205125)</ept> - The rasterizer clips primitives, prepares primitives for the pixel shader, and determines how to invoke pixel shaders.","pos":[3187,3387]},{"content":"You can disable rasterization by telling the pipeline there is no pixel shader (set the pixel shader stage to NULL with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::PSSetShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept>), and disabling depth and stencil testing (set DepthEnable and StencilEnable to FALSE in <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>DEPTH<ph id=\"ph2\">\\_</ph>STENCIL<ph id=\"ph3\">\\_</ph>DESC<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476110)</ept>).","pos":[3388,3793]},{"content":"While disabled, rasterization-related pipeline counters will not update.","pos":[3794,3866]},{"content":"<bpt id=\"p1\">[</bpt>Pixel-Shader Stage<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205146#Pixel_Shader_Stage)</ept> - The pixel-shader stage receives interpolated data for a primitive and generates per-pixel data such as color.","pos":[3871,4083]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> methods that support this stage are prefixed with \"PS\".","pos":[4084,4227]},{"content":"<bpt id=\"p1\">[</bpt>Output-Merger Stage<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205120)</ept> - The output-merger stage combines various types of output data (pixel shader values, depth and stencil information) with the contents of the render target and depth/stencil buffers to generate the final pipeline result.","pos":[4232,4535]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> methods that support this stage are prefixed with \"OM\".","pos":[4536,4679]},{"content":"(There are also stages for geometry shaders, hull shaders, tesselators, and domain shaders, but since they have no analogues in OpenGL ES 2.0, we won't discuss them here.) For a complete list of the methods for these stages, refer to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> reference pages.","pos":[4681,5114]},{"content":"<bpt id=\"p1\">**</bpt>ID3D11DeviceContext1<ept id=\"p1\">**</ept> extends <bpt id=\"p2\">**</bpt>ID3D11DeviceContext<ept id=\"p2\">**</ept> for Direct3D 11.","pos":[5115,5188]},{"content":"Creating a shader","pos":[5193,5210]},{"content":"In Direct3D, shader resources are not created before compiling and loading them; rather, the resource is created when the HLSLis loaded.","pos":[5213,5349]},{"content":"Therefore, there is no directly analogous function to glCreateShader, which creates an initialized shader resource of a specific type (such as GL<ph id=\"ph1\">\\_</ph>VERTEX<ph id=\"ph2\">\\_</ph>SHADER or GL<ph id=\"ph3\">\\_</ph>FRAGMENT<ph id=\"ph4\">\\_</ph>SHADER).","pos":[5350,5537]},{"content":"Rather, shaders are created after the HLSL is loaded with specific functions like <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1::CreateVertexShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device1::CreatePixelShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</ept>, and which take the type and the compiled HLSL as parameters.","pos":[5538,5886]},{"content":"OpenGL ES 2.0","pos":[5890,5903]},{"content":"Direct3D 11","pos":[5907,5918]},{"content":"glCreateShader","pos":[6460,6474]},{"pos":[6477,6775],"content":"Call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1::CreateVertexShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device1::CreatePixelShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</ept> after successfully loading the compiled shader object, passing them the CSO as a buffer."},{"content":"Compiling a shader","pos":[6785,6803]},{"content":"Direct3D haders must be precompiled as Compiled Shader Object (.cso) files in Universal Windows Platform (UWP) apps and loaded using one of the Windows Runtime file APIs.","pos":[6806,6976]},{"content":"(Desktop apps can compile the shaders from text files or string at run-time.) The CSO files are built from any .hlsl files that are part of your Microsoft Visual Studio project, and retain the same names, only with a .cso file extension.","pos":[6977,7214]},{"content":"Ensure that they are included with your package when you ship!","pos":[7215,7277]},{"content":"OpenGL ES 2.0","pos":[7281,7294]},{"content":"Direct3D 11","pos":[7322,7333]},{"content":"glCompileShader","pos":[7719,7734]},{"content":"N/A.","pos":[7760,7764]},{"content":"Compile the shaders to .cso files in Visual Studio and include them in your package.","pos":[7765,7849]},{"content":"Using glGetShaderiv for compile status","pos":[7938,7976]},{"content":"N/A.","pos":[7979,7983]},{"content":"See the compilation output from Visual Studio's FX Compiler (FXC) if there are errors in compilation.","pos":[7984,8085]},{"content":"If compilation is successful, a corresponding CSO file is created.","pos":[8086,8152]},{"content":"Loading a shader","pos":[8162,8178]},{"content":"As noted in the section on creating a shader, Direct3D 11 creates the shader when the corresponding CSO file is loaded into a buffer and passed to one of the methods in the following table.","pos":[8181,8370]},{"content":"OpenGL ES 2.0","pos":[8374,8387]},{"content":"Direct3D 11","pos":[8390,8401]},{"content":"ShaderSource","pos":[8874,8886]},{"pos":[8890,9154],"content":"Call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1::CreateVertexShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device1::CreatePixelShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</ept> after successfully loading the compiled shader object."},{"content":"Setting up the pipeline","pos":[9164,9187]},{"content":"OpenGL ES 2.0 has the \"shader program\" object, which contains multiple shaders for execution.","pos":[9190,9283]},{"content":"Individual shaders are attached to the shader program object.","pos":[9284,9345]},{"content":"However, in Direct3D 11, you work with the rendering context (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept>) directly and create shaders on it.","pos":[9346,9531]},{"content":"OpenGL ES 2.0","pos":[9535,9548]},{"content":"Direct3D 11","pos":[9553,9564]},{"content":"glCreateProgram","pos":[9767,9782]},{"content":"N/A.","pos":[9785,9789]},{"content":"Direct3D 11 does not use the shader program object abstraction.","pos":[9790,9853]},{"content":"glLinkProgram","pos":[9883,9896]},{"content":"N/A.","pos":[9901,9905]},{"content":"Direct3D 11 does not use the shader program object abstraction.","pos":[9906,9969]},{"content":"glUseProgram","pos":[9999,10011]},{"content":"N/A.","pos":[10017,10021]},{"content":"Direct3D 11 does not use the shader program object abstraction.","pos":[10022,10085]},{"content":"glGetProgramiv","pos":[10115,10129]},{"pos":[10133,10254],"content":"Use the reference you created to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept>."},{"pos":[10261,10564],"content":"Create an instance of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/dn280493)</ept> with the static <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>D3D11CreateDevice<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept> method."},{"content":"Setting the viewport(s)","pos":[11252,11275]},{"content":"Setting a viewport in Direct3D 11 is very similar to how you set a viewport in OpenGL ES 2.0.","pos":[11278,11371]},{"content":"In Direct3D 11, call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::RSSetViewports<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476480)</ept> with a configured <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>CD3D11<ph id=\"ph1\">\\_</ph>VIEWPORT<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/jj151722)</ept>.","pos":[11372,11598]},{"content":"Direct3D 11: Setting a viewport.","pos":[11600,11632]},{"content":"OpenGL ES 2.0","pos":[11835,11848]},{"content":"Direct3D 11","pos":[11851,11862]},{"content":"glViewport","pos":[12157,12167]},{"pos":[12173,12360],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CD3D11<ph id=\"ph1\">\\_</ph>VIEWPORT<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/jj151722)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::RSSetViewports<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476480)</ept>"},{"content":"Configuring the vertex shaders","pos":[12370,12400]},{"content":"Configuring a vertex shader in Direct3D 11 is done when the shader is loaded.","pos":[12403,12480]},{"content":"Uniforms are passed as constant buffers using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::VSSetConstantBuffers1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446795)</ept>.","pos":[12481,12638]},{"content":"OpenGL ES 2.0","pos":[12642,12655]},{"content":"Direct3D 11","pos":[12677,12688]},{"content":"glAttachShader","pos":[12932,12946]},{"content":"ID3D11Device1::CreateVertexShader","pos":[12970,13003]},{"content":"glGetShaderiv, glGetShaderSource","pos":[13094,13126]},{"content":"ID3D11DeviceContext1::VSGetShader","pos":[13132,13165]},{"content":"glGetUniformfv, glGetUniformiv","pos":[13256,13286]},{"pos":[13291,13402],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::VSGetConstantBuffers1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446793)</ept>."},{"content":"Configuring the pixel shaders","pos":[13412,13441]},{"content":"Configuring a pixel shader in Direct3D 11 is done when the shader is loaded.","pos":[13444,13520]},{"content":"Uniforms are passed as constant buffers using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::PSSetConstantBuffers1.<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404649)</ept>","pos":[13521,13678]},{"content":"OpenGL ES 2.0","pos":[13682,13695]},{"content":"Direct3D 11","pos":[13717,13728]},{"content":"glAttachShader","pos":[13972,13986]},{"content":"ID3D11Device1::CreatePixelShader","pos":[14010,14042]},{"content":"glGetShaderiv, glGetShaderSource","pos":[14135,14167]},{"content":"ID3D11DeviceContext1::PSGetShader","pos":[14173,14206]},{"content":"glGetUniformfv, glGetUniformiv","pos":[14297,14327]},{"pos":[14332,14443],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::PSGetConstantBuffers1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404645)</ept>."},{"content":"Generating the final results","pos":[14453,14481]},{"content":"When the pipeline completes, you draw the results of the shader stages into the back buffer.","pos":[14484,14576]},{"content":"In Direct3D 11, just as it is with Open GL ES 2.0, this involves calling a draw command to output the results as a color map in the back buffer, and thensending that back buffer to the display.","pos":[14577,14770]},{"content":"OpenGL ES 2.0","pos":[14774,14787]},{"content":"Direct3D 11","pos":[14791,14802]},{"content":"glDrawElements","pos":[15304,15318]},{"pos":[15321,15634],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::Draw<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476407)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext1::DrawIndexed<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</ept> (or other Draw<ph id=\"ph1\">\\*</ph> methods on <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ID3D11DeviceContext1<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>)."},{"content":"eglSwapBuffers","pos":[15639,15653]},{"content":"IDXGISwapChain1::Present1","pos":[15659,15684]},{"content":"Porting GLSL to HLSL","pos":[15931,15951]},{"content":"GLSL and HLSL are not very different beyond complex type support and syntax some overall syntax.","pos":[15954,16050]},{"content":"Many developers find it easiest to port between the two by aliasing common OpenGL ES 2.0 instructions and definitions to their HLSL equivalent.","pos":[16051,16194]},{"content":"Note that Direct3D uses the Shader Model version to express the feature set of the HLSL supported by a graphics interface; OpenGL has a different version specification for HLSL.","pos":[16195,16372]},{"content":"The following table attempts to give you some approximate idea of the shader language feature sets defined for Direct3D 11 and OpenGL ES 2.0 in the terms of the other's version.","pos":[16373,16550]},{"content":"Shader language","pos":[16554,16569]},{"content":"GLSL feature version","pos":[16582,16602]},{"content":"Direct3D Shader Model","pos":[16802,16823]},{"content":"Direct3D 11 HLSL","pos":[17102,17118]},{"content":"~4.30.","pos":[17130,17136]},{"content":"SM 5.0","pos":[17350,17356]},{"content":"GLSL ES for OpenGL ES 2.0","pos":[17376,17401]},{"content":"1.40.","pos":[17404,17409]},{"content":"Older implementations of GLSL ES for OpenGL ES 2.0 may use 1.10 through 1.30.","pos":[17410,17487]},{"content":"Check your original code with glGetString(GL<ph id=\"ph1\">\\_</ph>SHADING<ph id=\"ph2\">\\_</ph>LANGUAGE<ph id=\"ph3\">\\_</ph>VERSION) or glGetString(SHADING<ph id=\"ph4\">\\_</ph>LANGUAGE<ph id=\"ph5\">\\_</ph>VERSION) to determine it.","pos":[17488,17621]},{"content":"~SM 2.0","pos":[17624,17631]},{"pos":[17652,17814],"content":"For more details of differences between the two shader languages, as well as common syntax mappings, read the <bpt id=\"p1\">[</bpt>GLSL-to-HLSL reference<ept id=\"p1\">](glsl-to-hlsl-reference.md)</ept>."},{"content":"Porting the OpenGL intrinsics to HLSL semantics","pos":[17819,17866]},{"content":"Direct3D 11 HLSL semantics are strings that, like a uniform or attribute name, are used to identify a value passed between the app and a shader program.","pos":[17869,18021]},{"content":"While they can be any of a variety of possible strings, the best practice is to use a string like POSITION or COLOR that indicates the usage.","pos":[18022,18163]},{"content":"You assign these semantics when you are constructing a constant buffer or buffer input layout.","pos":[18164,18258]},{"content":"You can also append a number between 0 and 7 to the semantic so that you use separate registers for similar values.","pos":[18259,18374]},{"content":"For example: COLOR0, COLOR1, COLOR2...","pos":[18375,18413]},{"content":"Semantics that are prefixed with \"SV<ph id=\"ph1\">\\_</ph>\" are system value semantics that are written to by your shader program; your app itself (running on the CPU) cannot modify them.","pos":[18415,18582]},{"content":"Typically, these contain values that are inputs or outputs from another shader stage in the graphics pipeline, or are generated entirely by the GPU.","pos":[18583,18731]},{"content":"Additionally, SV<ph id=\"ph1\">\\_</ph> semantics have different behaviors when they are used to specify input to or output from a shader stage.","pos":[18733,18856]},{"content":"For example, SV<ph id=\"ph1\">\\_</ph>POSITION (output) contains the vertex data transformed during the vertex shader stage, and SV<ph id=\"ph2\">\\_</ph>POSITION (input) contains the pixel position values interpolated during rasterization.","pos":[18857,19055]},{"content":"Here are a few mappings for common OpenGL ES 2.0 shader instrinsics:","pos":[19057,19125]},{"content":"OpenGL system value","pos":[19129,19148]},{"content":"Use this HLSL Semantic","pos":[19151,19173]},{"content":"gl<ph id=\"ph1\">\\_</ph>Position","pos":[19519,19531]},{"content":"POSITION(n) for vertex buffer data.","pos":[19541,19576]},{"content":"SV<ph id=\"ph1\">\\_</ph>POSITION provides a pixel position to the pixel shader and cannot be written by your app.","pos":[19577,19670]},{"content":"gl<ph id=\"ph1\">\\_</ph>Normal","pos":[19714,19724]},{"content":"NORMAL(n) for normal data provided by the vertex buffer.","pos":[19736,19792]},{"content":"gl<ph id=\"ph1\">\\_</ph>TexCoord<ph id=\"ph2\">\\[</ph>n","pos":[19909,19924]},{"content":"TEXCOORD(n) for texture UV (ST in some OpenGL documentation) coordinate data supplied to a shader.","pos":[19931,20029]},{"content":"gl<ph id=\"ph1\">\\_</ph>FragColor","pos":[20104,20117]},{"content":"COLOR(n) for RGBA color data supplied to a shader.","pos":[20126,20176]},{"content":"Note that it is treated identically to coordinate data; the semantic simply helps you identify that it is color data.","pos":[20177,20294]},{"content":"gl<ph id=\"ph1\">\\_</ph>FragData<ph id=\"ph2\">\\[</ph>n","pos":[20299,20314]},{"content":"SV<ph id=\"ph1\">\\_</ph>Target<ph id=\"ph2\">\\[</ph>n<ph id=\"ph3\">\\]</ph> for writing from a pixel shader to a target texture or other pixel buffer.","pos":[20321,20411]},{"content":"The method by which you code for semantics is not the same as using intrinsics in OpenGL ES 2.0.","pos":[20496,20592]},{"content":"In OpenGL, you can access many of the intrinsics directly without any configuration or declaration; in Direct3D, you must declare a field in a specific constant buffer to use a particular semantic, or you declare it as the return value for a shader's <bpt id=\"p1\">**</bpt>main()<ept id=\"p1\">**</ept> method.","pos":[20593,20862]},{"content":"Here's an example of a semantic used in a constant buffer definition:","pos":[20864,20933]},{"content":"This code defines a pair of simple constant buffers","pos":[21261,21312]},{"content":"And here's an example of a semantic used to define the value returned by a fragment shader:","pos":[21314,21405]},{"content":"In this case, SV<ph id=\"ph1\">\\_</ph>TARGET is the location of the render target that the pixel color (defined as a vector with four float values) is written to when the shader completes execution.","pos":[21559,21737]},{"pos":[21739,21878],"content":"For more details on the use of semantics with Direct3D, read <bpt id=\"p1\">[</bpt>HLSL Semantics<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</ept>."}],"content":"---\nauthor: mtoepke\ntitle: Compare the OpenGL ES 2.0 shader pipeline to Direct3D\ndescription: Conceptually, the Direct3D 11 shader pipeline is very similar to the one in OpenGL ES 2.0.\nms.assetid: 3678a264-e3f9-72d2-be91-f79cd6f7c4ca\n---\n\n# Compare the OpenGL ES 2.0 shader pipeline to Direct3D\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n**Important APIs**\n\n-   [Input-Assembler Stage](https://msdn.microsoft.com/library/windows/desktop/bb205116)\n-   [Vertex-Shader Stage](https://msdn.microsoft.com/library/windows/desktop/bb205146#Vertex_Shader_Stage)\n-   [Pixel-Shader Stage](https://msdn.microsoft.com/library/windows/desktop/bb205146#Pixel_Shader_Stage)\n\nConceptually, the Direct3D 11 shader pipeline is very similar to the one in OpenGL ES 2.0. In terms of API design, however, the major components for creating and managing the shader stages are parts of two primary interfaces, [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) and [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598). This topic attempts to map common OpenGL ES 2.0 shader pipeline API patterns to the Direct3D 11 equivalents in these interfaces.\n\n## Reviewing the Direct3D 11 shader pipeline\n\n\nThe shader objects are created with methods on the [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) interface, such as [**ID3D11Device1::CreateVertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476524) and [**ID3D11Device1::CreatePixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476513).\n\nThe Direct3D 11 graphics pipeline is managed by instances of the [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) interface, and has the following stages:\n\n-   [Input-Assembler Stage](https://msdn.microsoft.com/library/windows/desktop/bb205116). The input-assembler stage supplies data (triangles, lines and points) to the pipeline. [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) methods that support this stage are prefixed with \"IA\".\n-   [Vertex-Shader Stage](https://msdn.microsoft.com/library/windows/desktop/bb205146#Vertex_Shader_Stage) - The vertex-shader stage processes vertices, typically performing operations such as transformations, skinning, and lighting. A vertex shader always takes a single input vertex and produces a single output vertex. [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) methods that support this stage are prefixed with \"VS\".\n-   [Stream-Output Stage](https://msdn.microsoft.com/library/windows/desktop/bb205121) - The stream-output stage streams primitive data from the pipeline to memory on its way to the rasterizer. Data can be streamed out and/or passed into the rasterizer. Data streamed out to memory can be recirculated back into the pipeline as input data or read-back from the CPU. [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) methods that support this stage are prefixed with \"SO\".\n-   [Rasterizer Stage](https://msdn.microsoft.com/library/windows/desktop/bb205125) - The rasterizer clips primitives, prepares primitives for the pixel shader, and determines how to invoke pixel shaders. You can disable rasterization by telling the pipeline there is no pixel shader (set the pixel shader stage to NULL with [**ID3D11DeviceContext::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472)), and disabling depth and stencil testing (set DepthEnable and StencilEnable to FALSE in [**D3D11\\_DEPTH\\_STENCIL\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476110)). While disabled, rasterization-related pipeline counters will not update.\n-   [Pixel-Shader Stage](https://msdn.microsoft.com/library/windows/desktop/bb205146#Pixel_Shader_Stage) - The pixel-shader stage receives interpolated data for a primitive and generates per-pixel data such as color. [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) methods that support this stage are prefixed with \"PS\".\n-   [Output-Merger Stage](https://msdn.microsoft.com/library/windows/desktop/bb205120) - The output-merger stage combines various types of output data (pixel shader values, depth and stencil information) with the contents of the render target and depth/stencil buffers to generate the final pipeline result. [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) methods that support this stage are prefixed with \"OM\".\n\n(There are also stages for geometry shaders, hull shaders, tesselators, and domain shaders, but since they have no analogues in OpenGL ES 2.0, we won't discuss them here.)\nFor a complete list of the methods for these stages, refer to the [**ID3D11DeviceContext**](https://msdn.microsoft.com/library/windows/desktop/ff476385) and [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) reference pages. **ID3D11DeviceContext1** extends **ID3D11DeviceContext** for Direct3D 11.\n\n## Creating a shader\n\n\nIn Direct3D, shader resources are not created before compiling and loading them; rather, the resource is created when the HLSLis loaded. Therefore, there is no directly analogous function to glCreateShader, which creates an initialized shader resource of a specific type (such as GL\\_VERTEX\\_SHADER or GL\\_FRAGMENT\\_SHADER). Rather, shaders are created after the HLSL is loaded with specific functions like [**ID3D11Device1::CreateVertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476524) and [**ID3D11Device1::CreatePixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476513), and which take the type and the compiled HLSL as parameters.\n\n| OpenGL ES 2.0  | Direct3D 11                                                                                                                                                                                                                                                             |\n|----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| glCreateShader | Call [**ID3D11Device1::CreateVertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476524) and [**ID3D11Device1::CreatePixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476513) after successfully loading the compiled shader object, passing them the CSO as a buffer. |\n\n \n\n## Compiling a shader\n\n\nDirect3D haders must be precompiled as Compiled Shader Object (.cso) files in Universal Windows Platform (UWP) apps and loaded using one of the Windows Runtime file APIs. (Desktop apps can compile the shaders from text files or string at run-time.) The CSO files are built from any .hlsl files that are part of your Microsoft Visual Studio project, and retain the same names, only with a .cso file extension. Ensure that they are included with your package when you ship!\n\n| OpenGL ES 2.0                          | Direct3D 11                                                                                                                                                                   |\n|----------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| glCompileShader                        | N/A. Compile the shaders to .cso files in Visual Studio and include them in your package.                                                                                     |\n| Using glGetShaderiv for compile status | N/A. See the compilation output from Visual Studio's FX Compiler (FXC) if there are errors in compilation. If compilation is successful, a corresponding CSO file is created. |\n\n \n\n## Loading a shader\n\n\nAs noted in the section on creating a shader, Direct3D 11 creates the shader when the corresponding CSO file is loaded into a buffer and passed to one of the methods in the following table.\n\n| OpenGL ES 2.0 | Direct3D 11                                                                                                                                                                                                                           |\n|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| ShaderSource  | Call [**ID3D11Device1::CreateVertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476524) and [**ID3D11Device1::CreatePixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476513) after successfully loading the compiled shader object. |\n\n \n\n## Setting up the pipeline\n\n\nOpenGL ES 2.0 has the \"shader program\" object, which contains multiple shaders for execution. Individual shaders are attached to the shader program object. However, in Direct3D 11, you work with the rendering context ([**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598)) directly and create shaders on it.\n\n| OpenGL ES 2.0   | Direct3D 11                                                                                   |\n|-----------------|-----------------------------------------------------------------------------------------------|\n| glCreateProgram | N/A. Direct3D 11 does not use the shader program object abstraction.                          |\n| glLinkProgram   | N/A. Direct3D 11 does not use the shader program object abstraction.                          |\n| glUseProgram    | N/A. Direct3D 11 does not use the shader program object abstraction.                          |\n| glGetProgramiv  | Use the reference you created to [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598). |\n\n \n\nCreate an instance of [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) and [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/dn280493) with the static [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) method.\n\n``` syntax\nMicrosoft::WRL::ComPtr<ID3D11Device1>          m_d3dDevice;\nMicrosoft::WRL::ComPtr<ID3D11DeviceContext1>  m_d3dContext;\n\n// ...\n\nD3D11CreateDevice(\n  nullptr, // Specify nullptr to use the default adapter.\n  D3D_DRIVER_TYPE_HARDWARE,\n  nullptr,\n  creationFlags, // Set set debug and Direct2D compatibility flags.\n  featureLevels, // List of feature levels this app can support.\n  ARRAYSIZE(featureLevels),\n  D3D11_SDK_VERSION, // Always set this to D3D11_SDK_VERSION for Windows Store apps.\n  &device, // Returns the Direct3D device created.\n  &m_featureLevel, // Returns feature level of device created.\n  &m_d3dContext // Returns the device's immediate context.\n);\n```\n\n## Setting the viewport(s)\n\n\nSetting a viewport in Direct3D 11 is very similar to how you set a viewport in OpenGL ES 2.0. In Direct3D 11, call [**ID3D11DeviceContext::RSSetViewports**](https://msdn.microsoft.com/library/windows/desktop/ff476480) with a configured [**CD3D11\\_VIEWPORT**](https://msdn.microsoft.com/library/windows/desktop/jj151722).\n\nDirect3D 11: Setting a viewport.\n\n``` syntax\nCD3D11_VIEWPORT viewport(\n        0.0f,\n        0.0f,\n        m_d3dRenderTargetSize.Width,\n        m_d3dRenderTargetSize.Height\n        );\nm_d3dContext->RSSetViewports(1, &viewport);\n```\n\n| OpenGL ES 2.0 | Direct3D 11                                                                                                                                  |\n|---------------|----------------------------------------------------------------------------------------------------------------------------------------------|\n| glViewport    | [**CD3D11\\_VIEWPORT**](https://msdn.microsoft.com/library/windows/desktop/jj151722), [**ID3D11DeviceContext::RSSetViewports**](https://msdn.microsoft.com/library/windows/desktop/ff476480) |\n\n \n\n## Configuring the vertex shaders\n\n\nConfiguring a vertex shader in Direct3D 11 is done when the shader is loaded. Uniforms are passed as constant buffers using [**ID3D11DeviceContext1::VSSetConstantBuffers1**](https://msdn.microsoft.com/library/windows/desktop/hh446795).\n\n| OpenGL ES 2.0                    | Direct3D 11                                                                                               |\n|----------------------------------|-----------------------------------------------------------------------------------------------------------|\n| glAttachShader                   | [**ID3D11Device1::CreateVertexShader**](https://msdn.microsoft.com/library/windows/desktop/ff476524)                       |\n| glGetShaderiv, glGetShaderSource | [**ID3D11DeviceContext1::VSGetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476489)                       |\n| glGetUniformfv, glGetUniformiv   | [**ID3D11DeviceContext1::VSGetConstantBuffers1**](https://msdn.microsoft.com/library/windows/desktop/hh446793). |\n\n \n\n## Configuring the pixel shaders\n\n\nConfiguring a pixel shader in Direct3D 11 is done when the shader is loaded. Uniforms are passed as constant buffers using [**ID3D11DeviceContext1::PSSetConstantBuffers1.**](https://msdn.microsoft.com/library/windows/desktop/hh404649)\n\n| OpenGL ES 2.0                    | Direct3D 11                                                                                               |\n|----------------------------------|-----------------------------------------------------------------------------------------------------------|\n| glAttachShader                   | [**ID3D11Device1::CreatePixelShader**](https://msdn.microsoft.com/library/windows/desktop/ff476513)                         |\n| glGetShaderiv, glGetShaderSource | [**ID3D11DeviceContext1::PSGetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476468)                       |\n| glGetUniformfv, glGetUniformiv   | [**ID3D11DeviceContext1::PSGetConstantBuffers1**](https://msdn.microsoft.com/library/windows/desktop/hh404645). |\n\n \n\n## Generating the final results\n\n\nWhen the pipeline completes, you draw the results of the shader stages into the back buffer. In Direct3D 11, just as it is with Open GL ES 2.0, this involves calling a draw command to output the results as a color map in the back buffer, and thensending that back buffer to the display.\n\n| OpenGL ES 2.0  | Direct3D 11                                                                                                                                                                                                                                         |\n|----------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| glDrawElements | [**ID3D11DeviceContext1::Draw**](https://msdn.microsoft.com/library/windows/desktop/ff476407), [**ID3D11DeviceContext1::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476409) (or other Draw\\* methods on [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/ff476385)). |\n| eglSwapBuffers | [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797)                                                                                                                                                                              |\n\n \n\n## Porting GLSL to HLSL\n\n\nGLSL and HLSL are not very different beyond complex type support and syntax some overall syntax. Many developers find it easiest to port between the two by aliasing common OpenGL ES 2.0 instructions and definitions to their HLSL equivalent. Note that Direct3D uses the Shader Model version to express the feature set of the HLSL supported by a graphics interface; OpenGL has a different version specification for HLSL. The following table attempts to give you some approximate idea of the shader language feature sets defined for Direct3D 11 and OpenGL ES 2.0 in the terms of the other's version.\n\n| Shader language           | GLSL feature version                                                                                                                                                                                                      | Direct3D Shader Model |\n|---------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------|\n| Direct3D 11 HLSL          | ~4.30.                                                                                                                                                                                                                    | SM 5.0                |\n| GLSL ES for OpenGL ES 2.0 | 1.40. Older implementations of GLSL ES for OpenGL ES 2.0 may use 1.10 through 1.30. Check your original code with glGetString(GL\\_SHADING\\_LANGUAGE\\_VERSION) or glGetString(SHADING\\_LANGUAGE\\_VERSION) to determine it. | ~SM 2.0               |\n\n \n\nFor more details of differences between the two shader languages, as well as common syntax mappings, read the [GLSL-to-HLSL reference](glsl-to-hlsl-reference.md).\n\n## Porting the OpenGL intrinsics to HLSL semantics\n\n\nDirect3D 11 HLSL semantics are strings that, like a uniform or attribute name, are used to identify a value passed between the app and a shader program. While they can be any of a variety of possible strings, the best practice is to use a string like POSITION or COLOR that indicates the usage. You assign these semantics when you are constructing a constant buffer or buffer input layout. You can also append a number between 0 and 7 to the semantic so that you use separate registers for similar values. For example: COLOR0, COLOR1, COLOR2...\n\nSemantics that are prefixed with \"SV\\_\" are system value semantics that are written to by your shader program; your app itself (running on the CPU) cannot modify them. Typically, these contain values that are inputs or outputs from another shader stage in the graphics pipeline, or are generated entirely by the GPU.\n\nAdditionally, SV\\_ semantics have different behaviors when they are used to specify input to or output from a shader stage. For example, SV\\_POSITION (output) contains the vertex data transformed during the vertex shader stage, and SV\\_POSITION (input) contains the pixel position values interpolated during rasterization.\n\nHere are a few mappings for common OpenGL ES 2.0 shader instrinsics:\n\n| OpenGL system value | Use this HLSL Semantic                                                                                                                                                   |\n|---------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| gl\\_Position        | POSITION(n) for vertex buffer data. SV\\_POSITION provides a pixel position to the pixel shader and cannot be written by your app.                                        |\n| gl\\_Normal          | NORMAL(n) for normal data provided by the vertex buffer.                                                                                                                 |\n| gl\\_TexCoord\\[n\\]   | TEXCOORD(n) for texture UV (ST in some OpenGL documentation) coordinate data supplied to a shader.                                                                       |\n| gl\\_FragColor       | COLOR(n) for RGBA color data supplied to a shader. Note that it is treated identically to coordinate data; the semantic simply helps you identify that it is color data. |\n| gl\\_FragData\\[n\\]   | SV\\_Target\\[n\\] for writing from a pixel shader to a target texture or other pixel buffer.                                                                               |\n\n \n\nThe method by which you code for semantics is not the same as using intrinsics in OpenGL ES 2.0. In OpenGL, you can access many of the intrinsics directly without any configuration or declaration; in Direct3D, you must declare a field in a specific constant buffer to use a particular semantic, or you declare it as the return value for a shader's **main()** method.\n\nHere's an example of a semantic used in a constant buffer definition:\n\n```cpp\nstruct VertexShaderInput\n{\n  float3 pos : POSITION;\n  float3 color : COLOR0;\n};\n\n// The position is interpolated to the pixel value by the system. The per-vertex color data is also interpolated and passed through the pixel shader. \nstruct PixelShaderInput\n{\n  float4 pos : SV_POSITION;\n  float3 color : COLOR0;\n};\n```\n\nThis code defines a pair of simple constant buffers\n\nAnd here's an example of a semantic used to define the value returned by a fragment shader:\n\n```cpp\n// A pass-through for the (interpolated) color data.\nfloat4 main(PixelShaderInput input) : SV_TARGET\n{\n  return float4(input.color,1.0f);\n}\n```\n\nIn this case, SV\\_TARGET is the location of the render target that the pixel color (defined as a vector with four float values) is written to when the shader completes execution.\n\nFor more details on the use of semantics with Direct3D, read [HLSL Semantics](https://msdn.microsoft.com/library/windows/desktop/bb509647).\n\n \n\n \n\n\n\n\n"}