{"nodes":[{"content":"Port the GLSL","pos":[27,40]},{"content":"Once you've moved over the code that creates and configures your buffers and shader objects, it's time to port the code inside those shaders from OpenGL ES 2.0's GL Shader Language (GLSL) to Direct3D 11's High-level Shader Language (HLSL).","pos":[54,293]},{"content":"Port the GLSL","pos":[350,363]},{"content":"Updated for UWP apps on Windows 10.","pos":[369,404]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[405,497]},{"content":"Important APIs","pos":[505,519]},{"content":"HLSL Semantics","pos":[528,542]},{"content":"Shader Constants (HLSL)","pos":[610,633]},{"content":"Once you've moved over the code that creates and configures your buffers and shader objects, it's time to port the code inside those shaders from OpenGL ES 2.0's GL Shader Language (GLSL) to Direct3D 11's High-level Shader Language (HLSL).","pos":[697,936]},{"content":"In OpenGL ES 2.0, shaders return data after execution using intrinsics such as <bpt id=\"p1\">**</bpt>gl<ph id=\"ph1\">\\_</ph>Position<ept id=\"p1\">**</ept>, <bpt id=\"p2\">**</bpt>gl<ph id=\"ph2\">\\_</ph>FragColor<ept id=\"p2\">**</ept>, or <bpt id=\"p3\">**</bpt>gl<ph id=\"ph3\">\\_</ph>FragData<ph id=\"ph4\">\\[</ph>n<ph id=\"ph5\">\\]</ph><ept id=\"p3\">**</ept> (where n is the index for a specific render target).","pos":[938,1131]},{"content":"In Direct3D, there are no specific intrinsics, and the shaders return data as the return type of their respective main() functions.","pos":[1132,1263]},{"content":"Data that you want interpolated between shader stages, such as the vertex position or normal, is handled through the use of the <bpt id=\"p1\">**</bpt>varying<ept id=\"p1\">**</ept> declaration.","pos":[1265,1417]},{"content":"However, Direct3D doesn't have this declaration; rather, any data that you want passed between shader stages must be marked with an <bpt id=\"p1\">[</bpt>HLSL semantic<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb205574)</ept>.","pos":[1418,1627]},{"content":"The specific semantic chosen indicates the purpose of the data, and is.","pos":[1628,1699]},{"content":"For example, you'd declare vertex data that you want interpolated between the fragment shader as:","pos":[1700,1797]},{"content":"or","pos":[1829,1831]},{"content":"Where POSITION is the semantic used to indicate vertex position data.","pos":[1862,1931]},{"content":"POSITION is also a special case, since after interpolation, it cannot be accessed by the pixel shader.","pos":[1932,2034]},{"content":"Therefore, you must specify input to the pixel shader with SV<ph id=\"ph1\">\\_</ph>POSITION and the interpolated vertex data will be placed in that variable.","pos":[2035,2172]},{"content":"Semantics can be declared on the body (main) methods of shaders.","pos":[2208,2272]},{"content":"For pixel shaders, SV<ph id=\"ph1\">\\_</ph>TARGET<ph id=\"ph2\">\\[</ph>n<ph id=\"ph3\">\\]</ph>, which indicates a render target, is required on the body method.","pos":[2273,2373]},{"content":"(SV<ph id=\"ph1\">\\_</ph>TARGET without a numeric suffix defaults to render target index 0.)","pos":[2374,2446]},{"content":"Also note that vertex shaders are required to output the SV<ph id=\"ph1\">\\_</ph>POSITION system value semantic.","pos":[2448,2540]},{"content":"This semantic resolves the vertex position data to coordinate values where x is between -1 and 1, y is between -1 and 1, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).","pos":[2541,2778]},{"content":"Pixel shaders use the SV<ph id=\"ph1\">\\_</ph>POSITION system value semantic to retrieve the pixel location on the screen, where x is between 0 and the render target width and y is between 0 and the render target height (each offset by 0.5).","pos":[2779,3000]},{"content":"Feature level 9<ph id=\"ph1\">\\_</ph>x pixel shaders cannot read from the SV<ph id=\"ph2\">\\_</ph>POSITION value.","pos":[3001,3074]},{"pos":[3076,3190],"content":"Constant buffers must be declared with <bpt id=\"p1\">**</bpt>cbuffer<ept id=\"p1\">**</ept> and be associated with a specific starting register for lookup."},{"content":"Direct3D 11: An HLSL constant buffer declaration","pos":[3192,3240]},{"content":"Here, the constant buffer uses register b0 to hold the packed buffer.","pos":[3334,3403]},{"content":"All registers are referred to in the form b<ph id=\"ph1\">\\#</ph>.","pos":[3404,3450]},{"content":"For more information on the HLSL implementation of constant buffers, registers, and data packing, read <bpt id=\"p1\">[</bpt>Shader Constants (HLSL)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509581)</ept>.","pos":[3451,3641]},{"content":"Instructions","pos":[3643,3655]},{"content":"Step 1: Port the vertex shader","pos":[3674,3704]},{"content":"In our simple OpenGL ES 2.0 example, the vertex shader has three inputs: a constant model-view-projection 4x4 matrix, and two 4-coordinate vectors.","pos":[3706,3853]},{"content":"These two vectors contain the vertex position and its color.","pos":[3854,3914]},{"content":"The shader transforms the position vector to perspective coordinates and assigns it to the gl<ph id=\"ph1\">\\_</ph>Position intrinsic for rasterization.","pos":[3915,4047]},{"content":"The vertex color is copied to a varying variable for interpolation during rasterization, as well.","pos":[4048,4145]},{"content":"OpenGL ES 2.0: Vertex shader for the cube object (GLSL)","pos":[4147,4202]},{"content":"Now, in Direct3D, the constant model-view-projection matrix is contained in a constant buffer packed at register b0, and the vertex position and color are specifically marked with the appropriate respective HLSL semantics: POSITION and COLOR.","pos":[4415,4657]},{"content":"Since our input layout indicates a specific arrangement of these two vertex values, you create a struct to hold them and declare it as the type for the input parameter on the shader body function (main).","pos":[4658,4861]},{"content":"(You could also specify them as two individual parameters, but that could get cumbersome.) You also specify an output type for this stage, which contains the interpolated position and color, and declare it as the return value for the body function of the vertex shader.","pos":[4862,5131]},{"content":"Direct3D 11: Vertex shader for the cube object (HLSL)","pos":[5133,5186]},{"content":"The output data type, PixelShaderInput, is populated during rasterization and provided to the fragment (pixel) shader.","pos":[5798,5916]},{"content":"Step 2: Port the fragment shader","pos":[5922,5954]},{"content":"Our example fragment shader in GLSL is extremely simple: provide the gl<ph id=\"ph1\">\\_</ph>FragColor intrinsic with the interpolated color value.","pos":[5956,6083]},{"content":"OpenGL ES 2.0 will write it to the default render target.","pos":[6084,6141]},{"content":"OpenGL ES 2.0: Fragment shader for the cube object (GLSL)","pos":[6143,6200]},{"content":"Direct3D is almost as simple.","pos":[6288,6317]},{"content":"The only significant difference is that the body function of the pixel shader must return a value.","pos":[6318,6416]},{"content":"Since the color is a 4-coordinate (RGBA) float value, you indicate float4 as the return type, and then specify the default render target as the SV<ph id=\"ph1\">\\_</ph>TARGET system value semantic.","pos":[6417,6594]},{"content":"Direct3D 11: Pixel shader for the cube object (HLSL)","pos":[6596,6648]},{"content":"The color for the pixel at the position is written to the render target.","pos":[6837,6909]},{"content":"Now, let's see how to display the contents of that render target in <bpt id=\"p1\">[</bpt>Draw to the screen<ept id=\"p1\">](draw-to-the-screen.md)</ept>!","pos":[6910,7022]},{"content":"Previous step","pos":[7027,7040]},{"pos":[7043,7131],"content":"<bpt id=\"p1\">[</bpt>Port the vertex buffers and data<ept id=\"p1\">](port-the-vertex-buffers-and-data-config.md)</ept> Next step"},{"pos":[7143,7194],"content":"<bpt id=\"p1\">[</bpt>Draw to the screen<ept id=\"p1\">](draw-to-the-screen.md)</ept> Remarks"},{"content":"Understanding HLSL semantics and the packing of constant buffers can save you a bit of a debugging headache, as well as provide optimization opportunities.","pos":[7204,7359]},{"content":"If you get a chance, read through <bpt id=\"p1\">[</bpt>Variable Syntax (HLSL)<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb509706)</ept>, <bpt id=\"p2\">[</bpt>Introduction to Buffers in Direct3D 11<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476898)</ept>, and <bpt id=\"p3\">[</bpt>How to: Create a Constant Buffer<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476896)</ept>.","pos":[7360,7684]},{"content":"If not, though, here's a few starting tips to keep in mind about semantics and constant buffers:","pos":[7685,7781]},{"content":"Always double check your renderer's Direct3D configuration code to make sure that the structures for your constant buffers match the cbuffer struct declarations in your HLSL, and that the component scalar types match across both declarations.","pos":[7787,8029]},{"pos":[8034,8215],"content":"In your renderer's C++ code, use <bpt id=\"p1\">[</bpt>DirectXMath<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh437833)</ept> types in your constant buffer declarations to ensure proper data packing."},{"content":"The best way to efficiently use constant buffers is to organize shader variables into constant buffers based on their frequency of update.","pos":[8220,8358]},{"content":"For example, if you have some uniform data that is updated once per frame, and other uniform data that is updated only when the camera moves, consider separating that data into two separate constant buffers.","pos":[8359,8566]},{"content":"Semantics that you have forgotten to apply or which you have applied incorrectly will be your earliest source of shader compilation (FXC) errors.","pos":[8571,8716]},{"content":"Double-check them!","pos":[8717,8735]},{"content":"The docs can be a bit confusing, as many older pages and samples refer to different versions of HLSL semantics prior to Direct3D 11.","pos":[8736,8868]},{"content":"Make sure you know which Direct3D feature level you are targeting for each shader.","pos":[8873,8955]},{"content":"The semantics for feature level 9<ph id=\"ph1\">\\_\\*</ph> are different from those for 11<ph id=\"ph2\">\\_</ph>1.","pos":[8956,9029]},{"content":"The SV<ph id=\"ph1\">\\_</ph>POSITION semantic resolves the associated post-interpolation position data to coordinate values where x is between 0 and the render target width, y is between 0 and the render target height, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).","pos":[9034,9349]},{"content":"Related topics","pos":[9354,9368]},{"content":"How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11","pos":[9372,9431]},{"content":"Port the shader objects","pos":[9492,9515]},{"content":"Port the vertex buffers and data","pos":[9546,9578]},{"content":"Draw to the screen","pos":[9626,9644]}],"content":"---\nauthor: mtoepke\ntitle: Port the GLSL\ndescription: Once you've moved over the code that creates and configures your buffers and shader objects, it's time to port the code inside those shaders from OpenGL ES 2.0's GL Shader Language (GLSL) to Direct3D 11's High-level Shader Language (HLSL).\nms.assetid: 0de06c51-8a34-dc68-6768-ea9f75dc57ee\n---\n\n# Port the GLSL\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n**Important APIs**\n\n-   [HLSL Semantics](https://msdn.microsoft.com/library/windows/desktop/bb205574)\n-   [Shader Constants (HLSL)](https://msdn.microsoft.com/library/windows/desktop/bb509581)\n\nOnce you've moved over the code that creates and configures your buffers and shader objects, it's time to port the code inside those shaders from OpenGL ES 2.0's GL Shader Language (GLSL) to Direct3D 11's High-level Shader Language (HLSL).\n\nIn OpenGL ES 2.0, shaders return data after execution using intrinsics such as **gl\\_Position**, **gl\\_FragColor**, or **gl\\_FragData\\[n\\]** (where n is the index for a specific render target). In Direct3D, there are no specific intrinsics, and the shaders return data as the return type of their respective main() functions.\n\nData that you want interpolated between shader stages, such as the vertex position or normal, is handled through the use of the **varying** declaration. However, Direct3D doesn't have this declaration; rather, any data that you want passed between shader stages must be marked with an [HLSL semantic](https://msdn.microsoft.com/library/windows/desktop/bb205574). The specific semantic chosen indicates the purpose of the data, and is. For example, you'd declare vertex data that you want interpolated between the fragment shader as:\n\n`float4 vertPos : POSITION;`\n\nor\n\n`float4 vertColor : COLOR;`\n\nWhere POSITION is the semantic used to indicate vertex position data. POSITION is also a special case, since after interpolation, it cannot be accessed by the pixel shader. Therefore, you must specify input to the pixel shader with SV\\_POSITION and the interpolated vertex data will be placed in that variable.\n\n`float4 position : SV_POSITION;`\n\nSemantics can be declared on the body (main) methods of shaders. For pixel shaders, SV\\_TARGET\\[n\\], which indicates a render target, is required on the body method. (SV\\_TARGET without a numeric suffix defaults to render target index 0.)\n\nAlso note that vertex shaders are required to output the SV\\_POSITION system value semantic. This semantic resolves the vertex position data to coordinate values where x is between -1 and 1, y is between -1 and 1, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w). Pixel shaders use the SV\\_POSITION system value semantic to retrieve the pixel location on the screen, where x is between 0 and the render target width and y is between 0 and the render target height (each offset by 0.5). Feature level 9\\_x pixel shaders cannot read from the SV\\_POSITION value.\n\nConstant buffers must be declared with **cbuffer** and be associated with a specific starting register for lookup.\n\nDirect3D 11: An HLSL constant buffer declaration\n\n``` syntax\ncbuffer ModelViewProjectionConstantBuffer : register(b0)\n{\n  matrix mvp;\n};\n```\n\nHere, the constant buffer uses register b0 to hold the packed buffer. All registers are referred to in the form b\\#. For more information on the HLSL implementation of constant buffers, registers, and data packing, read [Shader Constants (HLSL)](https://msdn.microsoft.com/library/windows/desktop/bb509581).\n\nInstructions\n------------\n\n### Step 1: Port the vertex shader\n\nIn our simple OpenGL ES 2.0 example, the vertex shader has three inputs: a constant model-view-projection 4x4 matrix, and two 4-coordinate vectors. These two vectors contain the vertex position and its color. The shader transforms the position vector to perspective coordinates and assigns it to the gl\\_Position intrinsic for rasterization. The vertex color is copied to a varying variable for interpolation during rasterization, as well.\n\nOpenGL ES 2.0: Vertex shader for the cube object (GLSL)\n\n``` syntax\nuniform mat4 u_mvpMatrix; \nattribute vec4 a_position;\nattribute vec4 a_color;\nvarying vec4 destColor;\n\nvoid main()\n{           \n  gl_Position = u_mvpMatrix * a_position;\n  destColor = a_color;\n}\n```\n\nNow, in Direct3D, the constant model-view-projection matrix is contained in a constant buffer packed at register b0, and the vertex position and color are specifically marked with the appropriate respective HLSL semantics: POSITION and COLOR. Since our input layout indicates a specific arrangement of these two vertex values, you create a struct to hold them and declare it as the type for the input parameter on the shader body function (main). (You could also specify them as two individual parameters, but that could get cumbersome.) You also specify an output type for this stage, which contains the interpolated position and color, and declare it as the return value for the body function of the vertex shader.\n\nDirect3D 11: Vertex shader for the cube object (HLSL)\n\n``` syntax\ncbuffer ModelViewProjectionConstantBuffer : register(b0)\n{\n  matrix mvp;\n};\n\n// Per-vertex data used as input to the vertex shader.\nstruct VertexShaderInput\n{\n  float3 pos : POSITION;\n  float3 color : COLOR;\n};\n\n// Per-vertex color data passed through the pixel shader.\nstruct PixelShaderInput\n{\n  float3 pos : SV_POSITION;\n  float3 color : COLOR;\n};\n\nPixelShaderInput main(VertexShaderInput input)\n{\n  PixelShaderInput output;\n  float4 pos = float4(input.pos, 1.0f); // add the w-coordinate\n\n  pos = mul(mvp, projection);\n  output.pos = pos;\n\n  output.color = input.color;\n\n  return output;\n}\n```\n\nThe output data type, PixelShaderInput, is populated during rasterization and provided to the fragment (pixel) shader.\n\n### Step 2: Port the fragment shader\n\nOur example fragment shader in GLSL is extremely simple: provide the gl\\_FragColor intrinsic with the interpolated color value. OpenGL ES 2.0 will write it to the default render target.\n\nOpenGL ES 2.0: Fragment shader for the cube object (GLSL)\n\n``` syntax\nvarying vec4 destColor;\n\nvoid main()\n{\n  gl_FragColor = destColor;\n} \n```\n\nDirect3D is almost as simple. The only significant difference is that the body function of the pixel shader must return a value. Since the color is a 4-coordinate (RGBA) float value, you indicate float4 as the return type, and then specify the default render target as the SV\\_TARGET system value semantic.\n\nDirect3D 11: Pixel shader for the cube object (HLSL)\n\n``` syntax\nstruct PixelShaderInput\n{\n  float4 pos : SV_POSITION;\n  float3 color : COLOR;\n};\n\n\nfloat4 main(PixelShaderInput input) : SV_TARGET\n{\n  return float4(input.color, 1.0f);\n}\n```\n\nThe color for the pixel at the position is written to the render target. Now, let's see how to display the contents of that render target in [Draw to the screen](draw-to-the-screen.md)!\n\n## Previous step\n\n\n[Port the vertex buffers and data](port-the-vertex-buffers-and-data-config.md)\nNext step\n---------\n\n[Draw to the screen](draw-to-the-screen.md)\nRemarks\n-------\n\nUnderstanding HLSL semantics and the packing of constant buffers can save you a bit of a debugging headache, as well as provide optimization opportunities. If you get a chance, read through [Variable Syntax (HLSL)](https://msdn.microsoft.com/library/windows/desktop/bb509706), [Introduction to Buffers in Direct3D 11](https://msdn.microsoft.com/library/windows/desktop/ff476898), and [How to: Create a Constant Buffer](https://msdn.microsoft.com/library/windows/desktop/ff476896). If not, though, here's a few starting tips to keep in mind about semantics and constant buffers:\n\n-   Always double check your renderer's Direct3D configuration code to make sure that the structures for your constant buffers match the cbuffer struct declarations in your HLSL, and that the component scalar types match across both declarations.\n-   In your renderer's C++ code, use [DirectXMath](https://msdn.microsoft.com/library/windows/desktop/hh437833) types in your constant buffer declarations to ensure proper data packing.\n-   The best way to efficiently use constant buffers is to organize shader variables into constant buffers based on their frequency of update. For example, if you have some uniform data that is updated once per frame, and other uniform data that is updated only when the camera moves, consider separating that data into two separate constant buffers.\n-   Semantics that you have forgotten to apply or which you have applied incorrectly will be your earliest source of shader compilation (FXC) errors. Double-check them! The docs can be a bit confusing, as many older pages and samples refer to different versions of HLSL semantics prior to Direct3D 11.\n-   Make sure you know which Direct3D feature level you are targeting for each shader. The semantics for feature level 9\\_\\* are different from those for 11\\_1.\n-   The SV\\_POSITION semantic resolves the associated post-interpolation position data to coordinate values where x is between 0 and the render target width, y is between 0 and the render target height, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).\n\n## Related topics\n\n\n[How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md)\n\n[Port the shader objects](port-the-shader-config.md)\n\n[Port the vertex buffers and data](port-the-vertex-buffers-and-data-config.md)\n\n[Draw to the screen](draw-to-the-screen.md)\n\n \n\n \n\n\n\n\n"}