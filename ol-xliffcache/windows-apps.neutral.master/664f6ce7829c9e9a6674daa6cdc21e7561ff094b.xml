{"nodes":[{"content":"Bluetooth GATT","pos":[78,92]},{"content":"This article provides an overview of Bluetooth Generic Attribute Profile (GATT) for Universal Windows Platform (UWP) apps, along with sample code for three common GATT scenarios.","pos":[106,284]},{"content":"Bluetooth GATT","pos":[291,305]},{"content":"Updated for UWP apps on Windows 10.","pos":[310,345]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[346,438]},{"content":"Important APIs","pos":[446,460]},{"content":"Windows.Devices.Bluetooth","pos":[472,497]},{"content":"Windows.Devices.Bluetooth.GenericAttributeProfile","pos":[566,615]},{"content":"This article provides an overview of Bluetooth Generic Attribute Profile (GATT) for Universal Windows Platform (UWP) apps, along with sample code for three common GATT scenarios: retrieving Bluetooth data, controlling a Bluetooth LE thermometer device, and controlling the presentation of Bluetooth LE device data.","pos":[678,992]},{"content":"Overview","pos":[997,1005]},{"content":"Developers can use the APIs in the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Devices.Bluetooth.GenericAttributeProfile<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn297685)</ept> namespace to access Bluetooth LE services, descriptors, and characteristics.","pos":[1007,1232]},{"content":"Bluetooth LE devices expose their functionality through a collection of:","pos":[1233,1305]},{"content":"Primary Services","pos":[1311,1327]},{"content":"Included Services","pos":[1332,1349]},{"content":"Characteristics","pos":[1354,1369]},{"content":"Descriptors","pos":[1374,1385]},{"content":"Primary services define the functional contract of the LE device and contain a collection of characteristics that define the service.","pos":[1387,1520]},{"content":"Those characteristics, in turn, contain descriptors that describe the characteristics.","pos":[1521,1607]},{"content":"The Bluetooth GATT APIs expose objects and functions, rather than access to the raw transport.","pos":[1609,1703]},{"content":"At the driver level primary services are enumerated as Child Device Nodes of the Bluetooth LE device using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Devices.Enumeration<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR225459)</ept> APIs.","pos":[1704,1912]},{"content":"The Bluetooth GATT APIs also enable developers to work with Bluetooth LE devices with the ability to perform the following tasks:","pos":[1914,2043]},{"content":"Perform Service / Characteristic / Descriptor discovery","pos":[2049,2104]},{"content":"Read and Write Characteristic / Descriptor values","pos":[2109,2158]},{"content":"Register a callback for the Characteristic ValueChanged event","pos":[2163,2224]},{"content":"The Bluetooth GATT APIs simplify development by dealing with common properties and providing reasonable defaults to aid in device management and configuration.","pos":[2226,2385]},{"content":"They provide a means for developers to access functionality of a Bluetooth LE device from an app.","pos":[2386,2483]},{"content":"To create a useful implementation a developer has to have prior knowledge of the GATT services and characteristics the application intends to consume, and to process the specific characteristic values such that the binary data provided by the API is transformed into useful data before being presented to the user.","pos":[2485,2799]},{"content":"The Bluetooth GATT APIs expose only the basic primitives required to communicate with a Bluetooth LE device.","pos":[2800,2908]},{"content":"To interpret the data, an application profile must be defined, either by a Bluetooth SIG standard profile, or a custom profile implemented by a device vendor.","pos":[2909,3067]},{"content":"A profile creates a binding contract between the application and the device, as to what the exchanged data represents and how to interpret it.","pos":[3068,3210]},{"pos":[3212,3343],"content":"For convenience the Bluetooth SIG maintains a <bpt id=\"p1\">[</bpt>list of public profiles<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkID=317977)</ept> available."},{"content":"Retrieve Bluetooth data","pos":[3348,3371]},{"content":"In this example, the app consumes temperature measurements from a Bluetooth device that implements the Bluetooth LE Health Thermometer Service.","pos":[3373,3516]},{"content":"The app specifies that it wants to be notified when a new temperature measurement is available.","pos":[3517,3612]},{"content":"By registering an event handler for the \"Thermometer Characteristic Value Changed\" event, the app will receive characteristic value changed event notifications while it is running in the foreground.","pos":[3613,3811]},{"content":"Note that when the app is suspended, it must release all device resources and when it resumes, it must perform device enumeration and initialization once again.","pos":[3813,3973]},{"content":"If device interaction in the background is desired, please take a look at  <bpt id=\"p1\">[</bpt>DeviceUseTrigger<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.deviceusetrigger.aspx)</ept> or <bpt id=\"p2\">[</bpt>GattCharacteristicNotificationTrigger<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.gattcharacteristicnotificationtrigger.aspx)</ept>.","pos":[3974,4346]},{"content":"DeviceUseTrigger is typically better for higher frequency events whereas GattCharacteristicNotificationTrigger is better at handling infrequent events.","pos":[4347,4498]},{"content":"Control a Bluetooth LE thermometer device","pos":[8367,8408]},{"content":"In this example, an UWP app acts as a controller for a fictitious Bluetooth LE Thermometer device.","pos":[8410,8508]},{"content":"The device also declares a format characteristic which allows users to retrieve the value reading in either Celsius or Fahrenheit degrees, in addition to the standard characteristics of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>HealthThermometer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn297603)</ept> profile.","pos":[8509,8789]},{"content":"The app uses reliable write transactions to make sure that the format and measurement interval are set as a single value.","pos":[8790,8911]},{"content":"Control the presentation of Bluetooth LE device data","pos":[12757,12809]},{"content":"A Bluetooth LE devices may expose a battery service that provides the current battery level to the user.","pos":[12811,12915]},{"content":"The battery service includes an optional <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PresentationFormats<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn263742)</ept> descriptor which allows some flexibility in interpretation of the battery level data.","pos":[12916,13126]},{"content":"This scenario provides example of an app that works with such a device and uses the <bpt id=\"p1\">**</bpt>PresentationFormats<ept id=\"p1\">**</ept> property to format a characteristic value, before presenting it to the user.","pos":[13127,13311]}],"content":"---\nauthor: msatranjr\nms.assetid: 28B30708-FE08-4BE9-AE11-5429F963C330\ntitle: Bluetooth GATT\ndescription: This article provides an overview of Bluetooth Generic Attribute Profile (GATT) for Universal Windows Platform (UWP) apps, along with sample code for three common GATT scenarios.\n---\n# Bluetooth GATT\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n** Important APIs **\n\n-   [**Windows.Devices.Bluetooth**](https://msdn.microsoft.com/library/windows/apps/Dn263413)\n-   [**Windows.Devices.Bluetooth.GenericAttributeProfile**](https://msdn.microsoft.com/library/windows/apps/Dn297685)\n\nThis article provides an overview of Bluetooth Generic Attribute Profile (GATT) for Universal Windows Platform (UWP) apps, along with sample code for three common GATT scenarios: retrieving Bluetooth data, controlling a Bluetooth LE thermometer device, and controlling the presentation of Bluetooth LE device data.\n\n## Overview\n\nDevelopers can use the APIs in the [**Windows.Devices.Bluetooth.GenericAttributeProfile**](https://msdn.microsoft.com/library/windows/apps/Dn297685) namespace to access Bluetooth LE services, descriptors, and characteristics. Bluetooth LE devices expose their functionality through a collection of:\n\n-   Primary Services\n-   Included Services\n-   Characteristics\n-   Descriptors\n\nPrimary services define the functional contract of the LE device and contain a collection of characteristics that define the service. Those characteristics, in turn, contain descriptors that describe the characteristics.\n\nThe Bluetooth GATT APIs expose objects and functions, rather than access to the raw transport. At the driver level primary services are enumerated as Child Device Nodes of the Bluetooth LE device using the [**Windows.Devices.Enumeration**](https://msdn.microsoft.com/library/windows/apps/BR225459) APIs.\n\nThe Bluetooth GATT APIs also enable developers to work with Bluetooth LE devices with the ability to perform the following tasks:\n\n-   Perform Service / Characteristic / Descriptor discovery\n-   Read and Write Characteristic / Descriptor values\n-   Register a callback for the Characteristic ValueChanged event\n\nThe Bluetooth GATT APIs simplify development by dealing with common properties and providing reasonable defaults to aid in device management and configuration. They provide a means for developers to access functionality of a Bluetooth LE device from an app.\n\nTo create a useful implementation a developer has to have prior knowledge of the GATT services and characteristics the application intends to consume, and to process the specific characteristic values such that the binary data provided by the API is transformed into useful data before being presented to the user. The Bluetooth GATT APIs expose only the basic primitives required to communicate with a Bluetooth LE device. To interpret the data, an application profile must be defined, either by a Bluetooth SIG standard profile, or a custom profile implemented by a device vendor. A profile creates a binding contract between the application and the device, as to what the exchanged data represents and how to interpret it.\n\nFor convenience the Bluetooth SIG maintains a [list of public profiles](http://go.microsoft.com/fwlink/p/?LinkID=317977) available.\n\n## Retrieve Bluetooth data\n\nIn this example, the app consumes temperature measurements from a Bluetooth device that implements the Bluetooth LE Health Thermometer Service. The app specifies that it wants to be notified when a new temperature measurement is available. By registering an event handler for the \"Thermometer Characteristic Value Changed\" event, the app will receive characteristic value changed event notifications while it is running in the foreground.\n\nNote that when the app is suspended, it must release all device resources and when it resumes, it must perform device enumeration and initialization once again. If device interaction in the background is desired, please take a look at  [DeviceUseTrigger](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.deviceusetrigger.aspx) or [GattCharacteristicNotificationTrigger](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.gattcharacteristicnotificationtrigger.aspx). DeviceUseTrigger is typically better for higher frequency events whereas GattCharacteristicNotificationTrigger is better at handling infrequent events.  \n\n```csharp\ndouble convertTemperatureData(byte[] temperatureData)\n{\n    // Read temperature data in IEEE 11703 floating point format\n    // temperatureData[0] contains flags about optional data - not used\n    UInt32 mantissa = ((UInt32)temperatureData[3] << 16) |\n        ((UInt32)temperatureData[2] << 8) |\n        ((UInt32)temperatureData[1]);\n\n    Int32 exponent = (Int32)temperatureData[4];\n\n    return mantissa * Math.Pow(10.0, exponent);\n}\n\nasync void Initialize()\n{\n    var themometerServices = await Windows.Devices.Enumeration\n        .DeviceInformation.FindAllAsync(GattDeviceService\n            .GetDeviceSelectorFromUuid(\n                GattServiceUuids.HealthThermometer),\n        null);\n\n    GattDeviceService firstThermometerService = await\n        GattDeviceService.FromIdAsync(themometerServices[0].Id);\n\n    serviceNameTextBlock.Text = \"Using service: \" + \n        themometerServices[0].Name;\n\n    GattCharacteristic thermometerCharacteristic =\n        firstThermometerService.GetCharacteristics(\n            GattCharacteristicUuids.TemperatureMeasurement)[0];\n\n    thermometerCharacteristic.ValueChanged += temperatureMeasurementChanged;\n\n    await thermometerCharacteristic\n        .WriteClientCharacteristicConfigurationDescriptorAsync(\n            GattClientCharacteristicConfigurationDescriptorValue.Notify);\n}\n\nvoid temperatureMeasurementChanged(\n    GattCharacteristic sender,\n    GattValueChangedEventArgs eventArgs)\n{\n    byte[] temperatureData = new byte[eventArgs.CharacteristicValue.Length];\n    Windows.Storage.Streams.DataReader.FromBuffer(\n        eventArgs.CharacteristicValue).ReadBytes(temperatureData);\n\n    var temperatureValue = convertTemperatureData(temperatureData);\n\n    temperatureTextBlock.Text = temperatureValue.ToString();\n}\n```\n\n```cpp\ndouble MainPage::ConvertTemperatureData(\n    const Array<unsigned char>^ temperatureData)\n{\n    unsigned mantissa = ((unsigned)temperatureData[3] << 16) |\n        ((unsigned)temperatureData[2] << 8) |\n        ((unsigned)temperatureData[1]);\n\n    int exponent = (int)temperatureData[4];\n\n    return mantissa * pow(10.0, (double)exponent);\n}\n\nvoid MainPage::Initialize()\n{\n    create_task(DeviceInformation::FindAllAsync(\n        GattDeviceService::GetDeviceSelectorFromUuid(\n            GattServiceUuids::HealthThermometer), \n        nullptr)).then(\n            [this] (DeviceInformationCollection^ thermometerServices) \n    {\n        create_task(GattDeviceService::FromIdAsync(\n            thermometerServices->GetAt(0)->Id))\n            .then([this] (GattDeviceService^ firstThermometerService) \n        {\n            GattCharacteristic^ thermometerCharacteristic = \n                firstThermometerService->GetCharacteristics(\n                    GattCharacteristicUuids::TemperatureMeasurement)\n                        ->GetAt(0);\n\n            thermometerCharacteristic->ValueChanged += \n                ref new TypedEventHandler<\n                    GattCharacteristic^, \n                    GattValueChangedEventArgs^>(\n                        this, &MainPage::TemperatureMeasurementChanged);\n\n            create_task(thermometerCharacteristic->\n                WriteClientCharacteristicConfigurationDescriptorAsync(\n                GattClientCharacteristicConfigurationDescriptorValue\n                    ::Notify));\n        });\n    });\n}\n\n\nvoid MainPage::TemperatureMeasurementChanged(\n    GattCharacteristic^ sender,\n    GattValueChangedEventArgs^ eventArgs)\n{\n    auto temperatureData =  ref new Array<unsigned char>(\n        eventArgs->CharacteristicValue->Length);\n    DataReader::FromBuffer(eventArgs->CharacteristicValue)\n        ->ReadBytes(temperatureData);\n\n    double temperatureValue = ConvertTemperatureData(temperatureData);\n    std::wstringstream str;\n    str << temperatureValue;\n\n    temperatureTextBlock->Text = ref new String(str.str().c_str());\n}\n```\n\n## Control a Bluetooth LE thermometer device\n\nIn this example, an UWP app acts as a controller for a fictitious Bluetooth LE Thermometer device. The device also declares a format characteristic which allows users to retrieve the value reading in either Celsius or Fahrenheit degrees, in addition to the standard characteristics of the [**HealthThermometer**](https://msdn.microsoft.com/library/windows/apps/Dn297603) profile. The app uses reliable write transactions to make sure that the format and measurement interval are set as a single value.\n\n```csharp\n// Uuid of the \"Format\" Characteristic Value\nGuid formatCharacteristicUuid = \n    new Guid(\"{00000000-0000-0000-0000-000000000010}\");\n\n// Constant representing a Fahrenheit scale temperature measurement\nconst byte FahrenheitReading = 1;\nasync void Initialize()\n{\n    var themometerServices = await Windows.Devices.Enumeration\n        .DeviceInformation.FindAllAsync(GattDeviceService\n            .GetDeviceSelectorFromUuid(\n                GattServiceUuids.HealthThermometer),\n        null);\n\n    GattDeviceService thermometerService = await\n        GattDeviceService.FromIdAsync(themometerServices[0].Id);\n\n    serviceNameTextBlock.Text = \"Using service: \" + \n        themometerServices[0].Name;\n\n    GattCharacteristic intervalCharacteristic = thermometerService\n        .GetCharacteristics(GattCharacteristicUuids.MeasurementInterval)[0];\n\n    GattCharacteristic formatCharacteristic = thermometerService\n        .GetCharacteristics(formatCharacteristicUuid)[0];\n\n    GattReliableWriteTransaction gattTransaction = \n        new GattReliableWriteTransaction();\n\n    var writer = new Windows.Storage.Streams.DataWriter();\n\n    // Get a temperature reading every 60 seconds\n    writer.WriteUInt16(60);\n\n    gattTransaction.WriteValue(\n        intervalCharacteristic, \n        writer.DetachBuffer());\n\n    // Get the reading on the Fahrenheit scale\n    writer.WriteByte(FahrenheitReading);\n\n    gattTransaction.WriteValue(\n        formatCharacteristic, \n        writer.DetachBuffer());\n\n    GattCommunicationStatus status = await gattTransaction.CommitAsync();\n\n    if (GattCommunicationStatus.Unreachable == status)\n    {\n        statusTextBlock.Text = \"Writing to your device failed !\";\n    }\n}\n```\n\n```cpp\n// Uuid of the \"Format\" Characteristic Value\nGuid formatCharacteristicUuid(0x00000000, 0x0000, 0x0000, 0x00, 0x00, \n                                  0x00, 0x00, 0x00, 0x00, 0x00, 0x10);\n\n// Constant representing a Fahrenheit scale temperature measurement\nconst unsigned char FAHRENHEIT_READING = 1;\n\nvoid MainPage::Initialize()\n{\n    create_task(DeviceInformation::FindAllAsync(\n        GattDeviceService::GetDeviceSelectorFromUuid(\n            GattServiceUuids::HealthThermometer), \n        nullptr)).then(\n            [this] (DeviceInformationCollection^ thermometerServices) \n    {\n        create_task(GattDeviceService::FromIdAsync(\n            thermometerServices->GetAt(0)->Id)).then([this] (\n                GattDeviceService^ thermometerService) \n        {\n            GattCharacteristic^ intervalCharacteristic = \n                thermometerService->GetCharacteristics(\n                    GattCharacteristicUuids::MeasurementInterval)\n                        ->GetAt(0);\n\n            GattCharacteristic^ formatCharacteristic = \n                thermometerService->GetCharacteristics(\n                    formatCharacteristicUuid)->GetAt(0);\n\n            GattReliableWriteTransaction^ gattTransaction = \n                ref new GattReliableWriteTransaction();\n\n            DataWriter^ writer = ref new DataWriter();\n\n            // Get a temperature reading every 60 seconds\n            writer->WriteUInt16(60);\n\n            gattTransaction->WriteValue(\n                intervalCharacteristic, \n                writer->DetachBuffer());\n\n            writer->WriteByte(FAHRENHEIT_READING);\n\n            gattTransaction->WriteValue(\n                formatCharacteristic, \n                writer->DetachBuffer());\n\n            create_task(gattTransaction->CommitAsync())\n                .then([this] (GattCommunicationStatus status) \n            {\n                if (GattCommunicationStatus::Unreachable == status) \n                { \n                    statusTextBlock->Text = \n                        ref new String(L\"Writing to your device failed !\");\n                }\n            });\n        });\n    });\n\n```\n\n## Control the presentation of Bluetooth LE device data\n\nA Bluetooth LE devices may expose a battery service that provides the current battery level to the user. The battery service includes an optional [**PresentationFormats**](https://msdn.microsoft.com/library/windows/apps/Dn263742) descriptor which allows some flexibility in interpretation of the battery level data. This scenario provides example of an app that works with such a device and uses the **PresentationFormats** property to format a characteristic value, before presenting it to the user.\n\n```csharp\nasync void Initialize()\n{\n    var batteryServices = await Windows.Devices.Enumeration\n        .DeviceInformation.FindAllAsync(GattDeviceService\n            .GetDeviceSelectorFromUuid(GattServiceUuids.Battery),\n        null);\n\n    if (batteryServices.Count > 0)\n    {\n        // Use the first Battery service on the system\n        GattDeviceService batteryService = await GattDeviceService\n            .FromIdAsync(batteryServices[0].Id);\n\n        // Use the first Characteristic of that Service\n        GattCharacteristic batteryLevelCharacteristic =\n            batteryService.GetCharacteristics(\n                GattCharacteristicUuids.BatteryLevel)[0];\n\n        batteryLevelCharacteristic.ValueChanged += batteryLevelChanged;\n    }\n    else\n    {\n        statusTextBlock.Text = \"No Battery services found !\";\n    }\n}\n\nvoid batteryLevelChanged(\n    GattCharacteristic sender,\n    GattValueChangedEventArgs eventArgs)\n{\n    byte levelData = Windows.Storage.Streams.DataReader\n        .FromBuffer(eventArgs.CharacteristicValue).ReadByte();\n\n    double levelValue;\n\n    if (sender.PresentationFormats.Count > 0)\n    {\n        levelValue = levelData * \n            Math.Pow(10.0, sender.PresentationFormats[0].Exponent);\n    }\n    else\n    {\n        levelValue = (double)levelData;\n    }\n\n    batteryLevelTextBlock.Text = levelValue.ToString();\n}\n```\n\n```cpp\nvoid MainPage::Initialize()\n{\n    create_task(DeviceInformation::FindAllAsync(\n        GattDeviceService::GetDeviceSelectorFromUuid(\n            GattServiceUuids::Battery), \n        nullptr)).then([this] (DeviceInformationCollection^ batteryServices) \n    {\n        create_task(GattDeviceService::FromIdAsync(\n            batteryServices->GetAt(0)->Id)).then([this] (\n                GattDeviceService^ batteryService) \n        {\n            GattCharacteristic^ batteryLevelCharacteristic = \n                batteryService->GetCharacteristics(\n                    GattCharacteristicUuids::BatteryLevel)->GetAt(0);\n\n            batteryLevelCharacteristic->ValueChanged += \n                ref new TypedEventHandler<\n                    GattCharacteristic^, \n                    GattValueChangedEventArgs^>\n                    (this, &MainPage::BatteryLevelChanged);\n\n            create_task(batteryLevelCharacteristic\n                ->WriteClientCharacteristicConfigurationDescriptorAsync(\n                GattClientCharacteristicConfigurationDescriptorValue\n                    ::Notify));\n        });\n    });\n}\n\nvoid MainPage::BatteryLevelChanged(\n    GattCharacteristic^ sender,\n    GattValueChangedEventArgs^ eventArgs)\n{\n    unsigned char batteryLevelData = DataReader::FromBuffer(\n        eventArgs->CharacteristicValue)->ReadByte();\n\n    // if this characteristic has a presentation format\n    // use that information to format the value\n    double batteryLevelValue;\n    if (sender->PresentationFormats->Size > 0)\n    {\n        batteryLevelValue = batteryLevelData * \n            pow(10.0, sender->PresentationFormats->GetAt(0)->Exponent);\n    }\n    else\n    {\n        batteryLevelValue = batteryLevelData;\n    }\n\n    std::wstringstream str;\n    str << batteryLevelValue;\n    batteryLevelTextBlock->Text = \n        ref new String(str.str().c_str());\n}\n```\n\n\n\n"}