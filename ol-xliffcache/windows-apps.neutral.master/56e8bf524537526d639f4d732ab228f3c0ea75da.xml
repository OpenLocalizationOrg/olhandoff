{"nodes":[{"content":"Apply textures to primitives","pos":[27,55]},{"content":"Here, we load raw texture data and apply that data to a 3D primitive by using the cube that we created in Using depth and effects on primitives.","pos":[69,213]},{"content":"Apply textures to primitives","pos":[270,298]},{"content":"Updated for UWP apps on Windows 10.","pos":[304,339]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[340,432]},{"content":"Here, we load raw texture data and apply that data to a 3D primitive by using the cube that we created in <bpt id=\"p1\">[</bpt>Using depth and effects on primitives<ept id=\"p1\">](using-depth-and-effects-on-primitives.md)</ept>.","pos":[437,625]},{"content":"We also introduce a simple dot-product lighting model, where the cube surfaces are lighter or darker based on their distance and angle relative to a light source.","pos":[626,788]},{"pos":[790,837],"content":"<bpt id=\"p1\">**</bpt>Objective:<ept id=\"p1\">**</ept> To apply textures to primitives."},{"content":"Prerequisites","pos":[842,855]},{"content":"We assume that you are familiar with C++.","pos":[858,899]},{"content":"You also need basic experience with graphics programming concepts.","pos":[900,966]},{"pos":[968,1279],"content":"We also assume that you went through <bpt id=\"p1\">[</bpt>Quickstart: setting up DirectX resources and displaying an image<ept id=\"p1\">](setting-up-directx-resources.md)</ept>, <bpt id=\"p2\">[</bpt>Creating shaders and drawing primitives<ept id=\"p2\">](creating-shaders-and-drawing-primitives.md)</ept>, and <bpt id=\"p3\">[</bpt>Using depth and effects on primitives<ept id=\"p3\">](using-depth-and-effects-on-primitives.md)</ept>."},{"pos":[1281,1314],"content":"<bpt id=\"p1\">**</bpt>Time to complete:<ept id=\"p1\">**</ept> 20 minutes."},{"content":"Instructions","pos":[1316,1328]},{"content":"1. Defining variables for a textured cube","pos":[1347,1388]},{"content":"First, we need to define the <bpt id=\"p1\">**</bpt>BasicVertex<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>ConstantBuffer<ept id=\"p2\">**</ept> structures for the textured cube.","pos":[1390,1491]},{"content":"These structures specify the vertex positions, orientations, and textures for the cube and how the cube will be viewed.","pos":[1492,1611]},{"content":"Otherwise, we declare variables similarly to the previous tutorial, <bpt id=\"p1\">[</bpt>Using depth and effects on primitives<ept id=\"p1\">](using-depth-and-effects-on-primitives.md)</ept>.","pos":[1612,1762]},{"content":"2. Creating vertex and pixel shaders with surface and texture elements","pos":[2567,2637]},{"content":"Here, we create more complex vertex and pixel shaders than in the previous tutorial, <bpt id=\"p1\">[</bpt>Using depth and effects on primitives<ept id=\"p1\">](using-depth-and-effects-on-primitives.md)</ept>.","pos":[2639,2806]},{"content":"This app's vertex shader transforms each vertex position into projection space and passes the vertex texture coordinate through to the pixel shader.","pos":[2807,2955]},{"pos":[2957,3354],"content":"The app's array of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>INPUT<ph id=\"ph2\">\\_</ph>ELEMENT<ph id=\"ph3\">\\_</ph>DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structures that describe the layout of the vertex shader code has three layout elements: one element defines the vertex position, another element defines the surface normal vector (the direction that the surface normally faces), and the third element defines the texture coordinates."},{"content":"We create vertex, index, and constant buffers that define an orbiting textured cube.","pos":[3356,3440]},{"content":"To define an orbiting textured cube","pos":[3444,3479]},{"content":"First, we define the cube.","pos":[3487,3513]},{"content":"Each vertex is assigned a position, a surface normal vector, and texture coordinates.","pos":[3514,3599]},{"content":"We use multiple vertices for each corner to allow different normal vectors and texture coordinates to be defined for each face.","pos":[3600,3727]},{"content":"Next, we describe the vertex and index buffers (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>BUFFER<ph id=\"ph2\">\\_</ph>DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>D3D11<ph id=\"ph3\">\\_</ph>SUBRESOURCE<ph id=\"ph4\">\\_</ph>DATA<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept>) using the cube definition.","pos":[3732,3990]},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateBuffer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> once for each buffer.","pos":[3991,4114]},{"content":"Next, we create a constant buffer (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>BUFFER<ph id=\"ph2\">\\_</ph>DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept>) for passing model, view, and projection matrices to the vertex shader.","pos":[4119,4312]},{"content":"We can later use the constant buffer to rotate the cube and apply a perspective projection to it.","pos":[4313,4410]},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateBuffer<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> to create the constant buffer.","pos":[4411,4543]},{"content":"Finally, we specify the view transform that corresponds to a camera position of X = 0, Y = 1, Z = 2.","pos":[4548,4648]},{"content":"3. Creating textures and samplers","pos":[13790,13823]},{"pos":[13825,14002],"content":"Here, we apply texture data to a cube rather than applying colors as in the previous tutorial, <bpt id=\"p1\">[</bpt>Using depth and effects on primitives<ept id=\"p1\">](using-depth-and-effects-on-primitives.md)</ept>."},{"content":"We use raw texture data to create textures.","pos":[14004,14047]},{"content":"To create textures and samplers","pos":[14051,14082]},{"content":"First, we read raw texture data from the texturedata.bin file on disk.","pos":[14090,14160]},{"pos":[14165,14326],"content":"Next, we construct a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>SUBRESOURCE<ph id=\"ph2\">\\_</ph>DATA<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure that references that raw texture data."},{"content":"Then, we populate a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>TEXTURE2D<ph id=\"ph2\">\\_</ph>DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476253)</ept> structure to describe the texture.","pos":[14331,14475]},{"content":"We then pass the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>SUBRESOURCE<ph id=\"ph2\">\\_</ph>DATA<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> and <bpt id=\"p3\">**</bpt>D3D11<ph id=\"ph3\">\\_</ph>TEXTURE2D<ph id=\"ph4\">\\_</ph>DESC<ept id=\"p3\">**</ept> structures in a call to <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>ID3D11Device::CreateTexture2D<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/desktop/ff476521)</ept> to create the texture.","pos":[14476,14759]},{"content":"Next, we create a shader-resource view of the texture so shaders can use the texture.","pos":[14764,14849]},{"content":"To create the shader-resource view, we populate a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>SHADER<ph id=\"ph2\">\\_</ph>RESOURCE<ph id=\"ph3\">\\_</ph>VIEW<ph id=\"ph4\">\\_</ph>DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476211)</ept> to describe the shader-resource view and pass the shader-resource view description and the texture to <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device::CreateShaderResourceView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476519)</ept>.","pos":[14850,15211]},{"content":"In general, you match the view description with the texture description.","pos":[15212,15284]},{"content":"Next, we create sampler state for the texture.","pos":[15289,15335]},{"content":"This sampler state uses the relevant texture data to define how the color for a particular texture coordinate is determined.","pos":[15336,15460]},{"content":"We populate a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>SAMPLER<ph id=\"ph2\">\\_</ph>DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476207)</ept> structure to describe the sampler state.","pos":[15461,15603]},{"content":"We then pass the <bpt id=\"p1\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>SAMPLER<ph id=\"ph2\">\\_</ph>DESC<ept id=\"p1\">**</ept> structure in a call to <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11Device::CreateSamplerState<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476518)</ept> to create the sampler state.","pos":[15604,15797]},{"pos":[15802,15906],"content":"Finally, we declare a <bpt id=\"p1\">*</bpt>degree<ept id=\"p1\">*</ept> variable that we will use to animate the cube by rotating it every frame."},{"content":"4. Rotating and drawing the textured cube and presenting the rendered image","pos":[20427,20502]},{"content":"As in the previous tutorials, we enter an endless loop to continually render and display the scene.","pos":[20504,20603]},{"content":"We call the <bpt id=\"p1\">**</bpt>rotationY<ept id=\"p1\">**</ept> inline function (BasicMath.h) with a rotation amount to set values that will rotate the cube’s model matrix around the Y axis.","pos":[20604,20756]},{"content":"We then call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::UpdateSubresource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</ept> to update the constant buffer and rotate the cube model.","pos":[20757,20932]},{"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::OMSetRenderTargets<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept> to specify the render target and the depth-stencil view.","pos":[20933,21110]},{"content":"We call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::ClearRenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476388)</ept> to clear the render target to a solid blue color and call <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::ClearDepthStencilView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476387)</ept> to clear the depth buffer.","pos":[21111,21423]},{"content":"In the endless loop, we also draw the textured cube on the blue surface.","pos":[21425,21497]},{"content":"To draw the textured cube","pos":[21501,21526]},{"pos":[21534,21732],"content":"First, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::IASetInputLayout<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</ept> to describe how vertex buffer data is streamed into the input-assembler stage."},{"pos":[21737,22033],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::IASetVertexBuffers<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::IASetIndexBuffer<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476453)</ept> to bind the vertex and index buffers to the input-assembler stage."},{"pos":[22038,22416],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::IASetPrimitiveTopology<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476455)</ept> with the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>PRIMITIVE<ph id=\"ph2\">\\_</ph>TOPOLOGY<ph id=\"ph3\">\\_</ph>TRIANGLESTRIP<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476189#D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP)</ept> value to specify for the input-assembler stage to interpret the vertex data as a triangle strip."},{"pos":[22421,22769],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::VSSetShader<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> to initialize the vertex shader stage with the vertex shader code and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext::PSSetShader<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> to initialize the pixel shader stage with the pixel shader code."},{"pos":[22774,22973],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::VSSetConstantBuffers<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476491)</ept> to set the constant buffer that is used by the vertex shader pipeline stage."},{"pos":[22978,23163],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PSSetShaderResources<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476473)</ept> to bind the shader-resource view of the texture to the pixel shader pipeline stage."},{"pos":[23168,23323],"content":"Next, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PSSetSamplers<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476471)</ept> to set the sampler state to the pixel shader pipeline stage."},{"pos":[23328,23502],"content":"Finally, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</ept> to draw the cube and submit it to the rendering pipeline."},{"pos":[23504,23677],"content":"As in the previous tutorials, we call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain::Present<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174576)</ept> to present the rendered image to the window."},{"content":"Summary","pos":[26940,26947]},{"content":"We loaded raw texture data and applied that data to a 3D primitive.","pos":[26950,27017]}],"content":"---\nauthor: mtoepke\ntitle: Apply textures to primitives\ndescription: Here, we load raw texture data and apply that data to a 3D primitive by using the cube that we created in Using depth and effects on primitives.\nms.assetid: aeed09e3-c47a-4dd9-d0e8-d1b8bdd7e9b4\n---\n\n# Apply textures to primitives\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nHere, we load raw texture data and apply that data to a 3D primitive by using the cube that we created in [Using depth and effects on primitives](using-depth-and-effects-on-primitives.md). We also introduce a simple dot-product lighting model, where the cube surfaces are lighter or darker based on their distance and angle relative to a light source.\n\n**Objective:** To apply textures to primitives.\n\n## Prerequisites\n\n\nWe assume that you are familiar with C++. You also need basic experience with graphics programming concepts.\n\nWe also assume that you went through [Quickstart: setting up DirectX resources and displaying an image](setting-up-directx-resources.md), [Creating shaders and drawing primitives](creating-shaders-and-drawing-primitives.md), and [Using depth and effects on primitives](using-depth-and-effects-on-primitives.md).\n\n**Time to complete:** 20 minutes.\n\nInstructions\n------------\n\n### 1. Defining variables for a textured cube\n\nFirst, we need to define the **BasicVertex** and **ConstantBuffer** structures for the textured cube. These structures specify the vertex positions, orientations, and textures for the cube and how the cube will be viewed. Otherwise, we declare variables similarly to the previous tutorial, [Using depth and effects on primitives](using-depth-and-effects-on-primitives.md).\n\n```cpp\nstruct BasicVertex\n{\n    DirectX::XMFLOAT3 pos;  // Position\n    DirectX::XMFLOAT3 norm; // Surface normal vector\n    DirectX::XMFLOAT2 tex;  // Texture coordinate\n};\n\nstruct ConstantBuffer\n{\n    DirectX::XMFLOAT4X4 model;\n    DirectX::XMFLOAT4X4 view;\n    DirectX::XMFLOAT4X4 projection;\n};\n\n// This class defines the application as a whole.\nref class Direct3DTutorialFrameworkView : public IFrameworkView\n{\nprivate:\n    Platform::Agile<CoreWindow> m_window;\n    ComPtr<IDXGISwapChain1> m_swapChain;\n    ComPtr<ID3D11Device1> m_d3dDevice;\n    ComPtr<ID3D11DeviceContext1> m_d3dDeviceContext;\n    ComPtr<ID3D11RenderTargetView> m_renderTargetView;\n    ComPtr<ID3D11DepthStencilView> m_depthStencilView;\n    ComPtr<ID3D11Buffer> m_constantBuffer;\n    ConstantBuffer m_constantBufferData;\n```\n\n### 2. Creating vertex and pixel shaders with surface and texture elements\n\nHere, we create more complex vertex and pixel shaders than in the previous tutorial, [Using depth and effects on primitives](using-depth-and-effects-on-primitives.md). This app's vertex shader transforms each vertex position into projection space and passes the vertex texture coordinate through to the pixel shader.\n\nThe app's array of [**D3D11\\_INPUT\\_ELEMENT\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476180) structures that describe the layout of the vertex shader code has three layout elements: one element defines the vertex position, another element defines the surface normal vector (the direction that the surface normally faces), and the third element defines the texture coordinates.\n\nWe create vertex, index, and constant buffers that define an orbiting textured cube.\n\n**To define an orbiting textured cube**\n\n1.  First, we define the cube. Each vertex is assigned a position, a surface normal vector, and texture coordinates. We use multiple vertices for each corner to allow different normal vectors and texture coordinates to be defined for each face.\n2.  Next, we describe the vertex and index buffers ([**D3D11\\_BUFFER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476092) and [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220)) using the cube definition. We call [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501) once for each buffer.\n3.  Next, we create a constant buffer ([**D3D11\\_BUFFER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476092)) for passing model, view, and projection matrices to the vertex shader. We can later use the constant buffer to rotate the cube and apply a perspective projection to it. We call [**ID3D11Device::CreateBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476501) to create the constant buffer.\n4.  Finally, we specify the view transform that corresponds to a camera position of X = 0, Y = 1, Z = 2.\n\n```cpp\n        \n        auto loadVSTask = DX::ReadDataAsync(L\"SimpleVertexShader.cso\");\n        auto loadPSTask = DX::ReadDataAsync(L\"SimplePixelShader.cso\");\n          \n        auto createVSTask = loadVSTask.then([this](const std::vector<byte>& vertexShaderBytecode) {  \n\n          ComPtr<ID3D11VertexShader> vertexShader;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateVertexShader(\n                  vertexShaderBytecode->Data,\n                  vertexShaderBytecode->Length,\n                  nullptr,\n                  &vertexShader\n                  )\n              );\n\n          // Create an input layout that matches the layout defined in the vertex shader code.\n          // These correspond to the elements of the BasicVertex struct defined above.\n          const D3D11_INPUT_ELEMENT_DESC basicVertexLayoutDesc[] =\n          {\n              { \"POSITION\", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,  0, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n              { \"NORMAL\",   0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n              { \"TEXCOORD\", 0, DXGI_FORMAT_R32G32_FLOAT,    0, 24, D3D11_INPUT_PER_VERTEX_DATA, 0 },\n          };\n\n          ComPtr<ID3D11InputLayout> inputLayout;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateInputLayout(\n                  basicVertexLayoutDesc,\n                  ARRAYSIZE(basicVertexLayoutDesc),\n                  vertexShaderBytecode->Data,\n                  vertexShaderBytecode->Length,\n                  &inputLayout\n                  )\n              );\n        });\n        \n        // Load the raw pixel shader bytecode from disk and create a pixel shader with it.\n        auto createPSTask = loadPSTask.then([this](const std::vector<byte>& pixelShaderBytecode) {        \n\n          ComPtr<ID3D11PixelShader> pixelShader;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreatePixelShader(\n                  pixelShaderBytecode->Data,\n                  pixelShaderBytecode->Length,\n                  nullptr,\n                  &pixelShader\n                  )\n              );\n        });\n        \n        \n        // Create vertex and index buffers that define a simple unit cube.\n        auto createCubeTask = (createPSTask && createVSTask).then([this] () {\n        \n          // In the array below, which will be used to initialize the cube vertex buffers,\n          // multiple vertices are used for each corner to allow different normal vectors and\n          // texture coordinates to be defined for each face.\n          BasicVertex cubeVertices[] =\n          {\n              { DirectX::XMFLOAT3(-0.5f, 0.5f, -0.5f), DirectX::XMFLOAT3(0.0f, 1.0f, 0.0f), DirectX::XMFLOAT2(0.0f, 0.0f) }, // +Y (top face)\n              { DirectX::XMFLOAT3( 0.5f, 0.5f, -0.5f), DirectX::XMFLOAT3(0.0f, 1.0f, 0.0f), DirectX::XMFLOAT2(1.0f, 0.0f) },\n              { DirectX::XMFLOAT3( 0.5f, 0.5f,  0.5f), DirectX::XMFLOAT3(0.0f, 1.0f, 0.0f), DirectX::XMFLOAT2(1.0f, 1.0f) },\n              { DirectX::XMFLOAT3(-0.5f, 0.5f,  0.5f), DirectX::XMFLOAT3(0.0f, 1.0f, 0.0f), DirectX::XMFLOAT2(0.0f, 1.0f) },\n\n              { DirectX::XMFLOAT3(-0.5f, -0.5f,  0.5f), DirectX::XMFLOAT3(0.0f, -1.0f, 0.0f), DirectX::XMFLOAT2(0.0f, 0.0f) }, // -Y (bottom face)\n              { DirectX::XMFLOAT3( 0.5f, -0.5f,  0.5f), DirectX::XMFLOAT3(0.0f, -1.0f, 0.0f), DirectX::XMFLOAT2(1.0f, 0.0f) },\n              { DirectX::XMFLOAT3( 0.5f, -0.5f, -0.5f), DirectX::XMFLOAT3(0.0f, -1.0f, 0.0f), DirectX::XMFLOAT2(1.0f, 1.0f) },\n              { DirectX::XMFLOAT3(-0.5f, -0.5f, -0.5f), DirectX::XMFLOAT3(0.0f, -1.0f, 0.0f), DirectX::XMFLOAT2(0.0f, 1.0f) },\n\n              { DirectX::XMFLOAT3(0.5f,  0.5f,  0.5f), DirectX::XMFLOAT3(1.0f, 0.0f, 0.0f), DirectX::XMFLOAT2(0.0f, 0.0f) }, // +X (right face)\n              { DirectX::XMFLOAT3(0.5f,  0.5f, -0.5f), DirectX::XMFLOAT3(1.0f, 0.0f, 0.0f), DirectX::XMFLOAT2(1.0f, 0.0f) },\n              { DirectX::XMFLOAT3(0.5f, -0.5f, -0.5f), DirectX::XMFLOAT3(1.0f, 0.0f, 0.0f), DirectX::XMFLOAT2(1.0f, 1.0f) },\n              { DirectX::XMFLOAT3(0.5f, -0.5f,  0.5f), DirectX::XMFLOAT3(1.0f, 0.0f, 0.0f), DirectX::XMFLOAT2(0.0f, 1.0f) },\n\n              { DirectX::XMFLOAT3(-0.5f,  0.5f, -0.5f), DirectX::XMFLOAT3(-1.0f, 0.0f, 0.0f), DirectX::XMFLOAT2(0.0f, 0.0f) }, // -X (left face)\n              { DirectX::XMFLOAT3(-0.5f,  0.5f,  0.5f), DirectX::XMFLOAT3(-1.0f, 0.0f, 0.0f), DirectX::XMFLOAT2(1.0f, 0.0f) },\n              { DirectX::XMFLOAT3(-0.5f, -0.5f,  0.5f), DirectX::XMFLOAT3(-1.0f, 0.0f, 0.0f), DirectX::XMFLOAT2(1.0f, 1.0f) },\n              { DirectX::XMFLOAT3(-0.5f, -0.5f, -0.5f), DirectX::XMFLOAT3(-1.0f, 0.0f, 0.0f), DirectX::XMFLOAT2(0.0f, 1.0f) },\n\n              { DirectX::XMFLOAT3(-0.5f,  0.5f, 0.5f), DirectX::XMFLOAT3(0.0f, 0.0f, 1.0f), DirectX::XMFLOAT2(0.0f, 0.0f) }, // +Z (front face)\n              { DirectX::XMFLOAT3( 0.5f,  0.5f, 0.5f), DirectX::XMFLOAT3(0.0f, 0.0f, 1.0f), DirectX::XMFLOAT2(1.0f, 0.0f) },\n              { DirectX::XMFLOAT3( 0.5f, -0.5f, 0.5f), DirectX::XMFLOAT3(0.0f, 0.0f, 1.0f), DirectX::XMFLOAT2(1.0f, 1.0f) },\n              { DirectX::XMFLOAT3(-0.5f, -0.5f, 0.5f), DirectX::XMFLOAT3(0.0f, 0.0f, 1.0f), DirectX::XMFLOAT2(0.0f, 1.0f) },\n\n              { DirectX::XMFLOAT3( 0.5f,  0.5f, -0.5f), DirectX::XMFLOAT3(0.0f, 0.0f, -1.0f), DirectX::XMFLOAT2(0.0f, 0.0f) }, // -Z (back face)\n              { DirectX::XMFLOAT3(-0.5f,  0.5f, -0.5f), DirectX::XMFLOAT3(0.0f, 0.0f, -1.0f), DirectX::XMFLOAT2(1.0f, 0.0f) },\n              { DirectX::XMFLOAT3(-0.5f, -0.5f, -0.5f), DirectX::XMFLOAT3(0.0f, 0.0f, -1.0f), DirectX::XMFLOAT2(1.0f, 1.0f) },\n              { DirectX::XMFLOAT3( 0.5f, -0.5f, -0.5f), DirectX::XMFLOAT3(0.0f, 0.0f, -1.0f), DirectX::XMFLOAT2(0.0f, 1.0f) },\n          };\n\n          unsigned short cubeIndices[] =\n          {\n              0, 1, 2,\n              0, 2, 3,\n\n              4, 5, 6,\n              4, 6, 7,\n\n              8, 9, 10,\n              8, 10, 11,\n\n              12, 13, 14,\n              12, 14, 15,\n\n              16, 17, 18,\n              16, 18, 19,\n\n              20, 21, 22,\n              20, 22, 23\n          };\n\n          D3D11_BUFFER_DESC vertexBufferDesc = {0};\n          vertexBufferDesc.ByteWidth = sizeof(BasicVertex) * ARRAYSIZE(cubeVertices);\n          vertexBufferDesc.Usage = D3D11_USAGE_DEFAULT;\n          vertexBufferDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;\n          vertexBufferDesc.CPUAccessFlags = 0;\n          vertexBufferDesc.MiscFlags = 0;\n          vertexBufferDesc.StructureByteStride = 0;\n\n          D3D11_SUBRESOURCE_DATA vertexBufferData;\n          vertexBufferData.pSysMem = cubeVertices;\n          vertexBufferData.SysMemPitch = 0;\n          vertexBufferData.SysMemSlicePitch = 0;\n\n          ComPtr<ID3D11Buffer> vertexBuffer;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateBuffer(\n                  &vertexBufferDesc,\n                  &vertexBufferData,\n                  &vertexBuffer\n                  )\n              );\n\n          D3D11_BUFFER_DESC indexBufferDesc;\n          indexBufferDesc.ByteWidth = sizeof(unsigned short) * ARRAYSIZE(cubeIndices);\n          indexBufferDesc.Usage = D3D11_USAGE_DEFAULT;\n          indexBufferDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;\n          indexBufferDesc.CPUAccessFlags = 0;\n          indexBufferDesc.MiscFlags = 0;\n          indexBufferDesc.StructureByteStride = 0;\n\n          D3D11_SUBRESOURCE_DATA indexBufferData;\n          indexBufferData.pSysMem = cubeIndices;\n          indexBufferData.SysMemPitch = 0;\n          indexBufferData.SysMemSlicePitch = 0;\n\n          ComPtr<ID3D11Buffer> indexBuffer;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateBuffer(\n                  &indexBufferDesc,\n                  &indexBufferData,\n                  &indexBuffer\n                  )\n              );\n\n\n          // Create a constant buffer for passing model, view, and projection matrices\n          // to the vertex shader.  This will allow us to rotate the cube and apply\n          // a perspective projection to it.\n\n          D3D11_BUFFER_DESC constantBufferDesc = {0};\n          constantBufferDesc.ByteWidth = sizeof(m_constantBufferData);\n          constantBufferDesc.Usage = D3D11_USAGE_DEFAULT;\n          constantBufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;\n          constantBufferDesc.CPUAccessFlags = 0;\n          constantBufferDesc.MiscFlags = 0;\n          constantBufferDesc.StructureByteStride = 0;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateBuffer(\n                  &constantBufferDesc,\n                  nullptr,\n                  &m_constantBuffer\n                  )\n              );\n\n          // Specify the view transform corresponding to a camera position of\n          // X = 0, Y = 1, Z = 2.  For a generalized camera class, see Lesson 5.\n\n          m_constantBufferData.view = DirectX::XMFLOAT4X4(\n              -1.00000000f, 0.00000000f,  0.00000000f,  0.00000000f,\n               0.00000000f, 0.89442718f,  0.44721359f,  0.00000000f,\n               0.00000000f, 0.44721359f, -0.89442718f, -2.23606800f,\n               0.00000000f, 0.00000000f,  0.00000000f,  1.00000000f\n              );\n       });\n```\n\n### 3. Creating textures and samplers\n\nHere, we apply texture data to a cube rather than applying colors as in the previous tutorial, [Using depth and effects on primitives](using-depth-and-effects-on-primitives.md).\n\nWe use raw texture data to create textures.\n\n**To create textures and samplers**\n\n1.  First, we read raw texture data from the texturedata.bin file on disk.\n2.  Next, we construct a [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220) structure that references that raw texture data.\n3.  Then, we populate a [**D3D11\\_TEXTURE2D\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476253) structure to describe the texture. We then pass the [**D3D11\\_SUBRESOURCE\\_DATA**](https://msdn.microsoft.com/library/windows/desktop/ff476220) and **D3D11\\_TEXTURE2D\\_DESC** structures in a call to [**ID3D11Device::CreateTexture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476521) to create the texture.\n4.  Next, we create a shader-resource view of the texture so shaders can use the texture. To create the shader-resource view, we populate a [**D3D11\\_SHADER\\_RESOURCE\\_VIEW\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476211) to describe the shader-resource view and pass the shader-resource view description and the texture to [**ID3D11Device::CreateShaderResourceView**](https://msdn.microsoft.com/library/windows/desktop/ff476519). In general, you match the view description with the texture description.\n5.  Next, we create sampler state for the texture. This sampler state uses the relevant texture data to define how the color for a particular texture coordinate is determined. We populate a [**D3D11\\_SAMPLER\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476207) structure to describe the sampler state. We then pass the **D3D11\\_SAMPLER\\_DESC** structure in a call to [**ID3D11Device::CreateSamplerState**](https://msdn.microsoft.com/library/windows/desktop/ff476518) to create the sampler state.\n6.  Finally, we declare a *degree* variable that we will use to animate the cube by rotating it every frame.\n\n```cpp\n        \n        // Load the raw texture data from disk and construct a subresource description that references it.\n        auto loadTDTask = DX::ReadDataAsync(L\"texturedata.bin\");\n          \n        auto constructSubresourceTask = loadTDTask.then([this](const std::vector<byte>& vertexShaderBytecode) {  \n        \n          D3D11_SUBRESOURCE_DATA textureSubresourceData = {0};\n          textureSubresourceData.pSysMem = textureData->Data;\n\n          // Specify the size of a row in bytes, known as a priori about the texture data.\n          textureSubresourceData.SysMemPitch = 1024;\n\n          // As this is not a texture array or 3D texture, this parameter is ignored.\n          textureSubresourceData.SysMemSlicePitch = 0;\n\n          // Create a texture description from information known as a priori about the data.\n          // Generalized texture loading code can be found in the Resource Loading sample.\n          D3D11_TEXTURE2D_DESC textureDesc = {0};\n          textureDesc.Width = 256;\n          textureDesc.Height = 256;\n          textureDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\n          textureDesc.Usage = D3D11_USAGE_DEFAULT;\n          textureDesc.CPUAccessFlags = 0;\n          textureDesc.MiscFlags = 0;\n\n          // Most textures contain more than one MIP level.  For simplicity, this sample uses only one.\n          textureDesc.MipLevels = 1;\n\n          // As this will not be a texture array, this parameter is ignored.\n          textureDesc.ArraySize = 1;\n\n          // Don't use multi-sampling.\n          textureDesc.SampleDesc.Count = 1;\n          textureDesc.SampleDesc.Quality = 0;\n\n          // Allow the texture to be bound as a shader resource.\n          textureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;\n\n          ComPtr<ID3D11Texture2D> texture;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateTexture2D(\n                  &textureDesc,\n                  &textureSubresourceData,\n                  &texture\n                  )\n              );\n\n          // Once the texture is created, we must create a shader resource view of it\n          // so that shaders may use it.  In general, the view description will match\n          // the texture description.\n          D3D11_SHADER_RESOURCE_VIEW_DESC textureViewDesc;\n          ZeroMemory(&textureViewDesc, sizeof(textureViewDesc));\n          textureViewDesc.Format = textureDesc.Format;\n          textureViewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;\n          textureViewDesc.Texture2D.MipLevels = textureDesc.MipLevels;\n          textureViewDesc.Texture2D.MostDetailedMip = 0;\n\n          ComPtr<ID3D11ShaderResourceView> textureView;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateShaderResourceView(\n                  texture.Get(),\n                  &textureViewDesc,\n                  &textureView\n                  )\n              );\n\n          // Once the texture view is created, create a sampler.  This defines how the color\n          // for a particular texture coordinate is determined using the relevant texture data.\n          D3D11_SAMPLER_DESC samplerDesc;\n          ZeroMemory(&samplerDesc, sizeof(samplerDesc));\n\n          samplerDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;\n\n          // The sampler does not use anisotropic filtering, so this parameter is ignored.\n          samplerDesc.MaxAnisotropy = 0;\n\n          // Specify how texture coordinates outside of the range 0..1 are resolved.\n          samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;\n          samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;\n          samplerDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;\n\n          // Use no special MIP clamping or bias.\n          samplerDesc.MipLODBias = 0.0f;\n          samplerDesc.MinLOD = 0;\n          samplerDesc.MaxLOD = D3D11_FLOAT32_MAX;\n\n          // Don't use a comparison function.\n          samplerDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;\n\n          // Border address mode is not used, so this parameter is ignored.\n          samplerDesc.BorderColor[0] = 0.0f;\n          samplerDesc.BorderColor[1] = 0.0f;\n          samplerDesc.BorderColor[2] = 0.0f;\n          samplerDesc.BorderColor[3] = 0.0f;\n\n          ComPtr<ID3D11SamplerState> sampler;\n          DX::ThrowIfFailed(\n              m_d3dDevice->CreateSamplerState(\n                  &samplerDesc,\n                  &sampler\n                  )\n              );\n        });\n\n        // This value will be used to animate the cube by rotating it every frame;\n        float degree = 0.0f;\n```\n\n### 4. Rotating and drawing the textured cube and presenting the rendered image\n\nAs in the previous tutorials, we enter an endless loop to continually render and display the scene. We call the **rotationY** inline function (BasicMath.h) with a rotation amount to set values that will rotate the cube’s model matrix around the Y axis. We then call [**ID3D11DeviceContext::UpdateSubresource**](https://msdn.microsoft.com/library/windows/desktop/ff476486) to update the constant buffer and rotate the cube model. Next, we call [**ID3D11DeviceContext::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) to specify the render target and the depth-stencil view. We call [**ID3D11DeviceContext::ClearRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476388) to clear the render target to a solid blue color and call [**ID3D11DeviceContext::ClearDepthStencilView**](https://msdn.microsoft.com/library/windows/desktop/ff476387) to clear the depth buffer.\n\nIn the endless loop, we also draw the textured cube on the blue surface.\n\n**To draw the textured cube**\n\n1.  First, we call [**ID3D11DeviceContext::IASetInputLayout**](https://msdn.microsoft.com/library/windows/desktop/ff476454) to describe how vertex buffer data is streamed into the input-assembler stage.\n2.  Next, we call [**ID3D11DeviceContext::IASetVertexBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476456) and [**ID3D11DeviceContext::IASetIndexBuffer**](https://msdn.microsoft.com/library/windows/desktop/ff476453) to bind the vertex and index buffers to the input-assembler stage.\n3.  Next, we call [**ID3D11DeviceContext::IASetPrimitiveTopology**](https://msdn.microsoft.com/library/windows/desktop/ff476455) with the [**D3D11\\_PRIMITIVE\\_TOPOLOGY\\_TRIANGLESTRIP**](https://msdn.microsoft.com/library/windows/desktop/ff476189#D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP) value to specify for the input-assembler stage to interpret the vertex data as a triangle strip.\n4.  Next, we call [**ID3D11DeviceContext::VSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476493) to initialize the vertex shader stage with the vertex shader code and [**ID3D11DeviceContext::PSSetShader**](https://msdn.microsoft.com/library/windows/desktop/ff476472) to initialize the pixel shader stage with the pixel shader code.\n5.  Next, we call [**ID3D11DeviceContext::VSSetConstantBuffers**](https://msdn.microsoft.com/library/windows/desktop/ff476491) to set the constant buffer that is used by the vertex shader pipeline stage.\n6.  Next, we call [**PSSetShaderResources**](https://msdn.microsoft.com/library/windows/desktop/ff476473) to bind the shader-resource view of the texture to the pixel shader pipeline stage.\n7.  Next, we call [**PSSetSamplers**](https://msdn.microsoft.com/library/windows/desktop/ff476471) to set the sampler state to the pixel shader pipeline stage.\n8.  Finally, we call [**ID3D11DeviceContext::DrawIndexed**](https://msdn.microsoft.com/library/windows/desktop/ff476409) to draw the cube and submit it to the rendering pipeline.\n\nAs in the previous tutorials, we call [**IDXGISwapChain::Present**](https://msdn.microsoft.com/library/windows/desktop/bb174576) to present the rendered image to the window.\n\n```cpp\n            // Update the constant buffer to rotate the cube model.\n            m_constantBufferData.model = DirectX::XMMatrixRotationY(-degree);\n            degree += 1.0f;\n\n            m_d3dDeviceContext->UpdateSubresource(\n                m_constantBuffer.Get(),\n                0,\n                nullptr,\n                &m_constantBufferData,\n                0,\n                0\n                );\n\n            // Specify the render target and depth stencil we created as the output target.\n            m_d3dDeviceContext->OMSetRenderTargets(\n                1,\n                m_renderTargetView.GetAddressOf(),\n                m_depthStencilView.Get()\n                );\n\n            // Clear the render target to a solid color, and reset the depth stencil.\n            const float clearColor[4] = { 0.071f, 0.04f, 0.561f, 1.0f };\n            m_d3dDeviceContext->ClearRenderTargetView(\n                m_renderTargetView.Get(),\n                clearColor\n                );\n\n            m_d3dDeviceContext->ClearDepthStencilView(\n                m_depthStencilView.Get(),\n                D3D11_CLEAR_DEPTH,\n                1.0f,\n                0\n                );\n\n            m_d3dDeviceContext->IASetInputLayout(inputLayout.Get());\n\n            // Set the vertex and index buffers, and specify the way they define geometry.\n            UINT stride = sizeof(BasicVertex);\n            UINT offset = 0;\n            m_d3dDeviceContext->IASetVertexBuffers(\n                0,\n                1,\n                vertexBuffer.GetAddressOf(),\n                &stride,\n                &offset\n                );\n\n            m_d3dDeviceContext->IASetIndexBuffer(\n                indexBuffer.Get(),\n                DXGI_FORMAT_R16_UINT,\n                0\n                );\n\n            m_d3dDeviceContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n\n            // Set the vertex and pixel shader stage state.\n            m_d3dDeviceContext->VSSetShader(\n                vertexShader.Get(),\n                nullptr,\n                0\n                );\n\n            m_d3dDeviceContext->VSSetConstantBuffers(\n                0,\n                1,\n                m_constantBuffer.GetAddressOf()\n                );\n\n            m_d3dDeviceContext->PSSetShader(\n                pixelShader.Get(),\n                nullptr,\n                0\n                );\n\n            m_d3dDeviceContext->PSSetShaderResources(\n                0,\n                1,\n                textureView.GetAddressOf()\n                );\n\n            m_d3dDeviceContext->PSSetSamplers(\n                0,\n                1,\n                sampler.GetAddressOf()\n                );\n\n            // Draw the cube.\n            m_d3dDeviceContext->DrawIndexed(\n                ARRAYSIZE(cubeIndices),\n                0,\n                0\n                );\n\n            // Present the rendered image to the window.  Because the maximum frame latency is set to 1,\n            // the render loop will generally be throttled to the screen refresh rate, typically around\n            // 60 Hz, by sleeping the application on Present until the screen is refreshed.\n            DX::ThrowIfFailed(\n                m_swapChain->Present(1, 0)\n                );\n```\n\n## Summary\n\n\nWe loaded raw texture data and applied that data to a 3D primitive.\n\n \n\n \n\n\n\n\n"}