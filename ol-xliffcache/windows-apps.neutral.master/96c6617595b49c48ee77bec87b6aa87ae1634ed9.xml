{"nodes":[{"content":"Things you must do for any network-enabled app.","pos":[32,79]},{"content":"Networking basics","pos":[87,104]},{"content":"Networking basics","pos":[161,178]},{"content":"Updated for UWP apps on Windows 10.","pos":[183,218]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[219,311]},{"content":"Things you must do for any network-enabled app.","pos":[316,363]},{"content":"Capabilities","pos":[368,380]},{"content":"In order to use networking, you must add appropriate capability elements to your app manifest.","pos":[382,476]},{"content":"If no network capability is specified in your app's manifest, your app will have no networking capability, and any attempt to connect to the network will fail.","pos":[477,636]},{"content":"The following are the most-used networking capabilities.","pos":[638,694]},{"content":"Capability","pos":[698,708]},{"content":"Description","pos":[711,722]},{"content":"internetClient","pos":[758,772]},{"content":"Provides outbound access to the Internet and networks in public places, like airports and coffee shop.","pos":[777,879]},{"content":"Most apps that require Internet access should use this capability.","pos":[880,946]},{"content":"internetClientServer","pos":[953,973]},{"content":"Gives the app inbound and outbound network access from the Internet and networks in public places like airports and coffee shops.","pos":[978,1107]},{"content":"privateNetworkClientServer","pos":[1114,1140]},{"content":"Gives the app inbound and outbound network access at the user's trusted places, like home and work.","pos":[1145,1244]},{"content":"There are other capabilities that might be necessary for your app, in certain circumstances.","pos":[1248,1340]},{"content":"Capability","pos":[1344,1354]},{"content":"Description","pos":[1357,1368]},{"content":"pushNotifications","pos":[1404,1421]},{"content":"If your app uses socket activity triggers, you must specify this capability in the app manifest.","pos":[1426,1522]},{"content":"enterpriseAuthentication","pos":[1529,1553]},{"content":"Allows an app to connect to network resources that require domain credentials.","pos":[1558,1636]},{"content":"This capability will require a domain administrator to enable the functionality for all apps.","pos":[1637,1730]},{"content":"An example would be an app that retrieves data from SharePoint servers on a private Intranet.","pos":[1731,1824]},{"content":"With this capability your credentials can be used to access network resources on a network that requires credentials.","pos":[1831,1948]},{"content":"An app with this capability can impersonate you on the network.","pos":[1949,2012]},{"content":"This capability is not required to allow an app to access the Internet via an authenticating proxy.","pos":[2019,2118]},{"content":"proximity","pos":[2125,2134]},{"content":"Required for near-field proximity communication with devices in close proximity to the computer.","pos":[2139,2235]},{"content":"Near-field proximity may be used to send or connect with an application on a nearby device.","pos":[2236,2327]},{"content":"This capability allows an app to access the network to connect to a device in close proximity, with user consent to send an invite or accept an invite.","pos":[2334,2485]},{"content":"sharedUserCertificates","pos":[2492,2514]},{"content":"This capability allows an app to access software and hardware certificates, such as smart card certificates.","pos":[2519,2627]},{"content":"When this capability is invoked at runtime, the user must take action, such as inserting a card or selecting a certificate.","pos":[2628,2751]},{"content":"With this capability, your software and hardware certificates or a smart card are used for identification in the app.","pos":[2758,2875]},{"content":"This capability may be used by your employer, bank, or government services for identification.","pos":[2876,2970]},{"content":"Communicating when your app is not in the foreground","pos":[2977,3029]},{"content":"<bpt id=\"p1\">[</bpt>Support your app with background tasks<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt299103)</ept> contains general information about using background tasks to do work when your app is not in the foreground.","pos":[3031,3238]},{"content":"More specifically, your code must take special steps to be notified when it is not the current foreground app and data arrives over the network for it.","pos":[3239,3390]},{"content":"You used Control Channel Triggers for this purpose in Windows 8, and they are still supported in Windows 10.","pos":[3391,3499]},{"content":"Full information about using Control Channel Triggers is available <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>here<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>.","pos":[3500,3636]},{"content":"A new technology in Windows 10 provides better functionality with lower overhead for some scenarios, such as push-enabled stream sockets: the socket broker and socket activity triggers.","pos":[3637,3822]},{"content":"If your app uses <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DatagramSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br241319)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept>, or <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StreamSocketListener<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br226906)</ept>, then your app can transfer ownership of an open socket to a socket broker provided by the system, and then leave the foreground, or even terminate.","pos":[3824,4235]},{"content":"When a connection is made on the transferred socket, or traffic arrives on that socket, then your app or its designated background task are activated.","pos":[4236,4386]},{"content":"If your app is not running, it is started.","pos":[4387,4429]},{"content":"The socket broker then notifies your app using a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SocketActivityTrigger<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn806009)</ept> that new traffic has arrived.","pos":[4430,4594]},{"content":"Your app reclaims the socket from the socket broker and process the traffic on the socket.","pos":[4595,4685]},{"content":"This means that your app consumes far less system resources when it is not actively processing network traffic.","pos":[4686,4797]},{"content":"The socket broker is intended to replace Control Channel Triggers where it is applicable, because it provides the same functionality, but with fewer restrictions and a smaller memory footprint.","pos":[4799,4992]},{"content":"Socket broker can be used by apps that are not lock screen apps, and it is used the same way on phones as on other devices.","pos":[4993,5116]},{"content":"Apps need not be running when traffic arrives in order to be activated by the socket broker.","pos":[5117,5209]},{"content":"And the socket broker supports listening on TCP sockets, which Control Channel Triggers do not support.","pos":[5210,5313]},{"pos":[5315,5432],"content":"If your app uses socket activity triggers, you must specify the <bpt id=\"p1\">**</bpt>pushNotifications<ept id=\"p1\">**</ept> capability in the app manifest."},{"content":"Choosing a network trigger","pos":[5438,5464]},{"content":"There are some scenarios where either kind of trigger would be suitable.","pos":[5466,5538]},{"content":"When you are choosing which kind of trigger to use in your app, consider the following advice.","pos":[5539,5633]},{"pos":[5639,6020],"content":"If you are using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IXMLHTTPRequest2<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh831151)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>System.Net.Http.HttpClient<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/dn298639)</ept> or <bpt id=\"p5\">[</bpt>System.Net.Http.HttpClientHandler<ept id=\"p5\">](http://go.microsoft.com/fwlink/p/?linkid=241638)</ept>, you must use <bpt id=\"p6\">[</bpt><bpt id=\"p7\">**</bpt>ControlChannelTrigger<ept id=\"p7\">**</ept><ept id=\"p6\">](https://msdn.microsoft.com/library/windows/apps/hh701032)</ept>."},{"content":"If you are using push-enabled <bpt id=\"p1\">**</bpt>StreamSockets<ept id=\"p1\">**</ept>, you can use control channel triggers, but should prefer <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>SocketActivityTrigger<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/dn806009)</ept>.","pos":[6025,6216]},{"content":"The latter choice allows the system to free up memory and reduce power requirements when the connection is not being actively used.","pos":[6217,6348]},{"pos":[6353,6569],"content":"If you want to minimize the memory footprint of your app when it is not actively servicing network requests, prefer <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SocketActivityTrigger<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn806009)</ept> when possible."},{"pos":[6574,6759],"content":"If you want your app to be able to receive data while the system is in Connected Standby mode, use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SocketActivityTrigger<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/dn806009)</ept>."},{"pos":[6761,6911],"content":"For details and examples of how to use the socket broker, see <bpt id=\"p1\">[</bpt>Network communications in the background<ept id=\"p1\">](network-communications-in-the-background.md)</ept>."},{"content":"Secured connections","pos":[6916,6935]},{"content":"Secure Sockets Layer (SSL) and the more recent Transport Layer Security (TLS) are cryptographic protocols designed to provide authentication and encryption for network communication.","pos":[6937,7119]},{"content":"These protocols are designed to prevent eavesdropping and tampering when sending and receiving network data.","pos":[7120,7228]},{"content":"These protocols use a client-server model for the protocol exchanges.","pos":[7229,7298]},{"content":"These protocols also use digital certificates and certificate authorities to verify that the server is who it claims to be.","pos":[7299,7422]},{"content":"Creating secure socket connections","pos":[7428,7462]},{"content":"A <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept> object can be configured to use SSL/TLS for communications between the client and the server.","pos":[7464,7636]},{"content":"This support for SSL/TLS is limited to using the <bpt id=\"p1\">**</bpt>StreamSocket<ept id=\"p1\">**</ept> object as the client in the SSL/TLS negotiation.","pos":[7637,7751]},{"content":"You cannot use SSL/TLS with the <bpt id=\"p1\">**</bpt>StreamSocket<ept id=\"p1\">**</ept> created by a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>StreamSocketListener<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br226906)</ept> when incoming communications are received, because SSL/TLS negotiation as a server is not implemented by the <bpt id=\"p4\">**</bpt>StreamSocket<ept id=\"p4\">**</ept> class.","pos":[7752,8031]},{"pos":[8033,8165],"content":"There are two ways to secure a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept> connection with SSL/TLS:"},{"pos":[8171,8363],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ConnectAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701504)</ept> - Make the initial connection to a network service and negotiate immediately to use SSL/TLS for all communications."},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UpgradeToSslAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226922)</ept> - Connect initially to a network service without encryption.","pos":[8368,8510]},{"content":"The app may send or receive data.","pos":[8511,8544]},{"content":"Then, upgrade the connection to use SSL/TLS for all further communications.","pos":[8545,8620]},{"content":"The SocketProtectionLevel value that you provide sets the minimum protection level you are willing to allow.","pos":[8622,8730]},{"content":"However, the eventual protection level of the established connection is determined in a negotiation process between both endpoints of the connection.","pos":[8731,8880]},{"content":"The result can be a more-secure protection level than the one you specified, if the other endpoint requires a higher level.","pos":[8881,9004]},{"content":"The SSL strength actually negotiated using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ConnectAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701504)</ept> or <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>UpgradeToSslAsync<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226922)</ept> can be determined by getting the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StreamSocketinformation.ProtectionLevel<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh967868)</ept> property after the async operation has completed successfully.","pos":[9005,9409]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Your code should never implicitly depend on using a particular protection level, or on the assumption that a given security level is used by default.","pos":[9413,9572]},{"content":"The security landscape changes constantly, and protocols and default protection levels will be changed over time in order to avoid the use of protocols with known weaknesses.","pos":[9573,9747]},{"content":"Defaults can vary depending on individual machine configuration, or on which software is installed and which patches have been applied.","pos":[9748,9883]},{"content":"If your app depends on the use of a particular security level, you must explicitly specify that level and then check to be sure that it is actually in use on the established connection.","pos":[9884,10069]},{"content":"Use ConnectAsync","pos":[10075,10091]},{"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ConnectAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701504)</ept> can be used to establish the initial connection with a network service and then negotiate immediately to use SSL/TLS for all communications.","pos":[10093,10310]},{"content":"There are two <bpt id=\"p1\">**</bpt>ConnectAsync<ept id=\"p1\">**</ept> methods that support passing a <bpt id=\"p2\">*</bpt>protectionLevel<ept id=\"p2\">*</ept> parameter:","pos":[10311,10401]},{"pos":[10407,10880],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ConnectAsync(EndpointPair, SocketProtectionLevel)<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701511)</ept> - Starts an asynchronous operation on a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept> object to connect to a remote network destination specified as an <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>EndpointPair<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/hh700953)</ept> object and a <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>SocketProtectionLevel<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/apps/br226880)</ept>."},{"pos":[10885,11309],"content":"<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ConnectAsync(HostName, String, SocketProtectionLevel)<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226916)</ept> - Starts an asynchronous operation on a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept> object to connect to a remote destination specified by a remote hostname, a remote service name, and a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>SocketProtectionLevel<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br226880)</ept>."},{"content":"If the <bpt id=\"p1\">*</bpt>protectionLevel<ept id=\"p1\">*</ept> parameter is set to <bpt id=\"p2\">**</bpt>Windows.Networking.Sockets.SocketProtectionLevel.Ssl<ept id=\"p2\">**</ept> when calling either of the above <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ConnectAsync<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701504)</ept> methods, the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StreamSocket<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept> must will be established to use SSL/TLS for encryption.","pos":[11311,11668]},{"content":"This value requires encryption and never allows a NULL cipher to be used.","pos":[11669,11742]},{"pos":[11744,11886],"content":"The normal sequence to use with one of these <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ConnectAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701504)</ept> methods is the same."},{"pos":[11892,11978],"content":"Create a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept>."},{"content":"If an advanced option on the socket is needed, use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamSocket.Control<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226917)</ept> property to get the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocketControl<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226893)</ept> instance associated with a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StreamSocket<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept> object.","pos":[11983,12338]},{"content":"Set a property on the <bpt id=\"p1\">**</bpt>StreamSocketControl<ept id=\"p1\">**</ept>.","pos":[12339,12385]},{"pos":[12390,12599],"content":"Call one of the above <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ConnectAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701504)</ept> methods to start an operation to connect to a remote destination and immediately negotiate the use of SSL/TLS."},{"pos":[12604,12923],"content":"The SSL strength actually negotiated using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ConnectAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701504)</ept> can be determined by getting the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocketinformation.ProtectionLevel<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh967868)</ept> property after the async operation has completed successfully."},{"content":"The following example creates a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept> and tries to establish a connection to the network service and negotiate immediately to use SSL/TLS.","pos":[12925,13134]},{"content":"If the negotiation is successful, all network communication using the <bpt id=\"p1\">**</bpt>StreamSocket<ept id=\"p1\">**</ept> between the client the network server will be encrypted.","pos":[13135,13278]},{"content":"[!div class=\"tabbedCodeSnippets\"]","pos":[13282,13315]},{"content":"Use UpgradeToSslAsync","pos":[15752,15773]},{"content":"When your code uses <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UpgradeToSslAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226922)</ept>, it first establishes a connection to a network service without encryption.","pos":[15775,15952]},{"content":"The app may send or receive some data, then upgrade the connection to use SSL/TLS for all further communications.","pos":[15953,16066]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UpgradeToSslAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226922)</ept> method takes two parameters.","pos":[16068,16182]},{"content":"The <bpt id=\"p1\">*</bpt>protectionLevel<ept id=\"p1\">*</ept> parameter indicates the protection level desired.","pos":[16183,16254]},{"content":"The <bpt id=\"p1\">*</bpt>validationHostName<ept id=\"p1\">*</ept> parameter is the hostname of the remote network destination that is used for validation when upgrading to SSL.","pos":[16255,16390]},{"content":"Normally the <bpt id=\"p1\">*</bpt>validationHostName<ept id=\"p1\">*</ept> would be the same hostname that the app used to initially establish the connection.","pos":[16391,16508]},{"content":"If the <bpt id=\"p1\">*</bpt>protectionLevel<ept id=\"p1\">*</ept> parameter is set to <bpt id=\"p2\">**</bpt>Windows.System.Socket.SocketProtectionLevel.Ssl<ept id=\"p2\">**</ept> when calling <bpt id=\"p3\">**</bpt>UpgradeToSslAsync<ept id=\"p3\">**</ept>, the <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>StreamSocket<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept> must use the SSL/TLS for encryption on further communications over the socket.","pos":[16509,16801]},{"content":"This value requires encryption and never allows a NULL cipher to be used.","pos":[16802,16875]},{"pos":[16877,17016],"content":"The normal sequence to use with the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UpgradeToSslAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226922)</ept> method is as follows:"},{"pos":[17022,17108],"content":"Create a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept>."},{"content":"If an advanced option on the socket is needed, use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamSocket.Control<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226917)</ept> property to get the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocketControl<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226893)</ept> instance associated with a <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StreamSocket<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept> object.","pos":[17113,17468]},{"content":"Set a property on the <bpt id=\"p1\">**</bpt>StreamSocketControl<ept id=\"p1\">**</ept>.","pos":[17469,17515]},{"content":"If any data needs to be sent and received unencrypted, send it now.","pos":[17520,17587]},{"pos":[17592,17753],"content":"Call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UpgradeToSslAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226922)</ept> method to start an operation to upgrade the connection to use SSL/TLS."},{"pos":[17758,18078],"content":"The SSL strength actually negotiated using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>UpgradeToSslAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226922)</ept> can be determined by getting the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>StreamSocketinformation.ProtectionLevel<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh967868)</ept> property after the async operation completes successfully."},{"content":"The following example creates a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept>, tries to establish a connection to the network service, sends some initial data, and then negotiates to use SSL/TLS.","pos":[18080,18306]},{"content":"If the negotiation is successful, all network communication using the <bpt id=\"p1\">**</bpt>StreamSocket<ept id=\"p1\">**</ept> between the client and the network server will be encrypted.","pos":[18307,18454]},{"content":"[!div class=\"tabbedCodeSnippets\"]","pos":[18458,18491]},{"content":"Creating secure WebSocket connections","pos":[24403,24440]},{"content":"Like traditional socket connections, WebSocket connections can also be encrypted with Transport Layer Security (TLS)/Secure Sockets Layer (SSL) when using the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamWebSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226923)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>MessageWebSocket<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br226842)</ept> features in Windows 8 for a Windows Store app.","pos":[24442,24812]},{"content":"In most cases you'll want to use a secure WebSocket connection.","pos":[24813,24876]},{"content":"This will increase the chances that your connection will succeed, as many proxies will reject unencrypted WebSocket connections.","pos":[24877,25005]},{"pos":[25007,25220],"content":"For examples of how to create, or upgrade to, a secure socket connection to a network service, see <bpt id=\"p1\">[</bpt>How to secure WebSocket connections with TLS/SSL<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh994399)</ept>."},{"content":"In addition to TLS/SSL encryption, a server may require a <bpt id=\"p1\">**</bpt>Sec-WebSocket-Protocol<ept id=\"p1\">**</ept> header value to complete the initial handshake.","pos":[25222,25354]},{"content":"This value, represented by the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamWebSocketInformation.Protocol<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701514)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>MessageWebSocketInformation.Protocol<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701358)</ept> properties, indicate the protocol version of the connection and enables the server to correctly interpret the opening handshake and the data being exchanged afterwards.","pos":[25355,25759]},{"content":"Using this protocol information, if at any point if the server cannot interpret the incoming data in a safe manner the connection can be closed.","pos":[25760,25904]},{"content":"If the initial request from the client either does not contain this value, or provides a value that doesn't match what the server expects, the expected value is sent from the server to the client on WebSocket handshake error.","pos":[25906,26131]},{"content":"Authentication","pos":[26136,26150]},{"content":"How to provide authentication credentials when connecting over the network.","pos":[26152,26227]},{"content":"Providing a client certificate with the StreamSocket class","pos":[26233,26291]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Networking.StreamSocket<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226882)</ept> class supports using SSL/TLS to authenticate the server the app is talking to.","pos":[26293,26471]},{"content":"In certain cases, the app also needs to authenticate itself to the server using a TLS client certificate.","pos":[26472,26577]},{"content":"In Windows 10, you can provide a client certificate on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamSocket.Control<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br226893)</ept> object (this must be set before the TLS handshake is started).","pos":[26578,26784]},{"content":"If the server requests the client certificate, Windows will respond with the certificate provided.","pos":[26785,26883]},{"content":"Here is a code snippet showing how to implement this:","pos":[26885,26938]},{"content":"Providing authentication credentials to a web service","pos":[27201,27254]},{"content":"The networking APIs that enable apps to interact with secure web services each provide their own methods to either initialize a client or set a request header with server and proxy authentication credentials.","pos":[27256,27464]},{"content":"Each method is set with a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PasswordCredential<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br227061)</ept> object that indicates a user name, password, and the resource for which these credentials are used.","pos":[27465,27673]},{"content":"The following table provides a mapping of these APIs:","pos":[27674,27727]},{"content":"WebSockets","pos":[27733,27743]},{"content":"MessageWebSocketControl.ServerCredential","pos":[27751,27791]},{"content":"MessageWebSocketControl.ProxyCredential","pos":[27998,28037]},{"content":"StreamWebSocketControl.ServerCredential","pos":[28109,28148]},{"content":"StreamWebSocketControl.ProxyCredential","pos":[28220,28258]},{"content":"Background Transfer","pos":[28334,28353]},{"content":"BackgroundDownloader.ServerCredential","pos":[28361,28398]},{"content":"BackgroundDownloader.ProxyCredential","pos":[28470,28506]},{"content":"BackgroundUploader.ServerCredential","pos":[28578,28613]},{"content":"BackgroundUploader.ProxyCredential","pos":[28685,28719]},{"content":"Syndication","pos":[28795,28806]},{"content":"SyndicationClient(PasswordCredential)","pos":[28814,28851]},{"content":"SyndicationClient.ServerCredential","pos":[28923,28957]},{"content":"SyndicationClient.ProxyCredential","pos":[29029,29062]},{"content":"AtomPub","pos":[29138,29145]},{"content":"AtomPubClient(PasswordCredential)","pos":[29153,29186]},{"content":"AtomPubClient.ServerCredential","pos":[29258,29288]},{"content":"AtomPubClient.ProxyCredential","pos":[29360,29389]},{"content":"Handling network exceptions","pos":[29458,29485]},{"content":"In most areas of programming, an exception indicates a significant problem or failure, caused by some flaw in the program.","pos":[29487,29609]},{"content":"In network programming, there is an additional source for exceptions: the network itself, and the nature of network communications.","pos":[29610,29741]},{"content":"Network communications are inherently unreliable and prone to unexpected failure.","pos":[29742,29823]},{"content":"For each of the ways your app uses networking, you must maintain some state information; and your app code must handle network exceptions by updating that state information and initiating appropriate logic for your app to re-establish or retry communication failures.","pos":[29824,30091]},{"content":"When Universal Windows apps throw an exception, your exception handler can retrieve more detailed information on the cause of the exception to better understand the failure and make appropriate decisions.","pos":[30093,30297]},{"content":"Each language projection supports a method to access this more detailed information.","pos":[30299,30383]},{"content":"An exception projects as an <bpt id=\"p1\">**</bpt>HRESULT<ept id=\"p1\">**</ept> value in Universal Windows apps.","pos":[30384,30456]},{"content":"The <bpt id=\"p1\">*</bpt>Winerror.h<ept id=\"p1\">*</ept> include file contains a very large list of possible <bpt id=\"p2\">**</bpt>HRESULT<ept id=\"p2\">**</ept> values that includes network errors.","pos":[30457,30574]},{"content":"The networking APIs support different methods for retrieving this detailed information on the cause of an exception.","pos":[30576,30692]},{"pos":[30698,30811],"content":"Some APIs provide a helper method that converts the <bpt id=\"p1\">**</bpt>HRESULT<ept id=\"p1\">**</ept> value from the exception to an enumeration value."},{"pos":[30816,30885],"content":"Other APIs provide a method to retrieve the actual <bpt id=\"p1\">**</bpt>HRESULT<ept id=\"p1\">**</ept> value."},{"content":"Related topics","pos":[30890,30904]},{"content":"Networking API Improvements in Windows 10","pos":[30909,30950]}],"content":"---\nauthor: DelfCo\ndescription: Things you must do for any network-enabled app.\ntitle: Networking basics\nms.assetid: 1F47D33B-6F00-4F74-A52D-538851FD38BE\n---\n\n# Networking basics\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nThings you must do for any network-enabled app.\n\n## Capabilities\n\nIn order to use networking, you must add appropriate capability elements to your app manifest. If no network capability is specified in your app's manifest, your app will have no networking capability, and any attempt to connect to the network will fail.\n\nThe following are the most-used networking capabilities.\n\n| Capability | Description |\n|------------|-------------|\n| **internetClient** | Provides outbound access to the Internet and networks in public places, like airports and coffee shop. Most apps that require Internet access should use this capability. |\n| **internetClientServer** | Gives the app inbound and outbound network access from the Internet and networks in public places like airports and coffee shops. |\n| **privateNetworkClientServer** | Gives the app inbound and outbound network access at the user's trusted places, like home and work. |\n\nThere are other capabilities that might be necessary for your app, in certain circumstances.\n\n| Capability | Description |\n|------------|-------------|\n| **pushNotifications** | If your app uses socket activity triggers, you must specify this capability in the app manifest. |\n| **enterpriseAuthentication** | Allows an app to connect to network resources that require domain credentials. This capability will require a domain administrator to enable the functionality for all apps. An example would be an app that retrieves data from SharePoint servers on a private Intranet. <br/> With this capability your credentials can be used to access network resources on a network that requires credentials. An app with this capability can impersonate you on the network. <br/> This capability is not required to allow an app to access the Internet via an authenticating proxy. |\n| **proximity** | Required for near-field proximity communication with devices in close proximity to the computer. Near-field proximity may be used to send or connect with an application on a nearby device. <br/> This capability allows an app to access the network to connect to a device in close proximity, with user consent to send an invite or accept an invite. |\n| **sharedUserCertificates** | This capability allows an app to access software and hardware certificates, such as smart card certificates. When this capability is invoked at runtime, the user must take action, such as inserting a card or selecting a certificate. <br/> With this capability, your software and hardware certificates or a smart card are used for identification in the app. This capability may be used by your employer, bank, or government services for identification. |\n\n## Communicating when your app is not in the foreground\n\n[Support your app with background tasks](https://msdn.microsoft.com/library/windows/apps/mt299103) contains general information about using background tasks to do work when your app is not in the foreground. More specifically, your code must take special steps to be notified when it is not the current foreground app and data arrives over the network for it. You used Control Channel Triggers for this purpose in Windows 8, and they are still supported in Windows 10. Full information about using Control Channel Triggers is available [**here**](https://msdn.microsoft.com/library/windows/apps/hh701032). A new technology in Windows 10 provides better functionality with lower overhead for some scenarios, such as push-enabled stream sockets: the socket broker and socket activity triggers.\n\nIf your app uses [**DatagramSocket**](https://msdn.microsoft.com/library/windows/apps/br241319), [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882), or [**StreamSocketListener**](https://msdn.microsoft.com/library/windows/apps/br226906), then your app can transfer ownership of an open socket to a socket broker provided by the system, and then leave the foreground, or even terminate. When a connection is made on the transferred socket, or traffic arrives on that socket, then your app or its designated background task are activated. If your app is not running, it is started. The socket broker then notifies your app using a [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009) that new traffic has arrived. Your app reclaims the socket from the socket broker and process the traffic on the socket. This means that your app consumes far less system resources when it is not actively processing network traffic.\n\nThe socket broker is intended to replace Control Channel Triggers where it is applicable, because it provides the same functionality, but with fewer restrictions and a smaller memory footprint. Socket broker can be used by apps that are not lock screen apps, and it is used the same way on phones as on other devices. Apps need not be running when traffic arrives in order to be activated by the socket broker. And the socket broker supports listening on TCP sockets, which Control Channel Triggers do not support.\n\nIf your app uses socket activity triggers, you must specify the **pushNotifications** capability in the app manifest.\n\n### Choosing a network trigger\n\nThere are some scenarios where either kind of trigger would be suitable. When you are choosing which kind of trigger to use in your app, consider the following advice.\n\n-   If you are using [**IXMLHTTPRequest2**](https://msdn.microsoft.com/library/windows/desktop/hh831151), [**System.Net.Http.HttpClient**](https://msdn.microsoft.com/library/windows/apps/dn298639) or [System.Net.Http.HttpClientHandler](http://go.microsoft.com/fwlink/p/?linkid=241638), you must use [**ControlChannelTrigger**](https://msdn.microsoft.com/library/windows/apps/hh701032).\n-   If you are using push-enabled **StreamSockets**, you can use control channel triggers, but should prefer [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009). The latter choice allows the system to free up memory and reduce power requirements when the connection is not being actively used.\n-   If you want to minimize the memory footprint of your app when it is not actively servicing network requests, prefer [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009) when possible.\n-   If you want your app to be able to receive data while the system is in Connected Standby mode, use [**SocketActivityTrigger**](https://msdn.microsoft.com/library/windows/apps/dn806009).\n\nFor details and examples of how to use the socket broker, see [Network communications in the background](network-communications-in-the-background.md).\n\n## Secured connections\n\nSecure Sockets Layer (SSL) and the more recent Transport Layer Security (TLS) are cryptographic protocols designed to provide authentication and encryption for network communication. These protocols are designed to prevent eavesdropping and tampering when sending and receiving network data. These protocols use a client-server model for the protocol exchanges. These protocols also use digital certificates and certificate authorities to verify that the server is who it claims to be.\n\n### Creating secure socket connections\n\nA [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882) object can be configured to use SSL/TLS for communications between the client and the server. This support for SSL/TLS is limited to using the **StreamSocket** object as the client in the SSL/TLS negotiation. You cannot use SSL/TLS with the **StreamSocket** created by a [**StreamSocketListener**](https://msdn.microsoft.com/library/windows/apps/br226906) when incoming communications are received, because SSL/TLS negotiation as a server is not implemented by the **StreamSocket** class.\n\nThere are two ways to secure a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882) connection with SSL/TLS:\n\n-   [**ConnectAsync**](https://msdn.microsoft.com/library/windows/apps/hh701504) - Make the initial connection to a network service and negotiate immediately to use SSL/TLS for all communications.\n-   [**UpgradeToSslAsync**](https://msdn.microsoft.com/library/windows/apps/br226922) - Connect initially to a network service without encryption. The app may send or receive data. Then, upgrade the connection to use SSL/TLS for all further communications.\n\nThe SocketProtectionLevel value that you provide sets the minimum protection level you are willing to allow. However, the eventual protection level of the established connection is determined in a negotiation process between both endpoints of the connection. The result can be a more-secure protection level than the one you specified, if the other endpoint requires a higher level. The SSL strength actually negotiated using [**ConnectAsync**](https://msdn.microsoft.com/library/windows/apps/hh701504) or [**UpgradeToSslAsync**](https://msdn.microsoft.com/library/windows/apps/br226922) can be determined by getting the [**StreamSocketinformation.ProtectionLevel**](https://msdn.microsoft.com/library/windows/apps/hh967868) property after the async operation has completed successfully.\n\n> **Note**  Your code should never implicitly depend on using a particular protection level, or on the assumption that a given security level is used by default. The security landscape changes constantly, and protocols and default protection levels will be changed over time in order to avoid the use of protocols with known weaknesses. Defaults can vary depending on individual machine configuration, or on which software is installed and which patches have been applied. If your app depends on the use of a particular security level, you must explicitly specify that level and then check to be sure that it is actually in use on the established connection.\n\n### Use ConnectAsync\n\n[**ConnectAsync**](https://msdn.microsoft.com/library/windows/apps/hh701504) can be used to establish the initial connection with a network service and then negotiate immediately to use SSL/TLS for all communications. There are two **ConnectAsync** methods that support passing a *protectionLevel* parameter:\n\n-   [**ConnectAsync(EndpointPair, SocketProtectionLevel)**](https://msdn.microsoft.com/library/windows/apps/hh701511) - Starts an asynchronous operation on a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882) object to connect to a remote network destination specified as an [**EndpointPair**](https://msdn.microsoft.com/library/windows/apps/hh700953) object and a [**SocketProtectionLevel**](https://msdn.microsoft.com/library/windows/apps/br226880).\n-   [**ConnectAsync(HostName, String, SocketProtectionLevel)**](https://msdn.microsoft.com/library/windows/apps/br226916) - Starts an asynchronous operation on a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882) object to connect to a remote destination specified by a remote hostname, a remote service name, and a [**SocketProtectionLevel**](https://msdn.microsoft.com/library/windows/apps/br226880).\n\nIf the *protectionLevel* parameter is set to **Windows.Networking.Sockets.SocketProtectionLevel.Ssl** when calling either of the above [**ConnectAsync**](https://msdn.microsoft.com/library/windows/apps/hh701504) methods, the [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882) must will be established to use SSL/TLS for encryption. This value requires encryption and never allows a NULL cipher to be used.\n\nThe normal sequence to use with one of these [**ConnectAsync**](https://msdn.microsoft.com/library/windows/apps/hh701504) methods is the same.\n\n-   Create a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882).\n-   If an advanced option on the socket is needed, use the [**StreamSocket.Control**](https://msdn.microsoft.com/library/windows/apps/br226917) property to get the [**StreamSocketControl**](https://msdn.microsoft.com/library/windows/apps/br226893) instance associated with a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882) object. Set a property on the **StreamSocketControl**.\n-   Call one of the above [**ConnectAsync**](https://msdn.microsoft.com/library/windows/apps/hh701504) methods to start an operation to connect to a remote destination and immediately negotiate the use of SSL/TLS.\n-   The SSL strength actually negotiated using [**ConnectAsync**](https://msdn.microsoft.com/library/windows/apps/hh701504) can be determined by getting the [**StreamSocketinformation.ProtectionLevel**](https://msdn.microsoft.com/library/windows/apps/hh967868) property after the async operation has completed successfully.\n\nThe following example creates a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882) and tries to establish a connection to the network service and negotiate immediately to use SSL/TLS. If the negotiation is successful, all network communication using the **StreamSocket** between the client the network server will be encrypted.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\nusing Windows.Networking;\nusing Windows.Networking.Sockets;\n\n    // Define some variables and set values\n    StreamSocket clientSocket = new StreamSocket();\n     \n    HostName serverHost = new HostName(\"www.contoso.com\");\n    string serverServiceName = \"https\";\n    \n    // For simplicity, the sample omits implementation of the\n    // NotifyUser method used to display status and error messages \n    \n    // Try to connect to contoso using HTTPS (port 443)\n    try {\n\n        // Call ConnectAsync method with SSL\n        await clientSocket.ConnectAsync(serverHost, serverServiceName, SocketProtectionLevel.Ssl);\n\n        NotifyUser(\"Connected\");\n    }\n    catch (Exception exception) {\n        // If this is an unknown status it means that the error is fatal and retry will likely fail.\n        if (SocketError.GetStatus(exception.HResult) == SocketErrorStatus.Unknown) {\n            throw;\n        }\n        \n        NotifyUser(\"Connect failed with error: \" + exception.Message);\n        // Could retry the connection, but for this simple example\n        // just close the socket.\n        \n        clientSocket.Dispose();\n        clientSocket = null; \n    }\n           \n    // Add code to send and receive data using the clientSocket\n    // and then close the clientSocket\n```\n```cpp\nusing Windows::Networking;\nusing Windows::Networking::Sockets;\n\n    // Define some variables and set values\n    StreamSocket^ clientSocket = new ref StreamSocket();\n \n    HostName^ serverHost = new ref HostName(\"www.contoso.com\");\n    String serverServiceName = \"https\";\n\n    // For simplicity, the sample omits implementation of the\n    // NotifyUser method used to display status and error messages \n\n    // Try to connect to the server using HTTPS and SSL (port 443)\n    task<void>(clientSocket->ConnectAsync(serverHost, serverServiceName, SocketProtectionLevel::SSL)).then([this] (task<void> previousTask) {\n        try\n        {\n            // Try getting all exceptions from the continuation chain above this point.\n            previousTask.Get();\n            NotifyUser(\"Connected\");\n        }\n        catch (Exception^ exception)\n        {\n            NotifyUser(\"Connect failed with error: \" + exception->Message);\n            \n            clientSocket.Close();\n            clientSocket = null;\n        }\n    });\n    // Add code to send and receive data using the clientSocket\n    // Then close the clientSocket when done\n```\n\n### Use UpgradeToSslAsync\n\nWhen your code uses [**UpgradeToSslAsync**](https://msdn.microsoft.com/library/windows/apps/br226922), it first establishes a connection to a network service without encryption. The app may send or receive some data, then upgrade the connection to use SSL/TLS for all further communications.\n\nThe [**UpgradeToSslAsync**](https://msdn.microsoft.com/library/windows/apps/br226922) method takes two parameters. The *protectionLevel* parameter indicates the protection level desired. The *validationHostName* parameter is the hostname of the remote network destination that is used for validation when upgrading to SSL. Normally the *validationHostName* would be the same hostname that the app used to initially establish the connection. If the *protectionLevel* parameter is set to **Windows.System.Socket.SocketProtectionLevel.Ssl** when calling **UpgradeToSslAsync**, the [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882) must use the SSL/TLS for encryption on further communications over the socket. This value requires encryption and never allows a NULL cipher to be used.\n\nThe normal sequence to use with the [**UpgradeToSslAsync**](https://msdn.microsoft.com/library/windows/apps/br226922) method is as follows:\n\n-   Create a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882).\n-   If an advanced option on the socket is needed, use the [**StreamSocket.Control**](https://msdn.microsoft.com/library/windows/apps/br226917) property to get the [**StreamSocketControl**](https://msdn.microsoft.com/library/windows/apps/br226893) instance associated with a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882) object. Set a property on the **StreamSocketControl**.\n-   If any data needs to be sent and received unencrypted, send it now.\n-   Call the [**UpgradeToSslAsync**](https://msdn.microsoft.com/library/windows/apps/br226922) method to start an operation to upgrade the connection to use SSL/TLS.\n-   The SSL strength actually negotiated using [**UpgradeToSslAsync**](https://msdn.microsoft.com/library/windows/apps/br226922) can be determined by getting the [**StreamSocketinformation.ProtectionLevel**](https://msdn.microsoft.com/library/windows/apps/hh967868) property after the async operation completes successfully.\n\nThe following example creates a [**StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882), tries to establish a connection to the network service, sends some initial data, and then negotiates to use SSL/TLS. If the negotiation is successful, all network communication using the **StreamSocket** between the client and the network server will be encrypted.\n\n> [!div class=\"tabbedCodeSnippets\"]\n```csharp\nusing Windows.Networking;\nusing Windows.Networking.Sockets;\nusing Windows.Storage.Streams;\n\n    // Define some variables and set values\n    StreamSocket clientSocket = new StreamSocket();\n \n    HostName serverHost = new HostName(\"www.contoso.com\");\n    string serverServiceName = \"http\";\n\n    // For simplicity, the sample omits implementation of the\n    // NotifyUser method used to display status and error messages \n\n    // Try to connect to contoso using HTTP (port 80)\n    try {\n        // Call ConnectAsync method with a plain socket\n        await clientSocket.ConnectAsync(serverHost, serverServiceName, SocketProtectionLevel.PlainSocket);\n\n        NotifyUser(\"Connected\");\n\n    }\n    catch (Exception exception) {\n        // If this is an unknown status it means that the error is fatal and retry will likely fail.\n        if (SocketError.GetStatus(exception.HResult) == SocketErrorStatus.Unknown) {\n            throw;\n        }\n\n        NotifyUser(\"Connect failed with error: \" + exception.Message, NotifyType.ErrorMessage);\n        // Could retry the connection, but for this simple example\n        // just close the socket.\n\n        clientSocket.Dispose();\n        clientSocket = null; \n        return;\n    }\n\n    // Now try to sent some data\n    DataWriter writer = new DataWriter(clientSocket.OutputStream);\n    string hello = \"Hello World  \";\n    Int32 len = (int) writer.MeasureString(hello); // Gets the UTF-8 string length.\n    writer.WriteInt32(len);\n    writer.WriteString(hello);\n    NotifyUser(\"Client: sending hello\");\n\n    try {\n        // Call StoreAsync method to store the hello message\n        await writer.StoreAsync();\n\n        NotifyUser(\"Client: sent data\");\n\n        writer.DetachStream(); // Detach stream, if not, DataWriter destructor will close it.\n    }\n    catch (Exception exception) {\n        NotifyUser(\"Store failed with error: \" + exception.Message);\n        // Could retry the store, but for this simple example\n            // just close the socket.\n\n            clientSocket.Dispose();\n            clientSocket = null; \n            return;\n    }\n\n    // Now upgrade the client to use SSL\n    try {\n        // Try to upgrade to SSL\n        await clientSocket.UpgradeToSslAsync(SocketProtectionLevel.Ssl, serverHost);\n\n        NotifyUser(\"Client: upgrade to SSL completed\");\n           \n        // Add code to send and receive data \n        // The close clientSocket when done\n    }\n    catch (Exception exception) {\n        // If this is an unknown status it means that the error is fatal and retry will likely fail.\n        if (SocketError.GetStatus(exception.HResult) == SocketErrorStatus.Unknown) {\n            throw;\n        }\n\n        NotifyUser(\"Upgrade to SSL failed with error: \" + exception.Message);\n\n        clientSocket.Dispose();\n        clientSocket = null; \n        return;\n    }\n```\n```cpp\nusing Windows::Networking;\nusing Windows::Networking::Sockets;\nusing Windows::Storage::Streams;\n\n    // Define some variables and set values\n    StreamSocket^ clientSocket = new ref StreamSocket();\n \n    Hostname^ serverHost = new ref HostName(\"www.contoso.com\");\n    String serverServiceName = \"http\";\n\n    // For simplicity, the sample omits implementation of the\n    // NotifyUser method used to display status and error messages \n\n    // Try to connect to contoso using HTTP (port 80)\n    task<void>(clientSocket->ConnectAsync(serverHost, serverServiceName, SocketProtectionLevel::PlainSocket)).then([this] (task<void> previousTask) {\n        try\n        {\n            // Try getting all exceptions from the continuation chain above this point.\n            previousTask.Get();\n            NotifyUser(\"Connected\");\n\n        }\n        catch (Exception^ exception)\n        {\n            NotifyUser(\"Connect failed with error: \" + exception->Message);\n \n            clientSocket->Close();\n            clientSocket = null;\n        }\n    });\n       \n    // Now try to sent some data\n    DataWriter^ writer = new ref DataWriter(clientSocket.OutputStream);\n    String hello = \"Hello World  \";\n    Int32 len = (int) writer->MeasureString(hello); // Gets the UTF-8 string length.\n    writer->writeInt32(len);\n    writer->writeString(hello);\n    NotifyUser(\"Client: sending hello\");\n\n    task<void>(writer->StoreAsync()).then([this] (task<void> previousTask) {\n        try {\n            // Try getting all exceptions from the continuation chain above this point.\n            previousTask.Get();\n\n            NotifyUser(\"Client: sent hello\");\n\n            writer->DetachStream(); // Detach stream, if not, DataWriter destructor will close it.\n       }\n       catch (Exception^ exception) {\n               NotifyUser(\"Store failed with error: \" + exception->Message);\n               // Could retry the store, but for this simple example\n               // just close the socket.\n \n               clientSocket->Close();\n               clientSocket = null;\n               return\n       }\n    });\n\n    // Now upgrade the client to use SSL\n    task<void>(clientSocket->UpgradeToSslAsync(clientSocket.SocketProtectionLevel.Ssl, serverHost)).then([this] (task<void> previousTask) {\n        try {\n            // Try getting all exceptions from the continuation chain above this point.\n            previousTask.Get();\n\n           NotifyUser(\"Client: upgrade to SSL completed\");\n           \n           // Add code to send and receive data \n           // Then close clientSocket when done\n        }\n        catch (Exception^ exception) {\n            // If this is an unknown status it means that the error is fatal and retry will likely fail.\n            if (SocketError.GetStatus(exception.HResult) == SocketErrorStatus.Unknown) {\n                throw;\n            }\n\n            NotifyUser(\"Upgrade to SSL failed with error: \" + exception.Message);\n\n            clientSocket->Close();\n            clientSocket = null; \n            return;\n        }\n    });\n```\n\n### Creating secure WebSocket connections\n\nLike traditional socket connections, WebSocket connections can also be encrypted with Transport Layer Security (TLS)/Secure Sockets Layer (SSL) when using the [**StreamWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226923) and [**MessageWebSocket**](https://msdn.microsoft.com/library/windows/apps/br226842) features in Windows 8 for a Windows Store app. In most cases you'll want to use a secure WebSocket connection. This will increase the chances that your connection will succeed, as many proxies will reject unencrypted WebSocket connections.\n\nFor examples of how to create, or upgrade to, a secure socket connection to a network service, see [How to secure WebSocket connections with TLS/SSL](https://msdn.microsoft.com/library/windows/apps/xaml/hh994399).\n\nIn addition to TLS/SSL encryption, a server may require a **Sec-WebSocket-Protocol** header value to complete the initial handshake. This value, represented by the [**StreamWebSocketInformation.Protocol**](https://msdn.microsoft.com/library/windows/apps/hh701514) and [**MessageWebSocketInformation.Protocol**](https://msdn.microsoft.com/library/windows/apps/hh701358) properties, indicate the protocol version of the connection and enables the server to correctly interpret the opening handshake and the data being exchanged afterwards. Using this protocol information, if at any point if the server cannot interpret the incoming data in a safe manner the connection can be closed.\n\nIf the initial request from the client either does not contain this value, or provides a value that doesn't match what the server expects, the expected value is sent from the server to the client on WebSocket handshake error.\n\n## Authentication\n\nHow to provide authentication credentials when connecting over the network.\n\n### Providing a client certificate with the StreamSocket class\n\nThe [**Windows.Networking.StreamSocket**](https://msdn.microsoft.com/library/windows/apps/br226882) class supports using SSL/TLS to authenticate the server the app is talking to. In certain cases, the app also needs to authenticate itself to the server using a TLS client certificate. In Windows 10, you can provide a client certificate on the [**StreamSocket.Control**](https://msdn.microsoft.com/library/windows/apps/br226893) object (this must be set before the TLS handshake is started). If the server requests the client certificate, Windows will respond with the certificate provided.\n\nHere is a code snippet showing how to implement this:\n\n```csharp\nvar socket = new StreamSocket();\nWindows.Security.Cryptography.Certificates.Certificate certificate = await GetClientCert();\nsocket.Control.ClientCertificate = certificate;\nawait socket.ConnectAsync(destination, SocketProtectionLevel.Tls12);\n```\n\n### Providing authentication credentials to a web service\n\nThe networking APIs that enable apps to interact with secure web services each provide their own methods to either initialize a client or set a request header with server and proxy authentication credentials. Each method is set with a [**PasswordCredential**](https://msdn.microsoft.com/library/windows/apps/br227061) object that indicates a user name, password, and the resource for which these credentials are used. The following table provides a mapping of these APIs:\n\n| **WebSockets** | [**MessageWebSocketControl.ServerCredential**](https://msdn.microsoft.com/library/windows/apps/br226848) |\n|-------------------------|----------------------------------------------------------------------------------------------------------|\n|  | [**MessageWebSocketControl.ProxyCredential**](https://msdn.microsoft.com/library/windows/apps/br226847) |\n|  | [**StreamWebSocketControl.ServerCredential**](https://msdn.microsoft.com/library/windows/apps/br226928) |\n|  | [**StreamWebSocketControl.ProxyCredential**](https://msdn.microsoft.com/library/windows/apps/br226927) |\n|  |  |\n| **Background Transfer** | [**BackgroundDownloader.ServerCredential**](https://msdn.microsoft.com/library/windows/apps/hh701076) |\n|  | [**BackgroundDownloader.ProxyCredential**](https://msdn.microsoft.com/library/windows/apps/hh701068) |\n|  | [**BackgroundUploader.ServerCredential**](https://msdn.microsoft.com/library/windows/apps/hh701184) |\n|  | [**BackgroundUploader.ProxyCredential**](https://msdn.microsoft.com/library/windows/apps/hh701178) |\n|  |  |\n| **Syndication** | [**SyndicationClient(PasswordCredential)**](https://msdn.microsoft.com/library/windows/apps/hh702355) |\n|  | [**SyndicationClient.ServerCredential**](https://msdn.microsoft.com/library/windows/apps/br243461) |\n|  | [**SyndicationClient.ProxyCredential**](https://msdn.microsoft.com/library/windows/apps/br243459) |\n|  |  |\n| **AtomPub** | [**AtomPubClient(PasswordCredential)**](https://msdn.microsoft.com/library/windows/apps/hh702262) |\n|  | [**AtomPubClient.ServerCredential**](https://msdn.microsoft.com/library/windows/apps/br243428) |\n|  | [**AtomPubClient.ProxyCredential**](https://msdn.microsoft.com/library/windows/apps/br243423) |\n \n## Handling network exceptions\n\nIn most areas of programming, an exception indicates a significant problem or failure, caused by some flaw in the program. In network programming, there is an additional source for exceptions: the network itself, and the nature of network communications. Network communications are inherently unreliable and prone to unexpected failure. For each of the ways your app uses networking, you must maintain some state information; and your app code must handle network exceptions by updating that state information and initiating appropriate logic for your app to re-establish or retry communication failures.\n\nWhen Universal Windows apps throw an exception, your exception handler can retrieve more detailed information on the cause of the exception to better understand the failure and make appropriate decisions.\n\nEach language projection supports a method to access this more detailed information. An exception projects as an **HRESULT** value in Universal Windows apps. The *Winerror.h* include file contains a very large list of possible **HRESULT** values that includes network errors.\n\nThe networking APIs support different methods for retrieving this detailed information on the cause of an exception.\n\n-   Some APIs provide a helper method that converts the **HRESULT** value from the exception to an enumeration value.\n-   Other APIs provide a method to retrieve the actual **HRESULT** value.\n\n## Related topics\n\n* [Networking API Improvements in Windows 10](http://blogs.windows.com/buildingapps/2015/07/02/networking-api-improvements-in-windows-10/)\n \n\n"}