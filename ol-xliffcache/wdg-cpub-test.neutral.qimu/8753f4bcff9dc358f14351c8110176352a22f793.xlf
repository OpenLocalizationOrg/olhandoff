<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci1\debug-test-perf\optimize-file-access.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8753f4bcff9dc358f14351c8110176352a22f793</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Optimize file access</source>
          <target state="new">Optimize file access</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Create Universal Windows Platform (UWP) apps that access the file system efficiently, avoiding performance issues due to disk latency and memory/CPU cycles.</source>
          <target state="new">Create Universal Windows Platform (UWP) apps that access the file system efficiently, avoiding performance issues due to disk latency and memory/CPU cycles.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Optimize file access</source>
          <target state="new">Optimize file access</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Create Universal Windows Platform (UWP) apps that access the file system efficiently, avoiding performance issues due to disk latency and memory/CPU cycles.</source>
          <target state="new">Create Universal Windows Platform (UWP) apps that access the file system efficiently, avoiding performance issues due to disk latency and memory/CPU cycles.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>When you want to access a large collection of files and you want to access property values other than the typical Name, FileType, and Path properties, access them by creating <bpt id="p1">[</bpt><bpt id="p2">**</bpt>QueryOptions<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR207995)</ept> and calling <bpt id="p3">[</bpt><bpt id="p4">**</bpt>SetPropertyPrefetch<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR207995-setpropertyprefetch)</ept>.</source>
          <target state="new">When you want to access a large collection of files and you want to access property values other than the typical Name, FileType, and Path properties, access them by creating <bpt id="p1">[</bpt><bpt id="p2">**</bpt>QueryOptions<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR207995)</ept> and calling <bpt id="p3">[</bpt><bpt id="p4">**</bpt>SetPropertyPrefetch<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR207995-setpropertyprefetch)</ept>.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>SetPropertyPrefetch<ept id="p1">**</ept> method can dramatically improve the performance of apps that display a collection of items obtained from the file system, such as a collection of images.</source>
          <target state="new">The <bpt id="p1">**</bpt>SetPropertyPrefetch<ept id="p1">**</ept> method can dramatically improve the performance of apps that display a collection of items obtained from the file system, such as a collection of images.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The next set of examples shows a few ways to access multiple files.</source>
          <target state="new">The next set of examples shows a few ways to access multiple files.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The first example uses <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows.Storage.StorageFolder.GetFilesAsync<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR227273)</ept> to retrieve the name info for a set of files.</source>
          <target state="new">The first example uses <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows.Storage.StorageFolder.GetFilesAsync<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR227273)</ept> to retrieve the name info for a set of files.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>This approach provides good performance, because the example accesses only the name property.</source>
          <target state="new">This approach provides good performance, because the example accesses only the name property.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>[!div class="tabbedCodeSnippets"]</source>
          <target state="new">[!div class="tabbedCodeSnippets"]</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The second example uses <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows.Storage.StorageFolder.GetFilesAsync<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR227273)</ept> and then retrieves the image properties for each file.</source>
          <target state="new">The second example uses <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows.Storage.StorageFolder.GetFilesAsync<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR227273)</ept> and then retrieves the image properties for each file.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This approach provides poor performance.</source>
          <target state="new">This approach provides poor performance.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>[!div class="tabbedCodeSnippets"]</source>
          <target state="new">[!div class="tabbedCodeSnippets"]</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The third example uses <bpt id="p1">[</bpt><bpt id="p2">**</bpt>QueryOptions<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR207995)</ept> to get info about a set of files.</source>
          <target state="new">The third example uses <bpt id="p1">[</bpt><bpt id="p2">**</bpt>QueryOptions<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR207995)</ept> to get info about a set of files.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This approach provides much better performance than the previous example.</source>
          <target state="new">This approach provides much better performance than the previous example.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>[!div class="tabbedCodeSnippets"]</source>
          <target state="new">[!div class="tabbedCodeSnippets"]</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If you're performing multiple operations on Windows.Storage objects such as <ph id="ph1">`Windows.Storage.ApplicationData.Current.LocalFolder`</ph>, create a local variable to reference that storage source so that you don't recreate intermediate objects each time you access it.</source>
          <target state="new">If you're performing multiple operations on Windows.Storage objects such as <ph id="ph1">`Windows.Storage.ApplicationData.Current.LocalFolder`</ph>, create a local variable to reference that storage source so that you don't recreate intermediate objects each time you access it.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Stream performance in C# and Visual Basic</source>
          <target state="new">Stream performance in C# and Visual Basic</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Buffering between UWP and .NET streams</source>
          <target state="new">Buffering between UWP and .NET streams</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>There are many scenarios when you might want to convert a UWP stream (such as a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows.Storage.Streams.IInputStream<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR241718)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>IOutputStream<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR241728)</ept>) to a .NET stream (<bpt id="p5">[</bpt><bpt id="p6">**</bpt>System.IO.Stream<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.aspx)</ept>).</source>
          <target state="new">There are many scenarios when you might want to convert a UWP stream (such as a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows.Storage.Streams.IInputStream<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR241718)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>IOutputStream<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR241728)</ept>) to a .NET stream (<bpt id="p5">[</bpt><bpt id="p6">**</bpt>System.IO.Stream<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.aspx)</ept>).</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For example, this is useful when you are writing a UWP app and want to use existing .NET code that works on streams with the UWP file system.</source>
          <target state="new">For example, this is useful when you are writing a UWP app and want to use existing .NET code that works on streams with the UWP file system.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In order to enable this, .NET APIs for Windows Store apps provides extension methods that allow you to convert between .NET and UWP stream types.</source>
          <target state="new">In order to enable this, .NET APIs for Windows Store apps provides extension methods that allow you to convert between .NET and UWP stream types.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For more info, see <bpt id="p1">[</bpt><bpt id="p2">**</bpt>WindowsRuntimeStreamExtensions<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.aspx)</ept>.</source>
          <target state="new">For more info, see <bpt id="p1">[</bpt><bpt id="p2">**</bpt>WindowsRuntimeStreamExtensions<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>When you convert a UWP stream to a .NET stream, you effectively create an adapter for the underlying UWP stream.</source>
          <target state="new">When you convert a UWP stream to a .NET stream, you effectively create an adapter for the underlying UWP stream.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Under some circumstances, there is a runtime cost associated with invoking methods on UWP streams.</source>
          <target state="new">Under some circumstances, there is a runtime cost associated with invoking methods on UWP streams.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>This may affect the speed of your app, especially in scenarios where you perform many small, frequent read or write operations.</source>
          <target state="new">This may affect the speed of your app, especially in scenarios where you perform many small, frequent read or write operations.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In order to speed up apps, the UWP stream adapters contain a data buffer.</source>
          <target state="new">In order to speed up apps, the UWP stream adapters contain a data buffer.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>The following code sample demonstrates small consecutive reads using a UWP stream adapter with a default buffer size.</source>
          <target state="new">The following code sample demonstrates small consecutive reads using a UWP stream adapter with a default buffer size.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>[!div class="tabbedCodeSnippets"]</source>
          <target state="new">[!div class="tabbedCodeSnippets"]</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This default buffering behavior is desirable in most scenarios where you convert a UWP stream to a .NET stream.</source>
          <target state="new">This default buffering behavior is desirable in most scenarios where you convert a UWP stream to a .NET stream.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>However, in some scenarios you may want to tweak the buffering behavior in order to increase performance.</source>
          <target state="new">However, in some scenarios you may want to tweak the buffering behavior in order to increase performance.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Working with large data sets</source>
          <target state="new">Working with large data sets</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>When reading or writing larger sets of data you may be able to increase your read or write throughput by providing a large buffer size to the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AsStreamForRead<ept id="p2">**</ept><ept id="p1">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>AsStreamForWrite<ept id="p4">**</ept><ept id="p3">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite)</ept>, and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>AsStream<ept id="p6">**</ept><ept id="p5">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream)</ept> extension methods.</source>
          <target state="new">When reading or writing larger sets of data you may be able to increase your read or write throughput by providing a large buffer size to the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AsStreamForRead<ept id="p2">**</ept><ept id="p1">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>AsStreamForWrite<ept id="p4">**</ept><ept id="p3">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite)</ept>, and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>AsStream<ept id="p6">**</ept><ept id="p5">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream)</ept> extension methods.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This gives the stream adapter a larger internal buffer size.</source>
          <target state="new">This gives the stream adapter a larger internal buffer size.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For instance, when passing a stream that comes from a large file to an XML parser, the parser can make many sequential small reads from the stream.</source>
          <target state="new">For instance, when passing a stream that comes from a large file to an XML parser, the parser can make many sequential small reads from the stream.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>A large buffer can reduce the number of calls to the underlying UWP stream and boost performance.</source>
          <target state="new">A large buffer can reduce the number of calls to the underlying UWP stream and boost performance.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   You should be careful when setting a buffer size that is larger than approximately 80 KB, as this may cause fragmentation on the garbage collector heap (see <bpt id="p2">[</bpt>Improve garbage collection performance<ept id="p2">](improve-garbage-collection-performance.md)</ept>).</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   You should be careful when setting a buffer size that is larger than approximately 80 KB, as this may cause fragmentation on the garbage collector heap (see <bpt id="p2">[</bpt>Improve garbage collection performance<ept id="p2">](improve-garbage-collection-performance.md)</ept>).</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The following code example creates a managed stream adapter with an 81,920 byte buffer.</source>
          <target state="new">The following code example creates a managed stream adapter with an 81,920 byte buffer.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>[!div class="tabbedCodeSnippets"]</source>
          <target state="new">[!div class="tabbedCodeSnippets"]</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Stream.CopyTo<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copyto.aspx)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>CopyToAsync<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copytoasync.aspx)</ept> methods also allocate a local buffer for copying between streams.</source>
          <target state="new">The <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Stream.CopyTo<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copyto.aspx)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>CopyToAsync<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.stream.copytoasync.aspx)</ept> methods also allocate a local buffer for copying between streams.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>As with the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AsStreamForRead<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.asstreamforread.aspx)</ept> extension method, you may be able to get better performance for large stream copies by overriding the default buffer size.</source>
          <target state="new">As with the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AsStreamForRead<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.windowsruntimestreamextensions.asstreamforread.aspx)</ept> extension method, you may be able to get better performance for large stream copies by overriding the default buffer size.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The following code example demonstrates changing the default buffer size of a <bpt id="p1">**</bpt>CopyToAsync<ept id="p1">**</ept> call.</source>
          <target state="new">The following code example demonstrates changing the default buffer size of a <bpt id="p1">**</bpt>CopyToAsync<ept id="p1">**</ept> call.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>[!div class="tabbedCodeSnippets"]</source>
          <target state="new">[!div class="tabbedCodeSnippets"]</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>This example uses a buffer size of 1 MB, which is greater than the 80 KB previously recommended.</source>
          <target state="new">This example uses a buffer size of 1 MB, which is greater than the 80 KB previously recommended.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Using such a large buffer can improve throughput of the copy operation for very large data sets (that is, several hundred megabytes).</source>
          <target state="new">Using such a large buffer can improve throughput of the copy operation for very large data sets (that is, several hundred megabytes).</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>However, this buffer is allocated on the large object heap and could potentially degrade garbage collection performance.</source>
          <target state="new">However, this buffer is allocated on the large object heap and could potentially degrade garbage collection performance.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>You should only use large buffer sizes if it will noticeably improve the performance of your app.</source>
          <target state="new">You should only use large buffer sizes if it will noticeably improve the performance of your app.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>When you are working with a large number of streams simultaneously, you might want to reduce or eliminate the memory overhead of the buffer.</source>
          <target state="new">When you are working with a large number of streams simultaneously, you might want to reduce or eliminate the memory overhead of the buffer.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can specify a smaller buffer, or set the <bpt id="p1">*</bpt>bufferSize<ept id="p1">*</ept> parameter to 0 to turn off buffering entirely for that stream adapter.</source>
          <target state="new">You can specify a smaller buffer, or set the <bpt id="p1">*</bpt>bufferSize<ept id="p1">*</ept> parameter to 0 to turn off buffering entirely for that stream adapter.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can still achieve good throughput performance without buffering if you perform large reads and writes to the managed stream.</source>
          <target state="new">You can still achieve good throughput performance without buffering if you perform large reads and writes to the managed stream.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Performing latency-sensitive operations</source>
          <target state="new">Performing latency-sensitive operations</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You might also want to avoid buffering if you want low-latency reads and writes and do not want to read in large blocks out of the underlying UWP stream.</source>
          <target state="new">You might also want to avoid buffering if you want low-latency reads and writes and do not want to read in large blocks out of the underlying UWP stream.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>For example, you might want low-latency reads and writes if you are using the stream for network communications.</source>
          <target state="new">For example, you might want low-latency reads and writes if you are using the stream for network communications.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In a chat app you might use a stream over a network interface to send messages back in forth.</source>
          <target state="new">In a chat app you might use a stream over a network interface to send messages back in forth.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In this case you want to send messages as soon as they are ready and not wait for the buffer to fill up.</source>
          <target state="new">In this case you want to send messages as soon as they are ready and not wait for the buffer to fill up.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>If you set the buffer size to 0 when calling the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AsStreamForRead<ept id="p2">**</ept><ept id="p1">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>AsStreamForWrite<ept id="p4">**</ept><ept id="p3">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite)</ept>, and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>AsStream<ept id="p6">**</ept><ept id="p5">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream)</ept> extension methods, then the resulting adapter will not allocate a buffer, and all calls will manipulate the underlying UWP stream directly.</source>
          <target state="new">If you set the buffer size to 0 when calling the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AsStreamForRead<ept id="p2">**</ept><ept id="p1">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>AsStreamForWrite<ept id="p4">**</ept><ept id="p3">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite)</ept>, and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>AsStream<ept id="p6">**</ept><ept id="p5">](Overload:System.IO.WindowsRuntimeStreamExtensions.AsStream)</ept> extension methods, then the resulting adapter will not allocate a buffer, and all calls will manipulate the underlying UWP stream directly.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>