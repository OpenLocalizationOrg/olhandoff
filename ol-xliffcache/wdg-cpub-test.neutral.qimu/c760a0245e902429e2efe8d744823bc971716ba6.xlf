<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\port-the-shader-config.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c760a0245e902429e2efe8d744823bc971716ba6</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Port the shader objects</source>
          <target state="new">Port the shader objects</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.</source>
          <target state="new">When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Port the shader objects</source>
          <target state="new">Port the shader objects</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Important APIs</source>
          <target state="new">Important APIs</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>ID3D11Device</source>
          <target state="new">ID3D11Device</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>ID3D11DeviceContext</source>
          <target state="new">ID3D11DeviceContext</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.</source>
          <target state="new">When porting the simple renderer from OpenGL ES 2.0, the first step is to set up the equivalent vertex and fragment shader objects in Direct3D 11, and to make sure that the main program can communicate with the shader objects after they are compiled.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   Have you created a new Direct3D project?</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   Have you created a new Direct3D project?</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If not, follow the instructions in <bpt id="p1">[</bpt>Create a new DirectX 11 project for Universal Windows Platform (UWP)<ept id="p1">](user-interface.md)</ept>.</source>
          <target state="new">If not, follow the instructions in <bpt id="p1">[</bpt>Create a new DirectX 11 project for Universal Windows Platform (UWP)<ept id="p1">](user-interface.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This walkthrough assumes that you have the created the DXGI and Direct3D resources for drawing to the screen, and which are provided in the template.</source>
          <target state="new">This walkthrough assumes that you have the created the DXGI and Direct3D resources for drawing to the screen, and which are provided in the template.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Much like OpenGL ES 2.0, the compiled shaders in Direct3D must be associated with a drawing context.</source>
          <target state="new">Much like OpenGL ES 2.0, the compiled shaders in Direct3D must be associated with a drawing context.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>However, Direct3D does not have the concept of a shader program object per se; instead, you must assign the shaders directly to a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>.</source>
          <target state="new">However, Direct3D does not have the concept of a shader program object per se; instead, you must assign the shaders directly to a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This step follows the OpenGL ES 2.0 process for creating and binding shader objects, and provides you with the corresponding API behaviors in Direct3D.</source>
          <target state="new">This step follows the OpenGL ES 2.0 process for creating and binding shader objects, and provides you with the corresponding API behaviors in Direct3D.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="new">Instructions</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Step 1: Compile the shaders</source>
          <target state="new">Step 1: Compile the shaders</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In this simple OpenGL ES 2.0 sample, the shaders are stored as text files and loaded as string data for run-time compilation.</source>
          <target state="new">In this simple OpenGL ES 2.0 sample, the shaders are stored as text files and loaded as string data for run-time compilation.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Compile a shader</source>
          <target state="new">OpenGL ES 2.0: Compile a shader</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In Direct3D, shaders are not compiled during run-time; they are always compiled to CSO files when the rest of the program is compiled.</source>
          <target state="new">In Direct3D, shaders are not compiled during run-time; they are always compiled to CSO files when the rest of the program is compiled.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>When you compile your app with Microsoft Visual Studio, the HLSL files are compiled to CSO (.cso) files that your app must load.</source>
          <target state="new">When you compile your app with Microsoft Visual Studio, the HLSL files are compiled to CSO (.cso) files that your app must load.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Make sure you include these CSO files with your app when you package it!</source>
          <target state="new">Make sure you include these CSO files with your app when you package it!</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   The following example performs the shader loading and compilation asynchronously using the <bpt id="p2">**</bpt>auto<ept id="p2">**</ept> keyword and lambda syntax.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   The following example performs the shader loading and compilation asynchronously using the <bpt id="p2">**</bpt>auto<ept id="p2">**</ept> keyword and lambda syntax.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>ReadDataAsync() is a method implemented for the template that reads in a CSO file as an array of byte data (fileData).</source>
          <target state="new">ReadDataAsync() is a method implemented for the template that reads in a CSO file as an array of byte data (fileData).</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Compile a shader</source>
          <target state="new">Direct3D 11: Compile a shader</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Step 2: Create and load the vertex and fragment (pixel) shaders</source>
          <target state="new">Step 2: Create and load the vertex and fragment (pixel) shaders</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0 has the notion of a shader "program", which serves as the interface between the main program running on the CPU and the shaders, which are executed on the GPU.</source>
          <target state="new">OpenGL ES 2.0 has the notion of a shader "program", which serves as the interface between the main program running on the CPU and the shaders, which are executed on the GPU.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Shaders are compiled (or loaded from compiled sources) and associated with a program, which enables execution on the GPU.</source>
          <target state="new">Shaders are compiled (or loaded from compiled sources) and associated with a program, which enables execution on the GPU.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Loading the vertex and fragment shaders into a shading program</source>
          <target state="new">OpenGL ES 2.0: Loading the vertex and fragment shaders into a shading program</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Direct3D does not have the concept of a shader program object.</source>
          <target state="new">Direct3D does not have the concept of a shader program object.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Rather, the shaders are created when one of the shader creation methods on the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</ept> interface (such as <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11Device::CreateVertexShader<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</ept> or <bpt id="p5">[</bpt><bpt id="p6">**</bpt>ID3D11Device::CreatePixelShader<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</ept>) is called.</source>
          <target state="new">Rather, the shaders are created when one of the shader creation methods on the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</ept> interface (such as <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11Device::CreateVertexShader<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</ept> or <bpt id="p5">[</bpt><bpt id="p6">**</bpt>ID3D11Device::CreatePixelShader<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</ept>) is called.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>To set the shaders for the current drawing context, we provide them to corresponding <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> with a set shader method, such as <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::VSSetShader<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> for the vertex shader or <bpt id="p5">[</bpt><bpt id="p6">**</bpt>ID3D11DeviceContext::PSSetShader<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> for the fragment shader.</source>
          <target state="new">To set the shaders for the current drawing context, we provide them to corresponding <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> with a set shader method, such as <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::VSSetShader<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> for the vertex shader or <bpt id="p5">[</bpt><bpt id="p6">**</bpt>ID3D11DeviceContext::PSSetShader<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> for the fragment shader.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Set the shaders for the graphics device drawing context.</source>
          <target state="new">Direct3D 11: Set the shaders for the graphics device drawing context.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Step 3: Define the data to supply to the shaders</source>
          <target state="new">Step 3: Define the data to supply to the shaders</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In our OpenGL ES 2.0 example, we have one <bpt id="p1">**</bpt>uniform<ept id="p1">**</ept> to declare for the shader pipeline:</source>
          <target state="new">In our OpenGL ES 2.0 example, we have one <bpt id="p1">**</bpt>uniform<ept id="p1">**</ept> to declare for the shader pipeline:</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>u<ph id="ph1">\_</ph>mvpMatrix<ept id="p1">**</ept>: a 4x4 array of floats that represents the final model-view-projection transformation matrix that takes the model coordinates for the cube and transforms them into 2D projection coordinates for scan conversion.</source>
          <target state="new"><bpt id="p1">**</bpt>u<ph id="ph1">\_</ph>mvpMatrix<ept id="p1">**</ept>: a 4x4 array of floats that represents the final model-view-projection transformation matrix that takes the model coordinates for the cube and transforms them into 2D projection coordinates for scan conversion.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>And two <bpt id="p1">**</bpt>attribute<ept id="p1">**</ept> values for the vertex data:</source>
          <target state="new">And two <bpt id="p1">**</bpt>attribute<ept id="p1">**</ept> values for the vertex data:</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>a<ph id="ph1">\_</ph>position<ept id="p1">**</ept>: a 4-float vector for the model coordinates of a vertex.</source>
          <target state="new"><bpt id="p1">**</bpt>a<ph id="ph1">\_</ph>position<ept id="p1">**</ept>: a 4-float vector for the model coordinates of a vertex.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>a<ph id="ph1">\_</ph>color<ept id="p1">**</ept>: A 4-float vector for the RGBA color value associated with the vertex.</source>
          <target state="new"><bpt id="p1">**</bpt>a<ph id="ph1">\_</ph>color<ept id="p1">**</ept>: A 4-float vector for the RGBA color value associated with the vertex.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Open GL ES 2.0: GLSL definitions for the uniforms and attributes</source>
          <target state="new">Open GL ES 2.0: GLSL definitions for the uniforms and attributes</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The corresponding main program variables are defined as fields on the renderer object, in this case.</source>
          <target state="new">The corresponding main program variables are defined as fields on the renderer object, in this case.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>(Refer to the header in <bpt id="p1">[</bpt>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11<ept id="p1">](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md)</ept>.) Once we've done that, we need to specify the locations in memory where the main program will supply these values for the shader pipeline, which we typically do right before a draw call:</source>
          <target state="new">(Refer to the header in <bpt id="p1">[</bpt>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11<ept id="p1">](port-a-simple-opengl-es-2-0-renderer-to-directx-11-1.md)</ept>.) Once we've done that, we need to specify the locations in memory where the main program will supply these values for the shader pipeline, which we typically do right before a draw call:</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Marking the location of the uniform and attribute data</source>
          <target state="new">OpenGL ES 2.0: Marking the location of the uniform and attribute data</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Direct3D does not have the concept of an "attribute" or a "uniform" in the same sense (or, at least, it does not share this syntax).</source>
          <target state="new">Direct3D does not have the concept of an "attribute" or a "uniform" in the same sense (or, at least, it does not share this syntax).</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Rather, it has constant buffers, represented as Direct3D subresources -- resources that are shared between the main program and the shader programs.</source>
          <target state="new">Rather, it has constant buffers, represented as Direct3D subresources -- resources that are shared between the main program and the shader programs.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Some of these subresources, such as vertex positions and colors, are described as HLSL semantics.</source>
          <target state="new">Some of these subresources, such as vertex positions and colors, are described as HLSL semantics.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more info on constant buffers and HLSL semantics as they relate to OpenGL ES 2.0 concepts, read <bpt id="p1">[</bpt>Port frame buffer objects, uniforms, and attributes<ept id="p1">](porting-uniforms-and-attributes.md)</ept>.</source>
          <target state="new">For more info on constant buffers and HLSL semantics as they relate to OpenGL ES 2.0 concepts, read <bpt id="p1">[</bpt>Port frame buffer objects, uniforms, and attributes<ept id="p1">](porting-uniforms-and-attributes.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>When moving this process to Direct3D, we convert the uniform to a Direct3D constant buffer (cbuffer) and assign it a register for lookup with the <bpt id="p1">**</bpt>register<ept id="p1">**</ept> HLSL semantic.</source>
          <target state="new">When moving this process to Direct3D, we convert the uniform to a Direct3D constant buffer (cbuffer) and assign it a register for lookup with the <bpt id="p1">**</bpt>register<ept id="p1">**</ept> HLSL semantic.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The two vertex attributes are handled as input elements to the shader pipeline stages, and are also assigned <bpt id="p1">[</bpt>HLSL semantics<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb205574)</ept> (POSITION and COLOR0) that inform the shaders.</source>
          <target state="new">The two vertex attributes are handled as input elements to the shader pipeline stages, and are also assigned <bpt id="p1">[</bpt>HLSL semantics<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb205574)</ept> (POSITION and COLOR0) that inform the shaders.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The pixel shader takes an SV<ph id="ph1">\_</ph>POSITION, with the SV<ph id="ph2">\_</ph> prefix indicating that it is a system value generated by the GPU.</source>
          <target state="new">The pixel shader takes an SV<ph id="ph1">\_</ph>POSITION, with the SV<ph id="ph2">\_</ph> prefix indicating that it is a system value generated by the GPU.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>(In this case, it is a pixel position generated during scan conversion.) VertexShaderInput and PixelShaderInput are not declared as constant buffers because the former will be used to define the vertex buffer (see <bpt id="p1">[</bpt>Port the vertex buffers and data<ept id="p1">](port-the-vertex-buffers-and-data-config.md)</ept>), and the data for the latter is generated as the result of a previous stage in the pipeline, which in this case is the vertex shader.</source>
          <target state="new">(In this case, it is a pixel position generated during scan conversion.) VertexShaderInput and PixelShaderInput are not declared as constant buffers because the former will be used to define the vertex buffer (see <bpt id="p1">[</bpt>Port the vertex buffers and data<ept id="p1">](port-the-vertex-buffers-and-data-config.md)</ept>), and the data for the latter is generated as the result of a previous stage in the pipeline, which in this case is the vertex shader.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Direct3D: HLSL definitions for the constant buffers and vertex data</source>
          <target state="new">Direct3D: HLSL definitions for the constant buffers and vertex data</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>For more info on porting to constant buffers and the application of HLSL semantics, read <bpt id="p1">[</bpt>Port frame buffer objects, uniforms, and attributes<ept id="p1">](porting-uniforms-and-attributes.md)</ept>.</source>
          <target state="new">For more info on porting to constant buffers and the application of HLSL semantics, read <bpt id="p1">[</bpt>Port frame buffer objects, uniforms, and attributes<ept id="p1">](porting-uniforms-and-attributes.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Here are the structures for the layout of the data passed to the shader pipeline with a constant or vertex buffer.</source>
          <target state="new">Here are the structures for the layout of the data passed to the shader pipeline with a constant or vertex buffer.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Declaring the constant and vertex buffers layout</source>
          <target state="new">Direct3D 11: Declaring the constant and vertex buffers layout</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Use the DirectXMath XM<ph id="ph1">\*</ph> types for your constant buffer elements, since they provide proper packing and alignment for the contents when they are sent to the shader pipeline.</source>
          <target state="new">Use the DirectXMath XM<ph id="ph1">\*</ph> types for your constant buffer elements, since they provide proper packing and alignment for the contents when they are sent to the shader pipeline.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If you use standard Windows platform float types and arrays, you must perform the packing and alignment yourself.</source>
          <target state="new">If you use standard Windows platform float types and arrays, you must perform the packing and alignment yourself.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>To bind a constant buffer, create a layout description as a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CD3D11<ph id="ph1">\_</ph>BUFFER<ph id="ph2">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/jj151620)</ept> structure, and pass it to <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3DDevice::CreateBuffer<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept>.</source>
          <target state="new">To bind a constant buffer, create a layout description as a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CD3D11<ph id="ph1">\_</ph>BUFFER<ph id="ph2">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/jj151620)</ept> structure, and pass it to <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3DDevice::CreateBuffer<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept>.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Then, in your render method, pass the constant buffer to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::UpdateSubresource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</ept> before drawing.</source>
          <target state="new">Then, in your render method, pass the constant buffer to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::UpdateSubresource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</ept> before drawing.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Bind the constant buffer</source>
          <target state="new">Direct3D 11: Bind the constant buffer</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The vertex buffer is created and updated similarly, and is discussed in the next step, <bpt id="p1">[</bpt>Port the vertex buffers and data<ept id="p1">](port-the-vertex-buffers-and-data-config.md)</ept>.</source>
          <target state="new">The vertex buffer is created and updated similarly, and is discussed in the next step, <bpt id="p1">[</bpt>Port the vertex buffers and data<ept id="p1">](port-the-vertex-buffers-and-data-config.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Next step</source>
          <target state="new">Next step</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Port the vertex buffers and data</source>
          <target state="new">Port the vertex buffers and data</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</source>
          <target state="new">How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Port the vertex buffers and data</source>
          <target state="new">Port the vertex buffers and data</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Port the GLSL</source>
          <target state="new">Port the GLSL</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Draw to the screen</source>
          <target state="new">Draw to the screen</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>