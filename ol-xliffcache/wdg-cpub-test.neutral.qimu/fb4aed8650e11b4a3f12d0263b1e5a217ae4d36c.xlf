<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\asynchronous-programming-directx-and-cpp.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fb4aed8650e11b4a3f12d0263b1e5a217ae4d36c</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Asynchronous programming (DirectX and C++)</source>
          <target state="new">Asynchronous programming (DirectX and C++)</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This topic covers various points to consider when you are using asynchronous programming and threading with DirectX.</source>
          <target state="new">This topic covers various points to consider when you are using asynchronous programming and threading with DirectX.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Asynchronous programming (DirectX and C++)</source>
          <target state="new">Asynchronous programming (DirectX and C++)</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>This topic covers various points to consider when you are using asynchronous programming and threading with DirectX.</source>
          <target state="new">This topic covers various points to consider when you are using asynchronous programming and threading with DirectX.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Async programming and DirectX</source>
          <target state="new">Async programming and DirectX</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you're just learning about DirectX, or even if you're experienced with it, consider putting all your graphics processing pipeline on one thread.</source>
          <target state="new">If you're just learning about DirectX, or even if you're experienced with it, consider putting all your graphics processing pipeline on one thread.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>In any given scene in a game, there are common resources such as bitmaps, shaders, and other assets that require exclusive access.</source>
          <target state="new">In any given scene in a game, there are common resources such as bitmaps, shaders, and other assets that require exclusive access.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>These same resources require that you synchronize any access to these resources across the parallel threads.</source>
          <target state="new">These same resources require that you synchronize any access to these resources across the parallel threads.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Rendering is a difficult process to parallelize across multiple threads.</source>
          <target state="new">Rendering is a difficult process to parallelize across multiple threads.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>However, if your game is sufficiently complex, or if you are looking to get improved performance, you can use asynchronous programming to parallelize some of the components that are not specific to your rendering pipeline.</source>
          <target state="new">However, if your game is sufficiently complex, or if you are looking to get improved performance, you can use asynchronous programming to parallelize some of the components that are not specific to your rendering pipeline.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Modern hardware features multiple core and hyperthreaded CPUs, and your app should take advantage of this!</source>
          <target state="new">Modern hardware features multiple core and hyperthreaded CPUs, and your app should take advantage of this!</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can ensure this by using asynchronous programming for some of the components of your game that don't need direct access to the Direct3D device context, such as:</source>
          <target state="new">You can ensure this by using asynchronous programming for some of the components of your game that don't need direct access to the Direct3D device context, such as:</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>file I/O</source>
          <target state="new">file I/O</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>physics</source>
          <target state="new">physics</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>AI</source>
          <target state="new">AI</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>networking</source>
          <target state="new">networking</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>audio</source>
          <target state="new">audio</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>controls</source>
          <target state="new">controls</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>XAML-based UI components</source>
          <target state="new">XAML-based UI components</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Your app can handle these components on multiple concurrent threads.</source>
          <target state="new">Your app can handle these components on multiple concurrent threads.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>File I/O, especially asset loading, benefits greatly from asynchronous loading, because your game or app can be in an interactive state while several (or several hundred) megabytes of assets are being loaded or streamed.</source>
          <target state="new">File I/O, especially asset loading, benefits greatly from asynchronous loading, because your game or app can be in an interactive state while several (or several hundred) megabytes of assets are being loaded or streamed.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The easiest way to create and manage these threads is by using the <bpt id="p1">[</bpt>Parallel Patterns Library<ept id="p1">](https://msdn.microsoft.com/library/dd492418.aspx)</ept> and the <bpt id="p2">**</bpt>task<ept id="p2">**</ept> pattern, as contained in the <bpt id="p3">**</bpt>concurrency<ept id="p3">**</ept> namespace defined in PPLTasks.h.</source>
          <target state="new">The easiest way to create and manage these threads is by using the <bpt id="p1">[</bpt>Parallel Patterns Library<ept id="p1">](https://msdn.microsoft.com/library/dd492418.aspx)</ept> and the <bpt id="p2">**</bpt>task<ept id="p2">**</ept> pattern, as contained in the <bpt id="p3">**</bpt>concurrency<ept id="p3">**</ept> namespace defined in PPLTasks.h.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Using the <bpt id="p1">[</bpt>Parallel Patterns Library<ept id="p1">](https://msdn.microsoft.com/library/dd492418.aspx)</ept> takes direct advantage of multiple core and hyperthreaded CPUs, and can improve everything from perceived load times to the hitches and lags that come with intensive CPU calculations or network processing.</source>
          <target state="new">Using the <bpt id="p1">[</bpt>Parallel Patterns Library<ept id="p1">](https://msdn.microsoft.com/library/dd492418.aspx)</ept> takes direct advantage of multiple core and hyperthreaded CPUs, and can improve everything from perceived load times to the hitches and lags that come with intensive CPU calculations or network processing.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   In a Universal Windows Platform (UWP) app, the user interface runs entirely in a single-threaded apartment (STA).</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   In a Universal Windows Platform (UWP) app, the user interface runs entirely in a single-threaded apartment (STA).</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If you are creating a UI for your DirectX game using <bpt id="p1">[</bpt>XAML interop<ept id="p1">](directx-and-xaml-interop.md)</ept>, you can only access the controls by using the STA.</source>
          <target state="new">If you are creating a UI for your DirectX game using <bpt id="p1">[</bpt>XAML interop<ept id="p1">](directx-and-xaml-interop.md)</ept>, you can only access the controls by using the STA.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Multithreading with Direct3D devices</source>
          <target state="new">Multithreading with Direct3D devices</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Multithreading for device contexts is only available on graphics devices that support a Direct3D feature level of 11<ph id="ph1">\_</ph>0 or higher.</source>
          <target state="new">Multithreading for device contexts is only available on graphics devices that support a Direct3D feature level of 11<ph id="ph1">\_</ph>0 or higher.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>However, you might want to maximize the use of the powerful GPU in many platforms, such as dedicated gaming platforms.</source>
          <target state="new">However, you might want to maximize the use of the powerful GPU in many platforms, such as dedicated gaming platforms.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In the simplest case, you might want to separate the rendering of a heads-up display (HUD) overlay from the 3D scene rendering and projection and have both components use separate parallel pipelines.</source>
          <target state="new">In the simplest case, you might want to separate the rendering of a heads-up display (HUD) overlay from the 3D scene rendering and projection and have both components use separate parallel pipelines.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Both threads must use the same <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> to create and manage the resource objects (the textures, meshes, shaders, and other assets), though, which is single-threaded, and which requires that you implement some sort of synchronization mechanism (such as critical sections) to access it safely.</source>
          <target state="new">Both threads must use the same <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> to create and manage the resource objects (the textures, meshes, shaders, and other assets), though, which is single-threaded, and which requires that you implement some sort of synchronization mechanism (such as critical sections) to access it safely.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>And, while you can create separate command lists for the device context on different threads (for deferred rendering), you cannot play those command lists back simultaneously on the same <bpt id="p1">**</bpt>ID3D11DeviceContext<ept id="p1">**</ept> instance.</source>
          <target state="new">And, while you can create separate command lists for the device context on different threads (for deferred rendering), you cannot play those command lists back simultaneously on the same <bpt id="p1">**</bpt>ID3D11DeviceContext<ept id="p1">**</ept> instance.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Now, your app can also use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</ept>, which is safe for multithreading, to create resource objects.</source>
          <target state="new">Now, your app can also use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</ept>, which is safe for multithreading, to create resource objects.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>So, why not always use <bpt id="p1">**</bpt>ID3D11Device<ept id="p1">**</ept> instead of <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ID3D11DeviceContext<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>?</source>
          <target state="new">So, why not always use <bpt id="p1">**</bpt>ID3D11Device<ept id="p1">**</ept> instead of <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ID3D11DeviceContext<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>?</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Well, currently, driver support for multithreading might not be available for some graphics interfaces.</source>
          <target state="new">Well, currently, driver support for multithreading might not be available for some graphics interfaces.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You can query the device and find out if it does support multithreading, but if you are looking to reach the broadest audience, you might stick with single-threaded <bpt id="p1">**</bpt>ID3D11DeviceContext<ept id="p1">**</ept> for resource object management.</source>
          <target state="new">You can query the device and find out if it does support multithreading, but if you are looking to reach the broadest audience, you might stick with single-threaded <bpt id="p1">**</bpt>ID3D11DeviceContext<ept id="p1">**</ept> for resource object management.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>That said, when the graphics device driver doesn't support multithreading or command lists, Direct3D 11 attempts to handle synchronized access to the device context internally; and if command lists are not supported, it provides a software implementation.</source>
          <target state="new">That said, when the graphics device driver doesn't support multithreading or command lists, Direct3D 11 attempts to handle synchronized access to the device context internally; and if command lists are not supported, it provides a software implementation.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>As a result, you can write multithreaded code that will run on platforms with graphics interfaces that lack driver support for multithreaded device context access.</source>
          <target state="new">As a result, you can write multithreaded code that will run on platforms with graphics interfaces that lack driver support for multithreaded device context access.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If your app supports separate threads for processing command lists and for displaying frames, you probably want to keep the GPU active, processing the command lists while displaying frames in a timely fashion without perceptible stutter or lag.</source>
          <target state="new">If your app supports separate threads for processing command lists and for displaying frames, you probably want to keep the GPU active, processing the command lists while displaying frames in a timely fashion without perceptible stutter or lag.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>In this case, you could use a separate <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> for each thread, and to share resources (like textures) by creating them with the D3D11<ph id="ph1">\_</ph>RESOURCE<ph id="ph2">\_</ph>MISC<ph id="ph3">\_</ph>SHARED flag.</source>
          <target state="new">In this case, you could use a separate <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> for each thread, and to share resources (like textures) by creating them with the D3D11<ph id="ph1">\_</ph>RESOURCE<ph id="ph2">\_</ph>MISC<ph id="ph3">\_</ph>SHARED flag.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In this scenario, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::Flush<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476425)</ept> must be called on the processing thread to complete the execution of the command list prior to displaying the results of processing the resource object in the display thread.</source>
          <target state="new">In this scenario, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::Flush<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476425)</ept> must be called on the processing thread to complete the execution of the command list prior to displaying the results of processing the resource object in the display thread.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Deferred rendering</source>
          <target state="new">Deferred rendering</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Deferred rendering records graphics commands in a command list so that they can be played back at some other time, and is designed to support rendering on one thread while recording commands for rendering on additional threads.</source>
          <target state="new">Deferred rendering records graphics commands in a command list so that they can be played back at some other time, and is designed to support rendering on one thread while recording commands for rendering on additional threads.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>After these commands are completed, they can be executed on the thread that generates the final display object (frame buffer, texture, or other graphics output).</source>
          <target state="new">After these commands are completed, they can be executed on the thread that generates the final display object (frame buffer, texture, or other graphics output).</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Create a deferred context using <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateDeferredContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476505)</ept> (instead of <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11CreateDevice<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept> or <bpt id="p5">[</bpt><bpt id="p6">**</bpt>D3D11CreateDeviceAndSwapChain<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/ff476083)</ept>, which create an immediate context).</source>
          <target state="new">Create a deferred context using <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateDeferredContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476505)</ept> (instead of <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11CreateDevice<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept> or <bpt id="p5">[</bpt><bpt id="p6">**</bpt>D3D11CreateDeviceAndSwapChain<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/ff476083)</ept>, which create an immediate context).</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For more info, see <bpt id="p1">[</bpt>Immediate and Deferred Rendering<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476892)</ept>.</source>
          <target state="new">For more info, see <bpt id="p1">[</bpt>Immediate and Deferred Rendering<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476892)</ept>.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Introduction to Multithreading in Direct3D 11</source>
          <target state="new">Introduction to Multithreading in Direct3D 11</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>