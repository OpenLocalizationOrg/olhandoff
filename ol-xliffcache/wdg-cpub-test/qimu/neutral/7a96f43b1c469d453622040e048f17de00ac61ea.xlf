<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\simple-port-from-direct3d-9-to-11-1-part-2--rendering.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7a96f43b1c469d453622040e048f17de00ac61ea</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Convert the rendering framework</source>
          <target state="new">Convert the rendering framework</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Shows how to convert a simple rendering framework from Direct3D 9 to Direct3D 11, including how to port geometry buffers, how to compile and load HLSL shader programs, and how to implement the rendering chain in Direct3D 11.</source>
          <target state="new">Shows how to convert a simple rendering framework from Direct3D 9 to Direct3D 11, including how to port geometry buffers, how to compile and load HLSL shader programs, and how to implement the rendering chain in Direct3D 11.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Convert the rendering framework</source>
          <target state="new">Convert the rendering framework</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="new">Summary</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Part 1: Initialize Direct3D 11</source>
          <target state="new">Part 1: Initialize Direct3D 11</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Part 2: Convert the rendering framework</source>
          <target state="new">Part 2: Convert the rendering framework</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Part 3: Port the game loop</source>
          <target state="new">Part 3: Port the game loop</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Shows how to convert a simple rendering framework from Direct3D 9 to Direct3D 11, including how to port geometry buffers, how to compile and load HLSL shader programs, and how to implement the rendering chain in Direct3D 11.</source>
          <target state="new">Shows how to convert a simple rendering framework from Direct3D 9 to Direct3D 11, including how to port geometry buffers, how to compile and load HLSL shader programs, and how to implement the rendering chain in Direct3D 11.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Part 2 of the <bpt id="p1">[</bpt>Port a simple Direct3D 9 app to DirectX 11 and Universal Windows Platform (UWP)<ept id="p1">](walkthrough--simple-port-from-direct3d-9-to-11-1.md)</ept> walkthrough.</source>
          <target state="new">Part 2 of the <bpt id="p1">[</bpt>Port a simple Direct3D 9 app to DirectX 11 and Universal Windows Platform (UWP)<ept id="p1">](walkthrough--simple-port-from-direct3d-9-to-11-1.md)</ept> walkthrough.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Convert effects to HLSL shaders</source>
          <target state="new">Convert effects to HLSL shaders</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The following example is a simple D3DX technique, written for the legacy Effects API, for hardware vertex transformation and pass-through color data.</source>
          <target state="new">The following example is a simple D3DX technique, written for the legacy Effects API, for hardware vertex transformation and pass-through color data.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Direct3D 9 shader code</source>
          <target state="new">Direct3D 9 shader code</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>In Direct3D 11, we can still use our HLSL shaders.</source>
          <target state="new">In Direct3D 11, we can still use our HLSL shaders.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>We put each shader in its own HLSL file so that Visual Studio compiles them into separate files and later, we'll load them as separate Direct3D resources.</source>
          <target state="new">We put each shader in its own HLSL file so that Visual Studio compiles them into separate files and later, we'll load them as separate Direct3D resources.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>We set the target level to <bpt id="p1">[</bpt>Shader Model 4 Level 9<ph id="ph1">\_</ph>1 (/4<ph id="ph2">\_</ph>0<ph id="ph3">\_</ph>level<ph id="ph4">\_</ph>9<ph id="ph5">\_</ph>1)<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476876)</ept> because these shaders are written for DirectX 9.1 GPUs.</source>
          <target state="new">We set the target level to <bpt id="p1">[</bpt>Shader Model 4 Level 9<ph id="ph1">\_</ph>1 (/4<ph id="ph2">\_</ph>0<ph id="ph3">\_</ph>level<ph id="ph4">\_</ph>9<ph id="ph5">\_</ph>1)<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476876)</ept> because these shaders are written for DirectX 9.1 GPUs.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>When we defined the input layout, we made sure it represented the same data structure we use to store per-vertex data in system memory and in GPU memory.</source>
          <target state="new">When we defined the input layout, we made sure it represented the same data structure we use to store per-vertex data in system memory and in GPU memory.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Similarly, the output of a vertex shader should match the structure used as input to the pixel shader.</source>
          <target state="new">Similarly, the output of a vertex shader should match the structure used as input to the pixel shader.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The rules are not the same as passing data from one function to another in C++; you can omit unused variables at the end of the structure.</source>
          <target state="new">The rules are not the same as passing data from one function to another in C++; you can omit unused variables at the end of the structure.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>But the order can't be rearranged and you can't skip content in the middle of the data structure.</source>
          <target state="new">But the order can't be rearranged and you can't skip content in the middle of the data structure.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="new">Note</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The rules in Direct3D 9 for binding vertex shaders to pixel shaders were more relaxed than the rules in Direct3D 11.</source>
          <target state="new">The rules in Direct3D 9 for binding vertex shaders to pixel shaders were more relaxed than the rules in Direct3D 11.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The Direct3D 9 arrangement was flexible, but inefficient.</source>
          <target state="new">The Direct3D 9 arrangement was flexible, but inefficient.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>It's possible that your HLSL files uses older syntax for shader semantics - for example, COLOR instead of SV<ph id="ph1">\_</ph>TARGET.</source>
          <target state="new">It's possible that your HLSL files uses older syntax for shader semantics - for example, COLOR instead of SV<ph id="ph1">\_</ph>TARGET.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If so you'll need to enable HLSL compatibility mode (/Gec compiler option) or update the shader <bpt id="p1">[</bpt>semantics<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</ept> to the current syntax.</source>
          <target state="new">If so you'll need to enable HLSL compatibility mode (/Gec compiler option) or update the shader <bpt id="p1">[</bpt>semantics<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</ept> to the current syntax.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The vertex shader in this example has been updated with current syntax.</source>
          <target state="new">The vertex shader in this example has been updated with current syntax.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Here's our hardware transformation vertex shader, this time defined in its own file.</source>
          <target state="new">Here's our hardware transformation vertex shader, this time defined in its own file.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Vertex shaders are required to output the SV<ph id="ph1">\_</ph>POSITION system value semantic.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Vertex shaders are required to output the SV<ph id="ph1">\_</ph>POSITION system value semantic.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This semantic resolves the vertex position data to coordinate values where x is between -1 and 1, y is between -1 and 1, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).</source>
          <target state="new">This semantic resolves the vertex position data to coordinate values where x is between -1 and 1, y is between -1 and 1, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>HLSL vertex shader (feature level 9.1)</source>
          <target state="new">HLSL vertex shader (feature level 9.1)</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>This is all we need for our pass-through pixel shader.</source>
          <target state="new">This is all we need for our pass-through pixel shader.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Even though we call it a pass-through, it's actually getting perspective-correct interpolated color data for each pixel.</source>
          <target state="new">Even though we call it a pass-through, it's actually getting perspective-correct interpolated color data for each pixel.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Note that the SV<ph id="ph1">\_</ph>TARGET system value semantic is applied to the color value output by our pixel shader as required by the API.</source>
          <target state="new">Note that the SV<ph id="ph1">\_</ph>TARGET system value semantic is applied to the color value output by our pixel shader as required by the API.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Shader level 9<ph id="ph1">\_</ph>x pixel shaders cannot read from the SV<ph id="ph2">\_</ph>POSITION system value semantic.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Shader level 9<ph id="ph1">\_</ph>x pixel shaders cannot read from the SV<ph id="ph2">\_</ph>POSITION system value semantic.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Model 4.0 (and higher) pixel shaders can use SV<ph id="ph1">\_</ph>POSITION to retrieve the pixel location on the screen, where x is between 0 and the render target width and y is between 0 and the render target height (each offset by 0.5).</source>
          <target state="new">Model 4.0 (and higher) pixel shaders can use SV<ph id="ph1">\_</ph>POSITION to retrieve the pixel location on the screen, where x is between 0 and the render target width and y is between 0 and the render target height (each offset by 0.5).</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Most pixel shaders are much more complex than a pass through; note that higher Direct3D feature levels allow a much greater number of calculations per shader program.</source>
          <target state="new">Most pixel shaders are much more complex than a pass through; note that higher Direct3D feature levels allow a much greater number of calculations per shader program.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>HLSL pixel shader (feature level 9.1)</source>
          <target state="new">HLSL pixel shader (feature level 9.1)</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Compile and load shaders</source>
          <target state="new">Compile and load shaders</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Direct3D 9 games often used the Effects library as a convenient way to implement programmable pipelines.</source>
          <target state="new">Direct3D 9 games often used the Effects library as a convenient way to implement programmable pipelines.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Effects could be compiled at run-time using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3DXCreateEffectFromFile function<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb172768)</ept> method.</source>
          <target state="new">Effects could be compiled at run-time using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3DXCreateEffectFromFile function<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb172768)</ept> method.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Loading an effect in Direct3D 9</source>
          <target state="new">Loading an effect in Direct3D 9</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Direct3D 11 works with shader programs as binary resources.</source>
          <target state="new">Direct3D 11 works with shader programs as binary resources.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Shaders are compiled when the project is built and then treated as resources.</source>
          <target state="new">Shaders are compiled when the project is built and then treated as resources.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>So our example will load the shader bytecode into system memory, use the Direct3D device interface to create a Direct3D resource for each shader, and point to the Direct3D shader resources when we set up each frame.</source>
          <target state="new">So our example will load the shader bytecode into system memory, use the Direct3D device interface to create a Direct3D resource for each shader, and point to the Direct3D shader resources when we set up each frame.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Loading a shader resource in Direct3D 11</source>
          <target state="new">Loading a shader resource in Direct3D 11</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>To include the shader bytecode in your compiled app package, just add the HLSL file to the Visual Studio project.</source>
          <target state="new">To include the shader bytecode in your compiled app package, just add the HLSL file to the Visual Studio project.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Visual Studio will use the <bpt id="p1">[</bpt>Effect-Compiler Tool<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb232919)</ept> (FXC) to compile HLSL files into compiled shader objects (.CSO files) and include them in the app package.</source>
          <target state="new">Visual Studio will use the <bpt id="p1">[</bpt>Effect-Compiler Tool<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb232919)</ept> (FXC) to compile HLSL files into compiled shader objects (.CSO files) and include them in the app package.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   Be sure to set the correct target feature level for the HLSL compiler: right-click the HLSL source file in Visual Studio, select Properties, and change the <bpt id="p2">**</bpt>Shader Model<ept id="p2">**</ept> setting under <bpt id="p3">**</bpt>HLSL Compiler -<ph id="ph1">&amp;gt;</ph> General<ept id="p3">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   Be sure to set the correct target feature level for the HLSL compiler: right-click the HLSL source file in Visual Studio, select Properties, and change the <bpt id="p2">**</bpt>Shader Model<ept id="p2">**</ept> setting under <bpt id="p3">**</bpt>HLSL Compiler -<ph id="ph1">&amp;gt;</ph> General<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Direct3D checks this property against the hardware capabilities when your app creates the Direct3D shader resource.</source>
          <target state="new">Direct3D checks this property against the hardware capabilities when your app creates the Direct3D shader resource.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>hlsl shader properties</source>
          <target state="new">hlsl shader properties</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>hlsl shader type</source>
          <target state="new">hlsl shader type</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>This is a good place to create the input layout, which corresponds to the vertex stream declaration in Direct3D 9.</source>
          <target state="new">This is a good place to create the input layout, which corresponds to the vertex stream declaration in Direct3D 9.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The per-vertex data structure needs to match what the vertex shader uses; in Direct3D 11 we have more control over the input layout; we can define the array size and bit length of floating-point vectors and specify semantics for the vertex shader.</source>
          <target state="new">The per-vertex data structure needs to match what the vertex shader uses; in Direct3D 11 we have more control over the input layout; we can define the array size and bit length of floating-point vectors and specify semantics for the vertex shader.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>We create a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>INPUT<ph id="ph2">\_</ph>ELEMENT<ph id="ph3">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structure and use it to inform Direct3D what the per-vertex data will look like.</source>
          <target state="new">We create a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11<ph id="ph1">\_</ph>INPUT<ph id="ph2">\_</ph>ELEMENT<ph id="ph3">\_</ph>DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structure and use it to inform Direct3D what the per-vertex data will look like.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>We waited until after we loaded the vertex shader to define the input layout because the API validates the input layout against the vertex shader resource.</source>
          <target state="new">We waited until after we loaded the vertex shader to define the input layout because the API validates the input layout against the vertex shader resource.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If the input layout isn't compatible then Direct3D throws an exception.</source>
          <target state="new">If the input layout isn't compatible then Direct3D throws an exception.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Per-vertex data has to be stored in compatible types in system memory.</source>
          <target state="new">Per-vertex data has to be stored in compatible types in system memory.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>DirectXMath data types can help; for example, DXGI<ph id="ph1">\_</ph>FORMAT<ph id="ph2">\_</ph>R32G32B32<ph id="ph3">\_</ph>FLOAT corresponds to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XMFLOAT3<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ee419475)</ept>.</source>
          <target state="new">DirectXMath data types can help; for example, DXGI<ph id="ph1">\_</ph>FORMAT<ph id="ph2">\_</ph>R32G32B32<ph id="ph3">\_</ph>FLOAT corresponds to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XMFLOAT3<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ee419475)</ept>.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   Constant buffers use a fixed input layout that aligns to four floating-point numbers at a time.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   Constant buffers use a fixed input layout that aligns to four floating-point numbers at a time.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><bpt id="p2">**</bpt>XMFLOAT4<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ee419608)</ept> (and its derivatives) are recommended for constant buffer data.</source>
          <target state="new"><bpt id="p1">[</bpt><bpt id="p2">**</bpt>XMFLOAT4<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ee419608)</ept> (and its derivatives) are recommended for constant buffer data.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Setting the input layout in Direct3D 11</source>
          <target state="new">Setting the input layout in Direct3D 11</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Create geometry resources</source>
          <target state="new">Create geometry resources</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In Direct3D 9 we stored geometry resources by creating buffers on the Direct3D device, locking the memory, and copying data from CPU memory to GPU memory.</source>
          <target state="new">In Direct3D 9 we stored geometry resources by creating buffers on the Direct3D device, locking the memory, and copying data from CPU memory to GPU memory.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Direct3D 9</source>
          <target state="new">Direct3D 9</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>DirectX 11 follows a simpler process.</source>
          <target state="new">DirectX 11 follows a simpler process.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The API automatically copies the data from system memory to the GPU.</source>
          <target state="new">The API automatically copies the data from system memory to the GPU.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>We can use COM smart pointers to help make programming easier.</source>
          <target state="new">We can use COM smart pointers to help make programming easier.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>DirectX 11</source>
          <target state="new">DirectX 11</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Implement the rendering chain</source>
          <target state="new">Implement the rendering chain</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Direct3D 9 games often used an effect-based rendering chain.</source>
          <target state="new">Direct3D 9 games often used an effect-based rendering chain.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This type of rendering chain sets up the effect object, provides it with the resources it needs, and lets it render each pass.</source>
          <target state="new">This type of rendering chain sets up the effect object, provides it with the resources it needs, and lets it render each pass.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Direct3D 9 rendering chain</source>
          <target state="new">Direct3D 9 rendering chain</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The DirectX 11 rendering chain will still do the same tasks, but the rendering passes need to be implemented differently.</source>
          <target state="new">The DirectX 11 rendering chain will still do the same tasks, but the rendering passes need to be implemented differently.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Instead of putting the specifics in FX files and letting the rendering techniques be more-or-less opaque to our C++ code, we'll set up all our rendering in C++.</source>
          <target state="new">Instead of putting the specifics in FX files and letting the rendering techniques be more-or-less opaque to our C++ code, we'll set up all our rendering in C++.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Here's how our rendering chain will look.</source>
          <target state="new">Here's how our rendering chain will look.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>We need to supply the input layout we created after loading the vertex shader, supply each of the shader objects, and specify the constant buffers for each shader to use.</source>
          <target state="new">We need to supply the input layout we created after loading the vertex shader, supply each of the shader objects, and specify the constant buffers for each shader to use.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>This example doesn't include multiple rendering passes, but if it did we'd do a similar rendering chain for each pass, changing the setup as needed.</source>
          <target state="new">This example doesn't include multiple rendering passes, but if it did we'd do a similar rendering chain for each pass, changing the setup as needed.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Direct3D 11 rendering chain</source>
          <target state="new">Direct3D 11 rendering chain</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The swap chain is part of graphics infrastructure, so we use our DXGI swap chain to present the completed frame.</source>
          <target state="new">The swap chain is part of graphics infrastructure, so we use our DXGI swap chain to present the completed frame.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>DXGI blocks the call until the next vsync; then it returns, and our game loop can continue to the next iteration.</source>
          <target state="new">DXGI blocks the call until the next vsync; then it returns, and our game loop can continue to the next iteration.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Presenting a frame to the screen using DirectX 11</source>
          <target state="new">Presenting a frame to the screen using DirectX 11</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The rendering chain we just created will be called from a game loop implemented in the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IFrameworkView::Run<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh700505)</ept> method.</source>
          <target state="new">The rendering chain we just created will be called from a game loop implemented in the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IFrameworkView::Run<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh700505)</ept> method.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This is shown in <bpt id="p1">[</bpt>Part 3: Viewport and game loop<ept id="p1">](simple-port-from-direct3d-9-to-11-1-part-3--viewport-and-game-loop.md)</ept>.</source>
          <target state="new">This is shown in <bpt id="p1">[</bpt>Part 3: Viewport and game loop<ept id="p1">](simple-port-from-direct3d-9-to-11-1-part-3--viewport-and-game-loop.md)</ept>.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>