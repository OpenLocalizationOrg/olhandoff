<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\load-a-game-asset.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cf9b09714f4a05e42103b4650e8e766bc69624ec</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Load resources in your DirectX game</source>
          <target state="new">Load resources in your DirectX game</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Most games, at some point, load resources and assets (such as shaders, textures, predefined meshes or other graphics data) from local storage or some other data stream.</source>
          <target state="new">Most games, at some point, load resources and assets (such as shaders, textures, predefined meshes or other graphics data) from local storage or some other data stream.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Load resources in your DirectX game</source>
          <target state="new">Load resources in your DirectX game</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Most games, at some point, load resources and assets (such as shaders, textures, predefined meshes or other graphics data) from local storage or some other data stream.</source>
          <target state="new">Most games, at some point, load resources and assets (such as shaders, textures, predefined meshes or other graphics data) from local storage or some other data stream.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Here, we walk you through a high-level view of what you must consider when loading these files to use in your Universal Windows Platform (UWP) game.</source>
          <target state="new">Here, we walk you through a high-level view of what you must consider when loading these files to use in your Universal Windows Platform (UWP) game.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>For example, the meshes for polygonal objects in your game might have been created with another tool, and exported to a specific format.</source>
          <target state="new">For example, the meshes for polygonal objects in your game might have been created with another tool, and exported to a specific format.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The same is true for textures, and more so: while a flat, uncompressed bitmap can be commonly written by most tools and understood by most graphics APIs, it can be extremely inefficient for use in your game.</source>
          <target state="new">The same is true for textures, and more so: while a flat, uncompressed bitmap can be commonly written by most tools and understood by most graphics APIs, it can be extremely inefficient for use in your game.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Here, we guide you through the basic steps for loading three different types of graphic resources for use with Direct3D: meshes (models), textures (bitmaps), and compiled shader objects.</source>
          <target state="new">Here, we guide you through the basic steps for loading three different types of graphic resources for use with Direct3D: meshes (models), textures (bitmaps), and compiled shader objects.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>What you need to know</source>
          <target state="new">What you need to know</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Technologies</source>
          <target state="new">Technologies</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Parallel Patterns Library (ppltasks.h)</source>
          <target state="new">Parallel Patterns Library (ppltasks.h)</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="new">Prerequisites</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Understand the basic Windows Runtime</source>
          <target state="new">Understand the basic Windows Runtime</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Understand asynchronous tasks</source>
          <target state="new">Understand asynchronous tasks</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Understand the basic concepts of 3-D graphics programming.</source>
          <target state="new">Understand the basic concepts of 3-D graphics programming.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This sample also includes three code files for resource loading and management.</source>
          <target state="new">This sample also includes three code files for resource loading and management.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You'll encounter the code objects defined in these files throughout this topic.</source>
          <target state="new">You'll encounter the code objects defined in these files throughout this topic.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>BasicLoader.h/.cpp</source>
          <target state="new">BasicLoader.h/.cpp</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>BasicReaderWriter.h/.cpp</source>
          <target state="new">BasicReaderWriter.h/.cpp</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>DDSTextureLoader.h/.cpp</source>
          <target state="new">DDSTextureLoader.h/.cpp</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The complete code for these samples can be found in the following links.</source>
          <target state="new">The complete code for these samples can be found in the following links.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Topic</source>
          <target state="new">Topic</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="new">Description</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Complete code for BasicLoader</source>
          <target state="new">Complete code for BasicLoader</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Complete code for a class and methods that convert and load graphics mesh objects into memory.</source>
          <target state="new">Complete code for a class and methods that convert and load graphics mesh objects into memory.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Complete code for BasicReaderWriter</source>
          <target state="new">Complete code for BasicReaderWriter</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Complete code for a class and methods for reading and writing binary data files in general.</source>
          <target state="new">Complete code for a class and methods for reading and writing binary data files in general.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Used by the <bpt id="p1">[</bpt>BasicLoader<ept id="p1">](complete-code-for-basicloader.md)</ept> class.</source>
          <target state="new">Used by the <bpt id="p1">[</bpt>BasicLoader<ept id="p1">](complete-code-for-basicloader.md)</ept> class.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Complete code for DDSTextureLoader</source>
          <target state="new">Complete code for DDSTextureLoader</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Complete code for a class and method that loads a DDS texture from memory.</source>
          <target state="new">Complete code for a class and method that loads a DDS texture from memory.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="new">Instructions</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Asynchronous loading</source>
          <target state="new">Asynchronous loading</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Asynchronous loading is handled using the <bpt id="p1">**</bpt>task<ept id="p1">**</ept> template from the Parallel Patterns Library (PPL).</source>
          <target state="new">Asynchronous loading is handled using the <bpt id="p1">**</bpt>task<ept id="p1">**</ept> template from the Parallel Patterns Library (PPL).</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>task<ept id="p1">**</ept> contains a method call followed by a lambda that processes the results of the async call after it completes, and usually follows the format of:</source>
          <target state="new">A <bpt id="p1">**</bpt>task<ept id="p1">**</ept> contains a method call followed by a lambda that processes the results of the async call after it completes, and usually follows the format of:</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="new">.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Tasks can be chained together using the <bpt id="p1">**</bpt>.then()<ept id="p1">**</ept> syntax, so that when one operation completes, another async operation that depends on the results of the prior operation can be run.</source>
          <target state="new">Tasks can be chained together using the <bpt id="p1">**</bpt>.then()<ept id="p1">**</ept> syntax, so that when one operation completes, another async operation that depends on the results of the prior operation can be run.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In this way, you can load, convert, and manage complex assets on separate threads in a way that appears almost invisible to the player.</source>
          <target state="new">In this way, you can load, convert, and manage complex assets on separate threads in a way that appears almost invisible to the player.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>For more details, read <bpt id="p1">[</bpt>Asynchronous programming in C++<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/mt187334)</ept>.</source>
          <target state="new">For more details, read <bpt id="p1">[</bpt>Asynchronous programming in C++<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/mt187334)</ept>.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Now, let's look at the basic structure for declaring and creating an async file loading method, <bpt id="p1">**</bpt>ReadDataAsync<ept id="p1">**</ept>.</source>
          <target state="new">Now, let's look at the basic structure for declaring and creating an async file loading method, <bpt id="p1">**</bpt>ReadDataAsync<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In this code, when your code calls the <bpt id="p1">**</bpt>ReadDataAsync<ept id="p1">**</ept> method defined above, a task is created to read a buffer from the file system.</source>
          <target state="new">In this code, when your code calls the <bpt id="p1">**</bpt>ReadDataAsync<ept id="p1">**</ept> method defined above, a task is created to read a buffer from the file system.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Once it completes, a chained task takes the buffer and streams the bytes from that buffer into an array using the static <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DataReader<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208119)</ept> type.</source>
          <target state="new">Once it completes, a chained task takes the buffer and streams the bytes from that buffer into an array using the static <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DataReader<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208119)</ept> type.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Here's the call you make to <bpt id="p1">**</bpt>ReadDataAsync<ept id="p1">**</ept>.</source>
          <target state="new">Here's the call you make to <bpt id="p1">**</bpt>ReadDataAsync<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>When it completes, your code receives an array of bytes read from the provided file.</source>
          <target state="new">When it completes, your code receives an array of bytes read from the provided file.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Since <bpt id="p1">**</bpt>ReadDataAsync<ept id="p1">**</ept> itself is defined as a task, you can use a lambda to perform a specific operation when the byte array is returned, such as passing that byte data to a DirectX function that can use it.</source>
          <target state="new">Since <bpt id="p1">**</bpt>ReadDataAsync<ept id="p1">**</ept> itself is defined as a task, you can use a lambda to perform a specific operation when the byte array is returned, such as passing that byte data to a DirectX function that can use it.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>If your game is sufficiently simple, load your resources with a method like this when the user starts the game.</source>
          <target state="new">If your game is sufficiently simple, load your resources with a method like this when the user starts the game.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You can do this before you start the main game loop from some point in the call sequence of your <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IFrameworkView::Run<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh700505)</ept> implementation.</source>
          <target state="new">You can do this before you start the main game loop from some point in the call sequence of your <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IFrameworkView::Run<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh700505)</ept> implementation.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Again, you call your resource loading methods asynchronously so the game can start quicker and so the player doesn't have to wait until the loading completes before engaging in early interactions.</source>
          <target state="new">Again, you call your resource loading methods asynchronously so the game can start quicker and so the player doesn't have to wait until the loading completes before engaging in early interactions.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>However, you don't want to start the game proper until all of the async loading has completed!</source>
          <target state="new">However, you don't want to start the game proper until all of the async loading has completed!</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Create some method for signaling when loading is complete, such as a specific field, and use the lambdas on your loading method(s) to set that signal when finished.</source>
          <target state="new">Create some method for signaling when loading is complete, such as a specific field, and use the lambdas on your loading method(s) to set that signal when finished.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Check the variable before starting any components that use those loaded resources.</source>
          <target state="new">Check the variable before starting any components that use those loaded resources.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Here's an example using the async methods defined in BasicLoader.cpp to load shaders, a mesh, and a texture when the game starts up.</source>
          <target state="new">Here's an example using the async methods defined in BasicLoader.cpp to load shaders, a mesh, and a texture when the game starts up.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Notice that it sets a specific field on the game object, <bpt id="p1">**</bpt>m<ph id="ph1">\_</ph>loadingComplete<ept id="p1">**</ept>, when all of the loading methods finish.</source>
          <target state="new">Notice that it sets a specific field on the game object, <bpt id="p1">**</bpt>m<ph id="ph1">\_</ph>loadingComplete<ept id="p1">**</ept>, when all of the loading methods finish.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Note that the tasks have been aggregated using the &amp;&amp; operator such that the lambda that sets the loading complete flag is triggered only when all of the tasks complete.</source>
          <target state="new">Note that the tasks have been aggregated using the &amp;&amp; operator such that the lambda that sets the loading complete flag is triggered only when all of the tasks complete.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Note that if you have multiple flags, you have the possibility of race conditions.</source>
          <target state="new">Note that if you have multiple flags, you have the possibility of race conditions.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For example, if the lambda sets two flags sequentially to the same value, another thread may only see the first flag set if it examines them before the second flag is set.</source>
          <target state="new">For example, if the lambda sets two flags sequentially to the same value, another thread may only see the first flag set if it examines them before the second flag is set.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>You've seen how to load resource files asynchronously.</source>
          <target state="new">You've seen how to load resource files asynchronously.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Synchronous file loads are much simpler, and you can find examples of them in <bpt id="p1">[</bpt>Complete code for BasicReaderWriter<ept id="p1">](complete-code-for-basicreaderwriter.md)</ept> and <bpt id="p2">[</bpt>Complete code for BasicLoader<ept id="p2">](complete-code-for-basicloader.md)</ept>.</source>
          <target state="new">Synchronous file loads are much simpler, and you can find examples of them in <bpt id="p1">[</bpt>Complete code for BasicReaderWriter<ept id="p1">](complete-code-for-basicreaderwriter.md)</ept> and <bpt id="p2">[</bpt>Complete code for BasicLoader<ept id="p2">](complete-code-for-basicloader.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Of course, different resource and asset types often require additional processing or conversion before they are ready to be used in your graphics pipeline.</source>
          <target state="new">Of course, different resource and asset types often require additional processing or conversion before they are ready to be used in your graphics pipeline.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Let's take a look at three specific types of resources: meshes, textures, and shaders.</source>
          <target state="new">Let's take a look at three specific types of resources: meshes, textures, and shaders.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Loading meshes</source>
          <target state="new">Loading meshes</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Meshes are vertex data, either generated procedurally by code within your game or exported to a file from another app (like 3DStudio MAX or Alias WaveFront) or tool.</source>
          <target state="new">Meshes are vertex data, either generated procedurally by code within your game or exported to a file from another app (like 3DStudio MAX or Alias WaveFront) or tool.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>These meshes represent the models in your game, from simple primitives like cubes and spheres to cars and houses and characters.</source>
          <target state="new">These meshes represent the models in your game, from simple primitives like cubes and spheres to cars and houses and characters.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>They often contain color and animation data, as well, depending on their format.</source>
          <target state="new">They often contain color and animation data, as well, depending on their format.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>We'll focus on meshes that contain only vertex data.</source>
          <target state="new">We'll focus on meshes that contain only vertex data.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>To load a mesh correctly, you must know the format of the data in the file for the mesh.</source>
          <target state="new">To load a mesh correctly, you must know the format of the data in the file for the mesh.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Our simple <bpt id="p1">**</bpt>BasicReaderWriter<ept id="p1">**</ept> type above simply reads the data in as a byte stream; it doesn't know that the byte data represents a mesh, much less a specific mesh format as exported by another application!</source>
          <target state="new">Our simple <bpt id="p1">**</bpt>BasicReaderWriter<ept id="p1">**</ept> type above simply reads the data in as a byte stream; it doesn't know that the byte data represents a mesh, much less a specific mesh format as exported by another application!</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You must perform the conversion as you bring the mesh data into memory.</source>
          <target state="new">You must perform the conversion as you bring the mesh data into memory.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>(You should always try to package asset data in a format that's as close to the internal representation as possible.</source>
          <target state="new">(You should always try to package asset data in a format that's as close to the internal representation as possible.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Doing so will reduce resource utilization and save time.)</source>
          <target state="new">Doing so will reduce resource utilization and save time.)</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Let's get the byte data from the mesh's file.</source>
          <target state="new">Let's get the byte data from the mesh's file.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The format in the example assumes that the file is a sample-specific format suffixed with .vbo.</source>
          <target state="new">The format in the example assumes that the file is a sample-specific format suffixed with .vbo.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>(Again, this format is not the same as OpenGL's VBO format.) Each vertex itself maps to the <bpt id="p1">**</bpt>BasicVertex<ept id="p1">**</ept> type, which is a struct defined in the code for the obj2vbo converter tool.</source>
          <target state="new">(Again, this format is not the same as OpenGL's VBO format.) Each vertex itself maps to the <bpt id="p1">**</bpt>BasicVertex<ept id="p1">**</ept> type, which is a struct defined in the code for the obj2vbo converter tool.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The layout of the vertex data in the .vbo file looks like this:</source>
          <target state="new">The layout of the vertex data in the .vbo file looks like this:</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The first 32 bits (4 bytes) of the data stream contain the number of vertices (numVertices) in the mesh, represented as a uint32 value.</source>
          <target state="new">The first 32 bits (4 bytes) of the data stream contain the number of vertices (numVertices) in the mesh, represented as a uint32 value.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The next 32 bits (4 bytes) of the data stream contain the number of indices in the mesh (numIndices), represented as a uint32 value.</source>
          <target state="new">The next 32 bits (4 bytes) of the data stream contain the number of indices in the mesh (numIndices), represented as a uint32 value.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>After that, the subsequent (numVertices <ph id="ph1">\*</ph> sizeof(<bpt id="p1">**</bpt>BasicVertex<ept id="p1">**</ept>)) bits contain the vertex data.</source>
          <target state="new">After that, the subsequent (numVertices <ph id="ph1">\*</ph> sizeof(<bpt id="p1">**</bpt>BasicVertex<ept id="p1">**</ept>)) bits contain the vertex data.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>The last (numIndices <ph id="ph1">\*</ph> 16) bits of data contain the index data, represented as a sequence of uint16 values.</source>
          <target state="new">The last (numIndices <ph id="ph1">\*</ph> 16) bits of data contain the index data, represented as a sequence of uint16 values.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The point is this: know the bit-level layout of the mesh data you have loaded.</source>
          <target state="new">The point is this: know the bit-level layout of the mesh data you have loaded.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Also, be sure you are consistent with endian-ness.</source>
          <target state="new">Also, be sure you are consistent with endian-ness.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>All Windows 8 platforms are little-endian.</source>
          <target state="new">All Windows 8 platforms are little-endian.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>In the example, you call a method, CreateMesh, from the <bpt id="p1">**</bpt>LoadMeshAsync<ept id="p1">**</ept> method to perform this bit-level interpretation.</source>
          <target state="new">In the example, you call a method, CreateMesh, from the <bpt id="p1">**</bpt>LoadMeshAsync<ept id="p1">**</ept> method to perform this bit-level interpretation.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CreateMesh<ept id="p1">**</ept> interprets the byte data loaded from the file, and creates a vertex buffer and an index buffer for the mesh by passing the vertex and index lists, respectively, to <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ID3D11Device::CreateBuffer<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> and specifying either D3D11<ph id="ph1">\_</ph>BIND<ph id="ph2">\_</ph>VERTEX<ph id="ph3">\_</ph>BUFFER or D3D11<ph id="ph4">\_</ph>BIND<ph id="ph5">\_</ph>INDEX<ph id="ph6">\_</ph>BUFFER.</source>
          <target state="new"><bpt id="p1">**</bpt>CreateMesh<ept id="p1">**</ept> interprets the byte data loaded from the file, and creates a vertex buffer and an index buffer for the mesh by passing the vertex and index lists, respectively, to <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ID3D11Device::CreateBuffer<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> and specifying either D3D11<ph id="ph1">\_</ph>BIND<ph id="ph2">\_</ph>VERTEX<ph id="ph3">\_</ph>BUFFER or D3D11<ph id="ph4">\_</ph>BIND<ph id="ph5">\_</ph>INDEX<ph id="ph6">\_</ph>BUFFER.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Here's the code used in <bpt id="p1">**</bpt>BasicLoader<ept id="p1">**</ept>:</source>
          <target state="new">Here's the code used in <bpt id="p1">**</bpt>BasicLoader<ept id="p1">**</ept>:</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You typically create a vertex/index buffer pair for every mesh you use in your game.</source>
          <target state="new">You typically create a vertex/index buffer pair for every mesh you use in your game.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Where and when you load the meshes is up to you.</source>
          <target state="new">Where and when you load the meshes is up to you.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If you have a lot of meshes, you may only want to load some from the disk at specific points in the game, such as during specific, pre-defined loading states.</source>
          <target state="new">If you have a lot of meshes, you may only want to load some from the disk at specific points in the game, such as during specific, pre-defined loading states.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For large meshes, like terrain data, you can stream the vertices from a cache, but that is a more complex procedure and not in the scope of this topic.</source>
          <target state="new">For large meshes, like terrain data, you can stream the vertices from a cache, but that is a more complex procedure and not in the scope of this topic.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Again, know your vertex data format!</source>
          <target state="new">Again, know your vertex data format!</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>There are many, many ways to represent vertex data across the tools used to create models.</source>
          <target state="new">There are many, many ways to represent vertex data across the tools used to create models.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>There are also many different ways to represent the input layout of the vertex data to Direct3D, such as triangle lists and strips.</source>
          <target state="new">There are also many different ways to represent the input layout of the vertex data to Direct3D, such as triangle lists and strips.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For more information about vertex data, read <bpt id="p1">[</bpt>Introduction to Buffers in Direct3D 11<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476898)</ept> and <bpt id="p2">[</bpt>Primitives<ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/bb147291)</ept>.</source>
          <target state="new">For more information about vertex data, read <bpt id="p1">[</bpt>Introduction to Buffers in Direct3D 11<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476898)</ept> and <bpt id="p2">[</bpt>Primitives<ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/bb147291)</ept>.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Next, let's look at loading textures.</source>
          <target state="new">Next, let's look at loading textures.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Loading textures</source>
          <target state="new">Loading textures</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The most common asset in a game—and the one that comprises most of the files on disk and in memory—are textures.</source>
          <target state="new">The most common asset in a game—and the one that comprises most of the files on disk and in memory—are textures.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Like meshes, textures can come in a variety of formats, and you convert them to a format that Direct3D can use when you load them.</source>
          <target state="new">Like meshes, textures can come in a variety of formats, and you convert them to a format that Direct3D can use when you load them.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Textures also come in a wide variety of types and are used to create different effects.</source>
          <target state="new">Textures also come in a wide variety of types and are used to create different effects.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>MIP levels for textures can be used to improve the look and performance of distance objects; dirt and light maps are used to layer effects and detail atop a base texture; and normal maps are used in per-pixel lighting calculations.</source>
          <target state="new">MIP levels for textures can be used to improve the look and performance of distance objects; dirt and light maps are used to layer effects and detail atop a base texture; and normal maps are used in per-pixel lighting calculations.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>In a modern game, a typical scene can potentially have thousands of individual textures, and your code must effectively manage them all!</source>
          <target state="new">In a modern game, a typical scene can potentially have thousands of individual textures, and your code must effectively manage them all!</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Also like meshes, there are a number of specific formats that are used to make memory usage for efficient.</source>
          <target state="new">Also like meshes, there are a number of specific formats that are used to make memory usage for efficient.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Since textures can easily consume a large portion of the GPU (and system) memory, they are often compressed in some fashion.</source>
          <target state="new">Since textures can easily consume a large portion of the GPU (and system) memory, they are often compressed in some fashion.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>You aren't required to use compression on your game's textures, and you can use any compression/decompression algorithm(s) you want as long as you provide the Direct3D shaders with data in a format it can understand (like a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Texture2D<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept> bitmap).</source>
          <target state="new">You aren't required to use compression on your game's textures, and you can use any compression/decompression algorithm(s) you want as long as you provide the Direct3D shaders with data in a format it can understand (like a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Texture2D<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept> bitmap).</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Direct3D provides support for the DXT texture compression algorithms, although every DXT format may not be supported in the player's graphics hardware.</source>
          <target state="new">Direct3D provides support for the DXT texture compression algorithms, although every DXT format may not be supported in the player's graphics hardware.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>DDS files contain DXT textures (and other texture compression formats as well), and are suffixed with .dds.</source>
          <target state="new">DDS files contain DXT textures (and other texture compression formats as well), and are suffixed with .dds.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>A DDS file is a binary file that contains the following information:</source>
          <target state="new">A DDS file is a binary file that contains the following information:</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>A DWORD (magic number) containing the four character code value 'DDS ' (0x20534444).</source>
          <target state="new">A DWORD (magic number) containing the four character code value 'DDS ' (0x20534444).</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>A description of the data in the file.</source>
          <target state="new">A description of the data in the file.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The data is described with a header description using <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DDS<ph id="ph1">\_</ph>HEADER<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb943982)</ept>; the pixel format is defined using <bpt id="p3">[</bpt><bpt id="p4">**</bpt>DDS<ph id="ph2">\_</ph>PIXELFORMAT<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/bb943984)</ept>.</source>
          <target state="new">The data is described with a header description using <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DDS<ph id="ph1">\_</ph>HEADER<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb943982)</ept>; the pixel format is defined using <bpt id="p3">[</bpt><bpt id="p4">**</bpt>DDS<ph id="ph2">\_</ph>PIXELFORMAT<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/bb943984)</ept>.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Note that the <bpt id="p1">**</bpt>DDS<ph id="ph1">\_</ph>HEADER<ept id="p1">**</ept> and <bpt id="p2">**</bpt>DDS<ph id="ph2">\_</ph>PIXELFORMAT<ept id="p2">**</ept> structures replace the deprecated DDSURFACEDESC2, DDSCAPS2 and DDPIXELFORMAT DirectDraw 7 structures.</source>
          <target state="new">Note that the <bpt id="p1">**</bpt>DDS<ph id="ph1">\_</ph>HEADER<ept id="p1">**</ept> and <bpt id="p2">**</bpt>DDS<ph id="ph2">\_</ph>PIXELFORMAT<ept id="p2">**</ept> structures replace the deprecated DDSURFACEDESC2, DDSCAPS2 and DDPIXELFORMAT DirectDraw 7 structures.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DDS<ph id="ph1">\_</ph>HEADER<ept id="p1">**</ept> is the binary equivalent of DDSURFACEDESC2 and DDSCAPS2.</source>
          <target state="new"><bpt id="p1">**</bpt>DDS<ph id="ph1">\_</ph>HEADER<ept id="p1">**</ept> is the binary equivalent of DDSURFACEDESC2 and DDSCAPS2.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>DDS<ph id="ph1">\_</ph>PIXELFORMAT<ept id="p1">**</ept> is the binary equivalent of DDPIXELFORMAT.</source>
          <target state="new"><bpt id="p1">**</bpt>DDS<ph id="ph1">\_</ph>PIXELFORMAT<ept id="p1">**</ept> is the binary equivalent of DDPIXELFORMAT.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>If the value of <bpt id="p1">**</bpt>dwFlags<ept id="p1">**</ept> in <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DDS<ph id="ph1">\_</ph>PIXELFORMAT<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/bb943984)</ept> is set to DDPF<ph id="ph2">\_</ph>FOURCC and <bpt id="p4">**</bpt>dwFourCC<ept id="p4">**</ept> is set to "DX10" an additional <bpt id="p5">[</bpt><bpt id="p6">**</bpt>DDS<ph id="ph3">\_</ph>HEADER<ph id="ph4">\_</ph>DXT10<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/bb943983)</ept> structure will be present to accommodate texture arrays or DXGI formats that cannot be expressed as an RGB pixel format such as floating point formats, sRGB formats etc. When the <bpt id="p7">**</bpt>DDS<ph id="ph5">\_</ph>HEADER<ph id="ph6">\_</ph>DXT10<ept id="p7">**</ept> structure is present, the entire data description will looks like this.</source>
          <target state="new">If the value of <bpt id="p1">**</bpt>dwFlags<ept id="p1">**</ept> in <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DDS<ph id="ph1">\_</ph>PIXELFORMAT<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/bb943984)</ept> is set to DDPF<ph id="ph2">\_</ph>FOURCC and <bpt id="p4">**</bpt>dwFourCC<ept id="p4">**</ept> is set to "DX10" an additional <bpt id="p5">[</bpt><bpt id="p6">**</bpt>DDS<ph id="ph3">\_</ph>HEADER<ph id="ph4">\_</ph>DXT10<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/bb943983)</ept> structure will be present to accommodate texture arrays or DXGI formats that cannot be expressed as an RGB pixel format such as floating point formats, sRGB formats etc. When the <bpt id="p7">**</bpt>DDS<ph id="ph5">\_</ph>HEADER<ph id="ph6">\_</ph>DXT10<ept id="p7">**</ept> structure is present, the entire data description will looks like this.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>A pointer to an array of bytes that contains the main surface data.</source>
          <target state="new">A pointer to an array of bytes that contains the main surface data.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>A pointer to an array of bytes that contains the remaining surfaces such as; mipmap levels, faces in a cube map, depths in a volume texture.</source>
          <target state="new">A pointer to an array of bytes that contains the remaining surfaces such as; mipmap levels, faces in a cube map, depths in a volume texture.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Follow these links for more information about the DDS file layout for a: <bpt id="p1">[</bpt>texture<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb205578)</ept>, a <bpt id="p2">[</bpt>cube map<ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/bb205577)</ept>, or a <bpt id="p3">[</bpt>volume texture<ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/bb205579)</ept>.</source>
          <target state="new">Follow these links for more information about the DDS file layout for a: <bpt id="p1">[</bpt>texture<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb205578)</ept>, a <bpt id="p2">[</bpt>cube map<ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/bb205577)</ept>, or a <bpt id="p3">[</bpt>volume texture<ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/bb205579)</ept>.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Many tools export to the DDS format.</source>
          <target state="new">Many tools export to the DDS format.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>If you don't have a tool to export your texture to this format, consider creating one.</source>
          <target state="new">If you don't have a tool to export your texture to this format, consider creating one.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>For more detail on the DDS format and how to work with it in your code, read <bpt id="p1">[</bpt>Programming Guide for DDS<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb943991)</ept>.</source>
          <target state="new">For more detail on the DDS format and how to work with it in your code, read <bpt id="p1">[</bpt>Programming Guide for DDS<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb943991)</ept>.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>In our example, we'll use DDS.</source>
          <target state="new">In our example, we'll use DDS.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>As with other resource types, you read the data from a file as a stream of bytes.</source>
          <target state="new">As with other resource types, you read the data from a file as a stream of bytes.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Once your loading task completes, the lambda call runs code (the <bpt id="p1">**</bpt>CreateTexture<ept id="p1">**</ept> method) to process the stream of bytes into a format that Direct3D can use.</source>
          <target state="new">Once your loading task completes, the lambda call runs code (the <bpt id="p1">**</bpt>CreateTexture<ept id="p1">**</ept> method) to process the stream of bytes into a format that Direct3D can use.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In the previous snippet, the lambda checks to see if the filename has an extension of "dds".</source>
          <target state="new">In the previous snippet, the lambda checks to see if the filename has an extension of "dds".</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>If it does, you assume that it is a DDS texture.</source>
          <target state="new">If it does, you assume that it is a DDS texture.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If not, well, use the Windows Imaging Component (WIC) APIs to discover the format and decode the data as a bitmap.</source>
          <target state="new">If not, well, use the Windows Imaging Component (WIC) APIs to discover the format and decode the data as a bitmap.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Either way, the result is a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Texture2D<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept> bitmap (or an error).</source>
          <target state="new">Either way, the result is a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Texture2D<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept> bitmap (or an error).</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>When this code completes, you have a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Texture2D<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept> in memory, loaded from an image file.</source>
          <target state="new">When this code completes, you have a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Texture2D<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept> in memory, loaded from an image file.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>As with meshes, you probably have a lot of them in your game and in any given scene.</source>
          <target state="new">As with meshes, you probably have a lot of them in your game and in any given scene.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Consider creating caches for regularly accessed textures per-scene or per-level, rather than loading them all when the game or level starts.</source>
          <target state="new">Consider creating caches for regularly accessed textures per-scene or per-level, rather than loading them all when the game or level starts.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>(The <bpt id="p1">**</bpt>CreateDDSTextureFromMemory<ept id="p1">**</ept> method called in the above sample can be explored in full in <bpt id="p2">[</bpt>Complete code for DDSTextureLoader<ept id="p2">](complete-code-for-ddstextureloader.md)</ept>.)</source>
          <target state="new">(The <bpt id="p1">**</bpt>CreateDDSTextureFromMemory<ept id="p1">**</ept> method called in the above sample can be explored in full in <bpt id="p2">[</bpt>Complete code for DDSTextureLoader<ept id="p2">](complete-code-for-ddstextureloader.md)</ept>.)</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Also, individual textures or texture "skins" may map to specific mesh polygons or surfaces.</source>
          <target state="new">Also, individual textures or texture "skins" may map to specific mesh polygons or surfaces.</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>This mapping data is usually exported by the tool an artist or designer used to create the model and the textures.</source>
          <target state="new">This mapping data is usually exported by the tool an artist or designer used to create the model and the textures.</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Make sure that you capture this information as well when you load the exported data, as you will use it map the correct textures to the corresponding surfaces when you perform fragment shading.</source>
          <target state="new">Make sure that you capture this information as well when you load the exported data, as you will use it map the correct textures to the corresponding surfaces when you perform fragment shading.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Loading shaders</source>
          <target state="new">Loading shaders</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Shaders are compiled High Level Shader Language (HLSL) files that are loaded into memory and invoked at specific stages of the graphics pipeline.</source>
          <target state="new">Shaders are compiled High Level Shader Language (HLSL) files that are loaded into memory and invoked at specific stages of the graphics pipeline.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>The most common and essential shaders are the vertex and pixel shaders, which process the individual vertices of your mesh and the pixels in the scene's viewport(s), respectively.</source>
          <target state="new">The most common and essential shaders are the vertex and pixel shaders, which process the individual vertices of your mesh and the pixels in the scene's viewport(s), respectively.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The HLSL code is executed to transform the geometry, apply lighting effects and textures, and perform post-processing on the rendered scene.</source>
          <target state="new">The HLSL code is executed to transform the geometry, apply lighting effects and textures, and perform post-processing on the rendered scene.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>A Direct3D game can have a number of different shaders, each one compiled into a separate CSO (Compiled Shader Object, .cso) file.</source>
          <target state="new">A Direct3D game can have a number of different shaders, each one compiled into a separate CSO (Compiled Shader Object, .cso) file.</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Normally, you don't have so many that you need to load them dynamically, and in most cases, you can simply load them when the game is starting, or on a per-level basis (such as a shader for rain effects).</source>
          <target state="new">Normally, you don't have so many that you need to load them dynamically, and in most cases, you can simply load them when the game is starting, or on a per-level basis (such as a shader for rain effects).</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The code in the <bpt id="p1">**</bpt>BasicLoader<ept id="p1">**</ept> class provides a number of overloads for different shaders, including vertex, geometry, pixel, and hull shaders.</source>
          <target state="new">The code in the <bpt id="p1">**</bpt>BasicLoader<ept id="p1">**</ept> class provides a number of overloads for different shaders, including vertex, geometry, pixel, and hull shaders.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The code below covers pixel shaders as an example.</source>
          <target state="new">The code below covers pixel shaders as an example.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>(You can review the complete code in <bpt id="p1">[</bpt>Complete code for BasicLoader<ept id="p1">](complete-code-for-basicloader.md)</ept>.)</source>
          <target state="new">(You can review the complete code in <bpt id="p1">[</bpt>Complete code for BasicLoader<ept id="p1">](complete-code-for-basicloader.md)</ept>.)</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>In this example, you use the <bpt id="p1">**</bpt>BasicReaderWriter<ept id="p1">**</ept> instance (<bpt id="p2">**</bpt>m<ph id="ph1">\_</ph>basicReaderWriter<ept id="p2">**</ept>) to read in the supplied compiled shader object (.cso) file as a byte stream.</source>
          <target state="new">In this example, you use the <bpt id="p1">**</bpt>BasicReaderWriter<ept id="p1">**</ept> instance (<bpt id="p2">**</bpt>m<ph id="ph1">\_</ph>basicReaderWriter<ept id="p2">**</ept>) to read in the supplied compiled shader object (.cso) file as a byte stream.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>Once that task completes, the lambda calls <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreatePixelShader<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</ept> with the byte data loaded from the file.</source>
          <target state="new">Once that task completes, the lambda calls <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreatePixelShader<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476513)</ept> with the byte data loaded from the file.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Your callback must set some flag indicating that the load was successful, and your code must check this flag before running the shader.</source>
          <target state="new">Your callback must set some flag indicating that the load was successful, and your code must check this flag before running the shader.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Vertex shaders are bit more complex.</source>
          <target state="new">Vertex shaders are bit more complex.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>For a vertex shader, you also load a separate input layout that defines the vertex data.</source>
          <target state="new">For a vertex shader, you also load a separate input layout that defines the vertex data.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The following code can be used to asynchronously load a vertex shader along with a custom vertex input layout.</source>
          <target state="new">The following code can be used to asynchronously load a vertex shader along with a custom vertex input layout.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Be sure that the vertex information that you load from your meshes can be correctly represented by this input layout!</source>
          <target state="new">Be sure that the vertex information that you load from your meshes can be correctly represented by this input layout!</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Let's create the input layout before you load the vertex shader.</source>
          <target state="new">Let's create the input layout before you load the vertex shader.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>In this particular layout, each vertex has the following data processed by the vertex shader:</source>
          <target state="new">In this particular layout, each vertex has the following data processed by the vertex shader:</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>A 3D coordinate position (x, y, z) in the model's coordinate space, represented as a trio of 32-bit floating point values.</source>
          <target state="new">A 3D coordinate position (x, y, z) in the model's coordinate space, represented as a trio of 32-bit floating point values.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>A normal vector for the vertex, also represented as three 32-bit floating point values.</source>
          <target state="new">A normal vector for the vertex, also represented as three 32-bit floating point values.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>A transformed 2D texture coordinate value (u, v) , represented as a pair of 32-bit floating values.</source>
          <target state="new">A transformed 2D texture coordinate value (u, v) , represented as a pair of 32-bit floating values.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>These per-vertex input elements are called <bpt id="p1">[</bpt>HLSL semantics<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</ept>, and they are a set of defined registers used to pass data to and from your compiled shader object.</source>
          <target state="new">These per-vertex input elements are called <bpt id="p1">[</bpt>HLSL semantics<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</ept>, and they are a set of defined registers used to pass data to and from your compiled shader object.</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Your pipeline runs the vertex shader once for every vertex in the mesh that you've loaded.</source>
          <target state="new">Your pipeline runs the vertex shader once for every vertex in the mesh that you've loaded.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The semantics define the input to (and output from) the vertex shader as it runs, and provide this data for your per-vertex computations in your shader's HLSL code.</source>
          <target state="new">The semantics define the input to (and output from) the vertex shader as it runs, and provide this data for your per-vertex computations in your shader's HLSL code.</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Now, load the vertex shader object.</source>
          <target state="new">Now, load the vertex shader object.</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>In this code, once you've read in the byte data for the vertex shader's CSO file, you create the vertex shader by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateVertexShader<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</ept>.</source>
          <target state="new">In this code, once you've read in the byte data for the vertex shader's CSO file, you create the vertex shader by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateVertexShader<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476524)</ept>.</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>After that, you create your input layout for the shader in the same lambda.</source>
          <target state="new">After that, you create your input layout for the shader in the same lambda.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Other shader types, such as hull and geometry shaders, can also require specific configuration.</source>
          <target state="new">Other shader types, such as hull and geometry shaders, can also require specific configuration.</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Complete code for a variety of shader loading methods is provided in <bpt id="p1">[</bpt>Complete code for BasicLoader<ept id="p1">](complete-code-for-basicloader.md)</ept> and in the <bpt id="p2">[</bpt>Direct3D resource loading sample<ept id="p2">]( http://go.microsoft.com/fwlink/p/?LinkID=265132)</ept>.</source>
          <target state="new">Complete code for a variety of shader loading methods is provided in <bpt id="p1">[</bpt>Complete code for BasicLoader<ept id="p1">](complete-code-for-basicloader.md)</ept> and in the <bpt id="p2">[</bpt>Direct3D resource loading sample<ept id="p2">]( http://go.microsoft.com/fwlink/p/?LinkID=265132)</ept>.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="new">Remarks</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>At this point, you should understand and be able to create or modify methods for asynchronously loading common game resources and assets, such as meshes, textures, and compiled shaders.</source>
          <target state="new">At this point, you should understand and be able to create or modify methods for asynchronously loading common game resources and assets, such as meshes, textures, and compiled shaders.</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Direct3D resource loading sample</source>
          <target state="new">Direct3D resource loading sample</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>Complete code for BasicLoader</source>
          <target state="new">Complete code for BasicLoader</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Complete code for BasicReaderWriter</source>
          <target state="new">Complete code for BasicReaderWriter</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Complete code for DDSTextureLoader</source>
          <target state="new">Complete code for DDSTextureLoader</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>