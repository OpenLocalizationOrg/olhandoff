{"nodes":[{"content":"Bluetooth RFCOMM","pos":[78,94]},{"content":"This article provides an overview of Bluetooth RFCOMM in Universal Windows Platform (UWP) apps, along with example code on how to send or receive a file.","pos":[108,261]},{"content":"Bluetooth RFCOMM","pos":[268,284]},{"content":"Updated for UWP apps on Windows 10.","pos":[289,324]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[325,417]},{"content":"Important APIs","pos":[425,439]},{"content":"Windows.Devices.Bluetooth","pos":[451,476]},{"content":"Windows.Devices.Bluetooth.Rfcomm","pos":[545,577]},{"content":"This article provides an overview of Bluetooth RFCOMM in Universal Windows Platform (UWP) apps, along with example code on how to send or receive a file..","pos":[640,794]},{"content":"Overview","pos":[799,807]},{"content":"The APIs in the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows.Devices.Bluetooth.Rfcomm<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn263529)</ept> namespace build on existing patterns for Windows.Devices, including <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>enumeration<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR225459)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>instantiation<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/BR225654)</ept>.","pos":[809,1148]},{"content":"Data reading and writing is designed to take advantage of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>established data stream patterns<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208119)</ept> and objects in <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Windows.Storage.Streams<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR241791)</ept>.","pos":[1149,1407]},{"content":"Service Discovery Protocol (SDP) attributes have a value and an expected type.","pos":[1408,1486]},{"content":"However, some common devices have faulty implementations of SDP attributes where the value is not of the expected type.","pos":[1487,1606]},{"content":"Additionally, many usages of RFCOMM do not require additional SDP attributes at all.","pos":[1607,1691]},{"content":"For these reasons, this API offers access to the unparsed SDP data, from which developers can obtain the information they need.","pos":[1692,1819]},{"content":"The RFCOMM APIs use the concept of service identifiers.","pos":[1821,1876]},{"content":"Although a service identifier is simply a 128-bit GUID, it is also commonly specified as either a 16- or 32-bit integer.","pos":[1877,1997]},{"content":"The RFCOMM API offers a wrapper for service identifiers that allows them be specified and consumed as 128-bit GUIDs as well as 32-bit integers but does not offer 16-bit integers.","pos":[1998,2176]},{"content":"This is not an issue for the API because languages will automatically upsize to a 32-bit integer and the identifier can still be correctly generated.","pos":[2177,2326]},{"content":"Apps can perform multi-step device operations in a background task so that they can run to completion even if the app is moved to the background and suspended.","pos":[2328,2487]},{"content":"This allows for reliable device servicing such as changes to persistent settings or firmware, and content synchronization, without requiring the user to sit and watch a progress bar.","pos":[2488,2670]},{"content":"Use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DeviceServicingTrigger<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn297315)</ept> for device servicing and the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DeviceUseTrigger<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/Dn297337)</ept> for content synchronization.","pos":[2671,2904]},{"content":"Note that these background tasks constrain the amount of time the app can run in the background, and are not intended to allow indefinite operation or infinite synchronization.","pos":[2905,3081]},{"pos":[3083,3290],"content":"For a complete code sample that details RFCOMM operation, see the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Bluetooth Rfcomm Chat Sample<ept id=\"p2\">**</ept><ept id=\"p1\">](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/BluetoothRfcommChat)</ept> on Github."},{"content":"Send a file as a client","pos":[3296,3319]},{"content":"When sending a file, the most basic scenario is to connect to a paired device based on a desired service.","pos":[3321,3426]},{"content":"This involves the following steps:","pos":[3427,3461]},{"pos":[3467,3637],"content":"Use the <bpt id=\"p1\">**</bpt>RfcommDeviceService.GetDeviceSelector<ph id=\"ph1\">\\*</ph><ept id=\"p1\">**</ept> functions to help generate an AQS query that can be used to enumerated paired device instances of the desired service."},{"pos":[3642,3929],"content":"Pick an enumerated device, create an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RfcommDeviceService<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn263463)</ept>, and read the SDP attributes as needed (using <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>established data helpers<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/BR208119)</ept> to parse the attribute's data)."},{"pos":[3934,4491],"content":"Create a socket and use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RfcommDeviceService.ConnectionHostName<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.devices.bluetooth.rfcomm.rfcommdeviceservice.connectionhostname.aspx)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>RfcommDeviceService.ConnectionServiceName<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/en-us/library/windows/apps/windows.devices.bluetooth.rfcomm.rfcommdeviceservice.connectionservicename.aspx)</ept> properties to <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>StreamSocket.ConnectAsync<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/Hh701504)</ept> to the remote device service with the appropriate parameters."},{"pos":[4496,4705],"content":"Follow established data stream patterns to read chunks of data from the file and send it on the socket's <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>StreamSocket.OutputStream<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR226920)</ept> to the device."},{"content":"Receive File as a Server","pos":[12113,12137]},{"content":"Another common RFCOMM App scenario is to host a service on the PC and expose it for other devices.","pos":[12139,12237]},{"pos":[12243,12371],"content":"Create a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RfcommServiceProvider<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/Dn263511)</ept> to advertise the desired service."},{"pos":[12376,12608],"content":"Set the SDP attributes as needed (using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>established data helpers<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/BR208119)</ept> to generate the attribute’s Data) and starts advertising the SDP records for other devices to retrieve."},{"content":"To connect to a client device, create a socket listener to start listening for incoming connection requests.","pos":[12613,12721]},{"content":"When a connection is received, store the connected socket for later processing.","pos":[12726,12805]},{"content":"Follow established data stream patterns to read chunks of data from the socket's InputStream and save it to a file.","pos":[12810,12925]},{"content":"In order to persist an RFCOMM service in the background, use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RfcommConnectionTrigger<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.rfcommconnectiontrigger.aspx)</ept>.","pos":[12927,13136]},{"content":"The background task is triggered on connection to the service.","pos":[13137,13199]},{"content":"The developer receives a handle to the socket in the background task.","pos":[13200,13269]},{"content":"The background task is long running and persists for as long as the socket is in use.","pos":[13270,13355]}],"content":"---\nauthor: msatranjr\nms.assetid: 5B3A6326-15EE-4618-AA8C-F1C7FB5232FB\ntitle: Bluetooth RFCOMM\ndescription: This article provides an overview of Bluetooth RFCOMM in Universal Windows Platform (UWP) apps, along with example code on how to send or receive a file.\n---\n# Bluetooth RFCOMM\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n** Important APIs **\n\n-   [**Windows.Devices.Bluetooth**](https://msdn.microsoft.com/library/windows/apps/Dn263413)\n-   [**Windows.Devices.Bluetooth.Rfcomm**](https://msdn.microsoft.com/library/windows/apps/Dn263529)\n\nThis article provides an overview of Bluetooth RFCOMM in Universal Windows Platform (UWP) apps, along with example code on how to send or receive a file..\n\n## Overview\n\nThe APIs in the [**Windows.Devices.Bluetooth.Rfcomm**](https://msdn.microsoft.com/library/windows/apps/Dn263529) namespace build on existing patterns for Windows.Devices, including [**enumeration**](https://msdn.microsoft.com/library/windows/apps/BR225459) and [**instantiation**](https://msdn.microsoft.com/library/windows/apps/BR225654). Data reading and writing is designed to take advantage of [**established data stream patterns**](https://msdn.microsoft.com/library/windows/apps/BR208119) and objects in [**Windows.Storage.Streams**](https://msdn.microsoft.com/library/windows/apps/BR241791). Service Discovery Protocol (SDP) attributes have a value and an expected type. However, some common devices have faulty implementations of SDP attributes where the value is not of the expected type. Additionally, many usages of RFCOMM do not require additional SDP attributes at all. For these reasons, this API offers access to the unparsed SDP data, from which developers can obtain the information they need.\n\nThe RFCOMM APIs use the concept of service identifiers. Although a service identifier is simply a 128-bit GUID, it is also commonly specified as either a 16- or 32-bit integer. The RFCOMM API offers a wrapper for service identifiers that allows them be specified and consumed as 128-bit GUIDs as well as 32-bit integers but does not offer 16-bit integers. This is not an issue for the API because languages will automatically upsize to a 32-bit integer and the identifier can still be correctly generated.\n\nApps can perform multi-step device operations in a background task so that they can run to completion even if the app is moved to the background and suspended. This allows for reliable device servicing such as changes to persistent settings or firmware, and content synchronization, without requiring the user to sit and watch a progress bar. Use the [**DeviceServicingTrigger**](https://msdn.microsoft.com/library/windows/apps/Dn297315) for device servicing and the [**DeviceUseTrigger**](https://msdn.microsoft.com/library/windows/apps/Dn297337) for content synchronization. Note that these background tasks constrain the amount of time the app can run in the background, and are not intended to allow indefinite operation or infinite synchronization.\n\nFor a complete code sample that details RFCOMM operation, see the [**Bluetooth Rfcomm Chat Sample**](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/BluetoothRfcommChat) on Github.  \n## Send a file as a client\n\nWhen sending a file, the most basic scenario is to connect to a paired device based on a desired service. This involves the following steps:\n\n-   Use the **RfcommDeviceService.GetDeviceSelector\\*** functions to help generate an AQS query that can be used to enumerated paired device instances of the desired service.\n-   Pick an enumerated device, create an [**RfcommDeviceService**](https://msdn.microsoft.com/library/windows/apps/Dn263463), and read the SDP attributes as needed (using [**established data helpers**](https://msdn.microsoft.com/library/windows/apps/BR208119) to parse the attribute's data).\n-   Create a socket and use the [**RfcommDeviceService.ConnectionHostName**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.devices.bluetooth.rfcomm.rfcommdeviceservice.connectionhostname.aspx) and [**RfcommDeviceService.ConnectionServiceName**](https://msdn.microsoft.com/en-us/library/windows/apps/windows.devices.bluetooth.rfcomm.rfcommdeviceservice.connectionservicename.aspx) properties to [**StreamSocket.ConnectAsync**](https://msdn.microsoft.com/library/windows/apps/Hh701504) to the remote device service with the appropriate parameters.\n-   Follow established data stream patterns to read chunks of data from the file and send it on the socket's [**StreamSocket.OutputStream**](https://msdn.microsoft.com/library/windows/apps/BR226920) to the device.\n\n```csharp\nWindows.Devices.Bluetooth.RfcommDeviceService _service;\nWindows.Networking.Sockets.StreamSocket _socket;\n\nasync void Initialize()\n{\n    // Enumerate devices with the object push service\n    auto services =\n        await Windows.Devices.Enumeration.DeviceInformation.FindAllAsync(\n            RfcommDeviceService.GetDeviceSelector(\n                RfcommServiceId.ObexObjectPush));\n\n    if (services.Count > 0) \n    {\n        // Initialize the target Bluetooth BR device\n        auto service = await RfcommDeviceService.FromIdAsync(services[0].Id);\n\n        // Check that the service meets this App's minimum requirement\n        if (SupportsProtection(service) && IsCompatibleVersion(service))\n        {\n            _service = service;\n\n            // Create a socket and connect to the target\n            _socket = new StreamSocket();\n            await _socket.ConnectAsync(\n                _service.ConnectionHostName,\n                _service.ConnectionServiceName,\n                SocketProtectionLevel\n                    .BluetoothEncryptionAllowNullAuthentication);\n\n            // The socket is connected. At this point the App can wait for\n            // the user to take some action, e.g. click a button to send a\n            // file to the device, which could invoke the Picker and then\n            // send the picked file. The transfer itself would use the\n            // Sockets API and not the Rfcomm API, and so is omitted here for\n            // brevity.\n        }\n    }\n}\n\n// This App requires a connection that is encrypted but does not care about\n// whether its authenticated.\nbool SupportsProtection(RfcommDeviceService service)\n{\n    switch (service.ProtectionLevel)\n    {\n    case SocketProtectionLevel.PlainSocket:\n        if ((service.MaximumProtectionLevel == SocketProtectionLevel\n                .BluetoothEncryptionWithAuthentication)\n            || (service.MaximumProtectionLevel == SocketProtectionLevel\n                .BluetoothEncryptionAllowNullAuthentication)\n        {\n            // The connection can be upgraded when opening the socket so the\n            // App may offer UI here to notify the user that Windows may\n            // prompt for a PIN exchange.\n            return true;\n        }\n        else\n        {\n            // The connection cannot be upgraded so an App may offer UI here\n            // to explain why a connection won't be made.\n            return false;\n        }\n    case SocketProtectionLevel.BluetoothEncryptionWithAuthentication:\n        return true;\n    case SocketProtectionLevel.BluetoothEncryptionAllowNullAuthentication:\n        return true;\n    }\n    return false;\n}\n\n// This App relies on CRC32 checking available in version 2.0 of the service.\nconst uint SERVICE_VERSION_ATTRIBUTE_ID = 0x0300;\nconst byte SERVICE_VERSION_ATTRIBUTE_TYPE = 0x0A;   // UINT32\nconst uint MINIMUM_SERVICE_VERSION = 200;\nbool IsCompatibleVersion(RfcommDeviceService service)\n{\n    auto attributes = await service.GetSdpRawAttributesAsync(\n        BluetothCacheMode.Uncached);\n    auto attribute = attributes[SERVICE_VERSION_ATTRIBUTE_ID];\n    auto reader = DataReader.FromBuffer(attribute);\n\n    // The first byte contains the attribute' s type\n    byte attributeType = reader.ReadByte();\n    if (attributeType == SERVICE_VERSION_ATTRIBUTE_TYPE)\n    {\n        // The remainder is the data\n        uint version = reader.Uint32();\n        return version >= MINIMUM_SERVICE_VERSION;\n    }\n}\n```\n\n```cpp\nWindows::Devices::Bluetooth::RfcommDeviceService^ _service;\nWindows::Networking::Sockets::StreamSocket^ _socket;\n\nvoid Initialize()\n{\n    // Enumerate devices with the object push service\n    create_task(\n        Windows::Devices::Enumeration::DeviceInformation::FindAllAsync(\n            RfcommDeviceService::GetDeviceSelector(\n                RfcommServiceId::ObexObjectPush)))\n    .then([](DeviceInformationCollection^ services)\n    {\n        if (services->Size > 0) \n        {\n            // Initialize the target Bluetooth BR device\n            create_task(RfcommDeviceService::FromIdAsync(services[0]->Id))\n            .then([](RfcommDeviceService^ service)\n            {\n                // Check that the service meets this App's minimum\n                // requirement\n                if (SupportsProtection(service)\n                    && IsCompatibleVersion(service))\n                {\n                    _service = service;\n\n                    // Create a socket and connect to the target\n                    _socket = ref new StreamSocket();\n                    create_task(_socket->ConnectAsync(\n                        _service->ConnectionHostName,\n                        _service->ConnectionServiceName,\n                        SocketProtectionLevel\n                            ::BluetoothEncryptionAllowNullAuthentication)\n                    .then([](void)\n                    {\n                        // The socket is connected. At this point the App can\n                        // wait for the user to take some action, e.g. click\n                        // a button to send a file to the device, which could\n                        // invoke the Picker and then send the picked file.\n                        // The transfer itself would use the Sockets API and\n                        // not the Rfcomm API, and so is omitted here for\n                        //brevity.\n                    });\n                }\n            });\n        }\n    });\n}\n\n// This App requires a connection that is encrypted but does not care about\n// whether its authenticated.\nbool SupportsProtection(RfcommDeviceService^ service)\n{\n    switch (service->ProtectionLevel)\n    {\n    case SocketProtectionLevel->PlainSocket:\n        if ((service->MaximumProtectionLevel == SocketProtectionLevel\n                ::BluetoothEncryptionWithAuthentication)\n            || (service->MaximumProtectionLevel == SocketProtectionLevel\n                ::BluetoothEncryptionAllowNullAuthentication)\n        {\n            // The connection can be upgraded when opening the socket so the\n            // App may offer UI here to notify the user that Windows may\n            // prompt for a PIN exchange.\n            return true;\n        }\n        else\n        {\n            // The connection cannot be upgraded so an App may offer UI here\n            // to explain why a connection won't be made.\n            return false;\n        }\n    case SocketProtectionLevel::BluetoothEncryptionWithAuthentication:\n        return true;\n    case SocketProtectionLevel::BluetoothEncryptionAllowNullAuthentication:\n        return true;\n    }\n    return false;\n}\n\n// This App relies on CRC32 checking available in version 2.0 of the service.\nconst uint SERVICE_VERSION_ATTRIBUTE_ID = 0x0300;\nconst byte SERVICE_VERSION_ATTRIBUTE_TYPE = 0x0A;   // UINT32\nconst uint MINIMUM_SERVICE_VERSION = 200;\nbool IsCompatibleVersion(RfcommDeviceService^ service)\n{\n    auto attributes = await service->GetSdpRawAttributesAsync(\n        BluetoothCacheMode::Uncached);\n    auto attribute = attributes[SERVICE_VERSION_ATTRIBUTE_ID];\n    auto reader = DataReader.FromBuffer(attribute);\n\n    // The first byte contains the attribute' s type\n    byte attributeType = reader->ReadByte();\n    if (attributeType == SERVICE_VERSION_ATTRIBUTE_TYPE)\n    {\n        // The remainder is the data\n        uint version = reader->Uint32();\n        return version >= MINIMUM_SERVICE_VERSION;\n    }\n}\n```\n\n## Receive File as a Server\n\nAnother common RFCOMM App scenario is to host a service on the PC and expose it for other devices.\n\n-   Create a [**RfcommServiceProvider**](https://msdn.microsoft.com/library/windows/apps/Dn263511) to advertise the desired service.\n-   Set the SDP attributes as needed (using [**established data helpers**](https://msdn.microsoft.com/library/windows/apps/BR208119) to generate the attribute’s Data) and starts advertising the SDP records for other devices to retrieve.\n-   To connect to a client device, create a socket listener to start listening for incoming connection requests.\n-   When a connection is received, store the connected socket for later processing.\n-   Follow established data stream patterns to read chunks of data from the socket's InputStream and save it to a file.\n\nIn order to persist an RFCOMM service in the background, use the [**RfcommConnectionTrigger**](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.rfcommconnectiontrigger.aspx). The background task is triggered on connection to the service. The developer receives a handle to the socket in the background task. The background task is long running and persists for as long as the socket is in use.    \n\n```csharp\nWindows.Devices.Bluetooth.RfcommServiceProvider _provider;\n\nasync void Initialize()\n{\n    // Initialize the provider for the hosted RFCOMM service\n    _provider = await Windows.Devices.Bluetooth.\n        RfcommServiceProvider.CreateAsync(RfcommServiceId.ObexObjectPush);\n\n    // Create a listener for this service and start listening\n    StreamSocketListener listener = new StreamSocketListener();\n    listener.ConnectionReceived += OnConnectionReceived;\n    await listener.BindServiceNameAsync(\n        _provider.ServiceId.AsString(),\n        SocketProtectionLevel\n            .BluetoothEncryptionAllowNullAuthentication);\n\n    // Set the SDP attributes and start advertising\n    InitializeServiceSdpAttributes(_provider);\n    _provider.StartAdvertising();\n}\n\nconst uint SERVICE_VERSION_ATTRIBUTE_ID = 0x0300;\nconst byte SERVICE_VERSION_ATTRIBUTE_TYPE = 0x0A;   // UINT32\nconst uint SERVICE_VERSION = 200;\nvoid InitializeServiceSdpAttributes(RfcommServiceProvider provider)\n{\n    auto writer = new Windows.Storage.Streams.DataWriter();\n\n    // First write the attribute type\n    writer.WriteByte(SERVICE_VERSION_ATTRIBUTE_TYPE)\n    // Then write the data\n    writer.WriteUint32(SERVICE_VERSION);\n    \n    auto data = writer.DetachBuffer();\n    provider.SdpRawAttributes.Add(SERVICE_VERSION_ATTRIBUTE_ID, data);\n}\n\nvoid OnConnectionReceived(\n    StreamSocketListener listener,\n    StreamSocketListenerConnectionReceivedEventArgs args)\n{\n    // Stop advertising/listening so that we're only serving one client\n    _provider.StopAdvertising();\n    await listener.Close();\n    _socket = args.Socket;\n\n    // The client socket is connected. At this point the App can wait for\n    // the user to take some action, e.g. click a button to receive a file\n    // from the device, which could invoke the Picker and then save the\n    // received file to the picked location. The transfer itself would use\n    // the Sockets API and not the Rfcomm API, and so is omitted here for\n    // brevity.\n}\n```\n\n```cpp\nWindows::Devices::Bluetooth::RfcommServiceProvider^ _provider;\n\nvoid Initialize()\n{\n    // Initialize the provider for the hosted RFCOMM service\n    create_task(Windows::Devices::Bluetooth.\n        RfcommServiceProvider::CreateAsync(\n            RfcommServiceId::ObexObjectPush))\n    .then([](RfcommServiceProvider^ provider) -> task<void> {\n        _provider = provider;\n\n        // Create a listener for this service and start listening\n        auto listener = ref new StreamSocketListener();\n        listener->ConnectionReceived += ref new TypedEventHandler<\n                StreamSocketListener^,\n                StreamSocketListenerConnectionReceivedEventArgs^>\n           (&OnConnectionReceived);\n        return create_task(listener->BindServiceNameAsync(\n            _provider->ServiceId->AsString(),\n            SocketProtectionLevel\n                ::BluetoothEncryptionAllowNullAuthentication));\n    }).then([listener](void) {\n        // Set the SDP attributes and start advertising\n        InitializeServiceSdpAttributes(_provider);\n        _provider->StartAdvertising();\n    });\n}\n\nconst uint SERVICE_VERSION_ATTRIBUTE_ID = 0x0300;\nconst byte SERVICE_VERSION_ATTRIBUTE_TYPE = 0x0A;   // UINT32\nconst uint SERVICE_VERSION = 200;\nvoid InitializeServiceSdpAttributes(RfcommServiceProvider^ provider)\n{\n    auto writer = ref new Windows::Storage::Streams::DataWriter();\n\n    // First write the attribute type\n    writer->WriteByte(SERVICE_VERSION_ATTRIBUTE_TYPE)\n    // Then write the data\n    writer->WriteUint32(SERVICE_VERSION);\n    \n    auto data = writer->DetachBuffer();\n    provider->SdpRawAttributes->Add(SERVICE_VERSION_ATTRIBUTE_ID, data);\n}\n\nvoid OnConnectionReceived(\n    StreamSocketListener^ listener,\n    StreamSocketListenerConnectionReceivedEventArgs^ args)\n{\n    // Stop advertising/listening so that we're only serving one client\n    _provider->StopAdvertising();\n    create_task(listener->Close())\n    .then([args](void) {\n        _socket = args->Socket;\n\n        // The client socket is connected. At this point the App can wait for\n        // the user to take some action, e.g. click a button to receive a\n        // file from the device, which could invoke the Picker and then save\n        // the received file to the picked location. The transfer itself\n        // would use the Sockets API and not the Rfcomm API, and so is\n        // omitted here for brevity.\n    });\n}\n```\n\n"}