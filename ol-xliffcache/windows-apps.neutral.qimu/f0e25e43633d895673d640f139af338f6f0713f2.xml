{"nodes":[{"content":"Initialize Direct3D 11","pos":[27,49]},{"content":"Shows how to convert Direct3D 9 initialization code to Direct3D 11, including how to get handles to the Direct3D device and the device context and how to use DXGI to set up a swap chain.","pos":[63,249]},{"content":"Initialize Direct3D 11","pos":[306,328]},{"content":"Updated for UWP apps on Windows 10.","pos":[334,369]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[370,462]},{"content":"Summary","pos":[469,476]},{"content":"Part 1: Initialize Direct3D 11","pos":[484,514]},{"content":"Part 2: Convert the rendering framework","pos":[520,559]},{"content":"Part 3: Port the game loop","pos":[624,650]},{"content":"Shows how to convert Direct3D 9 initialization code to Direct3D 11, including how to get handles to the Direct3D device and the device context and how to use DXGI to set up a swap chain.","pos":[725,911]},{"content":"Part 1 of the <bpt id=\"p1\">[</bpt>Port a simple Direct3D 9 app to DirectX 11 and Universal Windows Platform (UWP)<ept id=\"p1\">](walkthrough--simple-port-from-direct3d-9-to-11-1.md)</ept> walkthrough.","pos":[912,1073]},{"content":"Initialize the Direct3D device","pos":[1078,1108]},{"content":"In Direct3D 9, we created a handle to the Direct3D device by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDirect3D9::CreateDevice<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174313)</ept>.","pos":[1111,1272]},{"content":"We started by getting a pointer to <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDirect3D9 interface<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174300)</ept> and we specified a number of parameters to control the configuration of the Direct3D device and the swap chain.","pos":[1273,1507]},{"content":"Before doing this we called <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GetDeviceCaps<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dd144877)</ept> to make sure we weren't asking the device to do something it couldn't do.","pos":[1508,1690]},{"content":"Direct3D 9","pos":[1692,1702]},{"content":"In Direct3D 11, the device context and graphics infrastructure is considered separate from the device itself.","pos":[2543,2652]},{"content":"Initialization is divided into multiple steps.","pos":[2653,2699]},{"content":"First we create the device.","pos":[2701,2728]},{"content":"We get a list of the feature levels the device supports - this informs most of what we need to know about the GPU.","pos":[2729,2843]},{"content":"Also, we don't need to create an interface just to access Direct3D.","pos":[2844,2911]},{"content":"Instead we use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11CreateDevice<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept> core API.","pos":[2912,3025]},{"content":"This gives us a handle to the device and the device's immediate context.","pos":[3026,3098]},{"content":"The device context is used to set pipeline state and generate rendering commands.","pos":[3099,3180]},{"content":"After creating the Direct3D 11 device and context, we can take advantage of COM pointer functionality to get the most recent version of the interfaces, which include additional capability and are always recommended.","pos":[3182,3397]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   D3D<ph id=\"ph1\">\\_</ph>FEATURE<ph id=\"ph2\">\\_</ph>LEVEL<ph id=\"ph3\">\\_</ph>9<ph id=\"ph4\">\\_</ph>1 (which corresponds to shader model 2.0) is the minimum level your Windows Store game is required to support.","pos":[3401,3546]},{"content":"(Your game's ARM packages will fail certification if you don't support 9<ph id=\"ph1\">\\_</ph>1.) If your game also includes a rendering path for shader model 3 features, then you should include D3D<ph id=\"ph2\">\\_</ph>FEATURE<ph id=\"ph3\">\\_</ph>LEVEL<ph id=\"ph4\">\\_</ph>9<ph id=\"ph5\">\\_</ph>3 in the array.","pos":[3547,3761]},{"content":"Direct3D 11","pos":[3766,3777]},{"content":"Create a swap chain","pos":[4928,4947]},{"content":"Direct3D 11 includes a device API called DirectX graphics infrastructure (DXGI).","pos":[4950,5030]},{"content":"The DXGI interface allows us to (for example) control how the swap chain is configured and set up shared devices.","pos":[5031,5144]},{"content":"At this step in initializing Direct3D, we're going to use DXGI to create a swap chain.","pos":[5145,5231]},{"content":"Since we created the device, we can follow an interface chain back to the DXGI adapter.","pos":[5232,5319]},{"content":"The Direct3D device implements a COM interface for DXGI.","pos":[5321,5377]},{"content":"First we need to get that interface and use it to request the DXGI adapter hosting the device.","pos":[5378,5472]},{"content":"Then we use the DXGI adapter to create a DXGI factory.","pos":[5473,5527]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   These are COM interfaces so your first response might be to use <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>QueryInterface<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ms682521)</ept>.","pos":[5531,5688]},{"content":"You should use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Microsoft::WRL::ComPtr<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br244983.aspx)</ept> smart pointers instead.","pos":[5689,5819]},{"content":"Then just call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>As()<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br230426.aspx)</ept> method, supplying an empty COM pointer of the correct interface type.","pos":[5820,5982]},{"content":"Direct3D 11","pos":[5989,6000]},{"content":"Now that we have the DXGI factory, we can use it to create the swap chain.","pos":[6362,6436]},{"content":"Let's define the swap chain parameters.","pos":[6437,6476]},{"content":"We need to specify the surface format; we'll choose <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DXGI<ph id=\"ph1\">\\_</ph>FORMAT<ph id=\"ph2\">\\_</ph>B8G8R8A8<ph id=\"ph3\">\\_</ph>UNORM<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</ept> because it's compatible with Direct2D.","pos":[6477,6664]},{"content":"We'll turn off display scaling, multisampling, and stereo rendering because they aren't used in this example.","pos":[6665,6774]},{"content":"Since we are running directly in a CoreWindow we can leave the width and height set to 0 and get full-screen values automatically.","pos":[6775,6905]},{"pos":[6909,6994],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   Always set the <bpt id=\"p2\">*</bpt>SDKVersion<ept id=\"p2\">*</ept> parameter to D3D11<ph id=\"ph1\">\\_</ph>SDK<ph id=\"ph2\">\\_</ph>VERSION for UWP apps."},{"content":"Direct3D 11","pos":[7001,7012]},{"content":"To ensure we aren't rendering more often than the screen can actually display, we set frame latency to 1 and use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DXGI<ph id=\"ph1\">\\_</ph>SWAP<ph id=\"ph2\">\\_</ph>EFFECT<ph id=\"ph3\">\\_</ph>FLIP<ph id=\"ph4\">\\_</ph>SEQUENTIAL<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb173077)</ept>.","pos":[7253,7470]},{"content":"This saves power and is a store certification requirement; we'll learn more about presenting to the screen in part 2 of this walkthrough.","pos":[7471,7608]},{"pos":[7612,7812],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   You can use multithreading (for example, <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ThreadPool<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br229642)</ept> work items) to continue other work while the rendering thread is blocked."},{"content":"Direct3D 11","pos":[7819,7830]},{"content":"Now we can set up the back buffer for rendering.","pos":[7885,7933]},{"content":"Configure the back buffer as a render target","pos":[7938,7982]},{"content":"First we have to get a handle to the back buffer.","pos":[7985,8034]},{"content":"(Note that the back buffer is owned by the DXGI swap chain, whereas in DirectX 9 it was owned by the Direct3D device.) Then we tell the Direct3D device to use it as the render target by creating a render target <bpt id=\"p1\">*</bpt>view<ept id=\"p1\">*</ept> using the back buffer.","pos":[8035,8275]},{"content":"Direct3D 11","pos":[8279,8290]},{"content":"Now the device context comes into play.","pos":[8582,8621]},{"content":"We tell Direct3D to use our newly-created render target view by using the device context interface.","pos":[8622,8721]},{"content":"We'll retrieve the width and height of the back buffer so that we can target the whole window as our viewport.","pos":[8722,8832]},{"content":"Note that the back buffer is attached to the swap chain, so if the window size changes (for example, the user drags the game window to another monitor) the back buffer will need to be resized and some setup will need to be redone.","pos":[8833,9063]},{"content":"Direct3D 11","pos":[9067,9078]},{"content":"Now that we have a device handle and a full-screen render target, we are ready to load and draw geometry.","pos":[9366,9471]},{"content":"Continue to <bpt id=\"p1\">[</bpt>Part 2: Rendering<ept id=\"p1\">](simple-port-from-direct3d-9-to-11-1-part-2--rendering.md)</ept>.","pos":[9472,9562]}],"content":"---\nauthor: mtoepke\ntitle: Initialize Direct3D 11\ndescription: Shows how to convert Direct3D 9 initialization code to Direct3D 11, including how to get handles to the Direct3D device and the device context and how to use DXGI to set up a swap chain.\nms.assetid: 1bd5e8b7-fd9d-065c-9ff3-1a9b1c90da29\n---\n\n# Initialize Direct3D 11\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n**Summary**\n\n-   Part 1: Initialize Direct3D 11\n-   [Part 2: Convert the rendering framework](simple-port-from-direct3d-9-to-11-1-part-2--rendering.md)\n-   [Part 3: Port the game loop](simple-port-from-direct3d-9-to-11-1-part-3--viewport-and-game-loop.md)\n\n\nShows how to convert Direct3D 9 initialization code to Direct3D 11, including how to get handles to the Direct3D device and the device context and how to use DXGI to set up a swap chain. Part 1 of the [Port a simple Direct3D 9 app to DirectX 11 and Universal Windows Platform (UWP)](walkthrough--simple-port-from-direct3d-9-to-11-1.md) walkthrough.\n\n## Initialize the Direct3D device\n\n\nIn Direct3D 9, we created a handle to the Direct3D device by calling [**IDirect3D9::CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/bb174313). We started by getting a pointer to [**IDirect3D9 interface**](https://msdn.microsoft.com/library/windows/desktop/bb174300) and we specified a number of parameters to control the configuration of the Direct3D device and the swap chain. Before doing this we called [**GetDeviceCaps**](https://msdn.microsoft.com/library/windows/desktop/dd144877) to make sure we weren't asking the device to do something it couldn't do.\n\nDirect3D 9\n\n```cpp\nUINT32 AdapterOrdinal = 0;\nD3DDEVTYPE DeviceType = D3DDEVTYPE_HAL;\nD3DCAPS9 caps;\nm_pD3D->GetDeviceCaps(AdapterOrdinal, DeviceType, &caps); // caps bits\n\nD3DPRESENT_PARAMETERS params;\nZeroMemory(&params, sizeof(D3DPRESENT_PARAMETERS));\n\n// Swap chain parameters:\nparams.hDeviceWindow = m_hWnd;\nparams.AutoDepthStencilFormat = D3DFMT_D24X8;\nparams.BackBufferFormat = D3DFMT_X8R8G8B8;\nparams.MultiSampleQuality = D3DMULTISAMPLE_NONE;\nparams.MultiSampleType = D3DMULTISAMPLE_NONE;\nparams.SwapEffect = D3DSWAPEFFECT_DISCARD;\nparams.Windowed = true;\nparams.PresentationInterval = 0;\nparams.BackBufferCount = 2;\nparams.BackBufferWidth = 0;\nparams.BackBufferHeight = 0;\nparams.EnableAutoDepthStencil = true;\nparams.Flags = 2;\n\nm_pD3D->CreateDevice(\n    0,\n    D3DDEVTYPE_HAL,\n    m_hWnd,\n    64,\n    &params,\n    &m_pd3dDevice\n    );\n```\n\nIn Direct3D 11, the device context and graphics infrastructure is considered separate from the device itself. Initialization is divided into multiple steps.\n\nFirst we create the device. We get a list of the feature levels the device supports - this informs most of what we need to know about the GPU. Also, we don't need to create an interface just to access Direct3D. Instead we use the [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) core API. This gives us a handle to the device and the device's immediate context. The device context is used to set pipeline state and generate rendering commands.\n\nAfter creating the Direct3D 11 device and context, we can take advantage of COM pointer functionality to get the most recent version of the interfaces, which include additional capability and are always recommended.\n\n> **Note**   D3D\\_FEATURE\\_LEVEL\\_9\\_1 (which corresponds to shader model 2.0) is the minimum level your Windows Store game is required to support. (Your game's ARM packages will fail certification if you don't support 9\\_1.) If your game also includes a rendering path for shader model 3 features, then you should include D3D\\_FEATURE\\_LEVEL\\_9\\_3 in the array.\n\n \n\nDirect3D 11\n\n```cpp\n// This flag adds support for surfaces with a different color channel \n// ordering than the API default. It is required for compatibility with\n// Direct2D.\nUINT creationFlags = D3D11_CREATE_DEVICE_BGRA_SUPPORT;\n\n#if defined(_DEBUG)\n// If the project is in a debug build, enable debugging via SDK Layers.\ncreationFlags |= D3D11_CREATE_DEVICE_DEBUG;\n#endif\n\n// This example only uses feature level 9.1.\nD3D_FEATURE_LEVEL featureLevels[] = \n{\n    D3D_FEATURE_LEVEL_9_1\n};\n\n// Create the Direct3D 11 API device object and a corresponding context.\nComPtr<ID3D11Device> device;\nComPtr<ID3D11DeviceContext> context;\nD3D11CreateDevice(\n    nullptr, // Specify nullptr to use the default adapter.\n    D3D_DRIVER_TYPE_HARDWARE,\n    nullptr,\n    creationFlags,\n    featureLevels,\n    ARRAYSIZE(featureLevels),\n    D3D11_SDK_VERSION, // Windows Store apps must set this to D3D11_SDK_VERSION.\n    &device, // Returns the Direct3D device created.\n    nullptr,\n    &context // Returns the device immediate context.\n    );\n\n// Store pointers to the Direct3D 11.2 API device and immediate context.\ndevice.As(&m_d3dDevice);\n\ncontext.As(&m_d3dContext);\n```\n\n## Create a swap chain\n\n\nDirect3D 11 includes a device API called DirectX graphics infrastructure (DXGI). The DXGI interface allows us to (for example) control how the swap chain is configured and set up shared devices. At this step in initializing Direct3D, we're going to use DXGI to create a swap chain. Since we created the device, we can follow an interface chain back to the DXGI adapter.\n\nThe Direct3D device implements a COM interface for DXGI. First we need to get that interface and use it to request the DXGI adapter hosting the device. Then we use the DXGI adapter to create a DXGI factory.\n\n> **Note**   These are COM interfaces so your first response might be to use [**QueryInterface**](https://msdn.microsoft.com/library/windows/desktop/ms682521). You should use [**Microsoft::WRL::ComPtr**](https://msdn.microsoft.com/library/windows/apps/br244983.aspx) smart pointers instead. Then just call the [**As()**](https://msdn.microsoft.com/library/windows/apps/br230426.aspx) method, supplying an empty COM pointer of the correct interface type.\n\n \n\n**Direct3D 11**\n\n```cpp\nComPtr<IDXGIDevice2> dxgiDevice;\nm_d3dDevice.As(&dxgiDevice);\n\n// Then, the adapter hosting the device;\nComPtr<IDXGIAdapter> dxgiAdapter;\ndxgiDevice->GetAdapter(&dxgiAdapter);\n\n// Then, the factory that created the adapter interface:\nComPtr<IDXGIFactory2> dxgiFactory;\ndxgiAdapter->GetParent(\n    __uuidof(IDXGIFactory2),\n    &dxgiFactory\n    );\n```\n\nNow that we have the DXGI factory, we can use it to create the swap chain. Let's define the swap chain parameters. We need to specify the surface format; we'll choose [**DXGI\\_FORMAT\\_B8G8R8A8\\_UNORM**](https://msdn.microsoft.com/library/windows/desktop/bb173059) because it's compatible with Direct2D. We'll turn off display scaling, multisampling, and stereo rendering because they aren't used in this example. Since we are running directly in a CoreWindow we can leave the width and height set to 0 and get full-screen values automatically.\n\n> **Note**   Always set the *SDKVersion* parameter to D3D11\\_SDK\\_VERSION for UWP apps.\n\n \n\n**Direct3D 11**\n\n```cpp\nComPtr<IDXGISwapChain1> swapChain;\ndxgiFactory->CreateSwapChainForCoreWindow(\n    m_d3dDevice.Get(),\n    reinterpret_cast<IUnknown*>(window),\n    &swapChainDesc,\n    nullptr,\n    &swapChain\n    );\nswapChain.As(&m_swapChain);\n```\n\nTo ensure we aren't rendering more often than the screen can actually display, we set frame latency to 1 and use [**DXGI\\_SWAP\\_EFFECT\\_FLIP\\_SEQUENTIAL**](https://msdn.microsoft.com/library/windows/desktop/bb173077). This saves power and is a store certification requirement; we'll learn more about presenting to the screen in part 2 of this walkthrough.\n\n> **Note**   You can use multithreading (for example, [**ThreadPool**](https://msdn.microsoft.com/library/windows/apps/br229642) work items) to continue other work while the rendering thread is blocked.\n\n \n\n**Direct3D 11**\n\n```cpp\ndxgiDevice->SetMaximumFrameLatency(1);\n```\n\nNow we can set up the back buffer for rendering.\n\n## Configure the back buffer as a render target\n\n\nFirst we have to get a handle to the back buffer. (Note that the back buffer is owned by the DXGI swap chain, whereas in DirectX 9 it was owned by the Direct3D device.) Then we tell the Direct3D device to use it as the render target by creating a render target *view* using the back buffer.\n\n**Direct3D 11**\n\n```cpp\nComPtr<ID3D11Texture2D> backBuffer;\nm_swapChain->GetBuffer(\n    0,\n    __uuidof(ID3D11Texture2D),\n    &backBuffer\n    );\n\n// Create a render target view on the back buffer.\nm_d3dDevice->CreateRenderTargetView(\n    backBuffer.Get(),\n    nullptr,\n    &m_renderTargetView\n    );\n```\n\nNow the device context comes into play. We tell Direct3D to use our newly-created render target view by using the device context interface. We'll retrieve the width and height of the back buffer so that we can target the whole window as our viewport. Note that the back buffer is attached to the swap chain, so if the window size changes (for example, the user drags the game window to another monitor) the back buffer will need to be resized and some setup will need to be redone.\n\n**Direct3D 11**\n\n```cpp\nD3D11_TEXTURE2D_DESC backBufferDesc = {0};\nbackBuffer->GetDesc(&backBufferDesc);\n\nCD3D11_VIEWPORT viewport(\n    0.0f,\n    0.0f,\n    static_cast<float>(backBufferDesc.Width),\n    static_cast<float>(backBufferDesc.Height)\n    );\n\nm_d3dContext->RSSetViewports(1, &viewport);\n```\n\nNow that we have a device handle and a full-screen render target, we are ready to load and draw geometry. Continue to [Part 2: Rendering](simple-port-from-direct3d-9-to-11-1-part-2--rendering.md).\n\n \n\n \n\n\n\n\n"}