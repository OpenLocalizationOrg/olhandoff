{"nodes":[{"content":"Links the value of a property in a control template to the value of some other exposed property on the templated control.","pos":[32,153]},{"content":"TemplateBinding can only be used within a ControlTemplate definition in XAML.","pos":[154,231]},{"content":"TemplateBinding markup extension","pos":[239,271]},{"content":"{TemplateBinding} markup extension","pos":[328,362]},{"content":"Updated for UWP apps on Windows 10.","pos":[367,402]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[403,495]},{"content":"Links the value of a property in a control template to the value of some other exposed property on the templated control.","pos":[500,621]},{"content":"<bpt id=\"p1\">**</bpt>TemplateBinding<ept id=\"p1\">**</ept> can only be used within a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlTemplate<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br209391)</ept> definition in XAML.","pos":[622,767]},{"content":"XAML attribute usage","pos":[772,792]},{"content":"XAML attribute usage (for Setter property in template or style)","pos":[875,938]},{"content":"XAML values","pos":[1038,1049]},{"content":"Term","pos":[1053,1057]},{"content":"Description","pos":[1060,1071]},{"content":"propertyName","pos":[1099,1111]},{"content":"The name of the property being set in the setter syntax.","pos":[1114,1170]},{"content":"This must be a dependency property.","pos":[1171,1206]},{"content":"sourceProperty","pos":[1211,1225]},{"content":"The name of another dependency property that exists on the type being templated.","pos":[1228,1308]},{"content":"Remarks","pos":[1315,1322]},{"content":"Using <bpt id=\"p1\">**</bpt>TemplateBinding<ept id=\"p1\">**</ept> is a fundamental part of how you define a control template, either if you are a custom control author or if you are replacing a control template for existing controls.","pos":[1324,1517]},{"content":"For more info, see <bpt id=\"p1\">[</bpt>Quickstart: Control templates<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374)</ept>.","pos":[1518,1632]},{"content":"It's fairly common for <bpt id=\"p1\">*</bpt>propertyName<ept id=\"p1\">*</ept> and <bpt id=\"p2\">*</bpt>targetProperty<ept id=\"p2\">*</ept> to use the same property name.","pos":[1634,1723]},{"content":"In this case, a control might define a property on itself and forward the property to an existing and intuitively named property of one of its component parts.","pos":[1724,1883]},{"content":"For example, a control that incorporates a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>TextBlock<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209652)</ept> in its compositing, which is used to display the control's own <bpt id=\"p3\">**</bpt>Text<ept id=\"p3\">**</ept> property, might include this XAML as a part in the control template:","pos":[1884,2141]},{"content":"The types used as the value for the source property and the target property must match.","pos":[2194,2281]},{"content":"There's no opportunity to introduce a converter when you're using <bpt id=\"p1\">**</bpt>TemplateBinding<ept id=\"p1\">**</ept>.","pos":[2282,2368]},{"content":"Failing to match values results in an error when parsing the XAML.","pos":[2369,2435]},{"content":"If you need a converter you can use the verbose syntax for a template binding such as:","pos":[2436,2522]},{"pos":[2605,2787],"content":"Attempting to use a <bpt id=\"p1\">**</bpt>TemplateBinding<ept id=\"p1\">**</ept> outside of a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlTemplate<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br209391)</ept> definition in XAML will result in a parser error."},{"content":"You can use <bpt id=\"p1\">**</bpt>TemplateBinding<ept id=\"p1\">**</ept> for cases where the templated parent value is also deferred as another binding.","pos":[2789,2900]},{"content":"The evaluation for <bpt id=\"p1\">**</bpt>TemplateBinding<ept id=\"p1\">**</ept> can wait until any required runtime bindings have values.","pos":[2901,2997]},{"content":"A <bpt id=\"p1\">**</bpt>TemplateBinding<ept id=\"p1\">**</ept> is always a one-way binding.","pos":[2999,3049]},{"content":"Both properties involved must be dependency properties.","pos":[3050,3105]},{"content":"<bpt id=\"p1\">**</bpt>TemplateBinding<ept id=\"p1\">**</ept> is a markup extension.","pos":[3107,3149]},{"content":"Markup extensions are typically implemented when there is a requirement to escape attribute values to be other than literal values or handler names, and the requirement is more global than just putting type converters on certain types or properties.","pos":[3150,3399]},{"content":"All markup extensions in XAML use the \"{\" and \"}\" characters in their attribute syntax, which is the convention by which a XAML processor recognizes that a markup extension must process the attribute.","pos":[3400,3600]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  In the Windows Runtime XAML processor implementation, there is no backing class representation for <bpt id=\"p2\">**</bpt>TemplateBinding<ept id=\"p2\">**</ept>.","pos":[3602,3731]},{"content":"<bpt id=\"p1\">**</bpt>TemplateBinding<ept id=\"p1\">**</ept> is exclusively for use in XAML markup.","pos":[3732,3790]},{"content":"There isn't a straightforward way to reproduce the behavior in code.","pos":[3791,3859]},{"content":"Related topics","pos":[3864,3878]},{"content":"Quickstart: Control templates","pos":[3883,3912]},{"content":"Data binding in depth","pos":[3980,4001]},{"content":"ControlTemplate","pos":[4066,4081]},{"content":"XAML overview","pos":[4146,4159]},{"content":"Dependency properties overview","pos":[4182,4212]}],"content":"---\nauthor: jwmsft\ndescription: Links the value of a property in a control template to the value of some other exposed property on the templated control. TemplateBinding can only be used within a ControlTemplate definition in XAML.\ntitle: TemplateBinding markup extension\nms.assetid: FDE71086-9D42-4287-89ED-8FBFCDF169DC\n---\n\n# {TemplateBinding} markup extension\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nLinks the value of a property in a control template to the value of some other exposed property on the templated control. **TemplateBinding** can only be used within a [**ControlTemplate**](https://msdn.microsoft.com/library/windows/apps/br209391) definition in XAML.\n\n## XAML attribute usage\n\n``` syntax\n<object propertyName=\"{TemplateBinding sourceProperty}\" .../>\n```\n\n## XAML attribute usage (for Setter property in template or style)\n\n``` syntax\n<Setter Property=\"propertyName\" Value=\"{TemplateBinding sourceProperty}\" .../>\n```\n\n## XAML values\n\n| Term | Description |\n|------|-------------|\n| propertyName | The name of the property being set in the setter syntax. This must be a dependency property. |\n| sourceProperty | The name of another dependency property that exists on the type being templated. |\n\n## Remarks\n\nUsing **TemplateBinding** is a fundamental part of how you define a control template, either if you are a custom control author or if you are replacing a control template for existing controls. For more info, see [Quickstart: Control templates](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374).\n\nIt's fairly common for *propertyName* and *targetProperty* to use the same property name. In this case, a control might define a property on itself and forward the property to an existing and intuitively named property of one of its component parts. For example, a control that incorporates a [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) in its compositing, which is used to display the control's own **Text** property, might include this XAML as a part in the control template: `<TextBlock Text=\"{TemplateBinding Text}\" .... />`\n\nThe types used as the value for the source property and the target property must match. There's no opportunity to introduce a converter when you're using **TemplateBinding**. Failing to match values results in an error when parsing the XAML. If you need a converter you can use the verbose syntax for a template binding such as: `{Binding RelativeSource={RelativeSource TemplatedParent}, Converter=\"...\" ...}`\n\nAttempting to use a **TemplateBinding** outside of a [**ControlTemplate**](https://msdn.microsoft.com/library/windows/apps/br209391) definition in XAML will result in a parser error.\n\nYou can use **TemplateBinding** for cases where the templated parent value is also deferred as another binding. The evaluation for **TemplateBinding** can wait until any required runtime bindings have values.\n\nA **TemplateBinding** is always a one-way binding. Both properties involved must be dependency properties.\n\n**TemplateBinding** is a markup extension. Markup extensions are typically implemented when there is a requirement to escape attribute values to be other than literal values or handler names, and the requirement is more global than just putting type converters on certain types or properties. All markup extensions in XAML use the \"{\" and \"}\" characters in their attribute syntax, which is the convention by which a XAML processor recognizes that a markup extension must process the attribute.\n\n**Note**  In the Windows Runtime XAML processor implementation, there is no backing class representation for **TemplateBinding**. **TemplateBinding** is exclusively for use in XAML markup. There isn't a straightforward way to reproduce the behavior in code.\n\n## Related topics\n\n* [Quickstart: Control templates](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374)\n* [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946)\n* [**ControlTemplate**](https://msdn.microsoft.com/library/windows/apps/br209391)\n* [XAML overview](xaml-overview.md)\n* [Dependency properties overview](dependency-properties-overview.md)\n \n\n"}