{"nodes":[{"content":"Composition animations","pos":[78,100]},{"content":"Many composition object and effect properties can be animated using key frame and expression animations allowing properties of a UI element to change over time or based on a calculation.","pos":[114,300]},{"content":"Composition animations","pos":[307,329]},{"content":"Updated for UWP apps on Windows 10.","pos":[334,369]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[370,462]},{"content":"The Windows.UI.Composition WinRT API allows you to create, animate, transform and manipulate compositor objects in a unified API layer.","pos":[467,602]},{"content":"Composition Animations provide a powerful and efficient way to run animations in your application UI.","pos":[603,705]},{"content":"They have been designed from the ground up to ensure that your animations run at 60 FPS independent of the UI thread and to give you the flexibility to build amazing experiences using not only time, but input and other properties, to drive animations.","pos":[706,959]},{"content":"This topic provides an overview of the functionality available that allows you to animate properties of the Composition Object.","pos":[960,1087]},{"content":"This document assumes you are familiar with the basics of the Visual Layer structure.","pos":[1088,1173]},{"content":"For more information, <bpt id=\"p1\">[</bpt>see here<ept id=\"p1\">](./composition-visual-tree.md)</ept>.","pos":[1174,1237]},{"content":"There are two types of Composition Animations: <bpt id=\"p1\">**</bpt>KeyFrame Animations<ept id=\"p1\">**</ept>, and <bpt id=\"p2\">**</bpt>Expression Animations<ept id=\"p2\">**</ept>","pos":[1238,1340]},{"content":"Types of Composition Animations","pos":[1400,1431]},{"content":"<bpt id=\"p1\">**</bpt>KeyFrame Animations<ept id=\"p1\">**</ept> provide your traditional time-driven, <bpt id=\"p2\">*</bpt>frame-by-frame<ept id=\"p2\">*</ept> animation experiences.","pos":[1432,1533]},{"content":"Developers can explicitly define <bpt id=\"p1\">*</bpt>control points<ept id=\"p1\">*</ept> describing values an animating property needs to be at specific points in the animation timeline.","pos":[1534,1682]},{"content":"More importantly you are able to use Easing Functions (otherwise called Interpolators) to describe how to transition between these control points.","pos":[1683,1830]},{"content":"<bpt id=\"p1\">**</bpt>Expression Animations<ept id=\"p1\">**</ept> are a new type of animation introduced in the Visual Layer with the Windows 10 November Update (Build 10586).","pos":[1834,1969]},{"content":"The idea behind Expression Animations is a developer can create mathematical relationships between Visual properties and discrete values that will get evaluated and updated every frame.","pos":[1970,2156]},{"content":"Developers can reference properties on Composition objects or Property Sets, use mathematical function helpers and even reference Input to derive these mathematical relationships.","pos":[2157,2337]},{"content":"Expressions make experiences like Parallax and Sticky headers possible and smooth on the Windows platform.","pos":[2338,2445]},{"content":"Why Composition Animations?","pos":[2451,2478]},{"content":"Performance","pos":[2481,2492]},{"content":"When building Universal Windows applications, most developer code runs on the UI thread.","pos":[2498,2586]},{"content":"Thus, to ensure that the animations run smoothly across the different device categories, the system performs the animation calculations and work on an independent thread in order to maintain 60 FPS.","pos":[2587,2789]},{"content":"This means developers can count on the system to provide smooth animations while their applications perform other complex operations for advanced user experiences.","pos":[2790,2955]},{"content":"Possibilities","pos":[2964,2977]},{"content":"The goal for Composition Animations in the Visual Layer is to make beautiful UI possible.","pos":[2982,3071]},{"content":"We want to provide developers with the flexibility and different types of animations to build out their amazing ideas and push the envelope on UWP forward","pos":[3072,3226]},{"pos":[3230,3416],"content":"(You can also check out the <bpt id=\"p1\">[</bpt>Composition GitHub<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=789439)</ept> for samples on how to use the APIs and some higher fidelity samples of the APIs in action)"},{"content":"Templating","pos":[3422,3432]},{"content":"All Composition Animations in the Visual Layer are templates – this means that developers can use an animation on multiple objects without the need to create separate animations.","pos":[3438,3616]},{"content":"This allows developers to use the same animation and tweak properties or parameters to meet some other needs without the worry of obstructing the previous uses.","pos":[3617,3778]},{"content":"What can you animate with Composition Animations?","pos":[3785,3834]},{"content":"Composition Animations can be applied to most properties of Composition objects such as Visual, and InsetClip.","pos":[3835,3945]},{"content":"You can also apply Composition Animations to Composition Effects and Property Sets.","pos":[3946,4030]},{"content":"When choosing what to animate, take note of the type – use this to determine what type of KeyFrame Animation you construct or what type your Expression must resolve to.","pos":[4033,4202]},{"content":"Visual","pos":[4212,4218]},{"content":"Animatable Visual Properties","pos":[4220,4248]},{"content":"Type","pos":[4251,4255]},{"content":"AnchorPoint","pos":[4274,4285]},{"content":"Vector2","pos":[4289,4296]},{"content":"CenterPoint","pos":[4299,4310]},{"content":"Vector3","pos":[4314,4321]},{"content":"Offset","pos":[4324,4330]},{"content":"Vector3","pos":[4335,4342]},{"content":"Opacity","pos":[4345,4352]},{"content":"Scalar","pos":[4356,4362]},{"content":"Orientation","pos":[4365,4376]},{"content":"Quaternion","pos":[4380,4390]},{"content":"RotationAngle","pos":[4393,4406]},{"content":"Scalar","pos":[4408,4414]},{"content":"RotationAngleInDegrees","pos":[4417,4439]},{"content":"Scalar","pos":[4444,4450]},{"content":"RotationAxis","pos":[4453,4465]},{"content":"Vector3","pos":[4468,4475]},{"content":"Scale","pos":[4478,4483]},{"content":"Vector3","pos":[4485,4492]},{"content":"Size","pos":[4495,4499]},{"content":"Vector2","pos":[4502,4509]},{"content":"TransformMatrix*","pos":[4512,4528]},{"content":"Matrix4x4","pos":[4531,4540]},{"content":"*If you want to animate the entire TransformMatrix property as a Matrix4x4, you need to use an Expression Animation to do so.","pos":[4542,4667]},{"content":"Otherwise, you can target individual cells of the matrix and can use either KeyFrame or Expression animations there.","pos":[4668,4785]},{"content":"InsetClip","pos":[4792,4801]},{"content":"Animatable InsetClip Properties","pos":[4803,4834]},{"content":"Type","pos":[4838,4842]},{"content":"BottomInset","pos":[4887,4898]},{"content":"Scalar","pos":[4902,4908]},{"content":"LeftInset","pos":[4911,4920]},{"content":"Scalar","pos":[4922,4928]},{"content":"RightInset","pos":[4931,4941]},{"content":"Scalar","pos":[4946,4952]},{"content":"TopInset","pos":[4955,4963]},{"content":"Scalar","pos":[4966,4972]},{"content":"Visual Sub Channel Properties","pos":[4977,5006]},{"content":"In addition to being able to animate properties of Visual, you are also able to target the <bpt id=\"p1\">*</bpt>sub channel<ept id=\"p1\">*</ept> components of these properties for animations as well.","pos":[5007,5166]},{"content":"For example, say you simply want to animate the X Offset of a Visual rather than the entire Offset.","pos":[5167,5267]},{"content":"The animation can either target the Vector3 Offset property, or the Scalar X component of the Offset property.","pos":[5268,5379]},{"content":"In addition to being able to target an individual sub channel component of a property, you are also able to target multiple components.","pos":[5380,5516]},{"content":"For example, you can target the X and Y component of Scale.","pos":[5517,5577]},{"content":"Animatable Visual Sub Channel Properties","pos":[5580,5620]},{"content":"Type","pos":[5623,5627]},{"content":"AnchorPoint.x, y","pos":[5680,5696]},{"content":"Scalar","pos":[5697,5703]},{"content":"AnchorPoint.xy","pos":[5706,5720]},{"content":"Vector2","pos":[5721,5728]},{"content":"CenterPoint.x, y, z","pos":[5731,5750]},{"content":"Scalar","pos":[5751,5757]},{"content":"CenterPoint.xy, xz, yz","pos":[5760,5782]},{"content":"Vector2","pos":[5783,5790]},{"content":"Offset.x, y, z","pos":[5793,5807]},{"content":"Scalar","pos":[5808,5814]},{"content":"Offset.xy, xz, yz","pos":[5817,5834]},{"content":"Vector2","pos":[5835,5842]},{"content":"RotationAxis.x, y, z","pos":[5845,5865]},{"content":"Scalar","pos":[5866,5872]},{"content":"RotationAxis.xy, xz, yz","pos":[5875,5898]},{"content":"Vector2","pos":[5899,5906]},{"content":"Scale.x, y, z","pos":[5909,5922]},{"content":"Scalar","pos":[5923,5929]},{"content":"Scale.xy, xz, yz","pos":[5932,5948]},{"content":"Vector2","pos":[5949,5956]},{"content":"Size.x, y","pos":[5959,5968]},{"content":"Scalar","pos":[5969,5975]},{"content":"Size.xy","pos":[5978,5985]},{"content":"Vector2","pos":[5986,5993]},{"content":"TransformMatrix._11 ... TransformMatrix._NN,","pos":[5996,6040]},{"content":"Scalar","pos":[6041,6047]},{"content":"TransformMatrix._11_12 ... TransformMatrix._NN_NN","pos":[6050,6099]},{"content":"Vector2","pos":[6100,6107]},{"content":"TransformMatrix._11_12_13 ... TransformMatrix._NN_NN_NN","pos":[6110,6165]},{"content":"Vector3","pos":[6166,6173]},{"content":"TransformMatrix._11_12_13_14","pos":[6176,6204]},{"content":"Vector4","pos":[6205,6212]},{"content":"Color*","pos":[6215,6221]},{"content":"Colors (Windows.UI)","pos":[6226,6245]},{"content":"*Animating the Color subchannel of the Brush property is a bit different.","pos":[6248,6321]},{"content":"You attach StartAnimation() to the Visual.Brush, and declare the property to animate in the parameter as \"Color\".","pos":[6322,6435]},{"content":"(More details about animating color discussed later)","pos":[6436,6489]},{"content":"Property Sets and Effects","pos":[6493,6518]},{"content":"In addition to animating properties of Composition Visual and InsetClip, you are also able to animate properties in a PropertySet or an Effect.","pos":[6519,6662]},{"content":"For property sets, you define a property and store it in a Composition Property Set – that property can later be the target of an animation (and also be referenced simultaneously in another).","pos":[6663,6856]},{"content":"This will be discussed in more detail in the following sections.","pos":[6857,6921]},{"content":"For Effects, you are able to define graphical effects using the Composition Effects APIs (See here for the <bpt id=\"p1\">[</bpt>Effects Overview<ept id=\"p1\">](./composition-effects.md)</ept>.","pos":[6925,7077]},{"content":"In addition to defining Effects, you are also able to animate the property values of the Effect.","pos":[7078,7175]},{"content":"This is done by targeting the properties component of the Brush property on Sprite Visuals.","pos":[7176,7268]},{"content":"Quick Formula: Getting Started with Composition Animations","pos":[7272,7330]},{"content":"Before diving into the details on how to construct and use the different types of animations, below is a quick, high level formula for how to put together Composition Animations.","pos":[7331,7509]},{"content":"Decide which property, sub channel property or Effect you want to animate - make note of the type.","pos":[7516,7614]},{"content":"Create a new object for your animation – this will either be a KeyFrame or Expression Animation.","pos":[7621,7717]},{"content":"For KeyFrame animations, make sure you create a KeyFrame Animation type that matches the type of property you want to animate.","pos":[7727,7853]},{"content":"There is only a single type of Expression Animation.","pos":[7863,7915]},{"content":"Define the content for animation – Insert your Keyframes or define the Expression string","pos":[7922,8010]},{"content":"For KeyFrame animations, make sure the value of your KeyFrames are the same type as the property you want to animate.","pos":[8020,8137]},{"content":"For Expression animations, make sure your Expression string will resolve to the same type as the property you want to animate.","pos":[8147,8273]},{"content":"Start your animation on the Visual whose property you want to animate – call StartAnimation and include as parameters:   the name of the property you want to animate (in string form) and the object for your animation.","pos":[8280,8497]},{"content":"Using KeyFrame Animations","pos":[9443,9468]},{"content":"KeyFrame Animations are time-based animations that use one or more key frames to specify how the animated value should change over time.","pos":[9469,9605]},{"content":"The frames represent markers or control points, allowing you to define what the animated value should be at a specific time.","pos":[9606,9731]},{"content":"Creating your animation and defining KeyFrames","pos":[9739,9785]},{"content":"To construct a KeyFrame Animation, use the constructor method of your Compositor object that correlates to the type of the property you wish to animate.","pos":[9786,9938]},{"content":"The different types of KeyFrame Animation are:","pos":[9939,9986]},{"content":"ColorKeyFrameAnimation","pos":[9991,10013]},{"content":"QuaternionKeyFrameAnimation","pos":[10018,10045]},{"content":"ScalarKeyFrameAnimation","pos":[10050,10073]},{"content":"Vector2KeyFrameAnimation","pos":[10078,10102]},{"content":"Vector3KeyFrameAnimation","pos":[10107,10131]},{"content":"Vector4KeyFrameAnimation","pos":[10136,10160]},{"content":"An example that creates a Vector3 KeyFrame Animation:","pos":[10164,10217]},{"content":"Each KeyFrame animation is constructed by inserting individual KeyFrame segments that define two components (with an optional third)","pos":[10297,10429]},{"content":"Time: normalized progress state of the KeyFrame between 0.0 – 1.0","pos":[10436,10501]},{"content":"Value: specific value of the animating value at the time state","pos":[10506,10568]},{"content":"(Optional) Easing function: function to describe interpolation between previous and current KeyFrame (discussed later in this topic)","pos":[10573,10705]},{"content":"An example that inserts a KeyFrame at the halfway point of the animation:","pos":[10709,10782]},{"pos":[10859,10966],"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> When animating color with KeyFrame Animations, there are a few additional things to keep in mind:"},{"pos":[10971,11098],"content":"You attach StartAnimation to the Visual.Brush, instead of Visual, with <bpt id=\"p1\">**</bpt>Color<ept id=\"p1\">**</ept> as the property parameter you wish to animate."},{"content":"The \"value\" component of the KeyFrame is defined by the Colors object off of the Windows.UI namespace.","pos":[11103,11205]},{"pos":[11210,11436],"content":"You have the option to define the color space that the interpolation will go through by setting the InterpolationColorSpace property. Possible values include:\na.  CompositionColorSpace.Rgb\nb.  CompositionColorSpace.Hsl","leadings":["","    ","    "],"nodes":[{"content":"You have the option to define the color space that the interpolation will go through by setting the InterpolationColorSpace property.","pos":[0,133]},{"content":"Possible values include: a.","pos":[134,161]},{"content":"CompositionColorSpace.Rgb b.","pos":[163,191]},{"content":"CompositionColorSpace.Hsl","pos":[193,218]}]},{"content":"KeyFrame Animation Properties","pos":[11441,11470]},{"content":"Once you've defined your KeyFrame Animation and the individual KeyFrames, you are able to define multiple properties off of your animation:","pos":[11471,11610]},{"content":"DelayTime – time before an animation starts after StartAnimation() is called","pos":[11615,11691]},{"content":"Duration – duration of the animation","pos":[11696,11732]},{"content":"IterationBehavior – count or infinite repeat behavior for an animation","pos":[11737,11807]},{"content":"IterationCount – number of finite times a KeyFrame Animation will repeat","pos":[11812,11884]},{"content":"KeyFrame Count – read of how many KeyFrames in a particular KeyFrame Animation","pos":[11889,11967]},{"content":"StopBehavior – specifies the behavior of an animating property value when StopAnimation is called.","pos":[11972,12070]},{"content":"An example that sets the Duration of the animation to 5 seconds:","pos":[12074,12138]},{"content":"Easing Functions","pos":[12200,12216]},{"content":"Easing functions (CompositionEasingFunction) indicate how intermediate values progress from the previous key frame value to the current key frame value.","pos":[12217,12369]},{"content":"If you do not provide an easing function for the KeyFrame, a default curve will be used.","pos":[12370,12459]},{"content":"There are two types of easing functions supported:","pos":[12462,12512]},{"content":"Linear","pos":[12517,12523]},{"content":"Cubic Bezier","pos":[12528,12540]},{"content":"Cubic Beziers are a parametric function frequently used to describe smooth curves that can be scaled.","pos":[12544,12645]},{"content":"When using with Composition KeyFrame Animations, you define two control points that are Vector2 objects.","pos":[12646,12750]},{"content":"These control points are used to define the shape of the curve.","pos":[12751,12814]},{"content":"It is recommended to use similar sites such as <bpt id=\"p1\">[</bpt>this<ept id=\"p1\">](http://cubic-bezier.com/#0,-0.01,.48,.99)</ept> to visualize how the two control points construct the curve for a Cubic Bezier.","pos":[12815,12990]},{"content":"To create an easing function, utilize the constructor method off your Compositor object.","pos":[12992,13080]},{"content":"Two examples below that create a Linear easing function and a basic easeIn Cubic Bezier.","pos":[13081,13169]},{"content":"To add your easing function into your KeyFrame, simply add in the third parameter to the KeyFrame when inserting into the Animation.","pos":[13345,13477]},{"content":"An example that adds in a easeIn easing function with the KeyFrame:","pos":[13481,13548]},{"content":"Starting and Stopping KeyFrame Animations","pos":[13637,13678]},{"content":"After you have defined your animation and KeyFrames, you are ready to hook up your animation.","pos":[13679,13772]},{"content":"When starting your animation, you specify the Visual to be animated, the target property to be animated and a reference to the animation.","pos":[13773,13911]},{"content":"You do so by calling the StartAnimation() function.","pos":[13912,13964]},{"content":"Remember that calling StartAnimation() on a property will disconnect and remove any previously running animations.","pos":[13965,14079]},{"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> The reference to the property you choose to animate is in the form of a string.","pos":[14082,14171]},{"content":"An example that sets and starts an animation on the Visual’s Offset property:","pos":[14175,14252]},{"content":"If you want to target a sub channel property, you add the subchannel into the string defining the property you want to animate.","pos":[14318,14445]},{"content":"In the examples above, the syntax would change to StartAnimation(\"Offset.X, animation2), where animation2 is a ScalarKeyFrameAnimation.","pos":[14446,14582]},{"content":"After starting your animation, you also have the ability to stop it before it finishes.","pos":[14586,14673]},{"content":"This is done by using the StopAnimation() function.","pos":[14674,14725]},{"content":"An example that stops an animation on the Visual’s Offset property:","pos":[14728,14795]},{"content":"You also have the ability to define the behavior of the animation when it is explicitly stopped.","pos":[14849,14945]},{"content":"To do so, you define the Stop Behavior property off your animation.","pos":[14946,15013]},{"content":"There are three options:","pos":[15014,15038]},{"content":"LeaveCurrentValue: The animation will mark the value of the animated property to be the last calculated value of the animation","pos":[15043,15169]},{"content":"SetToFinalValue: The animation will mark the value of the animated property to be the value of the final keyframe","pos":[15174,15287]},{"content":"SetToInitialValue: The animation will mark the value of the animated property to be the value of the first keyframe","pos":[15292,15407]},{"content":"An example that sets the StopBehavior property for a KeyFrame Animation:","pos":[15411,15483]},{"content":"Animation Completion Events","pos":[15565,15592]},{"content":"With KeyFrame Animations, developers can use an Animation Batches to aggregate when a select animation (or group of animations) have completed.","pos":[15593,15736]},{"content":"Only KeyFrame animation completion events can be batched.","pos":[15737,15795]},{"content":"Expressions do not have a definite end so they do not fire a completion event.","pos":[15796,15874]},{"content":"If an Expression animation is started within a batch, the animation will execute as expected and it will not affect when the batch fires.","pos":[15875,16013]},{"content":"A batch completion event fires when all animations within the batch have completed.","pos":[16019,16102]},{"content":"The time it takes for a batch’s event to fire depends on the longest or most delayed animation in the batch.","pos":[16103,16212]},{"content":"Aggregating end states is useful when you need to know when groups of select animations complete in order to schedule some other work.","pos":[16213,16348]},{"content":"Batches will dispose once the completion event is fired.","pos":[16352,16408]},{"content":"You can also call Dispose() at any time to release the resource early.","pos":[16409,16479]},{"content":"You may want to manually dispose the batch object if a batched animation is ended early and you do not wish to pick up the completion event.","pos":[16480,16621]},{"content":"If an animation is interrupted or canceled the completion event will fire and count towards the batch it was set in.","pos":[16622,16739]},{"content":"This is demonstrated in the Animation_Batch SDK sample on the <bpt id=\"p1\">[</bpt>Windows/Composition GitHub<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?LinkId=789439)</ept>.","pos":[16740,16881]},{"content":"Scoped batches","pos":[16888,16902]},{"content":"To aggregate a specific group of animations or target a single animation’s completion event, you create a Scoped batch.","pos":[16903,17022]},{"content":"After creating a Scoped batch, all started animations aggregate until the batch is explicitly suspended or ended using the Suspend or End function.","pos":[17141,17288]},{"content":"Calling the Suspend function stops aggregating animates end states until Resume is called.","pos":[17294,17384]},{"content":"This allows you to explicitly exclude content from a given batch.","pos":[17385,17450]},{"content":"In the example below, the animation targeting the Offset property of VisualA will not be included in the batch:","pos":[17454,17565]},{"content":"In order to complete your batch you must call End().","pos":[17674,17726]},{"content":"Without an End call, the batch will remain open forever-collecting objects.","pos":[17727,17802]},{"content":"The following code snippet and diagram below shows an example of how the Batch will aggregate animations to track end states.","pos":[17807,17932]},{"content":"Note that in this example, Animations 1, 3, and 4 will have end states tracked by this Batch, but Animation 2 will not.","pos":[17933,18053]},{"content":"Batching a single animation's completion event","pos":[18406,18452]},{"content":"If you want to know when a single animation ends, you need to create a Scoped batch that will include just the animation you are targeting.","pos":[18453,18592]},{"content":"For example:","pos":[18593,18606]},{"content":"Retrieving a batch's completion event","pos":[18794,18831]},{"content":"When batching an animation or multiple animations, you will retrieve the batch’s completion event the same way.","pos":[18833,18944]},{"content":"You register the event-handling method for the Completed event of the targeted batch.","pos":[18945,19031]},{"content":"Batch states","pos":[19094,19106]},{"content":"There are two properties you can use to determine the state of an existing batch; IsActive and IsEnded.","pos":[19107,19210]},{"content":"The IsActive property returns true if a targeted batch is open to aggregating animations.","pos":[19214,19303]},{"content":"IsActive will return false when a batch is suspended or ended.","pos":[19304,19366]},{"content":"The IsEnded property returns true when you cannot add an animation to that specific batch.","pos":[19371,19461]},{"content":"A batch will be ended when you call explicitly call End() for a specific batch.","pos":[19462,19541]},{"content":"Using Expression Animations","pos":[19548,19575]},{"content":"Expression Animations are a new type of animation the Composition Team introduced with the November Update for Windows 10 (10586).","pos":[19576,19706]},{"content":"At a high level, Expression Animations are based on a mathematical equation/relationship between discrete values and references to other Composition object properties.","pos":[19707,19875]},{"content":"In contrast to KeyFrame Animations that use an interpolator function (Cubic Bezier, Quad, Quintic, etc.) to describe how the value changes over time, Expression Animations use a mathematical equation to define how the animated value is calculated each frame.","pos":[19876,20136]},{"content":"It’s important to point out that Expression Animations do not have a defined duration – once started, they will run and use the mathematical equation to determine the value of the animating property until they are explicitly stopped.","pos":[20137,20372]},{"content":"So why are Expression Animations useful?","pos":[20376,20416]},{"content":"The real power of Expression Animations comes from their ability to create a mathematical relationship that includes references to parameters or properties on other objects.","pos":[20419,20593]},{"content":"This means you can have an equation referencing values of properties on other Composition objects, local variables, or even shared values in Composition Property Sets.","pos":[20594,20762]},{"content":"Because of this reference model, and that the equation is evaluated every frame, if the values that define an equation change, so will the output of the equation.","pos":[20763,20926]},{"content":"This opens up bigger possibilities beyond traditional KeyFrame Animations where values must be discrete and pre-defined.","pos":[20927,21048]},{"content":"For example, experiences like Sticky Headers and Parallax can be easily described using Expression Animations.","pos":[21049,21160]},{"pos":[21162,21314],"content":"<bpt id=\"p1\">**</bpt>Note:<ept id=\"p1\">**</ept> We use the terms \"Expression\" or \"Expression String\" as reference to your mathematical equation that defines your Expression Animation object."},{"content":"Creating and Attaching your Expression Animation","pos":[21318,21366]},{"content":"Before we jump into the syntax of creating Expression Animations, there are a few core principles to mention:","pos":[21367,21476]},{"content":"Expression Animations use a defined mathematical equation to determine the value of the animating property every frame.","pos":[21483,21602]},{"content":"The mathematical equation is inputted into the Expression as a string.","pos":[21607,21677]},{"content":"The output of the mathematical equation must resolve to the same type as the property you plan to animate.","pos":[21682,21788]},{"content":"If they don't match, you will get an error when the Expression gets calculated.","pos":[21789,21868]},{"content":"If your equation resolves to Nan (number/0), the system will use the last previously calculated value.","pos":[21869,21971]},{"pos":[21976,22077],"content":"Expression Animations have an <bpt id=\"p1\">*</bpt>infinite lifetime<ept id=\"p1\">*</ept> – they will continue to run until they are stopped."},{"content":"To create your Expression Animation, simply use the constructor off your Composition object, where you define your Mathematical expression.","pos":[22081,22220]},{"content":"An example of the constructor where a very basic expression is defined that sums two Scalar values together (We will dive into more complicated expressions in the next section):","pos":[22225,22402]},{"content":"Similar to KeyFrame Animations, once you have defined your Expression Animation, you need to attach it to the Visual and declare the property you wish the animation to animate.","pos":[22484,22660]},{"content":"Below, we continue with the above example and attach our Expression Animation to the Visual’s Opacity property (A Scalar type):","pos":[22661,22789]},{"content":"Components of your Expression String","pos":[22857,22893]},{"content":"The example in the previous section demonstrated two simple Scalar values being added together.","pos":[22894,22989]},{"content":"Although this is a valid example of Expressions, it does not fully demonstrate the potential of what you can do with Expressions.","pos":[22990,23120]},{"content":"One thing to note about the example above is that because these are discrete values, every frame the equation will resolve to 0.5 and never change throughout the lifetime of the animation.","pos":[23121,23310]},{"content":"The real potential of Expressions comes from defining a mathematical relationship in which the values could change periodically or all the time.","pos":[23311,23456]},{"content":"Let’s walk through the different pieces that can make up these types of Expressions.","pos":[23461,23545]},{"content":"Operators, Precedence and Associativity","pos":[23552,23591]},{"content":"The Expression string supports usage of typical operators you would expect to describe mathematical relationships between different components of the equation:","pos":[23592,23751]},{"content":"Category","pos":[23756,23764]},{"content":"Operators","pos":[23767,23776]},{"content":"Unary","pos":[23802,23807]},{"content":"Multiplicative","pos":[23813,23827]},{"content":"* /","pos":[23832,23835]},{"content":"Additive","pos":[23838,23846]},{"content":"+ -","pos":[23849,23852]},{"content":"Similarly, when the Expression is evaluated, it will adhere to operator precedence and associativity as defined in the C# Language specification.","pos":[23855,24000]},{"content":"Put another way, it will adhere to basic order of operations.","pos":[24001,24063]},{"content":"In the example below, when evaluated, the parentheses will be resolved first before resolving the rest of the equation based on order of operations:","pos":[24067,24215]},{"content":"Property Parameters","pos":[24301,24320]},{"content":"Property parameters are one of the most powerful components of Expression Animations.","pos":[24321,24406]},{"content":"In the Expression string, you can reference values of properties from other objects such as Composition Visual, Composition Property Set or other C# objects.","pos":[24407,24565]},{"content":"To use these in an Expression string, you simply need to define the references as parameters to the Expression Animation.","pos":[24570,24691]},{"content":"This is done by mapping the string used in the Expression to the actual object.","pos":[24692,24772]},{"content":"This allows the system when evaluating the equation to know what to inspect to calculate the value.","pos":[24773,24872]},{"content":"There are different types of parameters that correlate to the type of the object you wish to include in the equation:","pos":[24873,24991]},{"content":"Type","pos":[24996,25000]},{"content":"Function to create parameter","pos":[25003,25031]},{"content":"Scalar","pos":[25072,25078]},{"content":"SetScalarParameter(String ref, Scalar obj)","pos":[25083,25125]},{"content":"Vector","pos":[25128,25134]},{"content":"SetVector2Parameter(String ref, Vector2 obj)","pos":[25139,25183]},{"content":"SetVector3Parameter(String ref, Vector3 obj)","pos":[25188,25232]},{"content":"SetVector4Parameter(String ref, Vector4 obj)","pos":[25237,25281]},{"content":"Matrix","pos":[25284,25290]},{"content":"SetMatrix3x2Parameter(String ref, Matrix3x2 obj)","pos":[25295,25343]},{"content":"SetMatrix4x4Parameter(String ref, Matrix4x4 obj)","pos":[25348,25396]},{"content":"Quaternion","pos":[25399,25409]},{"content":"SetQuaternionParameter(String ref, Quaternion obj)","pos":[25414,25464]},{"content":"Color","pos":[25467,25472]},{"content":"SetColorParameter(String ref, Color obj)","pos":[25474,25514]},{"content":"CompositionObject","pos":[25517,25534]},{"content":"SetReferenceParameter(String ref, Composition object obj)","pos":[25536,25593]},{"content":"In the example below, we create an Expression Animation that will reference the Offset of two other Composition Visuals and a basic System.Numerics Vector3 object.","pos":[25596,25759]},{"content":"Additionally, you can reference a value in a Property Set from an expression using the same model described above.","pos":[26127,26241]},{"content":"Composition Property Sets are a useful way to store data used by animations, and are useful for creating sharable, reusable data that isn’t tied to the lifetime of any other Composition objects.","pos":[26242,26437]},{"content":"Property Set values can be referenced in an expression similar to other property references.","pos":[26438,26531]},{"content":"(Property Sets are discussed in more detail in a later section)","pos":[26532,26595]},{"content":"We can modify the example directly above, such that a property set is used to define the commonOffset instead of a local variable:","pos":[26599,26729]},{"content":"Finally, when referencing properties of other objects, it also possible to reference the subchannel properties either in the Expression string or as part of the reference parameter.","pos":[27175,27356]},{"content":"In the example below, we reference the x subchannel of Offset properties from two Visuals – one in the Expression string itself and the other when creating the parameter reference.","pos":[27361,27541]},{"content":"Notice that when referencing the X component of Offset, we change our parameter type to a Scalar Parameter instead of a Vector3 like in the previous example:","pos":[27542,27699]},{"content":"Expression Helper Functions and Constructors","pos":[27932,27976]},{"content":"In addition to having access to Operators and Property Parameters, you can leverage a list of mathematical functions to use in their expressions.","pos":[27977,28122]},{"content":"These functions are provided to perform calculations and operations on different types that you would similarly do with System.Numerics objects.","pos":[28123,28268]},{"content":"An example below creates an Expression targeted towards Scalars that takes advantage of the Clamp helper function:","pos":[28272,28386]},{"pos":[28549,28752],"content":"In addition to a list of Helper functions, you are also able to use built-in Constructor methods inside an Expression string that will generate an instance of that type based on the provided parameters."},{"content":"An example below creates an Expression that defines a new Vector3 in the Expression string:","pos":[28756,28847]},{"content":"You can find the full extensive list of helper functions and constructors in the Appendix section, or for each type in the list below:","pos":[28963,29097]},{"content":"Scalar","pos":[29105,29111]},{"content":"Vector2","pos":[29127,29134]},{"content":"Vector3","pos":[29151,29158]},{"content":"Matrix3x2","pos":[29175,29184]},{"content":"Matrix4x4","pos":[29203,29212]},{"content":"Quaternion","pos":[29231,29241]},{"content":"Color","pos":[29261,29266]},{"content":"Expression Keywords","pos":[29282,29301]},{"content":"You can take advantage of special \"keywords\" that are treated differently when the Expression string is evaluated.","pos":[29302,29416]},{"content":"Because they are considered \"keywords\" they can’t be used as the string parameter portion of their Property references.","pos":[29417,29537]},{"content":"Keyword","pos":[29543,29550]},{"content":"Description","pos":[29554,29565]},{"content":"This.StartingValue","pos":[29593,29611]},{"content":"Provides a reference to the original starting value of the property that is being animated.","pos":[29613,29704]},{"content":"This.CurrentValue","pos":[29707,29724]},{"content":"Provides a reference to the currently \"known\" value of the property","pos":[29726,29793]},{"content":"Pi","pos":[29796,29798]},{"content":"Provides a keyword reference to the value of PI","pos":[29800,29847]},{"content":"An example below that demonstrates using the this.StartingValue keyword:","pos":[29850,29922]},{"content":"Expressions with Conditionals","pos":[30025,30054]},{"pos":[30055,30246],"content":"In addition to supporting mathematical relationships using operators, property references, and functions and constructors, you can also create an expression that contains a ternary operator:"},{"content":"Conditional statements enable you to write expressions such that based on a particular condition, different mathematical relationships will be used by the system to calculate the value of the animating property.","pos":[30311,30523]},{"content":"Ternary operators can be nested as the expressions for the true or false statements.","pos":[30524,30609]},{"content":"The following conditional operators are supported in the condition statement:","pos":[30613,30690]},{"content":"Equals (==)","pos":[30696,30707]},{"content":"Not Equals (!=)","pos":[30712,30727]},{"content":"Less than (&lt;)","pos":[30732,30745]},{"content":"Less than or equal to (&lt;=)","pos":[30750,30776]},{"content":"Great than (&gt;)","pos":[30781,30795]},{"content":"Great than or equal to (&gt;=)","pos":[30800,30827]},{"content":"The following conjunctions are supported as operators or functions in the condition statement:","pos":[30831,30925]},{"content":"Not: !","pos":[30930,30936]},{"content":"/ Not(bool1)","pos":[30937,30949]},{"content":"And: &amp;&amp; / And(bool1, bool2)","pos":[30954,30981]},{"content":"Or: || / Or(bool1, bool2)","pos":[30986,31011]},{"content":"Below is an example of an Expression Animation using a conditional.","pos":[31015,31082]},{"content":"Expression KeyFrames","pos":[31230,31250]},{"content":"Earlier in this document, we described how you create KeyFrame Animations and introduced you to Expression Animations and all the different pieces that you can use to make up the Expression string.","pos":[31251,31449]},{"content":"What if you wanted the power from Expressions Animations but wanted time interpolation provided by KeyFrame Animations?","pos":[31450,31569]},{"content":"The answer is Expression KeyFrames!","pos":[31570,31606]},{"content":"Instead of defining a discrete value for each control points in the KeyFrame Animation, you can have the value be an Expression string.","pos":[31610,31745]},{"content":"In this situation, the system will use the expression string to calculate what the value of the animating property should be at the given point in the timeline.","pos":[31746,31907]},{"content":"The system will then simply interpolate to this value like in a normal keyframe animation.","pos":[31908,31999]},{"content":"You don’t need to create special animations to use Expression KeyFrames – just insert an ExpressionKeyFrame into your standard KeyFrame animation, provide the time and your expression string as the value.","pos":[32005,32210]},{"content":"The example below demonstrates this, using an Expression string as the value for one of the KeyFrames:","pos":[32211,32313]},{"content":"Expression Sample","pos":[32509,32526]},{"content":"The code below shows an example of setting up an expression animation for a basic Parallax experience that pulls input values from the Scroll Viewer.","pos":[32527,32676]},{"content":"Animating With Property Sets","pos":[33450,33478]},{"content":"Composition Property Sets provide you with the ability to store values that can be shared across multiple animations and are not tied to the lifetime of another Composition object.","pos":[33479,33659]},{"content":"Property Sets are extremely useful to store common values and then easily reference them later on in animations.","pos":[33660,33773]},{"content":"You can also use Property Sets to store data based on application logic to drive an expression.","pos":[33774,33870]},{"content":"To create a property set, use the constructor method off your Compositor object:","pos":[33874,33954]},{"content":"Once you’ve created your Property Set, you can add a property and value to it:","pos":[34021,34099]},{"content":"Similar to what we’ve seen earlier, we can reference this property set value in an Expression Animation:","pos":[34167,34271]},{"content":"Property set values can also be animated.","pos":[34516,34557]},{"content":"This is done by attaching the animation to the PropertySet object, and then referring to the property name in the string.","pos":[34558,34679]},{"content":"Below, we animate the NewOffset property in the property set using a KeyFrame Animation.","pos":[34680,34769]},{"content":"You might be wondering if this code executed in an app, what happens to the animated property value the Expression Animation is attached to.","pos":[35064,35204]},{"content":"In this situation, the expression would initially output to a value, however, once the KeyFrame Animation begins to animate the Property in the Property Set, the Expression value will update as well, since the equation is calculated every frame.","pos":[35205,35452]},{"content":"This is the beauty of Property Sets with Expression and KeyFrame Animations!","pos":[35453,35529]},{"content":"Appendix","pos":[35536,35544]},{"content":"Expression Functions by Structure Type","pos":[35548,35586]},{"content":"Scalar","pos":[35590,35596]},{"content":"Function and Constructor Operations","pos":[35601,35636]},{"content":"Description","pos":[35638,35649]},{"content":"Abs(Float value)","pos":[35709,35725]},{"content":"Returns a Float representing the absolute value of the float parameter","pos":[35728,35798]},{"content":"Clamp(Float value, Float min, Float max)","pos":[35803,35843]},{"content":"Returns a  float value that is either greater than min and less than max or min if the value is less than min or max if the value is greater than max","pos":[35846,35995]},{"content":"Max (Float value1, Float value2)","pos":[36000,36032]},{"content":"Returns the greater float between value1 and value2.","pos":[36035,36087]},{"content":"Min (Float value1, Float value2)","pos":[36092,36124]},{"content":"Returns the lesser float between value1 and value2.","pos":[36127,36178]},{"content":"Lerp(Float value1, Float value2, Float progress)","pos":[36183,36231]},{"content":"Returns a float that represents the calculated linear interpolation calculation between the two Scalar values based on the progress (Note: Progress is between 0.0 and 1.0)","pos":[36234,36405]},{"content":"Slerp(Float value1, Float value2, Float progress)","pos":[36410,36459]},{"content":"Returns a Float that represents the calculated spherical interpolation between the two Float values based on the progress (Note: progress is between 0.0 and 1.0)","pos":[36461,36622]},{"content":"Mod(Float value1, Float value2)","pos":[36627,36658]},{"content":"Returns the Float remainder resulting from the division of value1 and value2","pos":[36662,36738]},{"content":"Ceil(Float value)","pos":[36743,36760]},{"content":"Returns the Float parameter rounded to next greater whole number","pos":[36766,36830]},{"content":"Floor(Float value)","pos":[36835,36853]},{"content":"Returns the Float parameter to the next lesser whole number","pos":[36858,36917]},{"content":"Sqrt(Float value)","pos":[36922,36939]},{"content":"Returns the square root of the Float parameter","pos":[36941,36987]},{"content":"Square(Float value)","pos":[36992,37011]},{"content":"Returns the square of the Float parameter","pos":[37015,37056]},{"content":"Sin(Float value1)","pos":[37061,37078]},{"content":"Asin(Float value2)","pos":[37082,37100]},{"content":"Returns the Sin or ArcSin of the Float parameter","pos":[37105,37153]},{"content":"Cos(Float value1)","pos":[37156,37173]},{"content":"ACos(Float value2)","pos":[37177,37195]},{"content":"Returns the Cos or ArcCos of the Float parameter","pos":[37200,37248]},{"content":"Tan(Float value1)","pos":[37251,37268]},{"content":"ATan(Float value2)","pos":[37272,37290]},{"content":"Returns the Tan or ArcTan of the Float parameter","pos":[37295,37343]},{"content":"Round(Float value)","pos":[37346,37364]},{"content":"Returns the Float parameter rounded to the nearest whole number","pos":[37369,37432]},{"content":"Log10(Float value)","pos":[37435,37453]},{"content":"Returns the Log (base 10) result of the Float parameter","pos":[37458,37513]},{"content":"Ln(Float value)","pos":[37516,37531]},{"content":"Returns the Natural Log result of the Float parameter","pos":[37535,37588]},{"content":"Pow(Float value, Float power)","pos":[37591,37620]},{"content":"Returns the result of the Float parameter raised to a particular power","pos":[37622,37692]},{"content":"ToDegrees(Float radians)","pos":[37695,37719]},{"content":"Returns the Float parameter converted into Degrees","pos":[37722,37772]},{"content":"ToRadians(Float degrees)","pos":[37775,37799]},{"content":"Returns the Float parameter converted into Radians","pos":[37802,37852]},{"content":"Vector2","pos":[37858,37865]},{"content":"Function and Constructor Operations","pos":[37870,37905]},{"content":"Description","pos":[37909,37920]},{"content":"Abs (Vector2 value)","pos":[37976,37995]},{"content":"Returns a Vector2 with absolute value applied to each component","pos":[37999,38062]},{"content":"Clamp (Vector2 value1, Vector2 min, Vector2 max)","pos":[38065,38113]},{"content":"Returns a Vector2 that contains the clamped values for each respective component","pos":[38116,38196]},{"content":"Max (Vector2 value1, Vector2 value2)","pos":[38199,38235]},{"content":"Returns a Vector2 that has performed a Max on each of the corresponding components from value1 and value2","pos":[38238,38343]},{"content":"Min (Vector2 value1, Vector2 value2)","pos":[38346,38382]},{"content":"Returns a Vector2 that has performed a Min on each of the corresponding components from value1 and value2","pos":[38385,38490]},{"content":"Scale(Vector2 value, Float factor)","pos":[38493,38527]},{"content":"Returns a Vector2 with each component of the vector multiplied by the scaling factor.","pos":[38532,38617]},{"content":"Transform(Vector2 value, Matrix3x2 matrix)","pos":[38620,38662]},{"content":"Returns a Vector2 resulting from the linear transformation between a Vector2 and a Matrix3x2 (aka multiplying a vector by a matrix).","pos":[38667,38799]},{"content":"Lerp(Vector2 value1, Vector2 value2, Float progress)","pos":[38802,38854]},{"content":"Returns a Vector2 that represents the calculated linear interpolation calculation between the two Vector2 values based on the progress (Note: Progress is between 0.0 and 1.0)","pos":[38857,39031]},{"content":"Length(Vector2 value)","pos":[39034,39055]},{"content":"Returns a Float value representing the length/magnitude of the Vector2","pos":[39057,39127]},{"content":"LengthSquared(Vector2)","pos":[39130,39152]},{"content":"Returns a Float value representing the square of the length/magnitude of a Vector2","pos":[39157,39239]},{"content":"Distance(Vector2 value1, Vector2 value2)","pos":[39242,39282]},{"content":"Returns a Float value representing the distance between two Vector2 values","pos":[39285,39359]},{"content":"DistanceSquared(Vector2 value1, Vector2 value2)","pos":[39362,39409]},{"content":"Returns a Float value representing the square of the distance between two Vector2 values","pos":[39413,39501]},{"content":"Normalize(Vector2 value)","pos":[39504,39528]},{"content":"Returns a Vector2 representing the unit vector of the parameter where all components have been normalized","pos":[39531,39636]},{"content":"Vector2(Float x, Float y)","pos":[39639,39664]},{"content":"Constructs a Vector2 using two Float parameters","pos":[39666,39713]},{"content":"Vector3","pos":[39719,39726]},{"content":"Function and Constructor Operations","pos":[39731,39766]},{"content":"Description","pos":[39770,39781]},{"content":"Abs (Vector3 value)","pos":[39837,39856]},{"content":"Returns a Vector3 with absolute value applied to each component","pos":[39860,39923]},{"content":"Clamp (Vector3 value1, Vector3 min, Vector3 max)","pos":[39926,39974]},{"content":"Returns a Vector3 that contains the clamped values for each respective component","pos":[39977,40057]},{"content":"Max (Vector3 value1, Vector3 value2)","pos":[40060,40096]},{"content":"Returns a Vector3 that has performed a Max on each of the corresponding components from value1 and value2","pos":[40099,40204]},{"content":"Min (Vector3 value1, Vector3 value2)","pos":[40207,40243]},{"content":"Returns a Vector3 that has performed a Min on each of the corresponding components from value1 and value2","pos":[40246,40351]},{"content":"Scale(Vector3 value, Float factor)","pos":[40354,40388]},{"content":"Returns a Vector3 with each component of the vector multiplied by the scaling factor.","pos":[40393,40478]},{"content":"Lerp(Vector3 value1, Vector3 value2, Float progress)","pos":[40481,40533]},{"content":"Returns a Vector3 that represents the calculated linear interpolation calculation between the two Vector3 values based on the progress (Note: Progress is between 0.0 and 1.0)","pos":[40536,40710]},{"content":"Length(Vector3 value)","pos":[40713,40734]},{"content":"Returns a Float value representing the length/magnitude of the Vector3","pos":[40736,40806]},{"content":"LengthSquared(Vector3)","pos":[40809,40831]},{"content":"Returns a Float value representing the square of the length/magnitude of a Vector3","pos":[40836,40918]},{"content":"Distance(Vector3 value1, Vector3 value2)","pos":[40921,40961]},{"content":"Returns a Float value representing the distance between two Vector3 values","pos":[40964,41038]},{"content":"DistanceSquared(Vector3 value1, Vector3 value2)","pos":[41041,41088]},{"content":"Returns a Float value representing the square of the distance between two Vector3 values","pos":[41092,41180]},{"content":"Normalize(Vector3 value)","pos":[41183,41207]},{"content":"Returns a Vector3 representing the unit vector of the parameter where all components have been normalized","pos":[41210,41315]},{"content":"Vector3(Float x, Float y, Float z)","pos":[41318,41352]},{"content":"Constructs a Vector3 using three Float parameters","pos":[41357,41406]},{"content":"Vector4","pos":[41412,41419]},{"content":"Function and Constructor Operations","pos":[41424,41459]},{"content":"Description","pos":[41463,41474]},{"content":"Abs (Vector4 value)","pos":[41530,41549]},{"content":"Returns a Vector3 with absolute value applied to each component","pos":[41553,41616]},{"content":"Clamp (Vector4 value1, Vector4 min, Vector4 max)","pos":[41619,41667]},{"content":"Returns a Vector4 that contains the clamped values for each respective component","pos":[41670,41750]},{"content":"Max (Vector4 value1 Vector4 value2)","pos":[41753,41788]},{"content":"Returns a Vector4 that has performed a Max on each of the corresponding components from value1 and value2","pos":[41792,41897]},{"content":"Min (Vector4 value1 Vector4 value2)","pos":[41900,41935]},{"content":"Returns a Vector4 that has performed a Min on each of the corresponding components from value1 and value2","pos":[41939,42044]},{"content":"Scale(Vector3 value, Float factor)","pos":[42047,42081]},{"content":"Returns a Vector3 with each component of the vector multiplied by the scaling factor.","pos":[42086,42171]},{"content":"Transform(Vector4 value, Matrix4x4 matrix)","pos":[42174,42216]},{"content":"Returns a Vector4 resulting from the linear transformation between a Vector4 and a Matrix4x4 (aka multiplying a vector by a matrix).","pos":[42221,42353]},{"content":"Lerp(Vector4 value1, Vector4 value2, Float progress)","pos":[42356,42408]},{"content":"Returns a Vector4 that represents the calculated linear interpolation calculation between the two Vector4 values based on the progress (Note: progress is between 0.0 and 1.0)","pos":[42411,42585]},{"content":"Length(Vector4 value)","pos":[42588,42609]},{"content":"Returns a Float value representing the length/magnitude of the Vector4","pos":[42611,42681]},{"content":"LengthSquared(Vector4)","pos":[42684,42706]},{"content":"Returns a Float value representing the square of the length/magnitude of a Vector4","pos":[42711,42793]},{"content":"Distance(Vector4 value1, Vector4 value2)","pos":[42796,42836]},{"content":"Returns a Float value representing the distance between two Vector4 values","pos":[42839,42913]},{"content":"DistanceSquared(Vector4 value1, Vector4 value2)","pos":[42916,42963]},{"content":"Returns a Float value representing the square of the distance between two Vector4 values","pos":[42967,43055]},{"content":"Normalize(Vector4 value)","pos":[43058,43082]},{"content":"Returns a Vector4 representing the unit vector of the parameter where all components have been normalized","pos":[43085,43190]},{"content":"Vector4(Float x, Float y, Float z, Float w)","pos":[43193,43236]},{"content":"Constructs a Vector4 using four Float parameters","pos":[43240,43288]},{"content":"Matrix3x2","pos":[43294,43303]},{"content":"Function and Constructor Operations","pos":[43308,43343]},{"content":"Description","pos":[43347,43358]},{"content":"Scale(Matrix3x2 value, Float factor)","pos":[43414,43450]},{"content":"Returns a Matrix3x2 with each component of the matrix multiplied by the scaling factor.","pos":[43453,43540]},{"content":"Inverse(Matrix 3x2 value)","pos":[43543,43568]},{"content":"Returns a Matrix3x2 object that represents the reciprocal matrix","pos":[43570,43634]},{"content":"Lerp(Matrix3x2 value1, Matrix3x2 value2, Float progress)","pos":[43637,43693]},{"content":"Returns a Matrix3x2 that represents the calculated linear interpolation calculation between the two Matrix3x2 values based on the progress (Note: progress is between 0.0 and 1.0)","pos":[43696,43874]},{"content":"Matrix3x2(Float M11, Float M12, Float M21, Float M22, Float M31, Float M32)","pos":[43877,43952]},{"content":"Constructs a Matrix3x2 using 6 Float parameters","pos":[43956,44003]},{"content":"Matrix3x2.CreateFromScale(Vector2 scale)","pos":[44006,44046]},{"content":"Constructs a Matrix3x2 from a Vector2   representing scale","pos":[44049,44107]},{"content":"scale.X, 0.0","pos":[44114,44126]},{"content":"0.0, scale.Y","pos":[44132,44144]},{"content":"0.0, 0.0","pos":[44150,44158]},{"content":"Matrix3x2.CreateFromTranslation(Vector2 translation)","pos":[44164,44216]},{"content":"Constructs a Matrix3x2 from a Vector2 representing translation","pos":[44219,44281]},{"content":"1.0, 0.0,","pos":[44288,44297]},{"content":"0.0, 1.0,","pos":[44303,44312]},{"content":"translation.X, translation.Y","pos":[44318,44346]},{"content":"Matrix4x4","pos":[44358,44367]},{"content":"Function and Constructor Operations","pos":[44372,44407]},{"content":"Description","pos":[44411,44422]},{"content":"Scale(Matrix4x4 value, Float factor)","pos":[44478,44514]},{"content":"Returns a Matrix 4x4 with each component of the matrix multiplied by the scaling factor.","pos":[44517,44605]},{"content":"Inverse(Matrix4x4)","pos":[44608,44626]},{"content":"Returns a Matrix4x4 object that represents the reciprocal matrix","pos":[44631,44695]},{"content":"Lerp(Matrix4x4 value1, Matrix4x4 value2, Float progress)","pos":[44698,44754]},{"content":"Returns a Matrix4x4 that represents the calculated linear interpolation calculation between the two Matrix4x4 values based on the progress (Note: progress is between 0.0 and 1.0)","pos":[44757,44935]},{"content":"Matrix4x4(Float M11, Float M12, Float M13, Float M14,","pos":[44938,44991]},{"content":"Float M21, Float M22, Float M23, Float M24,","pos":[44996,45039]},{"content":"Float M31, Float M32, Float M33, Float M34,","pos":[45048,45091]},{"content":"Float M41, Float M42, Float M43, Float M44)","pos":[45100,45143]},{"content":"Constructs a Matrix4x4 using 16 Float parameters","pos":[45145,45193]},{"content":"Matrix4x4.CreateFromScale(Vector3 scale)","pos":[45196,45236]},{"content":"Constructs a Matrix4x4 from a Vector3 representing scale","pos":[45239,45295]},{"content":"scale.X, 0.0, 0.0, 0.0,","pos":[45302,45325]},{"content":"0.0, scale.Y, 0.0, 0.0,","pos":[45331,45354]},{"content":"0.0, 0.0, scale.Z, 0.0,","pos":[45360,45383]},{"content":"0.0, 0.0, 0.0, 1.0","pos":[45389,45407]},{"content":"Matrix4x4.CreateFromTranslation(Vector3 translation)","pos":[45412,45464]},{"content":"Constructs a Matrix4x4 from a Vector3 representing translation","pos":[45467,45529]},{"content":"1.0, 0.0, 0.0, 0.0,","pos":[45536,45555]},{"content":"0.0, 1.0, 0.0, 0.0,","pos":[45561,45580]},{"content":"0.0, 0.0, 1.0, 0.0,","pos":[45586,45605]},{"content":"translation.X, translation.Y, translation.Z, 1.0","pos":[45611,45659]},{"content":"Matrix4x4.CreateFromAxisAngle(Vector3 axis, Float angle)","pos":[45664,45720]},{"content":"Constructs a Matrix4x4 from a Vector3 axis and a Float representing an angle","pos":[45723,45799]},{"content":"Quaternion","pos":[45805,45815]},{"content":"Function and Constructor Operations","pos":[45820,45855]},{"content":"Description","pos":[45859,45870]},{"content":"Slerp(Quaternion value1, Quaternion value2, Float progress)","pos":[45926,45985]},{"content":"Returns a Quaternion that represents the calculated spherical interpolation between the two Quaternion values based on the progress (Note: progress is between 0.0 and 1.0)","pos":[45989,46160]},{"content":"Concatenate(Quaternion value1 Quaternion value2)","pos":[46163,46211]},{"content":"Returns a Quaternion representing a concatenation of two Quaternions (aka a Quaternion that represents a combined two individual rotations)","pos":[46214,46353]},{"content":"Length(Quaternion value)","pos":[46356,46380]},{"content":"Returns a Float value representing the length/magnitude of the Quaternion.","pos":[46383,46457]},{"content":"LengthSquared(Quaternion)","pos":[46460,46485]},{"content":"Returns a Float value representing the square of the length/magnitude of a Quaternion","pos":[46487,46572]},{"content":"Normalize(Quaternion value)","pos":[46575,46602]},{"content":"Returns a Quaternion whose components have been normalized","pos":[46606,46664]},{"content":"Quaternion.CreateFromAxisAngle(Vector3 axis, Scalar angle)","pos":[46667,46725]},{"content":"Constructs a Quaternion from a Vector3 axis and a Scalar representing an angle","pos":[46730,46808]},{"content":"Quaternion(Float x, Float y, Float z, Float w)","pos":[46811,46857]},{"content":"Constructs a Quaternion from four Float values","pos":[46862,46908]},{"content":"Color","pos":[46914,46919]},{"content":"Function and Constructor Operations","pos":[46922,46957]},{"content":"Description","pos":[46961,46972]},{"content":"ColorLerp(Color colorTo, Color colorFrom, Float progress)","pos":[47028,47085]},{"content":"Returns a Color object that represents the calculated linear interpolation value between two color objects based on a given progress.","pos":[47087,47220]},{"content":"(Note: Progress is between 0.0 and 1.0)","pos":[47221,47260]},{"content":"ColorLerpRGB(Color colorTo, Color colorFrom, Float progress)","pos":[47263,47323]},{"content":"Returns a Color object that represents the calculated linear interpolation value between two objects based on a given progress in the RGB color space.","pos":[47326,47476]},{"content":"ColorLerpHSL(Color colorTo, Color colorFrom, Float progress)","pos":[47479,47539]},{"content":"Returns a Color object that represents the calculated linear interpolation value between two objects based on a given progress in the HSL color space.","pos":[47542,47692]},{"content":"ColorArgb(Float a, Float r, Float g, Float b)","pos":[47695,47740]},{"content":"Constructs an object representing Color defined by ARGB components","pos":[47742,47808]},{"content":"ColorHsl(Float h, Float s, Float l)","pos":[47811,47846]},{"content":"Constructs an object representing Color defined by HSL components (Note: Hue is defined from 0 and 2pi)","pos":[47850,47953]}],"content":"---\nauthor: scottmill\nms.assetid: 386faf59-8f22-2e7c-abc9-d04216e78894\ntitle: Composition animations\ndescription: Many composition object and effect properties can be animated using key frame and expression animations allowing properties of a UI element to change over time or based on a calculation.\n---\n# Composition animations\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nThe Windows.UI.Composition WinRT API allows you to create, animate, transform and manipulate compositor objects in a unified API layer. \nComposition Animations provide a powerful and efficient way to run animations in your application UI. \nThey have been designed from the ground up to ensure that your animations run at 60 FPS independent of the UI thread \nand to give you the flexibility to build amazing experiences using not only time, but input and other properties, to drive animations.\nThis topic provides an overview of the functionality available that allows you to animate properties of the Composition Object.\nThis document assumes you are familiar with the basics of the Visual Layer structure. For more information, [see here](./composition-visual-tree.md). \nThere are two types of Composition Animations: **KeyFrame Animations**, and **Expression Animations**  \n\n![](./images/composition-animation-types.png)  \n   \n \n##Types of Composition Animations\n**KeyFrame Animations** provide your traditional time-driven, *frame-by-frame* animation experiences. \nDevelopers can explicitly define *control points* describing values an animating property needs to be at specific points in the animation timeline. \nMore importantly you are able to use Easing Functions (otherwise called Interpolators) to describe how to transition between these control points.  \n\n**Expression Animations** are a new type of animation introduced in the Visual Layer with the Windows 10 November Update (Build 10586). \nThe idea behind Expression Animations is a developer can create mathematical relationships between Visual properties and discrete values that will get evaluated and updated every frame. \nDevelopers can reference properties on Composition objects or Property Sets, use mathematical function helpers and even reference Input to derive these mathematical relationships. \nExpressions make experiences like Parallax and Sticky headers possible and smooth on the Windows platform.  \n\n##Why Composition Animations?\n**Performance**  \n When building Universal Windows applications, most developer code runs on the UI thread. \n Thus, to ensure that the animations run smoothly across the different device categories, \n the system performs the animation calculations and work on an independent thread in order to maintain 60 FPS. \n This means developers can count on the system to provide smooth animations while their applications perform other complex operations for advanced user experiences.    \n \n**Possibilities**  \nThe goal for Composition Animations in the Visual Layer is to make beautiful UI possible. We want to provide developers with the flexibility and different types of animations to build out their amazing ideas and push the envelope on UWP forward\n \n (You can also check out the [Composition GitHub](http://go.microsoft.com/fwlink/?LinkID=789439) for samples on how to use the APIs and some higher fidelity samples of the APIs in action)  \n\n**Templating**  \n All Composition Animations in the Visual Layer are templates – this means that developers can use an animation on multiple objects without the need to create separate animations. \nThis allows developers to use the same animation and tweak properties or parameters to meet some other needs without the worry of obstructing the previous uses.  \n \n##What can you animate with Composition Animations?\nComposition Animations can be applied to most properties of Composition objects such as Visual, and InsetClip. \nYou can also apply Composition Animations to Composition Effects and Property Sets. **When choosing what to animate, take note of the type – use \nthis to determine what type of KeyFrame Animation you construct or what type your Expression must resolve to.**  \n \n###Visual\n|Animatable Visual Properties|  Type|\n|------|------|\n|AnchorPoint|   Vector2|\n|CenterPoint|   Vector3|\n|Offset|    Vector3|\n|Opacity|   Scalar|\n|Orientation|   Quaternion|\n|RotationAngle| Scalar|\n|RotationAngleInDegrees|    Scalar|\n|RotationAxis|  Vector3|\n|Scale| Vector3|\n|Size|  Vector2|\n|TransformMatrix*|  Matrix4x4|\n*If you want to animate the entire TransformMatrix property as a Matrix4x4, you need to use an Expression Animation to do so. \nOtherwise, you can target individual cells of the matrix and can use either KeyFrame or Expression animations there.  \n\n###InsetClip\n|Animatable InsetClip Properties|   Type|\n|-------------------------------|-------|\n|BottomInset|   Scalar|\n|LeftInset| Scalar|\n|RightInset|    Scalar|\n|TopInset|  Scalar|\n\n##Visual Sub Channel Properties\nIn addition to being able to animate properties of Visual, you are also able to target the *sub channel* components of these properties for animations as well. \nFor example, say you simply want to animate the X Offset of a Visual rather than the entire Offset. \nThe animation can either target the Vector3 Offset property, or the Scalar X component of the Offset property. \nIn addition to being able to target an individual sub channel component of a property, you are also able to target multiple components. \nFor example, you can target the X and Y component of Scale.\n\n|Animatable Visual Sub Channel Properties|  Type|\n|----------------------------------------|------|\n|AnchorPoint.x, y|Scalar|\n|AnchorPoint.xy|Vector2|\n|CenterPoint.x, y, z|Scalar|\n|CenterPoint.xy, xz, yz|Vector2|\n|Offset.x, y, z|Scalar|\n|Offset.xy, xz, yz|Vector2|\n|RotationAxis.x, y, z|Scalar|\n|RotationAxis.xy, xz, yz|Vector2|\n|Scale.x, y, z|Scalar|\n|Scale.xy, xz, yz|Vector2|\n|Size.x, y|Scalar|\n|Size.xy|Vector2|\n|TransformMatrix._11 ... TransformMatrix._NN,|Scalar|\n|TransformMatrix._11_12 ... TransformMatrix._NN_NN|Vector2|\n|TransformMatrix._11_12_13 ... TransformMatrix._NN_NN_NN|Vector3|\n|TransformMatrix._11_12_13_14|Vector4|\n|Color*|    Colors (Windows.UI)|\n\n*Animating the Color subchannel of the Brush property is a bit different. You attach StartAnimation() to the Visual.Brush, and declare the property to animate in the parameter as \"Color\". \n(More details about animating color discussed later)\n\n##Property Sets and Effects\nIn addition to animating properties of Composition Visual and InsetClip, you are also able to animate properties in a PropertySet or an Effect. \nFor property sets, you define a property and store it in a Composition Property Set – that property can later be the target of an animation (and also be referenced simultaneously \nin another). This will be discussed in more detail in the following sections.  \n\nFor Effects, you are able to define graphical effects using the Composition Effects APIs (See here for the [Effects Overview](./composition-effects.md). \nIn addition to defining Effects, you are also able to animate the property values of the Effect. \nThis is done by targeting the properties component of the Brush property on Sprite Visuals.\n\n##Quick Formula: Getting Started with Composition Animations\nBefore diving into the details on how to construct and use the different types of animations, below is a quick, high level formula for how to put together Composition Animations.  \n1.  Decide which property, sub channel property or Effect you want to animate - make note of the type.  \n2.  Create a new object for your animation – this will either be a KeyFrame or Expression Animation.  \n    *  For KeyFrame animations, make sure you create a KeyFrame Animation type that matches the type of property you want to animate.  \n    *  There is only a single type of Expression Animation.  \n3.  Define the content for animation – Insert your Keyframes or define the Expression string  \n    *  For KeyFrame animations, make sure the value of your KeyFrames are the same type as the property you want to animate.  \n    *  For Expression animations, make sure your Expression string will resolve to the same type as the property you want to animate.  \n4.  Start your animation on the Visual whose property you want to animate – call StartAnimation and include as parameters:   the name of the property you want to animate (in string form) and the object for your animation.  \n\n```cs\n// KeyFrame Animation Example to target Opacity property\n// Step 2 - Create your animation object\nvar animation = _compositor.CreateScalarKeyFrameAnimation();\n// Step 3 - Define Content\nanimation.InsertKeyFrameAnimation(1.0f, 0.2f); \n// Step 4 - Attach animation to Visual property and start animation\n_targetVisual.StartAnimation(\"Opacity\", animation); \n  \n// Expression Animation Example to target Opacity property\n// Step 2 - Create your animation object\nvar expression = _compositor.CreateExpressionAnimation(); \n// Step 3 - Define Content (you can also define the string as part of the expression object\n// declaration)\nexpression.Expression = \"targetVisual.Offset.X / windowWidth\";\nexpression.SetReferenceParameter(\"targetVisual\", _target);\nexpression.SetScalarParameter(\"windowWidth\", _xSizeWindow);\n// Step 4 - Attach animation to Visual property and start animation\n_targetVisual.StartAnimation(\"Opacity\", expression);\n\n```\n\n##Using KeyFrame Animations\nKeyFrame Animations are time-based animations that use one or more key frames to specify how the animated value should change over time. \nThe frames represent markers or control points, allowing you to define what the animated value should be at a specific time.  \n \n###Creating your animation and defining KeyFrames\nTo construct a KeyFrame Animation, use the constructor method of your Compositor object that correlates to the type of the property you wish to animate. \nThe different types of KeyFrame Animation are:\n*   ColorKeyFrameAnimation\n*   QuaternionKeyFrameAnimation\n*   ScalarKeyFrameAnimation\n*   Vector2KeyFrameAnimation\n*   Vector3KeyFrameAnimation\n*   Vector4KeyFrameAnimation  \n\nAn example that creates a Vector3 KeyFrame Animation:     \n```cs\nvar animation = _compositor.CreateVector3KeyFrameAnimation(); \n```\n\nEach KeyFrame animation is constructed by inserting individual KeyFrame segments that define two components (with an optional third)  \n*   Time: normalized progress state of the KeyFrame between 0.0 – 1.0\n*   Value: specific value of the animating value at the time state\n*   (Optional) Easing function: function to describe interpolation between previous and current KeyFrame (discussed later in this topic)  \n\nAn example that inserts a KeyFrame at the halfway point of the animation:\n```cs\nanimation.InsertKeyFrame(0.5f, new Vector3(50.0f, 80.0f, 0.0f));\n```\n\n**Note:** When animating color with KeyFrame Animations, there are a few additional things to keep in mind:\n1.  You attach StartAnimation to the Visual.Brush, instead of Visual, with **Color** as the property parameter you wish to animate.\n2.  The \"value\" component of the KeyFrame is defined by the Colors object off of the Windows.UI namespace.\n3.  You have the option to define the color space that the interpolation will go through by setting the InterpolationColorSpace property. Possible values include:\n    a.  CompositionColorSpace.Rgb\n    b.  CompositionColorSpace.Hsl\n\n\n##KeyFrame Animation Properties\nOnce you've defined your KeyFrame Animation and the individual KeyFrames, you are able to define multiple properties off of your animation:\n*   DelayTime – time before an animation starts after StartAnimation() is called\n*   Duration – duration of the animation\n*   IterationBehavior – count or infinite repeat behavior for an animation\n*   IterationCount – number of finite times a KeyFrame Animation will repeat\n*   KeyFrame Count – read of how many KeyFrames in a particular KeyFrame Animation\n*   StopBehavior – specifies the behavior of an animating property value when StopAnimation is called.  \n\nAn example that sets the Duration of the animation to 5 seconds:  \n```cs\nanimation.Duration = TimeSpan.FromSeconds(5);\n```\n\n##Easing Functions\nEasing functions (CompositionEasingFunction) indicate how intermediate values progress from the previous key frame value to the current key frame value. \nIf you do not provide an easing function for the KeyFrame, a default curve will be used.  \nThere are two types of easing functions supported:\n*   Linear\n*   Cubic Bezier  \n\nCubic Beziers are a parametric function frequently used to describe smooth curves that can be scaled. When using with Composition KeyFrame Animations, you define two control points that are Vector2 objects. These control points are used to define the shape of the curve. It is recommended to use similar sites such as [this](http://cubic-bezier.com/#0,-0.01,.48,.99) to visualize how the two control points construct the curve for a Cubic Bezier.\n\nTo create an easing function, utilize the constructor method off your Compositor object. Two examples below that create a Linear easing function and a basic easeIn Cubic Bezier.  \n```cs\nvar linear = _compositor.CreateLinearEasingFunction();\nvar easeIn = _compositor.CreateCubicBezierEasingFunction(new Vector2(0.5f, 0.0f), new Vector2(1.0f, 1.0f));\n```\nTo add your easing function into your KeyFrame, simply add in the third parameter to the KeyFrame when inserting into the Animation.   \nAn example that adds in a easeIn easing function with the KeyFrame:  \n```cs\nanimation.InsertKeyFrame(0.5f, new Vector3(50.0f, 80.0f, 0.0f), easeIn);\n```\n\n##Starting and Stopping KeyFrame Animations\nAfter you have defined your animation and KeyFrames, you are ready to hook up your animation. When starting your animation, you specify the Visual to be animated, \nthe target property to be animated and a reference to the animation. \nYou do so by calling the StartAnimation() function. Remember that calling StartAnimation() on a property will disconnect and remove any previously running animations.  \n**Note:** The reference to the property you choose to animate is in the form of a string.  \n\nAn example that sets and starts an animation on the Visual’s Offset property:  \n```cs\ntargetVisual.StartAnimation(\"Offset\", animation);\n```  \n\nIf you want to target a sub channel property, you add the subchannel into the string defining the property you want to animate. \nIn the examples above, the syntax would change to StartAnimation(\"Offset.X, animation2), where animation2 is a ScalarKeyFrameAnimation.  \n\nAfter starting your animation, you also have the ability to stop it before it finishes. This is done by using the StopAnimation() function.  \nAn example that stops an animation on the Visual’s Offset property:    \n```cs\ntargetVisual.StopAnimation(\"Offset\");\n```\n\nYou also have the ability to define the behavior of the animation when it is explicitly stopped. To do so, you define the Stop Behavior property off your animation. There are three options:\n*   LeaveCurrentValue: The animation will mark the value of the animated property to be the last calculated value of the animation\n*   SetToFinalValue: The animation will mark the value of the animated property to be the value of the final keyframe\n*   SetToInitialValue: The animation will mark the value of the animated property to be the value of the first keyframe  \n\nAn example that sets the StopBehavior property for a KeyFrame Animation:  \n```cs\nanimation.StopBehavior = AnimationStopBehavior.LeaveCurrentValue;\n```\n\n##Animation Completion Events\nWith KeyFrame Animations, developers can use an Animation Batches to aggregate when a select animation (or group of animations) have completed. \nOnly KeyFrame animation completion events can be batched. Expressions do not have a definite end so they do not fire a completion event. \nIf an Expression animation is started within a batch, the animation will execute as expected and it will not affect when the batch fires.    \n\nA batch completion event fires when all animations within the batch have completed. \nThe time it takes for a batch’s event to fire depends on the longest or most delayed animation in the batch.\n Aggregating end states is useful when you need to know when groups of select animations complete in order to schedule some other work.  \n\nBatches will dispose once the completion event is fired. You can also call Dispose() at any time to release the resource early. \nYou may want to manually dispose the batch object if a batched animation is ended early and you do not wish to pick up the completion event. \nIf an animation is interrupted or canceled the completion event will fire and count towards the batch it was set in. \nThis is demonstrated in the Animation_Batch SDK sample on the [Windows/Composition GitHub](http://go.microsoft.com/fwlink/p/?LinkId=789439).  \n \n##Scoped batches\nTo aggregate a specific group of animations or target a single animation’s completion event, you create a Scoped batch.    \n```cs\nCompositionScopedBatch myScopedBatch = _compositor.CreateScopedBatch(CompositionBatchTypes.Animation);\n``` \nAfter creating a Scoped batch, all started animations aggregate until the batch is explicitly suspended or ended using the Suspend or End function.    \n\nCalling the Suspend function stops aggregating animates end states until Resume is called. This allows you to explicitly exclude content from a given batch.  \n\nIn the example below, the animation targeting the Offset property of VisualA will not be included in the batch:  \n```cs\nmyScopedBatch.Suspend();\nVisualA.StartAnimation(\"Offset\", myAnimation);\nmyScopeBatch.Resume();\n```\n\nIn order to complete your batch you must call End(). Without an End call, the batch will remain open forever-collecting objects.  \n \nThe following code snippet and diagram below shows an example of how the Batch will aggregate animations to track end states. \nNote that in this example, Animations 1, 3, and 4 will have end states tracked by this Batch, but Animation 2 will not.  \n```cs\nmyScopedBatch.End();\nCompositionScopedBatch myScopedBatch =  _compositor.CreateScopedBatch(CompositionBatchTypes.Animation);\n// Start Animation1\n[…]\nmyScopedBatch.Suspend();\n// Start Animation2 \n[…]\nmyScopedBatch.Resume();\n// Start Animation3\n[…]\n// Start Animation4\n[…]\nmyScopedBatch.End();\n```  \n![](./images/composition-scopedbatch.png)\n \n##Batching a single animation's completion event\nIf you want to know when a single animation ends, you need to create a Scoped batch that will include just the animation you are targeting. \nFor example:  \n```cs\nCompositionScopedBatch myScopedBatch =  _compositor.CreateScopedBatch(CompositionBatchTypes.Animation);\nVisual.StartAnimation(\"Opacity\", myAnimation);\nmyScopedBatch.End();\n```\n\n##Retrieving a batch's completion event\n\nWhen batching an animation or multiple animations, you will retrieve the batch’s completion event the same way. \nYou register the event-handling method for the Completed event of the targeted batch.  \n\n```cs\nmyScopedBatch.Completed += OnBatchCompleted;\n``` \n\n##Batch states\nThere are two properties you can use to determine the state of an existing batch; IsActive and IsEnded.  \n\nThe IsActive property returns true if a targeted batch is open to aggregating animations. IsActive will return false when a batch is suspended or ended.   \n\nThe IsEnded property returns true when you cannot add an animation to that specific batch. A batch will be ended when you call explicitly call End() for a specific batch.  \n \n##Using Expression Animations\nExpression Animations are a new type of animation the Composition Team introduced with the November Update for Windows 10 (10586). \nAt a high level, Expression Animations are based on a mathematical equation/relationship between discrete values and references to other Composition object properties. \nIn contrast to KeyFrame Animations that use an interpolator function (Cubic Bezier, Quad, Quintic, etc.) to describe how the value changes over time, \nExpression Animations use a mathematical equation to define how the animated value is calculated each frame. \nIt’s important to point out that Expression Animations do not have a defined duration – once started, \nthey will run and use the mathematical equation to determine the value of the animating property until they are explicitly stopped.\n\n**So why are Expression Animations useful?** \nThe real power of Expression Animations comes from their ability to create a mathematical relationship that includes references to parameters or properties on other objects. \nThis means you can have an equation referencing values of properties on other Composition objects, local variables, or even shared values in Composition Property Sets. \nBecause of this reference model, and that the equation is evaluated every frame, if the values that define an equation change, so will the output of the equation. \nThis opens up bigger possibilities beyond traditional KeyFrame Animations where values must be discrete and pre-defined. \nFor example, experiences like Sticky Headers and Parallax can be easily described using Expression Animations.\n\n**Note:** We use the terms \"Expression\" or \"Expression String\" as reference to your mathematical equation that defines your Expression Animation object.\n\n##Creating and Attaching your Expression Animation\nBefore we jump into the syntax of creating Expression Animations, there are a few core principles to mention:  \n*   Expression Animations use a defined mathematical equation to determine the value of the animating property every frame.\n*   The mathematical equation is inputted into the Expression as a string.\n*   The output of the mathematical equation must resolve to the same type as the property you plan to animate. If they don't match, you will get an error when the Expression gets calculated. If your equation resolves to Nan (number/0), the system will use the last previously calculated value.\n*   Expression Animations have an *infinite lifetime* – they will continue to run until they are stopped.  \n\nTo create your Expression Animation, simply use the constructor off your Composition object, where you define your Mathematical expression.  \n \nAn example of the constructor where a very basic expression is defined that sums two Scalar values together (We will dive into more complicated expressions in the next section):  \n```cs\nvar expression = _compositor.CreateExpressionAnimation(\"0.2 + 0.3\");\n```\nSimilar to KeyFrame Animations, once you have defined your Expression Animation, you need to attach it to the Visual and declare the property you wish the animation to animate. \nBelow, we continue with the above example and attach our Expression Animation to the Visual’s Opacity property (A Scalar type):  \n```cs\ntargetVisual.StartAnimation(\"Opacity\", expression);\n```\n\n##Components of your Expression String\nThe example in the previous section demonstrated two simple Scalar values being added together. \nAlthough this is a valid example of Expressions, it does not fully demonstrate the potential of what you can do with Expressions. \nOne thing to note about the example above is that because these are discrete values, every frame the equation will resolve to 0.5 and never change throughout the lifetime of the animation. \nThe real potential of Expressions comes from defining a mathematical relationship in which the values could change periodically or all the time.  \n \nLet’s walk through the different pieces that can make up these types of Expressions.  \n\n###Operators, Precedence and Associativity\nThe Expression string supports usage of typical operators you would expect to describe mathematical relationships between different components of the equation:  \n\n|Category|  Operators|\n|--------|-----------|\n|Unary| -|\n|Multiplicative|    * /|\n|Additive|  + -|\n\nSimilarly, when the Expression is evaluated, it will adhere to operator precedence and associativity as defined in the C# Language specification. \nPut another way, it will adhere to basic order of operations.  \n\nIn the example below, when evaluated, the parentheses will be resolved first before resolving the rest of the equation based on order of operations:  \n```cs\n\"(5.0 * (72.4 – 36.0) + 5.0\" // (5.0 * 36.4 + 5) -> (182 + 5) -> 187\n```\n\n###Property Parameters\nProperty parameters are one of the most powerful components of Expression Animations. \nIn the Expression string, you can reference values of properties from other objects such as Composition Visual, Composition Property Set or other C# objects.   \n\nTo use these in an Expression string, you simply need to define the references as parameters to the Expression Animation. \nThis is done by mapping the string used in the Expression to the actual object. This allows the system when evaluating the equation to know what to inspect to calculate the value. \nThere are different types of parameters that correlate to the type of the object you wish to include in the equation:  \n\n|Type|  Function to create parameter|\n|----|------------------------------|\n|Scalar|    SetScalarParameter(String ref, Scalar obj)|\n|Vector|    SetVector2Parameter(String ref, Vector2 obj)<br/>SetVector3Parameter(String ref, Vector3 obj)<br/>SetVector4Parameter(String ref, Vector4 obj)|\n|Matrix|    SetMatrix3x2Parameter(String ref, Matrix3x2 obj)<br/>SetMatrix4x4Parameter(String ref, Matrix4x4 obj)|\n|Quaternion|    SetQuaternionParameter(String ref, Quaternion obj)|\n|Color| SetColorParameter(String ref, Color obj)|\n|CompositionObject| SetReferenceParameter(String ref, Composition object obj)|\n\nIn the example below, we create an Expression Animation that will reference the Offset of two other Composition Visuals and a basic System.Numerics Vector3 object.  \n```cs\nvar commonOffset = new Vector3(25.0, 17.0, 10.0);\nvar expression = _compositor.CreateExpressionAnimation(\"SomeOffset / ParentOffset + additionalOffset);\nexpression.SetVector3Parameter(\"SomeOffset\", childVisual.Offset);\nexpression.SetVector3Parameter(\"ParentOffset\", parentVisual.Offset);\nexpression.SetVector3Parameter(\"additionalOffset\", commonOffset);\n```\n\nAdditionally, you can reference a value in a Property Set from an expression using the same model described above. \nComposition Property Sets are a useful way to store data used by animations, and are useful for creating sharable, reusable data that isn’t tied to the lifetime of any other Composition objects. \nProperty Set values can be referenced in an expression similar to other property references. (Property Sets are discussed in more detail in a later section)  \n\nWe can modify the example directly above, such that a property set is used to define the commonOffset instead of a local variable:\n```cs\n_sharedProperties = _compositor.CreatePropertySet();\n_sharedProperties.InsertVector3(\"commonOffset\", offset);\nvar expression = _compositor.CreateExpressionAnimation(\"SomeOffset / ParentOffset + sharedProperties.commonOffset);\nexpression.SetVector3Parameter(\"SomeOffset\", childVisual.Offset);\nexpression.SetVector3Parameter(\"ParentOffset\", parentVisual.Offset);\nexpression.SetReferenceParameter(\"sharedProperties\", _sharedProperties);\n```\n\nFinally, when referencing properties of other objects, it also possible to reference the subchannel properties either in the Expression string or as part of the reference parameter.  \n \nIn the example below, we reference the x subchannel of Offset properties from two Visuals – one in the Expression string itself and the other when creating the parameter reference.\nNotice that when referencing the X component of Offset, we change our parameter type to a Scalar Parameter instead of a Vector3 like in the previous example:  \n```cs\nvar expression = _compositor.CreateExpressionAnimation(\"xOffset/ ParentOffset.X\");\nexpression.SetScalarParameter(\"xOffset\", childVisual.Offset.X);\nexpression.SetVector3Parameter(\"ParentOffset\", parentVisual.Offset);\n```\n\n###Expression Helper Functions and Constructors\nIn addition to having access to Operators and Property Parameters, you can leverage a list of mathematical functions to use in their expressions. \nThese functions are provided to perform calculations and operations on different types that you would similarly do with System.Numerics objects.  \n\nAn example below creates an Expression targeted towards Scalars that takes advantage of the Clamp helper function:  \n```cs\nvar expression = _compositor.CreateExpressionAnimation(\"Clamp((scroller.Offset.y * -1.0) – container.Offset.y, 0, container.Size.y – header.Size.y)\"\n```\n\nIn addition to a list of Helper functions, you are also able to use built-in Constructor methods inside an Expression string that will generate an instance of \nthat type based on the provided parameters.  \n\nAn example below creates an Expression that defines a new Vector3 in the Expression string:  \n```cs\nvar expression = _compositor.CreateExpressionAnimation(\"Offset / Vector3(targetX, targetY, targetZ\");\n```\n\nYou can find the full extensive list of helper functions and constructors in the Appendix section, or for each type in the list below:  \n*   [Scalar](#scalar)\n*   [Vector2](#vector2)\n*   [Vector3](#vector3)\n*   [Matrix3x2](#matrix3x2)\n*   [Matrix4x4](#matrix4x4)\n*   [Quaternion](#quaternion)\n*   [Color](#color)  \n\n###Expression Keywords\nYou can take advantage of special \"keywords\" that are treated differently when the Expression string is evaluated. \nBecause they are considered \"keywords\" they can’t be used as the string parameter portion of their Property references.  \n \n|Keyword|   Description|\n|-------|--------------|\n|This.StartingValue| Provides a reference to the original starting value of the property that is being animated.|\n|This.CurrentValue| Provides a reference to the currently \"known\" value of the property|\n|Pi| Provides a keyword reference to the value of PI|\n\nAn example below that demonstrates using the this.StartingValue keyword:  \n```cs\nvar expression = _compositor.CreateExpressionAnimation(\"this.StartingValue + delta\");\n```\n\n###Expressions with Conditionals\nIn addition to supporting mathematical relationships using operators, property references, and functions and constructors, \nyou can also create an expression that contains a ternary operator:  \n```\n(condition ? ifTrue_expression : ifFalse_expression)\n```\n\nConditional statements enable you to write expressions such that based on a particular condition, \ndifferent mathematical relationships will be used by the system to calculate the value of the animating property. \nTernary operators can be nested as the expressions for the true or false statements.  \n\nThe following conditional operators are supported in the condition statement: \n*   Equals (==)\n*   Not Equals (!=)\n*   Less than (<)\n*   Less than or equal to (<=)\n*   Great than (>)\n*   Great than or equal to (>=)  \n\nThe following conjunctions are supported as operators or functions in the condition statement:\n*   Not: ! / Not(bool1)\n*   And: && / And(bool1, bool2)\n*   Or: || / Or(bool1, bool2)  \n\nBelow is an example of an Expression Animation using a conditional.  \n```cs\nvar expression = _compositor.CreateExpressionAnimation(\"target.Offset.x > 50 ? 0.0f + (target.Offset.x / parent.Offset.x) : 1.0f\");\n```\n\n##Expression KeyFrames\nEarlier in this document, we described how you create KeyFrame Animations and introduced you to Expression Animations and all the different pieces \nthat you can use to make up the Expression string. What if you wanted the power from Expressions Animations but wanted time interpolation provided by KeyFrame Animations? \nThe answer is Expression KeyFrames!  \n\nInstead of defining a discrete value for each control points in the KeyFrame Animation, you can have the value be an Expression string. \nIn this situation, the system will use the expression string to calculate what the value of the animating property should be at the given point in the timeline. \nThe system will then simply interpolate to this value like in a normal keyframe animation.    \n\nYou don’t need to create special animations to use Expression KeyFrames – just insert an ExpressionKeyFrame into your standard KeyFrame animation, \nprovide the time and your expression string as the value. The example below demonstrates this, using an Expression string as the value for one of the KeyFrames:   \n```cs\nvar animation = _compositor.CreateScalarKeyFrameAnimation();\nanimation.InsertExpressionKeyFrame(0.25, \"VisualBOffset.X / VisualAOffset.Y\");\nanimation.InsertKeyFrame(1.00f, 0.8f);\n```\n\n##Expression Sample\nThe code below shows an example of setting up an expression animation for a basic Parallax experience that pulls input values from the Scroll Viewer.\n```cs\n// Get scrollviewer\nScrollViewer myScrollViewer = ThumbnailList.GetFirstDescendantOfType<ScrollViewer>();\n_scrollProperties = ElementCompositionPreview.GetScrollViewerManipulationPropertySet(myScrollViewer);\n\n// Setup the expression\n_parallaxExpression = compositor.CreateExpressionAnimation();\n_parallaxExpression.SetScalarParameter(\"StartOffset\", 0.0f);\n_parallaxExpression.SetScalarParameter(\"ParallaxValue\", 0.5f);\n_parallaxExpression.SetScalarParameter(\"ItemHeight\", 0.0f);\n_parallaxExpression.SetReferenceParameter(\"ScrollManipulation\", _scrollProperties);\n_parallaxExpression.Expression = \"(ScrollManipulation.Translation.Y + StartOffset - (0.5 *  ItemHeight)) * ParallaxValue - (ScrollManipulation.Translation.Y + StartOffset - (0.5   * ItemHeight))\";\n```\n\n##Animating With Property Sets\nComposition Property Sets provide you with the ability to store values that can be shared across multiple animations and are not tied to the lifetime of another Composition object. \nProperty Sets are extremely useful to store common values and then easily reference them later on in animations. \nYou can also use Property Sets to store data based on application logic to drive an expression.  \n\nTo create a property set, use the constructor method off your Compositor object:  \n```cs\n_sharedProperties = _compositor.CreatePropertySet();\n```\n\nOnce you’ve created your Property Set, you can add a property and value to it:  \n```cs\n_sharedProperties.InsertVector3(\"NewOffset\", offset);\n```\n\nSimilar to what we’ve seen earlier, we can reference this property set value in an Expression Animation:  \n```cs\nvar expression = _compositor.CreateExpressionAnimation(\"this.target.Offset + sharedProperties.NewOffset\");\nexpression.SetReferenceParameter(\"sharedProperties\", _sharedProperties);\ntargetVisual.StartAnimation(\"Offset\", expression);\n```\n\nProperty set values can also be animated. This is done by attaching the animation to the PropertySet object, and then referring to the property name in the string. \nBelow, we animate the NewOffset property in the property set using a KeyFrame Animation.  \n```cs\nvar keyFrameAnimation = _compositor.CreateVector3KeyFrameAnimation()\nkeyFrameAnimation.InsertKeyFrame(0.5f, new Vector3(25.0f, 68.0f, 0.0f);\nkeyFrameAnimation.InsertKeyFrame(1.0f, new Vector3(89.0f, 125.0f, 0.0f);\n_sharedProperties.StartAnimation(\"NewOffset\", keyFrameAnimation);\n```\n\n\nYou might be wondering if this code executed in an app, what happens to the animated property value the Expression Animation is attached to. \nIn this situation, the expression would initially output to a value, however, once the KeyFrame Animation begins to animate the Property in the Property Set, \nthe Expression value will update as well, since the equation is calculated every frame. This is the beauty of Property Sets with Expression and KeyFrame Animations!  \n \n##Appendix\n###Expression Functions by Structure Type\n###Scalar  \n\n|Function and Constructor Operations| Description|  \n|-----------------------------------|--------------|  \n|Abs(Float value)|  Returns a Float representing the absolute value of the float parameter|  \n|Clamp(Float value, Float min, Float max)|  Returns a  float value that is either greater than min and less than max or min if the value is less than min or max if the value is greater than max|  \n|Max (Float value1, Float value2)|  Returns the greater float between value1 and value2.|  \n|Min (Float value1, Float value2)|  Returns the lesser float between value1 and value2.|  \n|Lerp(Float value1, Float value2, Float progress)|  Returns a float that represents the calculated linear interpolation calculation between the two Scalar values based on the progress (Note: Progress is between 0.0 and 1.0)|  \n|Slerp(Float value1, Float value2, Float progress)| Returns a Float that represents the calculated spherical interpolation between the two Float values based on the progress (Note: progress is between 0.0 and 1.0)|  \n|Mod(Float value1, Float value2)|   Returns the Float remainder resulting from the division of value1 and value2|  \n|Ceil(Float value)|     Returns the Float parameter rounded to next greater whole number|  \n|Floor(Float value)|    Returns the Float parameter to the next lesser whole number|  \n|Sqrt(Float value)| Returns the square root of the Float parameter|  \n|Square(Float value)|   Returns the square of the Float parameter|  \n|Sin(Float value1)||\n|Asin(Float value2)|    Returns the Sin or ArcSin of the Float parameter|\n|Cos(Float value1)||\n|ACos(Float value2)|    Returns the Cos or ArcCos of the Float parameter|\n|Tan(Float value1)||\n|ATan(Float value2)|    Returns the Tan or ArcTan of the Float parameter|\n|Round(Float value)|    Returns the Float parameter rounded to the nearest whole number|\n|Log10(Float value)|    Returns the Log (base 10) result of the Float parameter|\n|Ln(Float value)|   Returns the Natural Log result of the Float parameter|\n|Pow(Float value, Float power)| Returns the result of the Float parameter raised to a particular power|\n|ToDegrees(Float radians)|  Returns the Float parameter converted into Degrees|\n|ToRadians(Float degrees)|  Returns the Float parameter converted into Radians|\n\n###Vector2  \n\n|Function and Constructor Operations|   Description|\n|-----------------------------------|--------------|\n|Abs (Vector2 value)|   Returns a Vector2 with absolute value applied to each component|\n|Clamp (Vector2 value1, Vector2 min, Vector2 max)|  Returns a Vector2 that contains the clamped values for each respective component|\n|Max (Vector2 value1, Vector2 value2)|  Returns a Vector2 that has performed a Max on each of the corresponding components from value1 and value2|\n|Min (Vector2 value1, Vector2 value2)|  Returns a Vector2 that has performed a Min on each of the corresponding components from value1 and value2|\n|Scale(Vector2 value, Float factor)|    Returns a Vector2 with each component of the vector multiplied by the scaling factor.|\n|Transform(Vector2 value, Matrix3x2 matrix)|    Returns a Vector2 resulting from the linear transformation between a Vector2 and a Matrix3x2 (aka multiplying a vector by a matrix).|\n|Lerp(Vector2 value1, Vector2 value2, Float progress)|  Returns a Vector2 that represents the calculated linear interpolation calculation between the two Vector2 values based on the progress (Note: Progress is between 0.0 and 1.0)|\n|Length(Vector2 value)| Returns a Float value representing the length/magnitude of the Vector2|\n|LengthSquared(Vector2)|    Returns a Float value representing the square of the length/magnitude of a Vector2|\n|Distance(Vector2 value1, Vector2 value2)|  Returns a Float value representing the distance between two Vector2 values|\n|DistanceSquared(Vector2 value1, Vector2 value2)|   Returns a Float value representing the square of the distance between two Vector2 values|\n|Normalize(Vector2 value)|  Returns a Vector2 representing the unit vector of the parameter where all components have been normalized|\n|Vector2(Float x, Float y)| Constructs a Vector2 using two Float parameters|\n\n###Vector3  \n\n|Function and Constructor Operations|   Description|\n|-----------------------------------|--------------|\n|Abs (Vector3 value)|   Returns a Vector3 with absolute value applied to each component|\n|Clamp (Vector3 value1, Vector3 min, Vector3 max)|  Returns a Vector3 that contains the clamped values for each respective component|\n|Max (Vector3 value1, Vector3 value2)|  Returns a Vector3 that has performed a Max on each of the corresponding components from value1 and value2|\n|Min (Vector3 value1, Vector3 value2)|  Returns a Vector3 that has performed a Min on each of the corresponding components from value1 and value2|\n|Scale(Vector3 value, Float factor)|    Returns a Vector3 with each component of the vector multiplied by the scaling factor.|\n|Lerp(Vector3 value1, Vector3 value2, Float progress)|  Returns a Vector3 that represents the calculated linear interpolation calculation between the two Vector3 values based on the progress (Note: Progress is between 0.0 and 1.0)|\n|Length(Vector3 value)| Returns a Float value representing the length/magnitude of the Vector3|\n|LengthSquared(Vector3)|    Returns a Float value representing the square of the length/magnitude of a Vector3|\n|Distance(Vector3 value1, Vector3 value2)|  Returns a Float value representing the distance between two Vector3 values|\n|DistanceSquared(Vector3 value1, Vector3 value2)|   Returns a Float value representing the square of the distance between two Vector3 values|\n|Normalize(Vector3 value)|  Returns a Vector3 representing the unit vector of the parameter where all components have been normalized|\n|Vector3(Float x, Float y, Float z)|    Constructs a Vector3 using three Float parameters|\n\n###Vector4  \n\n|Function and Constructor Operations|   Description|\n|-----------------------------------|--------------|\n|Abs (Vector4 value)|   Returns a Vector3 with absolute value applied to each component|\n|Clamp (Vector4 value1, Vector4 min, Vector4 max)|  Returns a Vector4 that contains the clamped values for each respective component|\n|Max (Vector4 value1 Vector4 value2)|   Returns a Vector4 that has performed a Max on each of the corresponding components from value1 and value2|\n|Min (Vector4 value1 Vector4 value2)|   Returns a Vector4 that has performed a Min on each of the corresponding components from value1 and value2|\n|Scale(Vector3 value, Float factor)|    Returns a Vector3 with each component of the vector multiplied by the scaling factor.|\n|Transform(Vector4 value, Matrix4x4 matrix)|    Returns a Vector4 resulting from the linear transformation between a Vector4 and a Matrix4x4 (aka multiplying a vector by a matrix).|\n|Lerp(Vector4 value1, Vector4 value2, Float progress)|  Returns a Vector4 that represents the calculated linear interpolation calculation between the two Vector4 values based on the progress (Note: progress is between 0.0 and 1.0)|\n|Length(Vector4 value)| Returns a Float value representing the length/magnitude of the Vector4|\n|LengthSquared(Vector4)|    Returns a Float value representing the square of the length/magnitude of a Vector4|\n|Distance(Vector4 value1, Vector4 value2)|  Returns a Float value representing the distance between two Vector4 values|\n|DistanceSquared(Vector4 value1, Vector4 value2)|   Returns a Float value representing the square of the distance between two Vector4 values|\n|Normalize(Vector4 value)|  Returns a Vector4 representing the unit vector of the parameter where all components have been normalized|\n|Vector4(Float x, Float y, Float z, Float w)|   Constructs a Vector4 using four Float parameters|\n\n###Matrix3x2  \n\n|Function and Constructor Operations|   Description|\n|-----------------------------------|--------------|\n|Scale(Matrix3x2 value, Float factor)|  Returns a Matrix3x2 with each component of the matrix multiplied by the scaling factor.|\n|Inverse(Matrix 3x2 value)| Returns a Matrix3x2 object that represents the reciprocal matrix|\n|Lerp(Matrix3x2 value1, Matrix3x2 value2, Float progress)|  Returns a Matrix3x2 that represents the calculated linear interpolation calculation between the two Matrix3x2 values based on the progress (Note: progress is between 0.0 and 1.0)|\n|Matrix3x2(Float M11, Float M12, Float M21, Float M22, Float M31, Float M32)|   Constructs a Matrix3x2 using 6 Float parameters|\n|Matrix3x2.CreateFromScale(Vector2 scale)|  Constructs a Matrix3x2 from a Vector2   representing scale<br/>\\[scale.X, 0.0<br/> 0.0, scale.Y<br/> 0.0, 0.0 \\]|\n|Matrix3x2.CreateFromTranslation(Vector2 translation)|  Constructs a Matrix3x2 from a Vector2 representing translation<br/>\\[1.0, 0.0,<br/> 0.0, 1.0,<br/> translation.X, translation.Y\\]|\n    \n###Matrix4x4  \n\n|Function and Constructor Operations|   Description|\n|-----------------------------------|--------------|\n|Scale(Matrix4x4 value, Float factor)|  Returns a Matrix 4x4 with each component of the matrix multiplied by the scaling factor.|\n|Inverse(Matrix4x4)|    Returns a Matrix4x4 object that represents the reciprocal matrix|\n|Lerp(Matrix4x4 value1, Matrix4x4 value2, Float progress)|  Returns a Matrix4x4 that represents the calculated linear interpolation calculation between the two Matrix4x4 values based on the progress (Note: progress is between 0.0 and 1.0)|\n|Matrix4x4(Float M11, Float M12, Float M13, Float M14,<br/>Float M21, Float M22, Float M23, Float M24,<br/>    Float M31, Float M32, Float M33, Float M34,<br/>    Float M41, Float M42, Float M43, Float M44)| Constructs a Matrix4x4 using 16 Float parameters|\n|Matrix4x4.CreateFromScale(Vector3 scale)|  Constructs a Matrix4x4 from a Vector3 representing scale<br/>\\[scale.X, 0.0, 0.0, 0.0,<br/> 0.0, scale.Y, 0.0, 0.0,<br/> 0.0, 0.0, scale.Z, 0.0,<br/> 0.0, 0.0, 0.0, 1.0\\]|\n|Matrix4x4.CreateFromTranslation(Vector3 translation)|  Constructs a Matrix4x4 from a Vector3 representing translation<br/>\\[1.0, 0.0, 0.0, 0.0,<br/> 0.0, 1.0, 0.0, 0.0,<br/> 0.0, 0.0, 1.0, 0.0,<br/> translation.X, translation.Y, translation.Z, 1.0\\]|\n|Matrix4x4.CreateFromAxisAngle(Vector3 axis, Float angle)|  Constructs a Matrix4x4 from a Vector3 axis and a Float representing an angle|\n\n###Quaternion  \n\n|Function and Constructor Operations|   Description|\n|-----------------------------------|--------------|\n|Slerp(Quaternion value1, Quaternion value2, Float progress)|   Returns a Quaternion that represents the calculated spherical interpolation between the two Quaternion values based on the progress (Note: progress is between 0.0 and 1.0)|\n|Concatenate(Quaternion value1 Quaternion value2)|  Returns a Quaternion representing a concatenation of two Quaternions (aka a Quaternion that represents a combined two individual rotations)|\n|Length(Quaternion value)|  Returns a Float value representing the length/magnitude of the Quaternion.|\n|LengthSquared(Quaternion)| Returns a Float value representing the square of the length/magnitude of a Quaternion|\n|Normalize(Quaternion value)|   Returns a Quaternion whose components have been normalized|\n|Quaternion.CreateFromAxisAngle(Vector3 axis, Scalar angle)|    Constructs a Quaternion from a Vector3 axis and a Scalar representing an angle|\n|Quaternion(Float x, Float y, Float z, Float w)|    Constructs a Quaternion from four Float values|\n\n###Color\n\n|Function and Constructor Operations|   Description|\n|-----------------------------------|--------------|\n|ColorLerp(Color colorTo, Color colorFrom, Float progress)| Returns a Color object that represents the calculated linear interpolation value between two color objects based on a given progress. (Note: Progress is between 0.0 and 1.0)|\n|ColorLerpRGB(Color colorTo, Color colorFrom, Float progress)|  Returns a Color object that represents the calculated linear interpolation value between two objects based on a given progress in the RGB color space.|\n|ColorLerpHSL(Color colorTo, Color colorFrom, Float progress)|  Returns a Color object that represents the calculated linear interpolation value between two objects based on a given progress in the HSL color space.|\n|ColorArgb(Float a, Float r, Float g, Float b)| Constructs an object representing Color defined by ARGB components|\n|ColorHsl(Float h, Float s, Float l)|   Constructs an object representing Color defined by HSL components (Note: Hue is defined from 0 and 2pi)|\n\n\n\n\n"}