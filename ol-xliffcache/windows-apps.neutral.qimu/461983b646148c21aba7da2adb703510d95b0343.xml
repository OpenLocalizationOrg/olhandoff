{"nodes":[{"content":"Compare EGL code to DXGI and Direct3D","pos":[27,64]},{"content":"The DirectX Graphics Interface (DXGI) and several Direct3D APIs serve the same role as EGL.","pos":[78,169]},{"content":"This topic helps you understand DXGI and Direct3D 11 from the perspective of EGL.","pos":[170,251]},{"content":"Compare EGL code to DXGI and Direct3D","pos":[308,345]},{"content":"Updated for UWP apps on Windows 10.","pos":[351,386]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[387,479]},{"content":"Important APIs","pos":[487,501]},{"content":"ID3D11Device1","pos":[512,525]},{"content":"ID3D11DeviceContext1","pos":[597,617]},{"content":"CoreWindow","pos":[689,699]},{"content":"The DirectX Graphics Interface (DXGI) and several Direct3D APIs serve the same role as EGL.","pos":[762,853]},{"content":"This topic helps you understand DXGI and Direct3D 11 from the perspective of EGL.","pos":[854,935]},{"content":"DXGI and Direct3D, like EGL, provide methods to configure graphics resources, obtain a rendering context for your shaders to draw into, and to display the results in a window.","pos":[937,1112]},{"content":"However, DXGI and Direct3D have quite a few more options, and require more effort to set up correctly when porting from EGL.","pos":[1113,1237]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   This guidance is based off the Khronos Group's open specification for EGL 1.4, found here: <bpt id=\"p2\">[</bpt>Khronos Native Platform Graphics Interface (EGL Version 1.4 - April 6, 2011) <ph id=\"ph1\">\\[</ph>PDF<ph id=\"ph2\">\\]</ph><ept id=\"p2\">](http://www.khronos.org/registry/egl/specs/eglspec.1.4.20110406.pdf)</ept>.","pos":[1241,1498]},{"content":"Differences in syntax specific to other platforms and development languages are not covered in this guidance.","pos":[1499,1608]},{"content":"How does DXGI and Direct3D compare?","pos":[1616,1651]},{"content":"The big advantage of EGL over DXGI and Direct3D is that it is relatively simple to start drawing to a window surface.","pos":[1654,1771]},{"content":"This is because OpenGL ES 2.0—and therefore EGL—is a specification implemented by multiple platform providers, whereas DXGI and Direct3D are a single reference that hardware vendor drivers must conform to.","pos":[1772,1977]},{"content":"This means that Microsoft must implement a set of APIs that enable the broadest possible set of vendor features, rather than focusing on a functional subset offered by a specific vendor, or by combining vendor-specific setup commands into simpler APIs.","pos":[1978,2230]},{"content":"On the other hand, Direct3D provides a single set of APIs that cover a very broad range of graphics hardware platforms and feature levels, and offer more flexibility for developers experienced with the platform.","pos":[2231,2442]},{"content":"Like EGL, DXGI and Direct3D provide APIs for the following behaviors:","pos":[2444,2513]},{"content":"Obtaining, and reading and writing to a frame buffer (called a \"swap chain\" in DXGI).","pos":[2519,2604]},{"content":"Associating the frame buffer with a UI window.","pos":[2609,2655]},{"content":"Obtaining and configuring rendering contexts in which to draw.","pos":[2660,2722]},{"content":"Issuing commands to the graphics pipeline for a specific rendering context.","pos":[2727,2802]},{"content":"Creating and managing shader resources, and associating them with a rendering content.","pos":[2807,2893]},{"content":"Rendering to specific render targets (such as textures).","pos":[2898,2954]},{"content":"Updating the window's display surface with the results of rendering with the graphics resources.","pos":[2959,3055]},{"content":"To see the basic Direct3D process for configuring the graphics pipeline, check out the DirectX 11 App (Universal Windows) template in Microsoft Visual Studio 2015.","pos":[3057,3220]},{"content":"The base rendering class in it provides a good baseline for setting up the Direct3D 11 graphics infrastructure and configuring basic resources on it, as well as supporting Universal Windows Platform (UWP) app features such as screen rotation.","pos":[3221,3463]},{"content":"EGL has very few APIs relative to Direct3D 11, and navigating the latter can be a challenge if you aren't familiar with the naming and jargon particular to the platform.","pos":[3465,3634]},{"content":"Here's a simple overview to help you get oriented.","pos":[3635,3685]},{"content":"First, review the basic EGL object to Direct3D interface mapping:","pos":[3687,3752]},{"content":"EGL abstraction","pos":[3756,3771]},{"content":"Similar Direct3D representation","pos":[3774,3805]},{"content":"EGLDisplay","pos":[5050,5060]},{"content":"In Direct3D (for UWP apps), the display handle is obtained through the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Windows::UI::CoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> API (or the <bpt id=\"p3\">**</bpt>ICoreWindowInterop<ept id=\"p3\">**</ept> interface that exposes the HWND).","pos":[5066,5293]},{"content":"The adapter and hardware configuration are set with the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGIAdapter<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174523)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IDXGIDevice1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404543)</ept> COM interfaces, respectively.","pos":[5294,5543]},{"content":"EGLSurface","pos":[5800,5810]},{"content":"In Direct3D, the buffers and other window resources (visible or offscreen) are created and configured by specific DXGI interfaces, including <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGIFactory2<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404556)</ept> (a factory pattern implementation used to acquire DXGI resources such as the<bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IDXGISwapChain1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</ept> (display buffers).","pos":[5816,6215]},{"content":"The <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> that represents the graphics device and its resources, is acquired with <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>D3D11Device::CreateDevice<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept>.","pos":[6216,6466]},{"content":"For render targets, use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11RenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept> interface.","pos":[6467,6595]},{"content":"EGLContext","pos":[6602,6612]},{"pos":[6618,6796],"content":"In Direct3D, you configure and issue commands to the graphics pipeline with the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> interface."},{"content":"EGLConfig","pos":[7276,7285]},{"pos":[7292,7513],"content":"In Direct3D 11, you create and configure graphics resources such as a buffers, textures, stencils and shaders with methods on the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> interface."},{"content":"Now, here's the most basic process for setting up a simple graphics display, resources and context in DXGI and Direct3D for a UWP app.","pos":[7957,8091]},{"pos":[8097,8338],"content":"Obtain a handle to the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> object for the app's core UI thread by calling <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>CoreWindow::GetForCurrentThread<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701589)</ept>."},{"content":"For UWP apps, acquire a swap chain from the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGIAdapter2<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404537)</ept> with <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IDXGIFactory2::CreateSwapChainForCoreWindow<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404559)</ept>, and pass it the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>CoreWindow<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> reference you obtained in step 1.","pos":[8343,8709]},{"content":"You will get an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</ept> instance in return.","pos":[8710,8828]},{"content":"Scope it to your renderer object and its rendering thread.","pos":[8829,8887]},{"content":"Obtain <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> and <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> instances by calling the <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>D3D11Device::CreateDevice<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept> method.","pos":[8892,9197]},{"content":"Scope them to your renderer object as well.","pos":[9198,9241]},{"pos":[9246,9413],"content":"Create shaders, textures, and other resources using methods on your renderer's <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> object."},{"pos":[9418,9605],"content":"Define buffers, run shaders and manage the pipeline stages using methods on your renderer's <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> object."},{"pos":[9610,9805],"content":"When the pipeline has executed and a frame is drawn to the back buffer, present it to the screen with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::Present1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</ept>."},{"content":"To examine this process in more detail, review <bpt id=\"p1\">[</bpt>Getting started with DirectX graphics<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh309467)</ept>.","pos":[9807,9955]},{"content":"The rest of this article covers many of the common steps for basic graphics pipeline setup and management.","pos":[9956,10062]},{"pos":[10065,10367],"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   Windows Desktop apps have different APIs for obtaining a Direct3D swap chain, such as <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>D3D11Device::CreateDeviceAndSwapChain<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476083)</ept>, and do not use a <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>CoreWindow<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> object."},{"content":"Obtaining a window for display","pos":[10375,10405]},{"content":"In this example, eglGetDisplay is passed an HWND for a window resource specific to the Microsoft Windows platform.","pos":[10408,10522]},{"content":"Other platforms, such as Apple's iOS (Cocoa) and Google's Android, have different handles or references to window resources, and may have different calling syntax altogether.","pos":[10523,10697]},{"content":"After obtaining a display, you initialize it, set the preferred configuration, and create a surface with a back buffer you can draw into.","pos":[10698,10835]},{"content":"Obtaining a display and configuring it with EGL..","pos":[10837,10886]},{"content":"In Direct3D, a UWP app's main window is represented by the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> object, which can be obtained from the app object by calling <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>CoreWindow::GetForCurrentThread<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/hh701589)</ept> as part of the initialization process of the \"view provider\" you construct for Direct3D.","pos":[11539,11918]},{"content":"(If you are using Direct3D-XAML interop, you use the XAML framework's view provider.) The process for creating a Direct3D view provider is covered in <bpt id=\"p1\">[</bpt>How to set up your app to display a view<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh465077)</ept>.","pos":[11919,12170]},{"content":"Obtaining a CoreWindow for Direct3D.","pos":[12172,12208]},{"content":"Once the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> reference is obtained, the window must be activated, which executes the <bpt id=\"p3\">**</bpt>Run<ept id=\"p3\">**</ept> method of your main object and begins window event processing.","pos":[12261,12487]},{"content":"After that, create an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> and an <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept>, and use them to get the underlying <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>IDXGIDevice1<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff471331)</ept> and <bpt id=\"p7\">[</bpt><bpt id=\"p8\">**</bpt>IDXGIAdapter<ept id=\"p8\">**</ept><ept id=\"p7\">](https://msdn.microsoft.com/library/windows/desktop/bb174523)</ept> so you can obtain an <bpt id=\"p9\">[</bpt><bpt id=\"p10\">**</bpt>IDXGIFactory2<ept id=\"p10\">**</ept><ept id=\"p9\">](https://msdn.microsoft.com/library/windows/desktop/hh404556)</ept> object to create a swap chain resource based on your <bpt id=\"p11\">[</bpt><bpt id=\"p12\">**</bpt>DXGI<ph id=\"ph1\">\\_</ph>SWAP<ph id=\"ph2\">\\_</ph>CHAIN<ph id=\"ph3\">\\_</ph>DESC1<ept id=\"p12\">**</ept><ept id=\"p11\">](https://msdn.microsoft.com/library/windows/desktop/hh404528)</ept> configuration.","pos":[12488,13147]},{"content":"Configuring and setting the DXGI swap chain on the CoreWindow for Direct3D.","pos":[13149,13224]},{"pos":[14910,15068],"content":"Call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::Present1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</ept> method after you prepare a frame in order to display it."},{"content":"Note that in Direct3D 11, there isn't an abstraction identical to EGLSurface.","pos":[15070,15147]},{"content":"(There is <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISurface1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff471343)</ept>, but it is used differently.) The closest conceptual approximation is the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11RenderTargetView<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept> object that we use to assign a texture (<bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>ID3D11Texture2D<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept>) as the back buffer that our shader pipeline will draw into.","pos":[15148,15586]},{"content":"Setting up the back buffer for the swap chain in Direct3D 11","pos":[15588,15648]},{"content":"A good practice is to call this code whenever the window is created or changes size.","pos":[15973,16057]},{"content":"During rendering, set the render target view with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::OMSetRenderTargets<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept> before setting up any other subresources like vertex buffers or shaders.","pos":[16058,16288]},{"content":"Creating a rendering context","pos":[16465,16493]},{"content":"In EGL 1.4, a \"display\" represents a set of window resources.","pos":[16496,16557]},{"content":"Typically, you configure a \"surface\" for the display by supplying a set of attributes to the display object and getting a surface in return.","pos":[16558,16698]},{"content":"You create a context for displaying the contents of the surface by creating that context and binding it to the surface and the display.","pos":[16699,16834]},{"content":"The call flow usually looks similar to this:","pos":[16836,16880]},{"content":"Call eglGetDisplay with the handle to a display or window resource and obtain a display object.","pos":[16886,16981]},{"content":"Initialize the display with eglInitialize.","pos":[16986,17028]},{"content":"Obtain the available display configuration and select one with eglGetConfigs and eglChooseConfig.","pos":[17033,17130]},{"content":"Create a window surface with eglCreateWindowSurface.","pos":[17135,17187]},{"content":"Create a display context for drawing with eglCreateContext.","pos":[17192,17251]},{"content":"Bind the display context to the display and the surface with eglMakeCurrent.","pos":[17256,17332]},{"content":"n the previous section, we created the EGLDisplay and the EGLSurface, and now we use the EGLDisplay to create a context and associate that context with the display, using the configured EGLSurface to parameterize the output.","pos":[17334,17558]},{"content":"Obtaining a rendering context with EGL 1.4","pos":[17560,17602]},{"pos":[17983,18410],"content":"A rendering context in Direct3D 11 is represented by an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> object, which represents the adapter and allows you to create Direct3D resources such as buffers and shaders; and by the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> object, which allows you to manage the graphics pipeline and execute the shaders."},{"content":"Be aware of Direct3D feature levels!","pos":[18412,18448]},{"content":"These are used to support older Direct3D hardware platforms, from DirectX 9.1 to DirectX 11.","pos":[18449,18541]},{"content":"Many platforms that use low power graphics hardware, such as tablets, only have access to DirectX 9.1 features, and older supported graphics hardware could be from 9.1 through 11.","pos":[18542,18721]},{"content":"Creating a rendering context with DXGI and Direct3D","pos":[18723,18774]},{"content":"Drawing into a texture or pixmap resource","pos":[19829,19870]},{"content":"To draw into a texture with OpenGL ES 2.0, configure a pixel buffer, or PBuffer.","pos":[19873,19953]},{"content":"After you successfully a configure and create an EGLSurface for it you can supply it with a rendering context and execute the shader pipeline to draw into the texture.","pos":[19954,20121]},{"content":"Draw into a pixel buffer with OpenGL ES 2.0","pos":[20123,20166]},{"content":"In Direct3D 11, you create an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Texture2D<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept> resource and makei it a render target.","pos":[20520,20671]},{"content":"Configure the render target using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>RENDER<ph id=\"ph2\">\\_</ph>TARGET<ph id=\"ph3\">\\_</ph>VIEW<ph id=\"ph4\">\\_</ph>DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476201)</ept>.","pos":[20672,20807]},{"content":"When you call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::Draw<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476407)</ept> method(or a similar Draw<ph id=\"ph1\">\\*</ph> operation on the device context) using this render target, the results are drawn into a texture.","pos":[20808,21042]},{"content":"Draw into a texture with Direct3D 11","pos":[21044,21080]},{"pos":[21524,21683],"content":"This texture can be passed to a shader if it is associated with an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11ShaderResourceView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476628)</ept>."},{"content":"Drawing to the screen","pos":[21688,21709]},{"content":"Once you have used your EGLContext to configure your buffers and update your data, you run the shaders bound to it and draw the results to the back buffer with glDrawElements.","pos":[21712,21887]},{"content":"You display the back buffer by calling eglSwapBuffers.","pos":[21888,21942]},{"content":"Open GL ES 2.0: Drawing to the screen.","pos":[21944,21982]},{"content":"In Direct3D 11, you configure your buffers and bind shaders with your <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain::Present1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</ept>.","pos":[22139,22301]},{"content":"Then you call one of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::Draw<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476407)</ept><ph id=\"ph1\">\\*</ph> methods to run the shaders and draw the results to a render target configured as the back buffer for the swap chain.","pos":[22302,22539]},{"content":"After that, you simply present the back buffer to the display by calling <bpt id=\"p1\">**</bpt>IDXGISwapChain::Present1<ept id=\"p1\">**</ept>.","pos":[22540,22642]},{"content":"Direct3D 11: Drawing to the screen.","pos":[22644,22679]},{"content":"Releasing graphics resources","pos":[22834,22862]},{"content":"In EGL, you release the window resources by passing the EGLDisplay to eglTerminate.","pos":[22865,22948]},{"content":"Terminating a display with EGL 1.4","pos":[22950,22984]},{"content":"In a UWP app, you can close the CoreWindow with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow::Close<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208260)</ept>, although this can only be used for secondary UI windows.","pos":[23035,23222]},{"content":"The primary UI thread and its associated CoreWindow cannot be closed; rather, they are expired by the operating system.","pos":[23223,23342]},{"content":"However, when a secondary CoreWindow is closed, the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow::Closed<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208261)</ept> event is raised.","pos":[23343,23494]},{"content":"API Reference mapping for EGL to Direct3D 11","pos":[23499,23543]},{"content":"EGL API","pos":[23548,23555]},{"content":"Similar Direct3D 11 API or behavior","pos":[23583,23618]},{"content":"eglBindAPI","pos":[24586,24596]},{"content":"N/A.","pos":[24621,24625]},{"content":"eglBindTexImage","pos":[25105,25120]},{"pos":[25140,25262],"content":"Call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateTexture2D<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476521)</ept> to set a 2D texture."},{"content":"eglChooseConfig","pos":[25644,25659]},{"content":"Direct3D does not supply a set of default frame buffer configurations.","pos":[25679,25749]},{"content":"The swap chain's configuration","pos":[25750,25780]},{"content":"eglCopyBuffers","pos":[26163,26177]},{"content":"To copy a buffer data, call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::CopyStructureCount<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476393)</ept>.","pos":[26198,26333]},{"content":"To copy a resource, call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3DDeviceCOntext::CopyResource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476392)</ept>.","pos":[26334,26458]},{"content":"eglCreateContext","pos":[26708,26724]},{"content":"Create a Direct3D device context by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11CreateDevice<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept>, which returns both a handle to a Direct3D device and a default Direct3D immediate context (<bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11DeviceContext1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept> object).","pos":[26743,27060]},{"content":"You can also create a Direct3D deferred context by calling <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device2::CreateDeferredContext<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dn280495)</ept> on the returned <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> object.","pos":[27061,27328]},{"content":"eglCreatePbufferFromClientBuffer","pos":[27333,27365]},{"content":"All buffers are read and written as a Direct3D subresource, such as an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Texture2D<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept>.","pos":[27368,27522]},{"content":"Copy from one to another compatible subresource type with a methods such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1:CopyResource<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476392)</ept>.","pos":[27523,27700]},{"content":"eglCreatePbufferSurface","pos":[27901,27924]},{"content":"To create a Direct3D device with no swap chain, call the static <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11CreateDevice<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept> method.","pos":[27936,28092]},{"content":"For a Direct3D render target view, call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateRenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476517)</ept>.","pos":[28093,28237]},{"content":"eglCreatePixmapSurface","pos":[28464,28486]},{"content":"To create a Direct3D device with no swap chain, call the static <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11CreateDevice<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476082)</ept> method.","pos":[28499,28655]},{"content":"For a Direct3D render target view, call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device::CreateRenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476517)</ept>.","pos":[28656,28800]},{"content":"eglCreateWindowSurface","pos":[29027,29049]},{"content":"Ontain an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</ept> (for the display buffers) and an <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>ID3D11Device1<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> (a virtual interface for the graphics device and its resources).","pos":[29062,29333]},{"content":"Use the <bpt id=\"p1\">**</bpt>ID3D11Device1<ept id=\"p1\">**</ept> to define an <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ID3D11RenderTargetView<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept> that you can use to create the frame buffer you supply to the <bpt id=\"p4\">**</bpt>IDXGISwapChain1<ept id=\"p4\">**</ept>.","pos":[29334,29545]},{"content":"eglDestroyContext","pos":[29638,29655]},{"content":"N/A.","pos":[29673,29677]},{"content":"Use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext::DiscardView1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/jj247573)</ept> to get rid of a render target view.","pos":[29678,29818]},{"content":"To close the parent <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404598)</ept>, set the instance to null and wait for the platform to reclaim its resources.","pos":[29819,30004]},{"content":"You cannot destroy the device context directly.","pos":[30005,30052]},{"content":"eglDestroySurface","pos":[30200,30217]},{"content":"N/A.","pos":[30235,30239]},{"content":"Graphics resources are cleaned up when the UWP app's CoreWindow is closed by the platform.","pos":[30240,30330]},{"content":"eglGetCurrentDisplay","pos":[30719,30739]},{"pos":[30754,30905],"content":"Call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow::GetForCurrentThread<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701589)</ept> to get a reference to the current main app window."},{"content":"eglGetCurrentSurface","pos":[31254,31274]},{"content":"This is the current <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11RenderTargetView<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept>.","pos":[31289,31399]},{"content":"Typically, this is scoped to your renderer object.","pos":[31400,31450]},{"content":"eglGetError","pos":[31799,31810]},{"content":"Errors are obtained as HRESULTs returned by most methods on DirectX interfaces.","pos":[31834,31913]},{"content":"If the method does not return an HRESULT, call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>GetLastError<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ms679360)</ept>.","pos":[31914,32041]},{"content":"To convert a system error into an HRESULT value, use the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>HRESULT<ph id=\"ph1\">\\_</ph>FROM<ph id=\"ph2\">\\_</ph>WIN32<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ms680746)</ept> macro.","pos":[32042,32193]},{"content":"eglInitialize","pos":[32391,32404]},{"pos":[32426,32577],"content":"Call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>CoreWindow::GetForCurrentThread<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh701589)</ept> to get a reference to the current main app window."},{"content":"eglMakeCurrent","pos":[32926,32940]},{"pos":[32961,33129],"content":"Set a render target for drawing on the current context with <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11DeviceContext1::OMSetRenderTargets<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476464)</ept>."},{"content":"eglQueryContext","pos":[33455,33470]},{"content":"N/A.","pos":[33490,33494]},{"content":"However, you may acquire rendering targets from an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> instance, as well as some configuration data.","pos":[33495,33672]},{"content":"(See the link for the list of available methods.)","pos":[33673,33722]},{"content":"eglQuerySurface","pos":[34009,34024]},{"content":"N/A.","pos":[34044,34048]},{"content":"However, you may acquire data about viewports and the current graphics hardware from methods on an <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ID3D11Device1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> instance.","pos":[34049,34238]},{"content":"(See the link for the list of available methods.)","pos":[34239,34288]},{"content":"eglReleaseTexImage","pos":[34563,34581]},{"content":"N/A.","pos":[34598,34602]},{"content":"eglReleaseThread","pos":[35082,35098]},{"pos":[35117,35232],"content":"For general GPU multithreading, read <bpt id=\"p1\">[</bpt>Multithreading<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476891)</ept>."},{"content":"eglSurfaceAttrib","pos":[35602,35618]},{"pos":[35637,35785],"content":"Use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>D3D11<ph id=\"ph1\">\\_</ph>RENDER<ph id=\"ph2\">\\_</ph>TARGET<ph id=\"ph3\">\\_</ph>VIEW<ph id=\"ph4\">\\_</ph>DESC<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476201)</ept> to configure a Direct3D render target view,"},{"content":"eglSwapBuffers","pos":[36140,36154]},{"pos":[36175,36272],"content":"Use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1::Present1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh446797)</ept>."},{"content":"eglSwapInterval","pos":[36681,36696]},{"pos":[36716,36803],"content":"See <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain1<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</ept>."},{"content":"eglTerminate","pos":[37231,37243]},{"content":"The CoreWindow used to display the output of the graphics pipeline is managed by the operating system.","pos":[37266,37368]},{"content":"eglWaitClient","pos":[37750,37763]},{"content":"For shared surfaces, use IDXGIKeyedMutex.","pos":[37785,37826]},{"content":"For general GPU multithreading, read <bpt id=\"p1\">[</bpt>Multithreading<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476891)</ept>.","pos":[37827,37942]},{"content":"eglWaitGL","pos":[38270,38279]},{"content":"For shared surfaces, use IDXGIKeyedMutex.","pos":[38305,38346]},{"content":"For general GPU multithreading, read <bpt id=\"p1\">[</bpt>Multithreading<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476891)</ept>.","pos":[38347,38462]},{"content":"eglWaitNative","pos":[38790,38803]},{"content":"For shared surfaces, use IDXGIKeyedMutex.","pos":[38825,38866]},{"content":"For general GPU multithreading, read <bpt id=\"p1\">[</bpt>Multithreading<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ff476891)</ept>.","pos":[38867,38982]}],"content":"---\nauthor: mtoepke\ntitle: Compare EGL code to DXGI and Direct3D\ndescription: The DirectX Graphics Interface (DXGI) and several Direct3D APIs serve the same role as EGL. This topic helps you understand DXGI and Direct3D 11 from the perspective of EGL.\nms.assetid: 90f5ecf1-dd5d-fea3-bed8-57a228898d2a\n---\n\n# Compare EGL code to DXGI and Direct3D\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\n\n**Important APIs**\n\n-   [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575)\n-   [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598)\n-   [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225)\n\nThe DirectX Graphics Interface (DXGI) and several Direct3D APIs serve the same role as EGL. This topic helps you understand DXGI and Direct3D 11 from the perspective of EGL.\n\nDXGI and Direct3D, like EGL, provide methods to configure graphics resources, obtain a rendering context for your shaders to draw into, and to display the results in a window. However, DXGI and Direct3D have quite a few more options, and require more effort to set up correctly when porting from EGL.\n\n> **Note**   This guidance is based off the Khronos Group's open specification for EGL 1.4, found here: [Khronos Native Platform Graphics Interface (EGL Version 1.4 - April 6, 2011) \\[PDF\\]](http://www.khronos.org/registry/egl/specs/eglspec.1.4.20110406.pdf). Differences in syntax specific to other platforms and development languages are not covered in this guidance.\n\n \n\n## How does DXGI and Direct3D compare?\n\n\nThe big advantage of EGL over DXGI and Direct3D is that it is relatively simple to start drawing to a window surface. This is because OpenGL ES 2.0—and therefore EGL—is a specification implemented by multiple platform providers, whereas DXGI and Direct3D are a single reference that hardware vendor drivers must conform to. This means that Microsoft must implement a set of APIs that enable the broadest possible set of vendor features, rather than focusing on a functional subset offered by a specific vendor, or by combining vendor-specific setup commands into simpler APIs. On the other hand, Direct3D provides a single set of APIs that cover a very broad range of graphics hardware platforms and feature levels, and offer more flexibility for developers experienced with the platform.\n\nLike EGL, DXGI and Direct3D provide APIs for the following behaviors:\n\n-   Obtaining, and reading and writing to a frame buffer (called a \"swap chain\" in DXGI).\n-   Associating the frame buffer with a UI window.\n-   Obtaining and configuring rendering contexts in which to draw.\n-   Issuing commands to the graphics pipeline for a specific rendering context.\n-   Creating and managing shader resources, and associating them with a rendering content.\n-   Rendering to specific render targets (such as textures).\n-   Updating the window's display surface with the results of rendering with the graphics resources.\n\nTo see the basic Direct3D process for configuring the graphics pipeline, check out the DirectX 11 App (Universal Windows) template in Microsoft Visual Studio 2015. The base rendering class in it provides a good baseline for setting up the Direct3D 11 graphics infrastructure and configuring basic resources on it, as well as supporting Universal Windows Platform (UWP) app features such as screen rotation.\n\nEGL has very few APIs relative to Direct3D 11, and navigating the latter can be a challenge if you aren't familiar with the naming and jargon particular to the platform. Here's a simple overview to help you get oriented.\n\nFirst, review the basic EGL object to Direct3D interface mapping:\n\n| EGL abstraction | Similar Direct3D representation                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n|-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| **EGLDisplay**  | In Direct3D (for UWP apps), the display handle is obtained through the [**Windows::UI::CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) API (or the **ICoreWindowInterop** interface that exposes the HWND). The adapter and hardware configuration are set with the [**IDXGIAdapter**](https://msdn.microsoft.com/library/windows/desktop/bb174523) and [**IDXGIDevice1**](https://msdn.microsoft.com/library/windows/desktop/hh404543) COM interfaces, respectively.                                                                                                                                                                                                                                                           |\n| **EGLSurface**  | In Direct3D, the buffers and other window resources (visible or offscreen) are created and configured by specific DXGI interfaces, including [**IDXGIFactory2**](https://msdn.microsoft.com/library/windows/desktop/hh404556) (a factory pattern implementation used to acquire DXGI resources such as the[**IDXGISwapChain1**](https://msdn.microsoft.com/library/windows/desktop/hh404631) (display buffers). The [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) that represents the graphics device and its resources, is acquired with [**D3D11Device::CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082). For render targets, use the [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582) interface. |\n| **EGLContext**  | In Direct3D, you configure and issue commands to the graphics pipeline with the [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) interface.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\n| **EGLConfig**   | In Direct3D 11, you create and configure graphics resources such as a buffers, textures, stencils and shaders with methods on the [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) interface.                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n\n \n\nNow, here's the most basic process for setting up a simple graphics display, resources and context in DXGI and Direct3D for a UWP app.\n\n1.  Obtain a handle to the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) object for the app's core UI thread by calling [**CoreWindow::GetForCurrentThread**](https://msdn.microsoft.com/library/windows/apps/hh701589).\n2.  For UWP apps, acquire a swap chain from the [**IDXGIAdapter2**](https://msdn.microsoft.com/library/windows/desktop/hh404537) with [**IDXGIFactory2::CreateSwapChainForCoreWindow**](https://msdn.microsoft.com/library/windows/desktop/hh404559), and pass it the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) reference you obtained in step 1. You will get an [**IDXGISwapChain1**](https://msdn.microsoft.com/library/windows/desktop/hh404631) instance in return. Scope it to your renderer object and its rendering thread.\n3.  Obtain [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) and [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) instances by calling the [**D3D11Device::CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) method. Scope them to your renderer object as well.\n4.  Create shaders, textures, and other resources using methods on your renderer's [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) object.\n5.  Define buffers, run shaders and manage the pipeline stages using methods on your renderer's [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) object.\n6.  When the pipeline has executed and a frame is drawn to the back buffer, present it to the screen with [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797).\n\nTo examine this process in more detail, review [Getting started with DirectX graphics](https://msdn.microsoft.com/library/windows/desktop/hh309467). The rest of this article covers many of the common steps for basic graphics pipeline setup and management.\n> **Note**   Windows Desktop apps have different APIs for obtaining a Direct3D swap chain, such as [**D3D11Device::CreateDeviceAndSwapChain**](https://msdn.microsoft.com/library/windows/desktop/ff476083), and do not use a [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) object.\n\n \n\n## Obtaining a window for display\n\n\nIn this example, eglGetDisplay is passed an HWND for a window resource specific to the Microsoft Windows platform. Other platforms, such as Apple's iOS (Cocoa) and Google's Android, have different handles or references to window resources, and may have different calling syntax altogether. After obtaining a display, you initialize it, set the preferred configuration, and create a surface with a back buffer you can draw into.\n\nObtaining a display and configuring it with EGL..\n\n``` syntax\n// Obtain an EGL display object.\nEGLDisplay display = eglGetDisplay(GetDC(hWnd));\nif (display == EGL_NO_DISPLAY)\n{\n  return EGL_FALSE;\n}\n\n// Initialize the display\nif (!eglInitialize(display, &majorVersion, &minorVersion))\n{\n  return EGL_FALSE;\n}\n\n// Obtain the display configs\nif (!eglGetConfigs(display, NULL, 0, &numConfigs))\n{\n  return EGL_FALSE;\n}\n\n// Choose the display config\nif (!eglChooseConfig(display, attribList, &config, 1, &numConfigs))\n{\n  return EGL_FALSE;\n}\n\n// Create a surface\nsurface = eglCreateWindowSurface(display, config, (EGLNativeWindowType)hWnd, NULL);\nif (surface == EGL_NO_SURFACE)\n{\n  return EGL_FALSE;\n}\n```\n\nIn Direct3D, a UWP app's main window is represented by the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) object, which can be obtained from the app object by calling [**CoreWindow::GetForCurrentThread**](https://msdn.microsoft.com/library/windows/apps/hh701589) as part of the initialization process of the \"view provider\" you construct for Direct3D. (If you are using Direct3D-XAML interop, you use the XAML framework's view provider.) The process for creating a Direct3D view provider is covered in [How to set up your app to display a view](https://msdn.microsoft.com/library/windows/apps/hh465077).\n\nObtaining a CoreWindow for Direct3D.\n\n``` syntax\nCoreWindow::GetForCurrentThread();\n```\n\nOnce the [**CoreWindow**](https://msdn.microsoft.com/library/windows/apps/br208225) reference is obtained, the window must be activated, which executes the **Run** method of your main object and begins window event processing. After that, create an [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) and an [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598), and use them to get the underlying [**IDXGIDevice1**](https://msdn.microsoft.com/library/windows/desktop/ff471331) and [**IDXGIAdapter**](https://msdn.microsoft.com/library/windows/desktop/bb174523) so you can obtain an [**IDXGIFactory2**](https://msdn.microsoft.com/library/windows/desktop/hh404556) object to create a swap chain resource based on your [**DXGI\\_SWAP\\_CHAIN\\_DESC1**](https://msdn.microsoft.com/library/windows/desktop/hh404528) configuration.\n\nConfiguring and setting the DXGI swap chain on the CoreWindow for Direct3D.\n\n``` syntax\n// Called when the CoreWindow object is created (or re-created).\nvoid SimpleDirect3DApp::SetWindow(CoreWindow^ window)\n{\n  // Register event handlers with the CoreWindow object.\n  // ...\n\n  // Obtain your ID3D11Device1 and ID3D11DeviceContext1 objects\n  // In this example, m_d3dDevice contains the scoped ID3D11Device1 object\n  // ...\n\n  ComPtr<IDXGIDevice1>  dxgiDevice;\n  // Get the underlying DXGI device of the Direct3D device.\n  m_d3dDevice.As(&dxgiDevice);\n\n  ComPtr<IDXGIAdapter> dxgiAdapter;\n  dxgiDevice->GetAdapter(&dxgiAdapter);\n\n  ComPtr<IDXGIFactory2> dxgiFactory;\n  dxgiAdapter->GetParent(\n    __uuidof(IDXGIFactory2), \n    &dxgiFactory);\n\n  DXGI_SWAP_CHAIN_DESC1 swapChainDesc = {0};\n  swapChainDesc.Width = static_cast<UINT>(m_d3dRenderTargetSize.Width); // Match the size of the window.\n  swapChainDesc.Height = static_cast<UINT>(m_d3dRenderTargetSize.Height);\n  swapChainDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM; // This is the most common swap chain format.\n  swapChainDesc.Stereo = false;\n  swapChainDesc.SampleDesc.Count = 1; // Don't use multi-sampling.\n  swapChainDesc.SampleDesc.Quality = 0;\n  swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\n  swapChainDesc.BufferCount = 2; // Use double-buffering to minimize latency.\n  swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL; // All Windows Store apps must use this SwapEffect.\n  swapChainDesc.Flags = 0;\n\n  // ...\n\n  Windows::UI::Core::CoreWindow^ window = m_window.Get();\n  dxgiFactory->CreateSwapChainForCoreWindow(\n    m_d3dDevice.Get(),\n    reinterpret_cast<IUnknown*>(window),\n    &swapChainDesc,\n    nullptr, // Allow on all displays.\n    &m_swapChainCoreWindow);\n}\n```\n\nCall the [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797) method after you prepare a frame in order to display it.\n\nNote that in Direct3D 11, there isn't an abstraction identical to EGLSurface. (There is [**IDXGISurface1**](https://msdn.microsoft.com/library/windows/desktop/ff471343), but it is used differently.) The closest conceptual approximation is the [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582) object that we use to assign a texture ([**ID3D11Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476635)) as the back buffer that our shader pipeline will draw into.\n\nSetting up the back buffer for the swap chain in Direct3D 11\n\n``` syntax\nComPtr<ID3D11RenderTargetView>    m_d3dRenderTargetViewWin; // scoped to renderer object\n\n// ...\n\nComPtr<ID3D11Texture2D> backBuffer2;\n    \nm_swapChainCoreWindow->GetBuffer(0, IID_PPV_ARGS(&backBuffer2));\n\nm_d3dDevice->CreateRenderTargetView(\n  backBuffer2.Get(),\n  nullptr,\n    &m_d3dRenderTargetViewWin);\n```\n\nA good practice is to call this code whenever the window is created or changes size. During rendering, set the render target view with [**ID3D11DeviceContext1::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464) before setting up any other subresources like vertex buffers or shaders.\n\n``` syntax\n// Set the render target for the draw operation.\nm_d3dContext->OMSetRenderTargets(\n        1,\n        d3dRenderTargetView.GetAddressOf(),\n        nullptr);\n```\n\n## Creating a rendering context\n\n\nIn EGL 1.4, a \"display\" represents a set of window resources. Typically, you configure a \"surface\" for the display by supplying a set of attributes to the display object and getting a surface in return. You create a context for displaying the contents of the surface by creating that context and binding it to the surface and the display.\n\nThe call flow usually looks similar to this:\n\n-   Call eglGetDisplay with the handle to a display or window resource and obtain a display object.\n-   Initialize the display with eglInitialize.\n-   Obtain the available display configuration and select one with eglGetConfigs and eglChooseConfig.\n-   Create a window surface with eglCreateWindowSurface.\n-   Create a display context for drawing with eglCreateContext.\n-   Bind the display context to the display and the surface with eglMakeCurrent.\n\nn the previous section, we created the EGLDisplay and the EGLSurface, and now we use the EGLDisplay to create a context and associate that context with the display, using the configured EGLSurface to parameterize the output.\n\nObtaining a rendering context with EGL 1.4\n\n```cpp\n// Configure your EGLDisplay and obtain an EGLSurface here ...\n// ...\n\n// Create a drawing context from the EGLDisplay\ncontext = eglCreateContext(display, config, EGL_NO_CONTEXT, contextAttribs);\nif (context == EGL_NO_CONTEXT)\n{\n  return EGL_FALSE;\n}   \n   \n// Make the context current\nif (!eglMakeCurrent(display, surface, surface, context))\n{\n  return EGL_FALSE;\n}\n```\n\nA rendering context in Direct3D 11 is represented by an [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) object, which represents the adapter and allows you to create Direct3D resources such as buffers and shaders; and by the [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) object, which allows you to manage the graphics pipeline and execute the shaders.\n\nBe aware of Direct3D feature levels! These are used to support older Direct3D hardware platforms, from DirectX 9.1 to DirectX 11. Many platforms that use low power graphics hardware, such as tablets, only have access to DirectX 9.1 features, and older supported graphics hardware could be from 9.1 through 11.\n\nCreating a rendering context with DXGI and Direct3D\n\n```cpp\n\n// ... \n\nUINT creationFlags = D3D11_CREATE_DEVICE_BGRA_SUPPORT;\nComPtr<IDXGIDevice> dxgiDevice;\n\nD3D_FEATURE_LEVEL featureLevels[] = \n{\n        D3D_FEATURE_LEVEL_11_1,\n        D3D_FEATURE_LEVEL_11_0,\n        D3D_FEATURE_LEVEL_10_1,\n        D3D_FEATURE_LEVEL_10_0,\n        D3D_FEATURE_LEVEL_9_3,\n        D3D_FEATURE_LEVEL_9_2,\n        D3D_FEATURE_LEVEL_9_1\n};\n\n// Create the Direct3D 11 API device object and a corresponding context.\nComPtr<ID3D11Device> device;\nComPtr<ID3D11DeviceContext> d3dContext;\n\nD3D11CreateDevice(\n  nullptr, // Specify nullptr to use the default adapter.\n  D3D_DRIVER_TYPE_HARDWARE,\n  nullptr,\n  creationFlags, // Set set debug and Direct2D compatibility flags.\n  featureLevels, // List of feature levels this app can support.\n  ARRAYSIZE(featureLevels),\n  D3D11_SDK_VERSION, // Always set this to D3D11_SDK_VERSION for Windows Store apps.\n  &device, // Returns the Direct3D device created.\n  &m_featureLevel, // Returns feature level of device created.\n  &d3dContext // Returns the device immediate context.\n);\n```\n\n## Drawing into a texture or pixmap resource\n\n\nTo draw into a texture with OpenGL ES 2.0, configure a pixel buffer, or PBuffer. After you successfully a configure and create an EGLSurface for it you can supply it with a rendering context and execute the shader pipeline to draw into the texture.\n\nDraw into a pixel buffer with OpenGL ES 2.0\n\n``` syntax\n// Create a pixel buffer surface to draw into\nEGLConfig pBufConfig;\nEGLint totalpBufAttrs;\n\nconst EGLint pBufConfigAttrs[] =\n{\n    // Configure the pBuffer here...\n};\n \neglChooseConfig(eglDsplay, pBufConfigAttrs, &pBufConfig, 1, &totalpBufAttrs);\nEGLSurface pBuffer = eglCreatePbufferSurface(eglDisplay, pBufConfig, EGL_TEXTURE_RGBA); \n```\n\nIn Direct3D 11, you create an [**ID3D11Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476635) resource and makei it a render target. Configure the render target using [**D3D11\\_RENDER\\_TARGET\\_VIEW\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476201). When you call the [**ID3D11DeviceContext::Draw**](https://msdn.microsoft.com/library/windows/desktop/ff476407) method(or a similar Draw\\* operation on the device context) using this render target, the results are drawn into a texture.\n\nDraw into a texture with Direct3D 11\n\n``` syntax\nComPtr<ID3D11Texture2D> renderTarget1;\n\nD3D11_RENDER_TARGET_VIEW_DESC renderTargetDesc = {0};\n// Configure renderTargetDesc here ...\n\nm_d3dDevice->CreateRenderTargetView(\n  renderTarget1.Get(),\n  nullptr,\n  &m_d3dRenderTargetViewWin);\n\n// Later, in your render loop...\n\n// Set the render target for the draw operation.\nm_d3dContext->OMSetRenderTargets(\n        1,\n        d3dRenderTargetView.GetAddressOf(),\n        nullptr);\n```\n\nThis texture can be passed to a shader if it is associated with an [**ID3D11ShaderResourceView**](https://msdn.microsoft.com/library/windows/desktop/ff476628).\n\n## Drawing to the screen\n\n\nOnce you have used your EGLContext to configure your buffers and update your data, you run the shaders bound to it and draw the results to the back buffer with glDrawElements. You display the back buffer by calling eglSwapBuffers.\n\nOpen GL ES 2.0: Drawing to the screen.\n\n``` syntax\nglDrawElements(GL_TRIANGLES, renderer->numIndices, GL_UNSIGNED_INT, 0);\n\neglSwapBuffers(drawContext->eglDisplay, drawContext->eglSurface);\n```\n\nIn Direct3D 11, you configure your buffers and bind shaders with your [**IDXGISwapChain::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797). Then you call one of the [**ID3D11DeviceContext1::Draw**](https://msdn.microsoft.com/library/windows/desktop/ff476407)\\* methods to run the shaders and draw the results to a render target configured as the back buffer for the swap chain. After that, you simply present the back buffer to the display by calling **IDXGISwapChain::Present1**.\n\nDirect3D 11: Drawing to the screen.\n\n``` syntax\n\nm_d3dContext->DrawIndexed(\n        m_indexCount,\n        0,\n        0);\n\n// ...\n\nm_swapChainCoreWindow->Present1(1, 0, &parameters);\n```\n\n## Releasing graphics resources\n\n\nIn EGL, you release the window resources by passing the EGLDisplay to eglTerminate.\n\nTerminating a display with EGL 1.4\n\n```cpp\nEGLBoolean eglTerminate(eglDisplay);\n```\n\nIn a UWP app, you can close the CoreWindow with [**CoreWindow::Close**](https://msdn.microsoft.com/library/windows/apps/br208260), although this can only be used for secondary UI windows. The primary UI thread and its associated CoreWindow cannot be closed; rather, they are expired by the operating system. However, when a secondary CoreWindow is closed, the [**CoreWindow::Closed**](https://msdn.microsoft.com/library/windows/apps/br208261) event is raised.\n\n## API Reference mapping for EGL to Direct3D 11\n\n\n| EGL API                          | Similar Direct3D 11 API or behavior                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n|----------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| eglBindAPI                       | N/A.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| eglBindTexImage                  | Call [**ID3D11Device::CreateTexture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476521) to set a 2D texture.                                                                                                                                                                                                                                                                                                                                                                                          |\n| eglChooseConfig                  | Direct3D does not supply a set of default frame buffer configurations. The swap chain's configuration                                                                                                                                                                                                                                                                                                                                                                                           |\n| eglCopyBuffers                   | To copy a buffer data, call [**ID3D11DeviceContext::CopyStructureCount**](https://msdn.microsoft.com/library/windows/desktop/ff476393). To copy a resource, call [**ID3DDeviceCOntext::CopyResource**](https://msdn.microsoft.com/library/windows/desktop/ff476392).                                                                                                                                                                                                                                                      |\n| eglCreateContext                 | Create a Direct3D device context by calling [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082), which returns both a handle to a Direct3D device and a default Direct3D immediate context ([**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598) object). You can also create a Direct3D deferred context by calling [**ID3D11Device2::CreateDeferredContext**](https://msdn.microsoft.com/library/windows/desktop/dn280495) on the returned [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) object. |\n| eglCreatePbufferFromClientBuffer | All buffers are read and written as a Direct3D subresource, such as an [**ID3D11Texture2D**](https://msdn.microsoft.com/library/windows/desktop/ff476635). Copy from one to another compatible subresource type with a methods such as [**ID3D11DeviceContext1:CopyResource**](https://msdn.microsoft.com/library/windows/desktop/ff476392).                                                                                                                                                                                                     |\n| eglCreatePbufferSurface          | To create a Direct3D device with no swap chain, call the static [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) method. For a Direct3D render target view, call [**ID3D11Device::CreateRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476517).                                                                                                                                                                                                                               |\n| eglCreatePixmapSurface           | To create a Direct3D device with no swap chain, call the static [**D3D11CreateDevice**](https://msdn.microsoft.com/library/windows/desktop/ff476082) method. For a Direct3D render target view, call [**ID3D11Device::CreateRenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476517).                                                                                                                                                                                                                               |\n| eglCreateWindowSurface           | Ontain an [**IDXGISwapChain1**](https://msdn.microsoft.com/library/windows/desktop/hh404631) (for the display buffers) and an [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) (a virtual interface for the graphics device and its resources). Use the **ID3D11Device1** to define an [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582) that you can use to create the frame buffer you supply to the **IDXGISwapChain1**.                                                                                         |\n| eglDestroyContext                | N/A. Use [**ID3D11DeviceContext::DiscardView1**](https://msdn.microsoft.com/library/windows/desktop/jj247573) to get rid of a render target view. To close the parent [**ID3D11DeviceContext1**](https://msdn.microsoft.com/library/windows/desktop/hh404598), set the instance to null and wait for the platform to reclaim its resources. You cannot destroy the device context directly.                                                                                                                                                |\n| eglDestroySurface                | N/A. Graphics resources are cleaned up when the UWP app's CoreWindow is closed by the platform.                                                                                                                                                                                                                                                                                                                                                                                                 |\n| eglGetCurrentDisplay             | Call [**CoreWindow::GetForCurrentThread**](https://msdn.microsoft.com/library/windows/apps/hh701589) to get a reference to the current main app window.                                                                                                                                                                                                                                                                                                                                                         |\n| eglGetCurrentSurface             | This is the current [**ID3D11RenderTargetView**](https://msdn.microsoft.com/library/windows/desktop/ff476582). Typically, this is scoped to your renderer object.                                                                                                                                                                                                                                                                                                                                                         |\n| eglGetError                      | Errors are obtained as HRESULTs returned by most methods on DirectX interfaces. If the method does not return an HRESULT, call [**GetLastError**](https://msdn.microsoft.com/library/windows/desktop/ms679360). To convert a system error into an HRESULT value, use the [**HRESULT\\_FROM\\_WIN32**](https://msdn.microsoft.com/library/windows/desktop/ms680746) macro.                                                                                                                                                                                                  |\n| eglInitialize                    | Call [**CoreWindow::GetForCurrentThread**](https://msdn.microsoft.com/library/windows/apps/hh701589) to get a reference to the current main app window.                                                                                                                                                                                                                                                                                                                                                         |\n| eglMakeCurrent                   | Set a render target for drawing on the current context with [**ID3D11DeviceContext1::OMSetRenderTargets**](https://msdn.microsoft.com/library/windows/desktop/ff476464).                                                                                                                                                                                                                                                                                                                                  |\n| eglQueryContext                  | N/A. However, you may acquire rendering targets from an [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) instance, as well as some configuration data. (See the link for the list of available methods.)                                                                                                                                                                                                                                                                                           |\n| eglQuerySurface                  | N/A. However, you may acquire data about viewports and the current graphics hardware from methods on an [**ID3D11Device1**](https://msdn.microsoft.com/library/windows/desktop/hh404575) instance. (See the link for the list of available methods.)                                                                                                                                                                                                                                                                               |\n| eglReleaseTexImage               | N/A.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| eglReleaseThread                 | For general GPU multithreading, read [Multithreading](https://msdn.microsoft.com/library/windows/desktop/ff476891).                                                                                                                                                                                                                                                                                                                                                                              |\n| eglSurfaceAttrib                 | Use [**D3D11\\_RENDER\\_TARGET\\_VIEW\\_DESC**](https://msdn.microsoft.com/library/windows/desktop/ff476201) to configure a Direct3D render target view,                                                                                                                                                                                                                                                                                                                                                               |\n| eglSwapBuffers                   | Use [**IDXGISwapChain1::Present1**](https://msdn.microsoft.com/library/windows/desktop/hh446797).                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| eglSwapInterval                  | See [**IDXGISwapChain1**](https://msdn.microsoft.com/library/windows/desktop/hh404631).                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| eglTerminate                     | The CoreWindow used to display the output of the graphics pipeline is managed by the operating system.                                                                                                                                                                                                                                                                                                                                                                                          |\n| eglWaitClient                    | For shared surfaces, use IDXGIKeyedMutex. For general GPU multithreading, read [Multithreading](https://msdn.microsoft.com/library/windows/desktop/ff476891).                                                                                                                                                                                                                                                                                                                                    |\n| eglWaitGL                        | For shared surfaces, use IDXGIKeyedMutex. For general GPU multithreading, read [Multithreading](https://msdn.microsoft.com/library/windows/desktop/ff476891).                                                                                                                                                                                                                                                                                                                                    |\n| eglWaitNative                    | For shared surfaces, use IDXGIKeyedMutex. For general GPU multithreading, read [Multithreading](https://msdn.microsoft.com/library/windows/desktop/ff476891).                                                                                                                                                                                                                                                                                                                                    |\n\n \n\n \n\n \n\n\n\n\n"}