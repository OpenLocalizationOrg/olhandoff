{"nodes":[{"content":"Reduce latency with DXGI 1.3 swap chains","pos":[27,67]},{"content":"Use DXGI 1.3 to reduce the effective frame latency by waiting for the swap chain to signal the appropriate time to begin rendering a new frame.","pos":[81,224]},{"content":"Reduce latency with DXGI 1.3 swap chains","pos":[281,321]},{"content":"Updated for UWP apps on Windows 10.","pos":[327,362]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[363,455]},{"content":"Use DXGI 1.3 to reduce the effective frame latency by waiting for the swap chain to signal the appropriate time to begin rendering a new frame.","pos":[460,603]},{"content":"Games typically need to provide the lowest amount of latency possible from the time the player input is received, to when the game responds to that input by updating the display.","pos":[604,782]},{"content":"This topic explains a technique available starting in Direct3D 11.2 that you can use to minimize the effective frame latency in your game.","pos":[783,921]},{"content":"How does waiting on the back buffer reduce latency?","pos":[926,977]},{"content":"With the flip model swap chain, back buffer \"flips\" are queued whenever your game calls <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain::Present<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb174576)</ept>.","pos":[980,1159]},{"content":"When the rendering loop calls Present(), the system blocks the thread until it is done presenting a prior frame, making room to queue up the new frame, before it actually presents.","pos":[1160,1340]},{"content":"This causes extra latency between the time the game draws a frame and the time the system allows it to display that frame.","pos":[1341,1463]},{"content":"In many cases, the system will reach a stable equilibrium where the game is always waiting almost a full extra frame between the time it renders and the time it presents each frame.","pos":[1464,1645]},{"content":"It's better to wait until the system is ready to accept a new frame, then render the frame based on current data and queue the frame immediately.","pos":[1646,1791]},{"content":"Create a waitable swap chain with the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DXGI<ph id=\"ph1\">\\_</ph>SWAP<ph id=\"ph2\">\\_</ph>CHAIN<ph id=\"ph3\">\\_</ph>FLAG<ph id=\"ph4\">\\_</ph>FRAME<ph id=\"ph5\">\\_</ph>LATENCY<ph id=\"ph6\">\\_</ph>WAITABLE<ph id=\"ph7\">\\_</ph>OBJECT<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb173076)</ept> flag.","pos":[1793,1961]},{"content":"Swap chains created this way can notify your rendering loop when the system is actually ready to accept a new frame.","pos":[1962,2078]},{"content":"This allows your game to render based on current data and then put the result in the present queue right away.","pos":[2079,2189]},{"content":"Step 1: Create a waitable swap chain","pos":[2194,2230]},{"pos":[2233,2485],"content":"Specify the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DXGI<ph id=\"ph1\">\\_</ph>SWAP<ph id=\"ph2\">\\_</ph>CHAIN<ph id=\"ph3\">\\_</ph>FLAG<ph id=\"ph4\">\\_</ph>FRAME<ph id=\"ph5\">\\_</ph>LATENCY<ph id=\"ph6\">\\_</ph>WAITABLE<ph id=\"ph7\">\\_</ph>OBJECT<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/bb173076)</ept> flag when you call <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>CreateSwapChainForCoreWindow<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/hh404559)</ept>."},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>   In contrast to some flags, this flag can't be added or removed using <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ResizeBuffers<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/desktop/bb174577)</ept>.","pos":[2618,2779]},{"content":"DXGI returns an error code if this flag is set differently from when the swap chain was created.","pos":[2780,2876]},{"content":"Step 2: Set the frame latency","pos":[3265,3294]},{"pos":[3297,3563],"content":"Set the frame latency with the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain2::SetMaximumFrameLatency<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dn268313)</ept> API, instead of calling <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>IDXGIDevice1::SetMaximumFrameLatency<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/desktop/ff471334)</ept>."},{"content":"By default, the frame latency for waitable swap chains is set to 1, which results in the least possible latency but also reduces CPU-GPU parallelism.","pos":[3565,3714]},{"content":"If you need increased CPU-GPU parallelism to achieve 60 FPS - that is, if the CPU and GPU each spend less than 16.7 ms a frame processing rendering work, but their combined sum is greater than 16.7 ms — set the frame latency to 2.","pos":[3715,3945]},{"content":"This allows the GPU to process work queued up by the CPU during the previous frame, while at the same time allowing the CPU to submit rendering commands for the current frame independently.","pos":[3946,4135]},{"content":"Step 3: Get the waitable object from the swap chain","pos":[4655,4706]},{"content":"Call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>IDXGISwapChain2::GetFrameLatencyWaitableObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/dn268309)</ept> to retrieve the wait handle.","pos":[4709,4856]},{"content":"The wait handle is a pointer to the waitable object.","pos":[4857,4909]},{"content":"Store this handle for use by your rendering loop.","pos":[4910,4959]},{"content":"Step 4: Wait before rendering each frame","pos":[5252,5292]},{"content":"Your rendering loop should wait for the swap chain to signal via the waitable object before it begins rendering every frame.","pos":[5295,5419]},{"content":"This includes the first frame rendered with the swap chain.","pos":[5420,5479]},{"content":"Use <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>WaitForSingleObjectEx<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/desktop/ms687036)</ept>, providing the wait handle retrieved in Step 2, to signal the start of each frame.","pos":[5480,5655]},{"content":"The following example shows the render loop from the DirectXLatency sample:","pos":[5657,5732]},{"content":"The following example shows the WaitForSingleObjectEx call from the DirectXLatency sample:","pos":[6662,6752]},{"content":"What should my game do while it waits for the swap chain to present?","pos":[7052,7120]},{"content":"If your game doesn’t have any tasks that block on the render loop, letting it wait for the swap chain to present can be advantageous because it saves power, which is especially important on mobile devices.","pos":[7123,7328]},{"content":"Otherwise, you can use multithreading to accomplish work while your game is waiting for the swap chain to present.","pos":[7329,7443]},{"content":"Here are just a few tasks that your game can complete:","pos":[7444,7498]},{"content":"Process network events","pos":[7504,7526]},{"content":"Update the AI","pos":[7531,7544]},{"content":"CPU-based physics","pos":[7549,7566]},{"content":"Deferred-context rendering (on supported devices)","pos":[7571,7620]},{"content":"Asset loading","pos":[7625,7638]},{"content":"For more information about multithreaded programming in Windows, see the following related topics.","pos":[7640,7738]},{"content":"Related topics","pos":[7743,7757]},{"content":"DirectXLatency sample","pos":[7763,7784]},{"content":"IDXGISwapChain2::GetFrameLatencyWaitableObject","pos":[7840,7886]},{"content":"WaitForSingleObjectEx","pos":[7956,7977]},{"content":"Windows.System.Threading","pos":[8047,8071]},{"content":"Asynchronous programming in C++","pos":[8136,8167]},{"content":"Processes and Threads","pos":[8230,8251]},{"content":"Synchronization","pos":[8317,8332]},{"content":"Using Event Objects (Windows)","pos":[8398,8427]}],"content":"---\nauthor: mtoepke\ntitle: Reduce latency with DXGI 1.3 swap chains\ndescription: Use DXGI 1.3 to reduce the effective frame latency by waiting for the swap chain to signal the appropriate time to begin rendering a new frame.\nms.assetid: c99b97ed-a757-879f-3d55-7ed77133f6ce\n---\n\n# Reduce latency with DXGI 1.3 swap chains\n\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nUse DXGI 1.3 to reduce the effective frame latency by waiting for the swap chain to signal the appropriate time to begin rendering a new frame. Games typically need to provide the lowest amount of latency possible from the time the player input is received, to when the game responds to that input by updating the display. This topic explains a technique available starting in Direct3D 11.2 that you can use to minimize the effective frame latency in your game.\n\n## How does waiting on the back buffer reduce latency?\n\n\nWith the flip model swap chain, back buffer \"flips\" are queued whenever your game calls [**IDXGISwapChain::Present**](https://msdn.microsoft.com/library/windows/desktop/bb174576). When the rendering loop calls Present(), the system blocks the thread until it is done presenting a prior frame, making room to queue up the new frame, before it actually presents. This causes extra latency between the time the game draws a frame and the time the system allows it to display that frame. In many cases, the system will reach a stable equilibrium where the game is always waiting almost a full extra frame between the time it renders and the time it presents each frame. It's better to wait until the system is ready to accept a new frame, then render the frame based on current data and queue the frame immediately.\n\nCreate a waitable swap chain with the [**DXGI\\_SWAP\\_CHAIN\\_FLAG\\_FRAME\\_LATENCY\\_WAITABLE\\_OBJECT**](https://msdn.microsoft.com/library/windows/desktop/bb173076) flag. Swap chains created this way can notify your rendering loop when the system is actually ready to accept a new frame. This allows your game to render based on current data and then put the result in the present queue right away.\n\n## Step 1: Create a waitable swap chain\n\n\nSpecify the [**DXGI\\_SWAP\\_CHAIN\\_FLAG\\_FRAME\\_LATENCY\\_WAITABLE\\_OBJECT**](https://msdn.microsoft.com/library/windows/desktop/bb173076) flag when you call [**CreateSwapChainForCoreWindow**](https://msdn.microsoft.com/library/windows/desktop/hh404559).\n\n```cpp\nswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT; // Enable GetFrameLatencyWaitableObject().\n```\n\n> **Note**   In contrast to some flags, this flag can't be added or removed using [**ResizeBuffers**](https://msdn.microsoft.com/library/windows/desktop/bb174577). DXGI returns an error code if this flag is set differently from when the swap chain was created.\n\n \n\n```cpp\n// If the swap chain already exists, resize it.\nHRESULT hr = m_swapChain->ResizeBuffers(\n    2, // Double-buffered swap chain.\n    static_cast<UINT>(m_d3dRenderTargetSize.Width),\n    static_cast<UINT>(m_d3dRenderTargetSize.Height),\n    DXGI_FORMAT_B8G8R8A8_UNORM,\n    DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT // Enable GetFrameLatencyWaitableObject().\n    );\n```\n\n## Step 2: Set the frame latency\n\n\nSet the frame latency with the [**IDXGISwapChain2::SetMaximumFrameLatency**](https://msdn.microsoft.com/library/windows/desktop/dn268313) API, instead of calling [**IDXGIDevice1::SetMaximumFrameLatency**](https://msdn.microsoft.com/library/windows/desktop/ff471334).\n\nBy default, the frame latency for waitable swap chains is set to 1, which results in the least possible latency but also reduces CPU-GPU parallelism. If you need increased CPU-GPU parallelism to achieve 60 FPS - that is, if the CPU and GPU each spend less than 16.7 ms a frame processing rendering work, but their combined sum is greater than 16.7 ms — set the frame latency to 2. This allows the GPU to process work queued up by the CPU during the previous frame, while at the same time allowing the CPU to submit rendering commands for the current frame independently.\n\n```cpp\n// Swapchains created with the DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT flag use their\n// own per-swapchain latency setting instead of the one associated with the DXGI device. The\n// default per-swapchain latency is 1, which ensures that DXGI does not queue more than one frame\n// at a time. This both reduces latency and ensures that the application will only render after\n// each VSync, minimizing power consumption.\n//DX::ThrowIfFailed(\n//    swapChain2->SetMaximumFrameLatency(1)\n//    );\n```\n\n## Step 3: Get the waitable object from the swap chain\n\n\nCall [**IDXGISwapChain2::GetFrameLatencyWaitableObject**](https://msdn.microsoft.com/library/windows/desktop/dn268309) to retrieve the wait handle. The wait handle is a pointer to the waitable object. Store this handle for use by your rendering loop.\n\n```cpp\n// Get the frame latency waitable object, which is used by the WaitOnSwapChain method. This\n// requires that swap chain be created with the DXGI_SWAP_CHAIN_FLAG_FRAME_LATENCY_WAITABLE_OBJECT\n// flag.\nm_frameLatencyWaitableObject = swapChain2->GetFrameLatencyWaitableObject();\n```\n\n## Step 4: Wait before rendering each frame\n\n\nYour rendering loop should wait for the swap chain to signal via the waitable object before it begins rendering every frame. This includes the first frame rendered with the swap chain. Use [**WaitForSingleObjectEx**](https://msdn.microsoft.com/library/windows/desktop/ms687036), providing the wait handle retrieved in Step 2, to signal the start of each frame.\n\nThe following example shows the render loop from the DirectXLatency sample:\n\n```cpp\nwhile (!m_windowClosed)\n{\n    if (m_windowVisible)\n    {\n        // Block this thread until the swap chain is finished presenting. Note that it is\n        // important to call this before the first Present in order to minimize the latency\n        // of the swap chain.\n        m_deviceResources->WaitOnSwapChain();\n\n        // Process any UI events in the queue.\n        CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessAllIfPresent);\n\n        // Update app state in response to any UI events that occurred.\n        m_main->Update();\n\n        // Render the scene.\n        m_main->Render();\n\n        // Present the scene.\n        m_deviceResources->Present();\n    }\n    else\n    {\n        // The window is hidden. Block until a UI event occurs.\n        CoreWindow::GetForCurrentThread()->Dispatcher->ProcessEvents(CoreProcessEventsOption::ProcessOneAndAllPending);\n    }\n}\n```\n\nThe following example shows the WaitForSingleObjectEx call from the DirectXLatency sample:\n\n```cpp\n// Block the current thread until the swap chain has finished presenting.\nvoid DX::DeviceResources::WaitOnSwapChain()\n{\n    DWORD result = WaitForSingleObjectEx(\n        m_frameLatencyWaitableObject,\n        1000, // 1 second timeout (shouldn't ever occur)\n        true\n        );\n}\n```\n\n## What should my game do while it waits for the swap chain to present?\n\n\nIf your game doesn’t have any tasks that block on the render loop, letting it wait for the swap chain to present can be advantageous because it saves power, which is especially important on mobile devices. Otherwise, you can use multithreading to accomplish work while your game is waiting for the swap chain to present. Here are just a few tasks that your game can complete:\n\n-   Process network events\n-   Update the AI\n-   CPU-based physics\n-   Deferred-context rendering (on supported devices)\n-   Asset loading\n\nFor more information about multithreaded programming in Windows, see the following related topics.\n\n## Related topics\n\n\n* [DirectXLatency sample](http://go.microsoft.com/fwlink/p/?LinkID=317361)\n* [**IDXGISwapChain2::GetFrameLatencyWaitableObject**](https://msdn.microsoft.com/library/windows/desktop/dn268309)\n* [**WaitForSingleObjectEx**](https://msdn.microsoft.com/library/windows/desktop/ms687036)\n* [**Windows.System.Threading**](https://msdn.microsoft.com/library/windows/apps/br229642)\n* [Asynchronous programming in C++](https://msdn.microsoft.com/library/windows/apps/mt187334)\n* [Processes and Threads](https://msdn.microsoft.com/library/windows/desktop/ms684841)\n* [Synchronization](https://msdn.microsoft.com/library/windows/desktop/ms686353)\n* [Using Event Objects (Windows)](https://msdn.microsoft.com/library/windows/desktop/ms686915)\n\n \n\n \n\n\n\n\n"}