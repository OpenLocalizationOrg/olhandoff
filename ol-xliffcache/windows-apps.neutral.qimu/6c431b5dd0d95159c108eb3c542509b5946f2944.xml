{"nodes":[{"content":"This topic explains the dependency property system that is available when you write a Windows Runtime app using C++, C#, or Visual Basic along with XAML definitions for UI.","pos":[32,204]},{"content":"Dependency properties overview","pos":[212,242]},{"content":"Dependency properties overview","pos":[299,329]},{"content":"Updated for UWP apps on Windows 10.","pos":[334,369]},{"content":"For Windows 8.x articles, see the <bpt id=\"p1\">[</bpt>archive<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>","pos":[370,462]},{"content":"This topic explains the dependency property system that is available when you write a Windows Runtime app using C++, C#, or Visual Basic along with XAML definitions for UI.","pos":[467,639]},{"content":"What is a dependency property?","pos":[644,674]},{"content":"A dependency property is a specialized type of property.","pos":[676,732]},{"content":"Specifically it's a property where the property's value is tracked and influenced by a dedicated property system that is part of the Windows Runtime.","pos":[733,882]},{"content":"In order to support a dependency property, the object that defines the property must be a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept> (in other words a class that has the <bpt id=\"p3\">**</bpt>DependencyObject<ept id=\"p3\">**</ept> base class somewhere in its inheritance).","pos":[884,1154]},{"content":"Many of the types you use for your UI definitions for a Windows Store app with XAML will be a <bpt id=\"p1\">**</bpt>DependencyObject<ept id=\"p1\">**</ept> subclass, and will support dependency properties.","pos":[1155,1319]},{"content":"However, any type that comes from a Windows Runtime namespace that doesn't have \"XAML\" in its name won't support dependency properties; properties of such types are ordinary properties that won't have the property system's dependency behavior.","pos":[1320,1563]},{"content":"The purpose of dependency properties is to provide a systemic way to compute the value of a property based on other inputs (other properties, events and states that occur within your app while it runs).","pos":[1565,1767]},{"content":"These other inputs might include:","pos":[1768,1801]},{"content":"External input such as user preference","pos":[1807,1845]},{"content":"Just-in-time property determination mechanisms such as data binding, animations and storyboards","pos":[1850,1945]},{"content":"Multiple-use templating patterns such as resources and styles","pos":[1950,2011]},{"content":"Values known through parent-child relationships with other elements in the object tree","pos":[2016,2102]},{"content":"A dependency property represents or supports a specific feature of the programming model for defining a Windows Runtime app with XAML for UI and C#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) for code.","pos":[2104,2329]},{"content":"These features include:","pos":[2330,2353]},{"content":"Data binding","pos":[2359,2371]},{"content":"Styles","pos":[2376,2382]},{"content":"Storyboarded animations","pos":[2387,2410]},{"content":"\"PropertyChanged\" behavior; a dependency property can be implemented to provide callbacks that can propagate changes to other dependency properties","pos":[2415,2562]},{"content":"Using a default value that comes from property metadata","pos":[2567,2622]},{"pos":[2627,2761],"content":"General property system utility such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ClearValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242357)</ept> and metadata lookup"},{"content":"Dependency properties and Windows Runtime properties","pos":[2766,2818]},{"content":"Dependency properties extend basic Windows Runtime property functionality by providing a global, internal property store that backs all of the dependency properties in an app at run time.","pos":[2820,3007]},{"content":"This is an alternative to the standard pattern of backing a property with a private field that's private in the property-definition class.","pos":[3008,3146]},{"content":"You can think of this internal property store as being a set of property identifiers and values that exist for any particular object (so long as it's a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>).","pos":[3147,3381]},{"content":"Rather than being identified by name, each property in the store is identified by a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyProperty<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept> instance.","pos":[3382,3558]},{"content":"However, the property system mostly hides this implementation detail: you can usually access dependency properties by using a simple name (the programmatic property name in the code language you're using, or an attribute name when you're writing XAML).","pos":[3559,3811]},{"content":"The base type that provides the underpinnings of the dependency property system is <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>.","pos":[3813,3977]},{"content":"<bpt id=\"p1\">**</bpt>DependencyObject<ept id=\"p1\">**</ept> defines methods that can access the dependency property, and instances of a <bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept> derived class internally support the property store concept we mentioned earlier.","pos":[3978,4177]},{"content":"Here is a summation of the terminology that we use in the documentation when discussing dependency properties:","pos":[4179,4289]},{"content":"Term","pos":[4293,4297]},{"content":"Description","pos":[4300,4311]},{"content":"Dependency property","pos":[4339,4358]},{"content":"A property that exists on a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyProperty<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept> identifier (see below).","pos":[4361,4495]},{"content":"Usually this identifier is available as a static member of the defining <bpt id=\"p1\">**</bpt>DependencyObject<ept id=\"p1\">**</ept> derived class.","pos":[4496,4603]},{"content":"Dependency property identifier","pos":[4608,4638]},{"pos":[4641,4779],"content":"A <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept>, that's why it is typically public even though it is read-only."},{"content":"Property wrapper","pos":[4784,4800]},{"content":"The callable <bpt id=\"p1\">**</bpt>get<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>set<ept id=\"p2\">**</ept> implementations for a Windows Runtime property.","pos":[4803,4883]},{"content":"Or, the language-specific projection of the original definition.","pos":[4884,4948]},{"content":"A <bpt id=\"p1\">**</bpt>get<ept id=\"p1\">**</ept> property wrapper implementation calls <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>SetValue<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept>, passing the relevant dependency property identifier as one input and the value to set as the second input.","pos":[4949,5177]},{"content":"The property wrapper is not just convenience for callers, it also exposes the dependency property to any process, tool or projection that uses Windows Runtime definitions for properties.","pos":[5182,5368]},{"content":"The following example defines a custom \"IsSpinning\" dependency property as defined for C#, and shows the relationship of the dependency property identifier to the property wrapper.","pos":[5370,5550]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  The preceding example is not intended as the complete example for how to create a custom dependency property.","pos":[6173,6292]},{"content":"It is intended to show dependency property concepts for anyone that prefers learning concepts through code.","pos":[6293,6400]},{"content":"For a more complete example, see <bpt id=\"p1\">[</bpt>Custom dependency properties<ept id=\"p1\">](custom-dependency-properties.md)</ept>.","pos":[6401,6498]},{"content":"Dependency property value precedence","pos":[6503,6539]},{"content":"When you get the value of a dependency property, you are obtaining a value that was determined for that property through any one of the inputs that participate in the Windows Runtime property system.","pos":[6541,6740]},{"content":"Dependency property value precedence exists so that the Windows Runtime property system can calculate values in a predictable way, and it's important that you be familiar with the basic precedence order too.","pos":[6741,6948]},{"content":"Otherwise, you might find yourself in a situation where you're trying to set a property at one level of precedence but something else (the system, third-party callers, some of your own code) is setting it at another level, and you'll get frustrated trying to figure out which property value is used and where that value came from.","pos":[6949,7279]},{"content":"For example, styles and templates are intended to be a shared starting point for establishing property values and thus appearances of a control.","pos":[7281,7425]},{"content":"But on a particular control instance you might want to change its value versus the common templated value, such as giving that control a different background color or a different text string as content.","pos":[7426,7628]},{"content":"The Windows Runtime property system considers local values at higher precedence than values provided by styles and templates.","pos":[7629,7754]},{"content":"That enables the scenario of having app-specific values overwrite the templates so that the controls are useful for your own use of them in app UI.","pos":[7755,7902]},{"content":"Dependency property precedence list","pos":[7908,7943]},{"content":"The following is the definitive order that the property system uses when assigning the run-time value for a dependency property.","pos":[7945,8073]},{"content":"Highest precedence is listed first.","pos":[8074,8109]},{"content":"You'll find more detailed explanations just past this list.","pos":[8110,8169]},{"content":"<bpt id=\"p1\">**</bpt>Animated values:<ept id=\"p1\">**</ept> Active animations, visual state animations, or animations with a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>HoldEnd<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br210306)</ept> behavior.","pos":[8175,8342]},{"content":"To have any practical effect, an animation applied to a property must have precedence over the base (unanimated) value, even if that value was set locally.","pos":[8343,8498]},{"content":"<bpt id=\"p1\">**</bpt>Local value:<ept id=\"p1\">**</ept> A local value might be set through the convenience of the property wrapper, which also equates to setting as an attribute or property element in XAML, or by a call to the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>SetValue<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br242361)</ept> method using a property of a specific instance.","pos":[8503,8811]},{"content":"If you set a local value by using a binding or a static resource, these each act in the precedence as if a local value was set, and bindings or resource references are erased if a new local value is set.","pos":[8812,9015]},{"pos":[9020,9276],"content":"<bpt id=\"p1\">**</bpt>Templated properties:<ept id=\"p1\">**</ept> An element has these if it was created as part of a template (from a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>ControlTemplate<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br209391)</ept> or <bpt id=\"p4\">[</bpt><bpt id=\"p5\">**</bpt>DataTemplate<ept id=\"p5\">**</ept><ept id=\"p4\">](https://msdn.microsoft.com/library/windows/apps/br242348)</ept>)."},{"pos":[9281,9434],"content":"<bpt id=\"p1\">**</bpt>Style setters:<ept id=\"p1\">**</ept> Values from a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Setter<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br208817)</ept> within styles from page or application resources."},{"pos":[9439,9529],"content":"<bpt id=\"p1\">**</bpt>Default value:<ept id=\"p1\">**</ept> A dependency property can have a default value as part of its metadata."},{"content":"Templated properties","pos":[9535,9555]},{"content":"Templated properties as a precedence item do not apply to any property of an element that you declare directly in XAML page markup.","pos":[9557,9688]},{"content":"The templated property concept exists only for objects that are created when the Windows Runtime applies a XAML template to a UI element and thus defines its visuals.","pos":[9689,9855]},{"content":"All the properties that are set from a control template have values of some kind.","pos":[9857,9938]},{"content":"These values are almost like an extended set of default values for the control and are often associated with values you can reset later by setting the property values directly.","pos":[9939,10115]},{"content":"Thus the template-set values must be distinguishable from a true local value, so that any new local value can overwrite it.","pos":[10116,10239]},{"content":"Note","pos":[10243,10247]},{"content":"In some cases the template might override even local values, if the template failed to expose <bpt id=\"p1\">[</bpt>{TemplateBinding} markup extension<ept id=\"p1\">](templatebinding-markup-extension.md)</ept> references for properties that should have been settable on instances.","pos":[10252,10490]},{"content":"This is usually done only if the property is really not intended to be set on instances, for example if it's only relevant to visuals and template behavior and not to the intended function or runtime logic of the control that uses the template.","pos":[10491,10735]},{"content":"Bindings and precedence","pos":[10742,10765]},{"content":"Binding operations have the appropriate precedence for whatever scope they're used for.","pos":[10767,10854]},{"content":"For example, a binding applied to a local value acts as local value, and a binding (<bpt id=\"p1\">[</bpt>{TemplateBinding} markup extension<ept id=\"p1\">](templatebinding-markup-extension.md)</ept>) for a property setter applies as a style setter does.","pos":[10855,11067]},{"content":"Because bindings must wait until run-time to obtain values from data sources, the process of determining the property value precedence for any property extends into run-time as well.","pos":[11068,11250]},{"content":"Not only do bindings operate at the same precedence as a local value, they really are a local value, where the binding is the placeholder for a value that is deferred.","pos":[11252,11419]},{"content":"If you have a binding in place for a property value, and you set a local value on it at run-time, that replaces the binding entirely.","pos":[11420,11553]},{"content":"Similarly, if you call <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetBinding<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br244257)</ept> to define a binding that only comes into existence at run-time, you replace any local value you might have applied in XAML or with previously executed code.","pos":[11554,11808]},{"content":"Storyboarded animations and base value","pos":[11814,11852]},{"content":"Storyboarded animations act on a concept of a <bpt id=\"p1\">*</bpt>base value<ept id=\"p1\">*</ept>.","pos":[11854,11913]},{"content":"The base value is the value that's determined by the property system using its precedence, but omitting that last step of looking for animations.","pos":[11914,12059]},{"content":"For example, a base value might come from a control's template, or it might come from setting a local value on an instance of a control.","pos":[12060,12196]},{"content":"Either way, applying an animation will overwrite this base value and apply the animated value for as long as your animation continues to run.","pos":[12197,12338]},{"content":"For an animated property, the base value can still have an effect on the animation's behavior, if that animation does not explicitly specify both <bpt id=\"p1\">**</bpt>From<ept id=\"p1\">**</ept> and <bpt id=\"p2\">**</bpt>To<ept id=\"p2\">**</ept>, or if the animation reverts the property to its base value when completed.","pos":[12340,12581]},{"content":"In these cases, once an animation is no longer running, the rest of the precedence is used again.","pos":[12582,12679]},{"content":"However, an animation that specifies a <bpt id=\"p1\">**</bpt>To<ept id=\"p1\">**</ept> with a <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>HoldEnd<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br210306)</ept> behavior can override a local value until the animation is removed, even when it visually appears to be stopped.","pos":[12681,12918]},{"content":"Conceptually this is like an animation that's running forever even if there is not a visual animation in the UI.","pos":[12919,13031]},{"content":"Multiple animations can be applied to a single property.","pos":[13033,13089]},{"content":"Each of these animations might have been defined to replace base values that came from different points in the value precedence.","pos":[13090,13218]},{"content":"However, these animations will all be running simultaneously at run time, and that often means that they must combine their values because each animation has equal influence on the value.","pos":[13219,13406]},{"content":"This depends on exactly how the animations are defined, and the type of the value that is being animated.","pos":[13407,13512]},{"pos":[13514,13617],"content":"For more info, see <bpt id=\"p1\">[</bpt>Storyboarded animations<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt187354)</ept>."},{"content":"Default values","pos":[13623,13637]},{"pos":[13639,13895],"content":"Establishing the default value for a dependency property with a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>PropertyMetadata<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208771)</ept> value is explained in more detail in the <bpt id=\"p3\">[</bpt>Custom dependency properties<ept id=\"p3\">](custom-dependency-properties.md)</ept> topic."},{"content":"Dependency properties still have default values even if those default values weren't explicitly defined in that property's metadata.","pos":[13897,14029]},{"content":"Unless they have been changed by metadata, default values for the Windows Runtime dependency properties are generally one of the following:","pos":[14030,14169]},{"content":"A property that uses a run-time object or the basic <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept> type (a <bpt id=\"p2\">*</bpt>reference type<ept id=\"p2\">*</ept>) has a default value of <bpt id=\"p3\">**</bpt>null<ept id=\"p3\">**</ept>.","pos":[14175,14296]},{"content":"For example, <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208713)</ept> is <bpt id=\"p3\">**</bpt>null<ept id=\"p3\">**</ept> until it's deliberately set or is inherited.","pos":[14297,14442]},{"content":"A property that uses a basic value such as numbers or a Boolean value (a <bpt id=\"p1\">*</bpt>value type<ept id=\"p1\">*</ept>) uses an expected default for that value.","pos":[14447,14574]},{"content":"For example, 0 for integers and floating-point numbers, <bpt id=\"p1\">**</bpt>false<ept id=\"p1\">**</ept> for a Boolean.","pos":[14575,14655]},{"content":"A property that uses a Windows Runtime structure has a default value that's obtained by calling that structure's implicit default constructor.","pos":[14660,14802]},{"content":"This constructor uses the defaults for each of the basic value fields of the structure.","pos":[14803,14890]},{"content":"For example, a default for a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Point<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br225870)</ept> value is initialized with its <bpt id=\"p3\">**</bpt>X<ept id=\"p3\">**</ept> and <bpt id=\"p4\">**</bpt>Y<ept id=\"p4\">**</ept> values as 0.","pos":[14891,15048]},{"content":"A property that uses an enumeration has a default value of the first defined member in that enumeration.","pos":[15053,15157]},{"content":"Check the reference for specific enumerations to see what the default value is.","pos":[15158,15237]},{"pos":[15242,15527],"content":"A property that uses a string (<bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>System.String<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/system.string.aspx)</ept> for .NET, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Platform::String<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx)</ept> for C++/CX) has a default value of an empty string (<bpt id=\"p5\">**</bpt>\"\"<ept id=\"p5\">**</ept>)."},{"content":"Collection properties aren't typically implemented as dependency properties, for reasons discussed further on in this topic.","pos":[15532,15656]},{"content":"But if you implement a custom collection property and you want it to be a dependency property, make sure to avoid an <bpt id=\"p1\">*</bpt>unintentional singleton<ept id=\"p1\">*</ept> as described near the end of <bpt id=\"p2\">[</bpt>Custom dependency properties<ept id=\"p2\">](custom-dependency-properties.md)</ept>.","pos":[15657,15893]},{"content":"Property functionality provided by a dependency property","pos":[15898,15954]},{"content":"Data binding","pos":[15960,15972]},{"content":"A dependency property can have its value set through applying a data binding.","pos":[15974,16051]},{"content":"Data binding uses the <bpt id=\"p1\">[</bpt>{Binding} markup extension<ept id=\"p1\">](binding-markup-extension.md)</ept> syntax in XAML, or the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Binding<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br209820)</ept> class in code.","pos":[16052,16241]},{"content":"For a databound property, the final property value determination is deferred until run time.","pos":[16242,16334]},{"content":"At that time the value is obtained from a data source.","pos":[16335,16389]},{"content":"The role that the dependency property system plays here is enabling a placeholder behavior for operations like loading XAML when the value is not yet known, and then supplying the value at run time by interacting with the Windows Runtime data binding engine.","pos":[16390,16648]},{"content":"The following example sets the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Text<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209676)</ept> value for a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>TextBlock<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br209652)</ept> element, using a binding in XAML.","pos":[16650,16869]},{"content":"The binding uses an inherited data context and an object data source.","pos":[16870,16939]},{"content":"(Neither of these is shown in the shortened example; for a more complete sample that shows context and source, see <bpt id=\"p1\">[</bpt>Data binding in depth<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt210946)</ept>.)","pos":[16940,17138]},{"content":"You can also establish bindings using code rather than XAML.","pos":[17217,17277]},{"content":"See <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetBinding<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br244257)</ept>.","pos":[17278,17357]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  Bindings like this are treated as a local value for purposes of dependency property value precedence.","pos":[17359,17470]},{"content":"If you set another local value for a property that originally held a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Binding<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209820)</ept> value, you will overwrite the binding entirely, not just the binding's run-time value.","pos":[17471,17698]},{"content":"Binding sources, binding targets, the role of FrameworkElement","pos":[17704,17766]},{"content":"To be the source of a binding, a property does not need to be a dependency property; you can generally use any property as a binding source, although this depends on your programming language and each has certain edge cases.","pos":[17768,17992]},{"content":"However, to be the target of a binding, that property must be a dependency property.","pos":[17993,18077]},{"content":"If you are creating a binding in code, note that the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>SetBinding<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br244257)</ept> API is defined only for <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>FrameworkElement<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept>.","pos":[18079,18312]},{"content":"However, you can create a binding definition using <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>BindingOperations<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209823)</ept> instead, and thus reference any <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>DependencyObject<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept> property.","pos":[18313,18568]},{"content":"For either code or XAML, remember that <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208713)</ept> is a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>FrameworkElement<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept> property.","pos":[18570,18780]},{"content":"By using a form of parent-child property inheritance (typically established in XAML markup), the binding system can resolve a <bpt id=\"p1\">**</bpt>DataContext<ept id=\"p1\">**</ept> that exists on a parent element.","pos":[18781,18955]},{"content":"This inheritance can evaluate even if the child object (which has the target property) is not a <bpt id=\"p1\">**</bpt>FrameworkElement<ept id=\"p1\">**</ept> and therefore does not hold its own <bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept> value.","pos":[18956,19131]},{"content":"However, the parent element being inherited must be a <bpt id=\"p1\">**</bpt>FrameworkElement<ept id=\"p1\">**</ept> in order to set and hold the <bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept>.","pos":[19132,19252]},{"content":"Alternatively, you must define the binding such that it can function with a <bpt id=\"p1\">**</bpt>null<ept id=\"p1\">**</ept> value for <bpt id=\"p2\">**</bpt>DataContext<ept id=\"p2\">**</ept>.","pos":[19253,19364]},{"content":"Wiring the binding is not the only thing that's needed for most data binding scenarios.","pos":[19366,19453]},{"content":"For a one-way or two-way binding to be effective, the source property must support change notifications that propagate to the binding system and thus the target.","pos":[19454,19615]},{"content":"For custom binding sources, this means that the property must support <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>INotifyPropertyChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/system.componentmodel.inotifypropertychanged.aspx)</ept>.","pos":[19616,19819]},{"content":"Collections should support <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>INotifyCollectionChanged<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/system.collections.specialized.inotifycollectionchanged.aspx)</ept>.","pos":[19820,19993]},{"content":"Certain classes support these interfaces in their implementations so that they are useful as base classes for data binding scenarios; an example of such a class is <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ObservableCollection<ph id=\"ph1\">&amp;lt;</ph>T<ph id=\"ph2\">&amp;gt;</ph><ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/xaml/ms668604.aspx)</ept>.","pos":[19994,20262]},{"content":"For more information on data binding and how data binding relates to the property system, see <bpt id=\"p1\">[</bpt>Data binding in depth<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt210946)</ept>.","pos":[20263,20439]},{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept>  The types listed here support Microsoft .NET data sources.","pos":[20441,20509]},{"content":"C++/CX data sources use different interfaces for change notification or observable behavior, see <bpt id=\"p1\">[</bpt>Data binding in depth<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt210946)</ept>.","pos":[20510,20689]},{"content":"Styles and templates","pos":[20695,20715]},{"content":"Styles and templates are two of the scenarios for properties being defined as dependency properties.","pos":[20717,20817]},{"content":"Styles are useful for setting properties that define the app's UI.","pos":[20818,20884]},{"content":"Styles are defined as resources in XAML, either as an entry in a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Resources<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208740)</ept> collection, or in separate XAML files such as theme resource dictionaries.","pos":[20885,21098]},{"content":"Styles interact with the property system because they contain setters for properties.","pos":[21099,21184]},{"content":"The most important property here is the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Control.Template<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209465)</ept> property of a <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Control<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br209390)</ept>: it defines most of the visual appearance and visual state for a <bpt id=\"p5\">**</bpt>Control<ept id=\"p5\">**</ept>.","pos":[21185,21469]},{"content":"For more info on styles, and some example XAML that defines a <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Style<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br208849)</ept> and uses setters, see <bpt id=\"p3\">[</bpt>Styling controls<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/mt210950)</ept>.","pos":[21470,21701]},{"content":"Values that come from styles or templates are deferred values, similar to bindings.","pos":[21703,21786]},{"content":"This is so that control users can re-template controls or redefine styles.","pos":[21787,21861]},{"content":"And that's why property setters in styles can only act on dependency properties, not ordinary properties.","pos":[21862,21967]},{"content":"Storyboarded animations","pos":[21973,21996]},{"content":"You can animate a dependency property's value using a storyboarded animation.","pos":[21998,22075]},{"content":"Storyboarded animations in the Windows Runtime are not merely visual decorations.","pos":[22076,22157]},{"content":"It's more useful to think of animations as being a state machine technique that can set the values of individual properties or of all properties and visuals of a control, and change these values over time.","pos":[22158,22363]},{"content":"To be animated, the animation's target property must be a dependency property.","pos":[22365,22443]},{"content":"Also, to be animated, the target property's value type must be supported by one of the existing <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Timeline<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br210517)</ept>-derived animation types.","pos":[22444,22637]},{"content":"Values of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>Color<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh673723)</ept>, <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Double<ept id=\"p4\">**</ept><ept id=\"p3\">](T:System.Double)</ept> and <bpt id=\"p5\">[</bpt><bpt id=\"p6\">**</bpt>Point<ept id=\"p6\">**</ept><ept id=\"p5\">](https://msdn.microsoft.com/library/windows/apps/br225870)</ept> can be animated using either interpolation or keyframe techniques.","pos":[22638,22889]},{"content":"Most other values can be animated using discrete <bpt id=\"p1\">**</bpt>Object<ept id=\"p1\">**</ept> key frames.","pos":[22890,22961]},{"content":"When an animation is applied and running, the animated value operates at a higher precedence than any value (such as a local value) that the property otherwise has.","pos":[22963,23127]},{"content":"Animations also have an optional <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>HoldEnd<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br210306)</ept> behavior that can cause animations to apply to property values even if the animation visually appears to be stopped.","pos":[23128,23349]},{"content":"The state machine principle is embodied by the use of storyboarded animations as part of the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>VisualStateManager<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br209021)</ept> state model for controls.","pos":[23351,23552]},{"content":"For more info on storyboarded animations, see <bpt id=\"p1\">[</bpt>Storyboarded animations<ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/mt187354)</ept>.","pos":[23553,23683]},{"content":"For more info on <bpt id=\"p1\">**</bpt>VisualStateManager<ept id=\"p1\">**</ept> and defining visual states for controls, see <bpt id=\"p2\">[</bpt>Storyboarded animations for visual states<ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/xaml/jj819808)</ept> or <bpt id=\"p3\">[</bpt>Quickstart: Control templates<ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374)</ept>.","pos":[23684,23974]},{"content":"Property-changed behavior","pos":[23980,24005]},{"content":"Property-changed behavior is the origin of the \"dependency\" part of dependency property terminology.","pos":[24007,24107]},{"content":"Maintaining valid values for a property when another property can influence the first property's value is a difficult development problem in many frameworks.","pos":[24108,24265]},{"content":"In the Windows Runtime property system, each dependency property can specify a callback that is invoked whenever its property value changes.","pos":[24266,24406]},{"content":"This callback can be used to notify or change related property values, in a generally synchronous manner.","pos":[24407,24512]},{"content":"Many existing dependency properties have a property-changed behavior.","pos":[24513,24582]},{"content":"You can also add similar callback behavior to custom dependency properties, and implement your own property-changed callbacks.","pos":[24583,24709]},{"content":"See <bpt id=\"p1\">[</bpt>Custom dependency properties<ept id=\"p1\">](custom-dependency-properties.md)</ept> for an example.","pos":[24710,24793]},{"pos":[24799,24831],"content":"Default value and <bpt id=\"p1\">**</bpt>ClearValue<ept id=\"p1\">**</ept>"},{"content":"A dependency property can have a default value defined as part of its property metadata.","pos":[24833,24921]},{"content":"For a dependency property, its default value doesn't become irrelevant after the property's been set the first time.","pos":[24922,25038]},{"content":"The default value might apply again at run-time whenever some other determinant in value precedence disappears.","pos":[25039,25150]},{"content":"(Dependency property value precedence is discussed in the next section.) For example, you might deliberately remove a style value or an animation that applies to a property, but you want the value to be a reasonable default after you do so.","pos":[25151,25391]},{"content":"The dependency property default value can provide this value, without needing to specifically set each property's value as an extra step.","pos":[25392,25529]},{"content":"You can deliberately set a property to the default value even after you have already set it with a local value.","pos":[25531,25642]},{"content":"To reset a value to be the default again, and also to enable other participants in precedence that might override the default but not a local value, call the <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>ClearValue<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242357)</ept> method (reference the property to clear as a method parameter).","pos":[25643,25939]},{"content":"You don't always want the property to literally use the default value, but clearing the local value and reverting to the default value might enable another item in precedence that you want to act now, such as using the value that came from a style setter in a control template.","pos":[25940,26217]},{"pos":[26222,26256],"content":"<bpt id=\"p1\">**</bpt>DependencyObject<ept id=\"p1\">**</ept> and threading"},{"content":"All <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept> instances must be created on the UI thread which is associated with the current <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>Window<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br209041)</ept> that is shown by a Windows Runtime app.","pos":[26258,26533]},{"content":"Although each <bpt id=\"p1\">**</bpt>DependencyObject<ept id=\"p1\">**</ept> must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by accessing the <bpt id=\"p2\">[</bpt><bpt id=\"p3\">**</bpt>Dispatcher<ept id=\"p3\">**</ept><ept id=\"p2\">](https://msdn.microsoft.com/library/windows/apps/br230616)</ept> property.","pos":[26534,26786]},{"content":"Then you can call methods such as <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>RunAsync<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/hh750317)</ept> on the <bpt id=\"p3\">[</bpt><bpt id=\"p4\">**</bpt>CoreDispatcher<ept id=\"p4\">**</ept><ept id=\"p3\">](https://msdn.microsoft.com/library/windows/apps/br208211)</ept> object, and execute your code within the rules of thread restrictions on the UI thread.","pos":[26787,27067]},{"content":"The threading aspects of <bpt id=\"p1\">[</bpt><bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept><ept id=\"p1\">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept> are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property.","pos":[27069,27316]},{"content":"Threading issues can usually be avoided in typical UI code that makes correct use of <bpt id=\"p1\">**</bpt>async<ept id=\"p1\">**</ept> patterns and background worker threads.","pos":[27317,27451]},{"content":"You typically only run into <bpt id=\"p1\">**</bpt>DependencyObject<ept id=\"p1\">**</ept>-related threading issues if you are defining your own <bpt id=\"p2\">**</bpt>DependencyObject<ept id=\"p2\">**</ept> types and you attempt to use them for data sources or other scenarios where a <bpt id=\"p3\">**</bpt>DependencyObject<ept id=\"p3\">**</ept> isn't necessarily appropriate.","pos":[27452,27705]},{"content":"Related topics","pos":[27710,27724]},{"content":"Conceptual material","pos":[27728,27747]},{"content":"Custom dependency properties","pos":[27753,27781]},{"content":"Attached properties overview","pos":[27819,27847]},{"content":"Data binding in depth","pos":[27885,27906]},{"content":"Storyboarded animations","pos":[27969,27992]},{"content":"Creating Windows Runtime components","pos":[28055,28090]},{"pos":[28162,28291],"content":"<bpt id=\"p1\">[</bpt>XAML user and custom controls sample<ept id=\"p1\">](http://go.microsoft.com/fwlink/p/?linkid=238581)</ept><ph id=\"ph1\">\n</ph><bpt id=\"p2\">**</bpt>APIs related to dependency properties<ept id=\"p2\">**</ept>"},{"content":"DependencyObject","pos":[28297,28313]},{"content":"DependencyProperty","pos":[28380,28398]}],"content":"---\nauthor: jwmsft\ndescription: This topic explains the dependency property system that is available when you write a Windows Runtime app using C++, C#, or Visual Basic along with XAML definitions for UI.\ntitle: Dependency properties overview\nms.assetid: AD649E66-F71C-4DAA-9994-617C886FDA7E\n---\n\n# Dependency properties overview\n\n\\[ Updated for UWP apps on Windows 10. For Windows 8.x articles, see the [archive](http://go.microsoft.com/fwlink/p/?linkid=619132) \\]\n\nThis topic explains the dependency property system that is available when you write a Windows Runtime app using C++, C#, or Visual Basic along with XAML definitions for UI.\n\n## What is a dependency property?\n\nA dependency property is a specialized type of property. Specifically it's a property where the property's value is tracked and influenced by a dedicated property system that is part of the Windows Runtime.\n\nIn order to support a dependency property, the object that defines the property must be a [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) (in other words a class that has the **DependencyObject** base class somewhere in its inheritance). Many of the types you use for your UI definitions for a Windows Store app with XAML will be a **DependencyObject** subclass, and will support dependency properties. However, any type that comes from a Windows Runtime namespace that doesn't have \"XAML\" in its name won't support dependency properties; properties of such types are ordinary properties that won't have the property system's dependency behavior.\n\nThe purpose of dependency properties is to provide a systemic way to compute the value of a property based on other inputs (other properties, events and states that occur within your app while it runs). These other inputs might include:\n\n-   External input such as user preference\n-   Just-in-time property determination mechanisms such as data binding, animations and storyboards\n-   Multiple-use templating patterns such as resources and styles\n-   Values known through parent-child relationships with other elements in the object tree\n\nA dependency property represents or supports a specific feature of the programming model for defining a Windows Runtime app with XAML for UI and C#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) for code. These features include:\n\n-   Data binding\n-   Styles\n-   Storyboarded animations\n-   \"PropertyChanged\" behavior; a dependency property can be implemented to provide callbacks that can propagate changes to other dependency properties\n-   Using a default value that comes from property metadata\n-   General property system utility such as [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357) and metadata lookup\n\n## Dependency properties and Windows Runtime properties\n\nDependency properties extend basic Windows Runtime property functionality by providing a global, internal property store that backs all of the dependency properties in an app at run time. This is an alternative to the standard pattern of backing a property with a private field that's private in the property-definition class. You can think of this internal property store as being a set of property identifiers and values that exist for any particular object (so long as it's a [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356)). Rather than being identified by name, each property in the store is identified by a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) instance. However, the property system mostly hides this implementation detail: you can usually access dependency properties by using a simple name (the programmatic property name in the code language you're using, or an attribute name when you're writing XAML).\n\nThe base type that provides the underpinnings of the dependency property system is [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356). **DependencyObject** defines methods that can access the dependency property, and instances of a **DependencyObject** derived class internally support the property store concept we mentioned earlier.\n\nHere is a summation of the terminology that we use in the documentation when discussing dependency properties:\n\n| Term | Description |\n|------|-------------|\n| Dependency property | A property that exists on a [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362) identifier (see below). Usually this identifier is available as a static member of the defining **DependencyObject** derived class. |\n| Dependency property identifier | A [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361), that's why it is typically public even though it is read-only. |\n| Property wrapper | The callable **get** and **set** implementations for a Windows Runtime property. Or, the language-specific projection of the original definition. A **get** property wrapper implementation calls [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361), passing the relevant dependency property identifier as one input and the value to set as the second input. | \n\nThe property wrapper is not just convenience for callers, it also exposes the dependency property to any process, tool or projection that uses Windows Runtime definitions for properties.\n\nThe following example defines a custom \"IsSpinning\" dependency property as defined for C#, and shows the relationship of the dependency property identifier to the property wrapper.\n\n```csharp\n// IsSpinningProperty is the dependency property identifier\n// no need for info in the last PropertyMetadata parameter, so we pass null\npublic static readonly DependencyProperty IsSpinningProperty = \n    DependencyProperty.Register(\n        \"IsSpinning\", typeof(Boolean),\n        typeof(ExampleClass), null\n    );\n// The property wrapper, so that callers can use this property through a simple ExampleClassInstance.IsSpinning usage rather than requiring property system APIs\npublic bool IsSpinning\n{\n    get { return (bool)GetValue(IsSpinningProperty); }\n    set { SetValue(IsSpinningProperty, value); }\n}\n```\n\n**Note**  The preceding example is not intended as the complete example for how to create a custom dependency property. It is intended to show dependency property concepts for anyone that prefers learning concepts through code. For a more complete example, see [Custom dependency properties](custom-dependency-properties.md).\n\n## Dependency property value precedence\n\nWhen you get the value of a dependency property, you are obtaining a value that was determined for that property through any one of the inputs that participate in the Windows Runtime property system. Dependency property value precedence exists so that the Windows Runtime property system can calculate values in a predictable way, and it's important that you be familiar with the basic precedence order too. Otherwise, you might find yourself in a situation where you're trying to set a property at one level of precedence but something else (the system, third-party callers, some of your own code) is setting it at another level, and you'll get frustrated trying to figure out which property value is used and where that value came from.\n\nFor example, styles and templates are intended to be a shared starting point for establishing property values and thus appearances of a control. But on a particular control instance you might want to change its value versus the common templated value, such as giving that control a different background color or a different text string as content. The Windows Runtime property system considers local values at higher precedence than values provided by styles and templates. That enables the scenario of having app-specific values overwrite the templates so that the controls are useful for your own use of them in app UI.\n\n### Dependency property precedence list\n\nThe following is the definitive order that the property system uses when assigning the run-time value for a dependency property. Highest precedence is listed first. You'll find more detailed explanations just past this list.\n\n1.  **Animated values:** Active animations, visual state animations, or animations with a [**HoldEnd**](https://msdn.microsoft.com/library/windows/apps/br210306) behavior. To have any practical effect, an animation applied to a property must have precedence over the base (unanimated) value, even if that value was set locally.\n2.  **Local value:** A local value might be set through the convenience of the property wrapper, which also equates to setting as an attribute or property element in XAML, or by a call to the [**SetValue**](https://msdn.microsoft.com/library/windows/apps/br242361) method using a property of a specific instance. If you set a local value by using a binding or a static resource, these each act in the precedence as if a local value was set, and bindings or resource references are erased if a new local value is set.\n3.  **Templated properties:** An element has these if it was created as part of a template (from a [**ControlTemplate**](https://msdn.microsoft.com/library/windows/apps/br209391) or [**DataTemplate**](https://msdn.microsoft.com/library/windows/apps/br242348)).\n4.  **Style setters:** Values from a [**Setter**](https://msdn.microsoft.com/library/windows/apps/br208817) within styles from page or application resources.\n5.  **Default value:** A dependency property can have a default value as part of its metadata.\n\n### Templated properties\n\nTemplated properties as a precedence item do not apply to any property of an element that you declare directly in XAML page markup. The templated property concept exists only for objects that are created when the Windows Runtime applies a XAML template to a UI element and thus defines its visuals.\n\nAll the properties that are set from a control template have values of some kind. These values are almost like an extended set of default values for the control and are often associated with values you can reset later by setting the property values directly. Thus the template-set values must be distinguishable from a true local value, so that any new local value can overwrite it.\n\n**Note**  \nIn some cases the template might override even local values, if the template failed to expose [{TemplateBinding} markup extension](templatebinding-markup-extension.md) references for properties that should have been settable on instances. This is usually done only if the property is really not intended to be set on instances, for example if it's only relevant to visuals and template behavior and not to the intended function or runtime logic of the control that uses the template.\n\n###  Bindings and precedence\n\nBinding operations have the appropriate precedence for whatever scope they're used for. For example, a binding applied to a local value acts as local value, and a binding ([{TemplateBinding} markup extension](templatebinding-markup-extension.md)) for a property setter applies as a style setter does. Because bindings must wait until run-time to obtain values from data sources, the process of determining the property value precedence for any property extends into run-time as well.\n\nNot only do bindings operate at the same precedence as a local value, they really are a local value, where the binding is the placeholder for a value that is deferred. If you have a binding in place for a property value, and you set a local value on it at run-time, that replaces the binding entirely. Similarly, if you call [**SetBinding**](https://msdn.microsoft.com/library/windows/apps/br244257) to define a binding that only comes into existence at run-time, you replace any local value you might have applied in XAML or with previously executed code.\n\n### Storyboarded animations and base value\n\nStoryboarded animations act on a concept of a *base value*. The base value is the value that's determined by the property system using its precedence, but omitting that last step of looking for animations. For example, a base value might come from a control's template, or it might come from setting a local value on an instance of a control. Either way, applying an animation will overwrite this base value and apply the animated value for as long as your animation continues to run.\n\nFor an animated property, the base value can still have an effect on the animation's behavior, if that animation does not explicitly specify both **From** and **To**, or if the animation reverts the property to its base value when completed. In these cases, once an animation is no longer running, the rest of the precedence is used again.\n\nHowever, an animation that specifies a **To** with a [**HoldEnd**](https://msdn.microsoft.com/library/windows/apps/br210306) behavior can override a local value until the animation is removed, even when it visually appears to be stopped. Conceptually this is like an animation that's running forever even if there is not a visual animation in the UI.\n\nMultiple animations can be applied to a single property. Each of these animations might have been defined to replace base values that came from different points in the value precedence. However, these animations will all be running simultaneously at run time, and that often means that they must combine their values because each animation has equal influence on the value. This depends on exactly how the animations are defined, and the type of the value that is being animated.\n\nFor more info, see [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/mt187354).\n\n### Default values\n\nEstablishing the default value for a dependency property with a [**PropertyMetadata**](https://msdn.microsoft.com/library/windows/apps/br208771) value is explained in more detail in the [Custom dependency properties](custom-dependency-properties.md) topic.\n\nDependency properties still have default values even if those default values weren't explicitly defined in that property's metadata. Unless they have been changed by metadata, default values for the Windows Runtime dependency properties are generally one of the following:\n\n-   A property that uses a run-time object or the basic **Object** type (a *reference type*) has a default value of **null**. For example, [**DataContext**](https://msdn.microsoft.com/library/windows/apps/br208713) is **null** until it's deliberately set or is inherited.\n-   A property that uses a basic value such as numbers or a Boolean value (a *value type*) uses an expected default for that value. For example, 0 for integers and floating-point numbers, **false** for a Boolean.\n-   A property that uses a Windows Runtime structure has a default value that's obtained by calling that structure's implicit default constructor. This constructor uses the defaults for each of the basic value fields of the structure. For example, a default for a [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870) value is initialized with its **X** and **Y** values as 0.\n-   A property that uses an enumeration has a default value of the first defined member in that enumeration. Check the reference for specific enumerations to see what the default value is.\n-   A property that uses a string ([**System.String**](https://msdn.microsoft.com/library/windows/apps/xaml/system.string.aspx) for .NET, [**Platform::String**](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx) for C++/CX) has a default value of an empty string (**\"\"**).\n-   Collection properties aren't typically implemented as dependency properties, for reasons discussed further on in this topic. But if you implement a custom collection property and you want it to be a dependency property, make sure to avoid an *unintentional singleton* as described near the end of [Custom dependency properties](custom-dependency-properties.md).\n\n## Property functionality provided by a dependency property\n\n### Data binding\n\nA dependency property can have its value set through applying a data binding. Data binding uses the [{Binding} markup extension](binding-markup-extension.md) syntax in XAML, or the [**Binding**](https://msdn.microsoft.com/library/windows/apps/br209820) class in code. For a databound property, the final property value determination is deferred until run time. At that time the value is obtained from a data source. The role that the dependency property system plays here is enabling a placeholder behavior for operations like loading XAML when the value is not yet known, and then supplying the value at run time by interacting with the Windows Runtime data binding engine.\n\nThe following example sets the [**Text**](https://msdn.microsoft.com/library/windows/apps/br209676) value for a [**TextBlock**](https://msdn.microsoft.com/library/windows/apps/br209652) element, using a binding in XAML. The binding uses an inherited data context and an object data source. (Neither of these is shown in the shortened example; for a more complete sample that shows context and source, see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946).)\n\n```XML\n<Canvas>\n  <TextBlock Text=\"{Binding Team.TeamName}\"/>\n</Canvas>\n```\n\nYou can also establish bindings using code rather than XAML. See [**SetBinding**](https://msdn.microsoft.com/library/windows/apps/br244257).\n\n**Note**  Bindings like this are treated as a local value for purposes of dependency property value precedence. If you set another local value for a property that originally held a [**Binding**](https://msdn.microsoft.com/library/windows/apps/br209820) value, you will overwrite the binding entirely, not just the binding's run-time value.\n\n### Binding sources, binding targets, the role of FrameworkElement\n\nTo be the source of a binding, a property does not need to be a dependency property; you can generally use any property as a binding source, although this depends on your programming language and each has certain edge cases. However, to be the target of a binding, that property must be a dependency property.\n\nIf you are creating a binding in code, note that the [**SetBinding**](https://msdn.microsoft.com/library/windows/apps/br244257) API is defined only for [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706). However, you can create a binding definition using [**BindingOperations**](https://msdn.microsoft.com/library/windows/apps/br209823) instead, and thus reference any [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) property.\n\nFor either code or XAML, remember that [**DataContext**](https://msdn.microsoft.com/library/windows/apps/br208713) is a [**FrameworkElement**](https://msdn.microsoft.com/library/windows/apps/br208706) property. By using a form of parent-child property inheritance (typically established in XAML markup), the binding system can resolve a **DataContext** that exists on a parent element. This inheritance can evaluate even if the child object (which has the target property) is not a **FrameworkElement** and therefore does not hold its own **DataContext** value. However, the parent element being inherited must be a **FrameworkElement** in order to set and hold the **DataContext**. Alternatively, you must define the binding such that it can function with a **null** value for **DataContext**.\n\nWiring the binding is not the only thing that's needed for most data binding scenarios. For a one-way or two-way binding to be effective, the source property must support change notifications that propagate to the binding system and thus the target. For custom binding sources, this means that the property must support [**INotifyPropertyChanged**](https://msdn.microsoft.com/library/windows/apps/xaml/system.componentmodel.inotifypropertychanged.aspx). Collections should support [**INotifyCollectionChanged**](https://msdn.microsoft.com/library/windows/apps/xaml/system.collections.specialized.inotifycollectionchanged.aspx). Certain classes support these interfaces in their implementations so that they are useful as base classes for data binding scenarios; an example of such a class is [**ObservableCollection&lt;T&gt;**](https://msdn.microsoft.com/library/windows/apps/xaml/ms668604.aspx). For more information on data binding and how data binding relates to the property system, see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946).\n\n**Note**  The types listed here support Microsoft .NET data sources. C++/CX data sources use different interfaces for change notification or observable behavior, see [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946).\n\n### Styles and templates\n\nStyles and templates are two of the scenarios for properties being defined as dependency properties. Styles are useful for setting properties that define the app's UI. Styles are defined as resources in XAML, either as an entry in a [**Resources**](https://msdn.microsoft.com/library/windows/apps/br208740) collection, or in separate XAML files such as theme resource dictionaries. Styles interact with the property system because they contain setters for properties. The most important property here is the [**Control.Template**](https://msdn.microsoft.com/library/windows/apps/br209465) property of a [**Control**](https://msdn.microsoft.com/library/windows/apps/br209390): it defines most of the visual appearance and visual state for a **Control**. For more info on styles, and some example XAML that defines a [**Style**](https://msdn.microsoft.com/library/windows/apps/br208849) and uses setters, see [Styling controls](https://msdn.microsoft.com/library/windows/apps/mt210950).\n\nValues that come from styles or templates are deferred values, similar to bindings. This is so that control users can re-template controls or redefine styles. And that's why property setters in styles can only act on dependency properties, not ordinary properties.\n\n### Storyboarded animations\n\nYou can animate a dependency property's value using a storyboarded animation. Storyboarded animations in the Windows Runtime are not merely visual decorations. It's more useful to think of animations as being a state machine technique that can set the values of individual properties or of all properties and visuals of a control, and change these values over time.\n\nTo be animated, the animation's target property must be a dependency property. Also, to be animated, the target property's value type must be supported by one of the existing [**Timeline**](https://msdn.microsoft.com/library/windows/apps/br210517)-derived animation types. Values of [**Color**](https://msdn.microsoft.com/library/windows/apps/hh673723), [**Double**](T:System.Double) and [**Point**](https://msdn.microsoft.com/library/windows/apps/br225870) can be animated using either interpolation or keyframe techniques. Most other values can be animated using discrete **Object** key frames.\n\nWhen an animation is applied and running, the animated value operates at a higher precedence than any value (such as a local value) that the property otherwise has. Animations also have an optional [**HoldEnd**](https://msdn.microsoft.com/library/windows/apps/br210306) behavior that can cause animations to apply to property values even if the animation visually appears to be stopped.\n\nThe state machine principle is embodied by the use of storyboarded animations as part of the [**VisualStateManager**](https://msdn.microsoft.com/library/windows/apps/br209021) state model for controls. For more info on storyboarded animations, see [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/mt187354). For more info on **VisualStateManager** and defining visual states for controls, see [Storyboarded animations for visual states](https://msdn.microsoft.com/library/windows/apps/xaml/jj819808) or [Quickstart: Control templates](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374).\n\n### Property-changed behavior\n\nProperty-changed behavior is the origin of the \"dependency\" part of dependency property terminology. Maintaining valid values for a property when another property can influence the first property's value is a difficult development problem in many frameworks. In the Windows Runtime property system, each dependency property can specify a callback that is invoked whenever its property value changes. This callback can be used to notify or change related property values, in a generally synchronous manner. Many existing dependency properties have a property-changed behavior. You can also add similar callback behavior to custom dependency properties, and implement your own property-changed callbacks. See [Custom dependency properties](custom-dependency-properties.md) for an example.\n\n### Default value and **ClearValue**\n\nA dependency property can have a default value defined as part of its property metadata. For a dependency property, its default value doesn't become irrelevant after the property's been set the first time. The default value might apply again at run-time whenever some other determinant in value precedence disappears. (Dependency property value precedence is discussed in the next section.) For example, you might deliberately remove a style value or an animation that applies to a property, but you want the value to be a reasonable default after you do so. The dependency property default value can provide this value, without needing to specifically set each property's value as an extra step.\n\nYou can deliberately set a property to the default value even after you have already set it with a local value. To reset a value to be the default again, and also to enable other participants in precedence that might override the default but not a local value, call the [**ClearValue**](https://msdn.microsoft.com/library/windows/apps/br242357) method (reference the property to clear as a method parameter). You don't always want the property to literally use the default value, but clearing the local value and reverting to the default value might enable another item in precedence that you want to act now, such as using the value that came from a style setter in a control template.\n\n## **DependencyObject** and threading\n\nAll [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) instances must be created on the UI thread which is associated with the current [**Window**](https://msdn.microsoft.com/library/windows/apps/br209041) that is shown by a Windows Runtime app. Although each **DependencyObject** must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by accessing the [**Dispatcher**](https://msdn.microsoft.com/library/windows/apps/br230616) property. Then you can call methods such as [**RunAsync**](https://msdn.microsoft.com/library/windows/apps/hh750317) on the [**CoreDispatcher**](https://msdn.microsoft.com/library/windows/apps/br208211) object, and execute your code within the rules of thread restrictions on the UI thread.\n\nThe threading aspects of [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356) are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property. Threading issues can usually be avoided in typical UI code that makes correct use of **async** patterns and background worker threads. You typically only run into **DependencyObject**-related threading issues if you are defining your own **DependencyObject** types and you attempt to use them for data sources or other scenarios where a **DependencyObject** isn't necessarily appropriate.\n\n## Related topics\n\n**Conceptual material**\n* [Custom dependency properties](custom-dependency-properties.md)\n* [Attached properties overview](attached-properties-overview.md)\n* [Data binding in depth](https://msdn.microsoft.com/library/windows/apps/mt210946)\n* [Storyboarded animations](https://msdn.microsoft.com/library/windows/apps/mt187354)\n* [Creating Windows Runtime components](https://msdn.microsoft.com/library/windows/apps/xaml/hh441572.aspx)\n* [XAML user and custom controls sample](http://go.microsoft.com/fwlink/p/?linkid=238581)\n**APIs related to dependency properties**\n* [**DependencyObject**](https://msdn.microsoft.com/library/windows/apps/br242356)\n* [**DependencyProperty**](https://msdn.microsoft.com/library/windows/apps/br242362)\n\n"}