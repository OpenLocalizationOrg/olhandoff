<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="zh-cn" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">f9be158bcfd777c2285ff8865063220fc13ae42c</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">description: Explains how to define and implement custom dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.</source>
          <target xml:space="preserve">description: Explains how to define and implement custom dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">title: Custom dependency properties</source>
          <target xml:space="preserve">title: Custom dependency properties</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: 5ADF7935-F2CF-4BB6-B1A5-F535C2ED8EF8</source>
          <target xml:space="preserve">ms.assetid: 5ADF7935-F2CF-4BB6-B1A5-F535C2ED8EF8</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">Custom dependency properties</source>
          <target xml:space="preserve">Custom dependency properties</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="106">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">Here we explain how to define and implement your own dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.</source>
          <target xml:space="preserve">Here we explain how to define and implement your own dependency properties for a Windows Runtime app using C++, C#, or Visual Basic.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source xml:space="preserve">We list reasons why app developers and component authors might want to create custom dependency properties.</source>
          <target xml:space="preserve">We list reasons why app developers and component authors might want to create custom dependency properties.</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">We describe the implementation steps for a custom dependency property, as well as some best practices that can improve performance, usability, or versatility of the dependency property.</source>
          <target xml:space="preserve">We describe the implementation steps for a custom dependency property, as well as some best practices that can improve performance, usability, or versatility of the dependency property.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">Prerequisites</source>
          <target xml:space="preserve">Prerequisites</target>
        </segment>
      </unit>
      <unit id="111">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](dependency-properties-overview.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">We assume that you have read the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc> and that you understand dependency properties from the perspective of a consumer of existing dependency properties.</source>
          <target xml:space="preserve">We assume that you have read the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc> and that you understand dependency properties from the perspective of a consumer of existing dependency properties.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C#, or Visual Basic.</source>
          <target xml:space="preserve">To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C#, or Visual Basic.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">What is a dependency property?</source>
          <target xml:space="preserve">What is a dependency property?</target>
        </segment>
      </unit>
      <unit id="114">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Dependency properties are properties that are registered with the Windows Runtime property system by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc> method, and that are identified by a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyProperty</pc></pc> identifier member on the defining class.</source>
          <target xml:space="preserve">Dependency properties are properties that are registered with the Windows Runtime property system by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc> method, and that are identified by a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyProperty</pc></pc> identifier member on the defining class.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source xml:space="preserve">You can enable what would otherwise be a common language runtime (CLR) or C++ property to support styling, data binding, animations, and default values by implementing it as a dependency property.</source>
          <target xml:space="preserve">You can enable what would otherwise be a common language runtime (CLR) or C++ property to support styling, data binding, animations, and default values by implementing it as a dependency property.</target>
        </segment>
      </unit>
      <unit id="116">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Dependency properties can be used only by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> types.</source>
          <target xml:space="preserve">Dependency properties can be used only by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> types.</target>
        </segment>
      </unit>
      <unit id="117">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> is quite high in the class hierarchy, so the majority of classes that are intended for UI and presentation support can support dependency properties.</source>
          <target xml:space="preserve">But <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> is quite high in the class hierarchy, so the majority of classes that are intended for UI and presentation support can support dependency properties.</target>
        </segment>
      </unit>
      <unit id="118">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](dependency-properties-overview.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more information about dependency properties and some of the terminology and conventions used for describing them in this documentation, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc>.</source>
          <target xml:space="preserve">For more information about dependency properties and some of the terminology and conventions used for describing them in this documentation, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc>.</target>
        </segment>
      </unit>
      <unit id="119">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209395)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208751)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/br209702)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Examples of dependency properties in the Windows Runtime are: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Background</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement.Width</pc></pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">TextBox.Text</pc></pc>, among many others.</source>
          <target xml:space="preserve">Examples of dependency properties in the Windows Runtime are: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Background</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement.Width</pc></pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">TextBox.Text</pc></pc>, among many others.</target>
        </segment>
      </unit>
      <unit id="120">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Each dependency property exposed by a class has a corresponding <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2">static</pc> <pc dataRefEnd="id6" dataRefStart="id5" id="p3">readonly</pc> property of type <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">DependencyProperty</pc></pc> that is exposed on that same class and that is the identifier for the dependency property.</source>
          <target xml:space="preserve">Each dependency property exposed by a class has a corresponding <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2">static</pc> <pc dataRefEnd="id6" dataRefStart="id5" id="p3">readonly</pc> property of type <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">DependencyProperty</pc></pc> that is exposed on that same class and that is the identifier for the dependency property.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">The identifier's name follows this convention: the name of the dependency property, with the string "Property" added to the end of the name.</source>
          <target xml:space="preserve">The identifier's name follows this convention: the name of the dependency property, with the string "Property" added to the end of the name.</target>
        </segment>
      </unit>
      <unit id="122">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209396)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, the corresponding <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyProperty</pc> identifier for the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Background</pc> property is <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Control.BackgroundProperty</pc></pc>.</source>
          <target xml:space="preserve">For example, the corresponding <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyProperty</pc> identifier for the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Background</pc> property is <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Control.BackgroundProperty</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="123">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The identifier stores the information about the dependency property as it was registered, and the identifier can then be used later for other operations involving the dependency property, such as calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc>.</source>
          <target xml:space="preserve">The identifier stores the information about the dependency property as it was registered, and the identifier can then be used later for other operations involving the dependency property, such as calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">Property wrappers</source>
          <target xml:space="preserve">Property wrappers</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">Dependency properties typically have a wrapper implementation.</source>
          <target xml:space="preserve">Dependency properties typically have a wrapper implementation.</target>
        </segment>
      </unit>
      <unit id="126">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Without the wrapper, the only way to get or set the properties would be to use the dependency property utility methods <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> and to pass the identifier to them as a parameter.</source>
          <target xml:space="preserve">Without the wrapper, the only way to get or set the properties would be to use the dependency property utility methods <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> and to pass the identifier to them as a parameter.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source xml:space="preserve">This is a rather unnatural usage for something that is ostensibly a property.</source>
          <target xml:space="preserve">This is a rather unnatural usage for something that is ostensibly a property.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">But with the wrapper, your code and any other code that references the dependency property can use a straightforward object-property syntax that is natural for the language you're using.</source>
          <target xml:space="preserve">But with the wrapper, your code and any other code that references the dependency property can use a straightforward object-property syntax that is natural for the language you're using.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source xml:space="preserve">If you implement a custom dependency property yourself and want it to be public and easy to call, define the property wrappers too.</source>
          <target xml:space="preserve">If you implement a custom dependency property yourself and want it to be public and easy to call, define the property wrappers too.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source xml:space="preserve">The property wrappers are also useful for reporting basic information about the dependency property to reflection or static analysis processes.</source>
          <target xml:space="preserve">The property wrappers are also useful for reporting basic information about the dependency property to reflection or static analysis processes.</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228011)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Specifically, the wrapper is where you place attributes such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentPropertyAttribute</pc></pc>.</source>
          <target xml:space="preserve">Specifically, the wrapper is where you place attributes such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentPropertyAttribute</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source xml:space="preserve">When to implement a property as a dependency property</source>
          <target xml:space="preserve">When to implement a property as a dependency property</target>
        </segment>
      </unit>
      <unit id="133">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Whenever you implement a public read/write property on a class, as long as your class derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>, you have the option to make your property work as a dependency property.</source>
          <target xml:space="preserve">Whenever you implement a public read/write property on a class, as long as your class derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>, you have the option to make your property work as a dependency property.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">Sometimes the typical technique of backing your property with a private field is adequate.</source>
          <target xml:space="preserve">Sometimes the typical technique of backing your property with a private field is adequate.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">Defining your custom property as a dependency property is not always necessary or appropriate.</source>
          <target xml:space="preserve">Defining your custom property as a dependency property is not always necessary or appropriate.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source xml:space="preserve">The choice will depend on the scenarios that you intend your property to support.</source>
          <target xml:space="preserve">The choice will depend on the scenarios that you intend your property to support.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">You might consider implementing your property as a dependency property when you want it to support one or more of these features of the Windows Runtime or of Windows Runtime apps:</source>
          <target xml:space="preserve">You might consider implementing your property as a dependency property when you want it to support one or more of these features of the Windows Runtime or of Windows Runtime apps:</target>
        </segment>
      </unit>
      <unit id="138">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Setting the property through a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc></source>
          <target xml:space="preserve">Setting the property through a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc></target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">Acting as valid target property for data binding</source>
          <target xml:space="preserve">Acting as valid target property for data binding</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210490)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Supporting animated values through a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboard</pc></pc></source>
          <target xml:space="preserve">Supporting animated values through a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboard</pc></pc></target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">Reporting when the previous value of the property has been changed by:</source>
          <target xml:space="preserve">Reporting when the previous value of the property has been changed by:</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source xml:space="preserve">Actions taken by the property system itself</source>
          <target xml:space="preserve">Actions taken by the property system itself</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">The environment</source>
          <target xml:space="preserve">The environment</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">User actions</source>
          <target xml:space="preserve">User actions</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source xml:space="preserve">Reading and writing styles</source>
          <target xml:space="preserve">Reading and writing styles</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source xml:space="preserve">Checklist for defining a dependency property</source>
          <target xml:space="preserve">Checklist for defining a dependency property</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source xml:space="preserve">Defining a dependency property can be thought of as a set of concepts.</source>
          <target xml:space="preserve">Defining a dependency property can be thought of as a set of concepts.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source xml:space="preserve">These concepts are not necessarily procedural steps, because several concepts can be addressed in a single line of code in the implementation.</source>
          <target xml:space="preserve">These concepts are not necessarily procedural steps, because several concepts can be addressed in a single line of code in the implementation.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source xml:space="preserve">This list gives just a quick overview.</source>
          <target xml:space="preserve">This list gives just a quick overview.</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source xml:space="preserve">We'll explain each concept in more detail later in this topic, and we'll show you example code in several languages.</source>
          <target xml:space="preserve">We'll explain each concept in more detail later in this topic, and we'll show you example code in several languages.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source xml:space="preserve">(Optional) Create property metadata for the dependency property.</source>
          <target xml:space="preserve">(Optional) Create property metadata for the dependency property.</target>
        </segment>
      </unit>
      <unit id="152">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242357)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You need property metadata only if you want property-changed behavior, or a metadata-based default value that can be restored by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc>.</source>
          <target xml:space="preserve">You need property metadata only if you want property-changed behavior, or a metadata-based default value that can be restored by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="153">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Register the property name with the property system (call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc>), specifying an owner type and the type of the property value.</source>
          <target xml:space="preserve">Register the property name with the property system (call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc>), specifying an owner type and the type of the property value.</target>
        </segment>
      </unit>
      <unit id="154">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">There's a required parameter for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> that expects property metadata.</source>
          <target xml:space="preserve">There's a required parameter for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> that expects property metadata.</target>
        </segment>
      </unit>
      <unit id="155">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> for this, or specify the actual property metadata if you have declared any.</source>
          <target xml:space="preserve">Specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> for this, or specify the actual property metadata if you have declared any.</target>
        </segment>
      </unit>
      <unit id="156">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> identifier as a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">public</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="p4">static</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="p5">readonly</pc> property member on the owner type.</source>
          <target xml:space="preserve">Define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> identifier as a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">public</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="p4">static</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="p5">readonly</pc> property member on the owner type.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source xml:space="preserve">Define a wrapper property, following the property accessor model that's used in the language you are implementing.</source>
          <target xml:space="preserve">Define a wrapper property, following the property accessor model that's used in the language you are implementing.</target>
        </segment>
      </unit>
      <unit id="158">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The wrapper property name should match the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">name</pc> string that you used in <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Register</pc></pc>.</source>
          <target xml:space="preserve">The wrapper property name should match the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">name</pc> string that you used in <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Register</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="159">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> accessors to connect the wrapper with the dependency property that it wraps, by calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetValue</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SetValue</pc></pc> and passing your own property's identifier as a parameter.</source>
          <target xml:space="preserve">Implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> accessors to connect the wrapper with the dependency property that it wraps, by calling <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetValue</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SetValue</pc></pc> and passing your own property's identifier as a parameter.</target>
        </segment>
      </unit>
      <unit id="160">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228011)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">(Optional) Place attributes such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentPropertyAttribute</pc></pc> on the wrapper.</source>
          <target xml:space="preserve">(Optional) Place attributes such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentPropertyAttribute</pc></pc> on the wrapper.</target>
        </segment>
      </unit>
      <unit id="161">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you are defining a custom attached property, you generally omit the wrapper.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you are defining a custom attached property, you generally omit the wrapper.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">Instead, you write a different style of accessor that a XAML processor can use.</source>
          <target xml:space="preserve">Instead, you write a different style of accessor that a XAML processor can use.</target>
        </segment>
      </unit>
      <unit id="163">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](custom-attached-properties.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom attached properties</pc>.</source>
          <target xml:space="preserve">See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom attached properties</pc>.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source xml:space="preserve">Registering the property</source>
          <target xml:space="preserve">Registering the property</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">For your property to be a dependency property, you must register the property into a property store maintained by the Windows Runtime property system.</source>
          <target xml:space="preserve">For your property to be a dependency property, you must register the property into a property store maintained by the Windows Runtime property system.</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source xml:space="preserve">You must give the property a unique identifier to be used as the qualifier for later property-system operations.</source>
          <target xml:space="preserve">You must give the property a unique identifier to be used as the qualifier for later property-system operations.</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source xml:space="preserve">These operations might be internal operations, or your own code calling property-system APIs.</source>
          <target xml:space="preserve">These operations might be internal operations, or your own code calling property-system APIs.</target>
        </segment>
      </unit>
      <unit id="168">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To register the property, you call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> method.</source>
          <target xml:space="preserve">To register the property, you call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> method.</target>
        </segment>
      </unit>
      <unit id="169">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Microsoft .NET languages (C# and Microsoft Visual Basic) you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> within the body of your class (inside the class, but outside any member definitions).</source>
          <target xml:space="preserve">For Microsoft .NET languages (C# and Microsoft Visual Basic) you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> within the body of your class (inside the class, but outside any member definitions).</target>
        </segment>
      </unit>
      <unit id="170">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The identifier is also provided by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> method call, as the return value.</source>
          <target xml:space="preserve">The identifier is also provided by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> method call, as the return value.</target>
        </segment>
      </unit>
      <unit id="171">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">[</data>
          <data id="id12">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
          <data id="id13">**</data>
          <data id="id14">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call is typically made outside of other member definitions because you use the return value to assign and create a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">public</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="p4">static</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="p5">readonly</pc> property of type <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">DependencyProperty</pc></pc> as part of your class.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call is typically made outside of other member definitions because you use the return value to assign and create a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">public</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="p4">static</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="p5">readonly</pc> property of type <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">DependencyProperty</pc></pc> as part of your class.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">This property becomes the identifier for your dependency property.</source>
          <target xml:space="preserve">This property becomes the identifier for your dependency property.</target>
        </segment>
      </unit>
      <unit id="173">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Here are examples of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call.</source>
          <target xml:space="preserve">Here are examples of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
          <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
        </segment>
      </unit>
      <unit id="175">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Registering the dependency property in a class body is the typical implementation, but you can also register a dependency property in the class static constructor.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Registering the dependency property in a class body is the typical implementation, but you can also register a dependency property in the class static constructor.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source xml:space="preserve">This approach may make sense if you need more than one line of code to initialize the dependency property.</source>
          <target xml:space="preserve">This approach may make sense if you need more than one line of code to initialize the dependency property.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source xml:space="preserve">For C++, you have options for how you split the implementation between the header and the code file.</source>
          <target xml:space="preserve">For C++, you have options for how you split the implementation between the header and the code file.</target>
        </segment>
      </unit>
      <unit id="178">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The typical split is to declare the identifier itself as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2">static</pc> property in the header, with a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">get</pc> implementation but no <pc dataRefEnd="id8" dataRefStart="id7" id="p4">set</pc>.</source>
          <target xml:space="preserve">The typical split is to declare the identifier itself as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">public</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2">static</pc> property in the header, with a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">get</pc> implementation but no <pc dataRefEnd="id8" dataRefStart="id7" id="p4">set</pc>.</target>
        </segment>
      </unit>
      <unit id="179">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> implementation refers to a private field, which is an uninitialized <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyProperty</pc></pc> instance.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> implementation refers to a private field, which is an uninitialized <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyProperty</pc></pc> instance.</target>
        </segment>
      </unit>
      <unit id="180">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can also declare the wrappers and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> implementations of the wrapper.</source>
          <target xml:space="preserve">You can also declare the wrappers and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> implementations of the wrapper.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">In this case the header includes some minimal implementation.</source>
          <target xml:space="preserve">In this case the header includes some minimal implementation.</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source xml:space="preserve">If the wrapper needs Windows Runtime attribution, attribute in the header too.</source>
          <target xml:space="preserve">If the wrapper needs Windows Runtime attribution, attribute in the header too.</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Put the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call in the code file, within a helper function that only gets run when the app initializes the first time.</source>
          <target xml:space="preserve">Put the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> call in the code file, within a helper function that only gets run when the app initializes the first time.</target>
        </segment>
      </unit>
      <unit id="184">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Use the return value of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Register</pc> to fill the static but uninitialized identifiers that you declared in the header, which you initially set to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">nullptr</pc> at the root scope of the implementation file.</source>
          <target xml:space="preserve">Use the return value of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Register</pc> to fill the static but uninitialized identifiers that you declared in the header, which you initially set to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">nullptr</pc> at the root scope of the implementation file.</target>
        </segment>
      </unit>
      <unit id="185">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For the C++ code, the reason why you have a private field and a public read-only property that surfaces the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyProperty</pc></pc> is so that other callers who use your dependency property can also use property-system utility APIs that require the identifier to be public.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For the C++ code, the reason why you have a private field and a public read-only property that surfaces the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyProperty</pc></pc> is so that other callers who use your dependency property can also use property-system utility APIs that require the identifier to be public.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">If you keep the identifier private, people can't use these utility APIs.</source>
          <target xml:space="preserve">If you keep the identifier private, people can't use these utility APIs.</target>
        </segment>
      </unit>
      <unit id="187">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/br242357)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">[</data>
          <data id="id14">](https://msdn.microsoft.com/library/windows/apps/br242358)</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
          <data id="id17">[</data>
          <data id="id18">](https://msdn.microsoft.com/library/windows/apps/br244257)</data>
          <data id="id19">**</data>
          <data id="id20">**</data>
          <data id="id21">[</data>
          <data id="id22">](https://msdn.microsoft.com/library/windows/apps/br208836)</data>
          <data id="id23">**</data>
          <data id="id24">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Examples of such API and scenarios include <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> by choice, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ClearValue</pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">GetAnimationBaseValue</pc></pc>, <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">SetBinding</pc></pc>, and <pc dataRefEnd="id22" dataRefStart="id21" id="p11"><pc dataRefEnd="id24" dataRefStart="id23" id="p12">Setter.Property</pc></pc>.</source>
          <target xml:space="preserve">Examples of such API and scenarios include <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> by choice, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ClearValue</pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">GetAnimationBaseValue</pc></pc>, <pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">SetBinding</pc></pc>, and <pc dataRefEnd="id22" dataRefStart="id21" id="p11"><pc dataRefEnd="id24" dataRefStart="id23" id="p12">Setter.Property</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="188">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can't use a public field for this, because Windows Runtime compile rules don't allow public data members that use reference types like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyProperty</pc>.</source>
          <target xml:space="preserve">You can't use a public field for this, because Windows Runtime compile rules don't allow public data members that use reference types like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyProperty</pc>.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source xml:space="preserve">Dependency property name conventions</source>
          <target xml:space="preserve">Dependency property name conventions</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source xml:space="preserve">There are naming conventions for dependency properties; follow them in all but exceptional circumstances.</source>
          <target xml:space="preserve">There are naming conventions for dependency properties; follow them in all but exceptional circumstances.</target>
        </segment>
      </unit>
      <unit id="191">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The dependency property itself has a basic name ("Label" in the preceding example) that is given as the first parameter of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc>.</source>
          <target xml:space="preserve">The dependency property itself has a basic name ("Label" in the preceding example) that is given as the first parameter of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source xml:space="preserve">The name must be unique within each registering type, and the uniqueness requirement also applies to any inherited members.</source>
          <target xml:space="preserve">The name must be unique within each registering type, and the uniqueness requirement also applies to any inherited members.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source xml:space="preserve">Dependency properties inherited through base types are considered to be part of the registering type already; names of inherited properties cannot be registered again.</source>
          <target xml:space="preserve">Dependency properties inherited through base types are considered to be part of the registering type already; names of inherited properties cannot be registered again.</target>
        </segment>
      </unit>
      <unit id="194">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  Although the name you provide here can be any string identifier that is valid in programming for your language of choice, you usually want to be able to set your dependency property in XAML too.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  Although the name you provide here can be any string identifier that is valid in programming for your language of choice, you usually want to be able to set your dependency property in XAML too.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source xml:space="preserve">To be set in XAML, the property name you choose must be a valid XAML name.</source>
          <target xml:space="preserve">To be set in XAML, the property name you choose must be a valid XAML name.</target>
        </segment>
      </unit>
      <unit id="196">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](xaml-overview.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML overview</pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML overview</pc>.</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source xml:space="preserve">When you create the identifier property, combine the name of the property as you registered it with the suffix "Property" ("LabelProperty", for example).</source>
          <target xml:space="preserve">When you create the identifier property, combine the name of the property as you registered it with the suffix "Property" ("LabelProperty", for example).</target>
        </segment>
      </unit>
      <unit id="198">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This property is your identifier for the dependency property, and it is used as an input for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetValue</pc></pc> calls you make in your own property wrappers.</source>
          <target xml:space="preserve">This property is your identifier for the dependency property, and it is used as an input for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetValue</pc></pc> calls you make in your own property wrappers.</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source xml:space="preserve">It is also used by the property system and potentially by XAML processors.</source>
          <target xml:space="preserve">It is also used by the property system and potentially by XAML processors.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source xml:space="preserve">Implementing the wrapper</source>
          <target xml:space="preserve">Implementing the wrapper</target>
        </segment>
      </unit>
      <unit id="201">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Your property wrapper should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">get</pc> implementation, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SetValue</pc></pc> in the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">set</pc> implementation.</source>
          <target xml:space="preserve">Your property wrapper should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">get</pc> implementation, and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SetValue</pc></pc> in the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">set</pc> implementation.</target>
        </segment>
      </unit>
      <unit id="202">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  In all but exceptional circumstances, your wrapper implementations should perform only the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">GetValue</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SetValue</pc></pc> operations.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Caution</pc>  In all but exceptional circumstances, your wrapper implementations should perform only the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">GetValue</pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">SetValue</pc></pc> operations.</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source xml:space="preserve">Otherwise, you'll get different behavior when your property is set via XAML versus when it is set via code.</source>
          <target xml:space="preserve">Otherwise, you'll get different behavior when your property is set via XAML versus when it is set via code.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source xml:space="preserve">For efficiency, the XAML parser bypasses wrappers when setting dependency properties; whenever possible, it uses the registry of dependency properties.</source>
          <target xml:space="preserve">For efficiency, the XAML parser bypasses wrappers when setting dependency properties; whenever possible, it uses the registry of dependency properties.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
          <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source xml:space="preserve">Property metadata for a custom dependency property</source>
          <target xml:space="preserve">Property metadata for a custom dependency property</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source xml:space="preserve">When property metadata is assigned to a dependency property, the same metadata is applied to that property for any instance of the property-owner type or its subclasses.</source>
          <target xml:space="preserve">When property metadata is assigned to a dependency property, the same metadata is applied to that property for any instance of the property-owner type or its subclasses.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source xml:space="preserve">In property metadata, you can specify two behaviors:</source>
          <target xml:space="preserve">In property metadata, you can specify two behaviors:</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source xml:space="preserve">A default value that the property system assigns to all cases of the property.</source>
          <target xml:space="preserve">A default value that the property system assigns to all cases of the property.</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source xml:space="preserve">A static callback method that is automatically invoked within the property system whenever a property value is detected.</source>
          <target xml:space="preserve">A static callback method that is automatically invoked within the property system whenever a property value is detected.</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source xml:space="preserve">Calling Register with property metadata</source>
          <target xml:space="preserve">Calling Register with property metadata</target>
        </segment>
      </unit>
      <unit id="212">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In the previous examples of calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc>, we passed a null value for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">propertyMetadata</pc> parameter.</source>
          <target xml:space="preserve">In the previous examples of calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc>, we passed a null value for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">propertyMetadata</pc> parameter.</target>
        </segment>
      </unit>
      <unit id="213">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To enable a dependency property to provide a default value or use a property-changed callback, you must define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> instance that provides one or both of these capabilities.</source>
          <target xml:space="preserve">To enable a dependency property to provide a default value or use a property-changed callback, you must define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> instance that provides one or both of these capabilities.</target>
        </segment>
      </unit>
      <unit id="214">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Typically you provide a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> as an inline-created instance, within the parameters for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyProperty.Register</pc></pc>.</source>
          <target xml:space="preserve">Typically you provide a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> as an inline-created instance, within the parameters for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyProperty.Register</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="215">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh701812)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/hh702099)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">[</data>
          <data id="id12">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
          <data id="id13">**</data>
          <data id="id14">**</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you are defining a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">CreateDefaultValueCallback</pc></pc> implementation, you must use the utility method <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">PropertyMetadata.Create</pc></pc> rather than calling a <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">PropertyMetadata</pc></pc> constructor to define the <pc dataRefEnd="id16" dataRefStart="id15" id="p8">PropertyMetadata</pc> instance.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you are defining a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">CreateDefaultValueCallback</pc></pc> implementation, you must use the utility method <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">PropertyMetadata.Create</pc></pc> rather than calling a <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">PropertyMetadata</pc></pc> constructor to define the <pc dataRefEnd="id16" dataRefStart="id15" id="p8">PropertyMetadata</pc> instance.</target>
        </segment>
      </unit>
      <unit id="216">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/br208770)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This next example modifies the previously shown <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc> examples by referencing a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata</pc></pc> instance with a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PropertyChangedCallback</pc></pc> value.</source>
          <target xml:space="preserve">This next example modifies the previously shown <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty.Register</pc></pc> examples by referencing a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata</pc></pc> instance with a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PropertyChangedCallback</pc></pc> value.</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source xml:space="preserve">The implementation of the "OnLabelChanged" callback will be shown later in this section.</source>
          <target xml:space="preserve">The implementation of the "OnLabelChanged" callback will be shown later in this section.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
          <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source xml:space="preserve">Default value</source>
          <target xml:space="preserve">Default value</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source xml:space="preserve">You can specify a default value for a dependency property such that the property always returns a particular default value when it is unset.</source>
          <target xml:space="preserve">You can specify a default value for a dependency property such that the property always returns a particular default value when it is unset.</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source xml:space="preserve">This value can be different than the inherent default value for the type of that property.</source>
          <target xml:space="preserve">This value can be different than the inherent default value for the type of that property.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source xml:space="preserve">If a default value is not specified, the default value for a dependency property is null for a reference type, or the default of the type for a value type or language primitive (for example, 0 for an integer or an empty string for a string).</source>
          <target xml:space="preserve">If a default value is not specified, the default value for a dependency property is null for a reference type, or the default of the type for a value type or language primitive (for example, 0 for an integer or an empty string for a string).</target>
        </segment>
      </unit>
      <unit id="223">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242357)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The main reason for establishing a default value is that this value is restored when you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc> on the property.</source>
          <target xml:space="preserve">The main reason for establishing a default value is that this value is restored when you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc> on the property.</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source xml:space="preserve">Establishing a default value on a per-property basis might be more convenient than establishing default values in constructors, particularly for value types.</source>
          <target xml:space="preserve">Establishing a default value on a per-property basis might be more convenient than establishing default values in constructors, particularly for value types.</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source xml:space="preserve">However, for reference types, make sure that establishing a default value does not create an unintentional singleton pattern.</source>
          <target xml:space="preserve">However, for reference types, make sure that establishing a default value does not create an unintentional singleton pattern.</target>
        </segment>
      </unit>
      <unit id="226">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#best-practices)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Best practices</pc> later in this topic</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Best practices</pc> later in this topic</target>
        </segment>
      </unit>
      <unit id="227">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242371)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Do not register with a default value of <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">UnsetValue</pc></pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Do not register with a default value of <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">UnsetValue</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source xml:space="preserve">If you do, it will confuse property consumers and will have unintended consequences within the property system.</source>
          <target xml:space="preserve">If you do, it will confuse property consumers and will have unintended consequences within the property system.</target>
        </segment>
      </unit>
      <unit id="229">
        <segment state="initial">
          <source xml:space="preserve">CreateDefaultValueCallback</source>
          <target xml:space="preserve">CreateDefaultValueCallback</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source xml:space="preserve">In some scenarios, you are defining dependency properties for objects that are used on more than one UI thread.</source>
          <target xml:space="preserve">In some scenarios, you are defining dependency properties for objects that are used on more than one UI thread.</target>
        </segment>
      </unit>
      <unit id="231">
        <segment state="initial">
          <source xml:space="preserve">This might be the case if you are defining a data object that is used by multiple apps, or a control that you use in more than one app.</source>
          <target xml:space="preserve">This might be the case if you are defining a data object that is used by multiple apps, or a control that you use in more than one app.</target>
        </segment>
      </unit>
      <unit id="232">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701812)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can enable the exchange of the object between different UI threads by providing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> implementation rather than a default value instance, which is tied to the thread that registered the property.</source>
          <target xml:space="preserve">You can enable the exchange of the object between different UI threads by providing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> implementation rather than a default value instance, which is tied to the thread that registered the property.</target>
        </segment>
      </unit>
      <unit id="233">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701812)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Basically a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> defines a factory for default values.</source>
          <target xml:space="preserve">Basically a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> defines a factory for default values.</target>
        </segment>
      </unit>
      <unit id="234">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The value returned by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDefaultValueCallback</pc> is always associated with the current UI <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc> thread that is using the object.</source>
          <target xml:space="preserve">The value returned by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateDefaultValueCallback</pc> is always associated with the current UI <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc> thread that is using the object.</target>
        </segment>
      </unit>
      <unit id="235">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701812)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh702115)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">**</data>
          <data id="id14">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To define metadata that specifies a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc>, you must call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata.Create</pc></pc> to return a metadata instance; the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PropertyMetadata</pc></pc> constructors do not have a signature that includes a <pc dataRefEnd="id14" dataRefStart="id13" id="p7">CreateDefaultValueCallback</pc> parameter.</source>
          <target xml:space="preserve">To define metadata that specifies a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc>, you must call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata.Create</pc></pc> to return a metadata instance; the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PropertyMetadata</pc></pc> constructors do not have a signature that includes a <pc dataRefEnd="id14" dataRefStart="id13" id="p7">CreateDefaultValueCallback</pc> parameter.</target>
        </segment>
      </unit>
      <unit id="236">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701812)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">**</data>
          <data id="id14">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The typical implementation pattern for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> is to create a new <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyObject</pc></pc> class, set the specific property value of each property of the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">DependencyObject</pc> to the intended default, and then return the new class as an <pc dataRefEnd="id12" dataRefStart="id11" id="p6">Object</pc> reference via the return value of the <pc dataRefEnd="id14" dataRefStart="id13" id="p7">CreateDefaultValueCallback</pc> method.</source>
          <target xml:space="preserve">The typical implementation pattern for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CreateDefaultValueCallback</pc></pc> is to create a new <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyObject</pc></pc> class, set the specific property value of each property of the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">DependencyObject</pc> to the intended default, and then return the new class as an <pc dataRefEnd="id12" dataRefStart="id11" id="p6">Object</pc> reference via the return value of the <pc dataRefEnd="id14" dataRefStart="id13" id="p7">CreateDefaultValueCallback</pc> method.</target>
        </segment>
      </unit>
      <unit id="237">
        <segment state="initial">
          <source xml:space="preserve">Property-changed callback method</source>
          <target xml:space="preserve">Property-changed callback method</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source xml:space="preserve">You can define a property-changed callback method to define your property's interactions with other dependency properties, or to set an internal property or state of your object whenever the property changes.</source>
          <target xml:space="preserve">You can define a property-changed callback method to define your property's interactions with other dependency properties, or to set an internal property or state of your object whenever the property changes.</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source xml:space="preserve">If your callback is invoked, the property system has determined that there is an effective property value change.</source>
          <target xml:space="preserve">If your callback is invoked, the property system has determined that there is an effective property value change.</target>
        </segment>
      </unit>
      <unit id="240">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Because the callback method is static, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d</pc> parameter of the callback is important because it tells you which instance of the class has reported a change.</source>
          <target xml:space="preserve">Because the callback method is static, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d</pc> parameter of the callback is important because it tells you which instance of the class has reported a change.</target>
        </segment>
      </unit>
      <unit id="241">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242364)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A typical implementation uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewValue</pc></pc> property of the event data and processes that value in some manner, usually by performing some other change on the object passed as <pc dataRefEnd="id6" dataRefStart="id5" id="p3">d</pc>.</source>
          <target xml:space="preserve">A typical implementation uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NewValue</pc></pc> property of the event data and processes that value in some manner, usually by performing some other change on the object passed as <pc dataRefEnd="id6" dataRefStart="id5" id="p3">d</pc>.</target>
        </segment>
      </unit>
      <unit id="242">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242365)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Additional responses to a property change are to reject the value reported by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewValue</pc>, to restore <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">OldValue</pc></pc>, or to set the value to a programmatic constraint applied to the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">NewValue</pc>.</source>
          <target xml:space="preserve">Additional responses to a property change are to reject the value reported by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NewValue</pc>, to restore <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">OldValue</pc></pc>, or to set the value to a programmatic constraint applied to the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">NewValue</pc>.</target>
        </segment>
      </unit>
      <unit id="243">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208770)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This next example shows a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyChangedCallback</pc></pc> implementation.</source>
          <target xml:space="preserve">This next example shows a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyChangedCallback</pc></pc> implementation.</target>
        </segment>
      </unit>
      <unit id="244">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">It implements the method you saw referenced in the previous <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> examples, as part of the construction arguments for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata</pc></pc>.</source>
          <target xml:space="preserve">It implements the method you saw referenced in the previous <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Register</pc></pc> examples, as part of the construction arguments for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PropertyMetadata</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="245">
        <segment state="initial">
          <source xml:space="preserve">The scenario addressed by this callback is that the class also has a calculated read-only property named "HasLabelValue" (implementation not shown).</source>
          <target xml:space="preserve">The scenario addressed by this callback is that the class also has a calculated read-only property named "HasLabelValue" (implementation not shown).</target>
        </segment>
      </unit>
      <unit id="246">
        <segment state="initial">
          <source xml:space="preserve">Whenever the "Label" property gets reevaluated, this callback method is invoked, and the callback enables the dependent calculated value to remain in synchronization with changes to the dependency property.</source>
          <target xml:space="preserve">Whenever the "Label" property gets reevaluated, this callback method is invoked, and the callback enables the dependent calculated value to remain in synchronization with changes to the dependency property.</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
          <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source xml:space="preserve">Property changed behavior for structures and enumerations</source>
          <target xml:space="preserve">Property changed behavior for structures and enumerations</target>
        </segment>
      </unit>
      <unit id="249">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If the type of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> is an enumeration or a structure, the callback may be invoked even if the internal values of the structure or the enumeration value did not change.</source>
          <target xml:space="preserve">If the type of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> is an enumeration or a structure, the callback may be invoked even if the internal values of the structure or the enumeration value did not change.</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source xml:space="preserve">This is different from a system primitive such as a string where it only is invoked if the value changed.</source>
          <target xml:space="preserve">This is different from a system primitive such as a string where it only is invoked if the value changed.</target>
        </segment>
      </unit>
      <unit id="251">
        <segment state="initial">
          <source xml:space="preserve">This is a side effect of box and unbox operations on these values that is done internally.</source>
          <target xml:space="preserve">This is a side effect of box and unbox operations on these values that is done internally.</target>
        </segment>
      </unit>
      <unit id="252">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208770)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242365)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/br242364)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you have a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyChangedCallback</pc></pc> method for a property where your value is an enumeration or structure, you need to compare the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OldValue</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">NewValue</pc></pc> by casting the values yourself and using the overloaded comparison operators that are available to the now-cast values.</source>
          <target xml:space="preserve">If you have a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyChangedCallback</pc></pc> method for a property where your value is an enumeration or structure, you need to compare the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OldValue</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">NewValue</pc></pc> by casting the values yourself and using the overloaded comparison operators that are available to the now-cast values.</target>
        </segment>
      </unit>
      <unit id="253">
        <segment state="initial">
          <source xml:space="preserve">Or, if no such operator is available (which might be the case for a custom structure), you may need to compare the individual values.</source>
          <target xml:space="preserve">Or, if no such operator is available (which might be the case for a custom structure), you may need to compare the individual values.</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source xml:space="preserve">You would typically choose to do nothing if the result is that the values have not changed.</source>
          <target xml:space="preserve">You would typically choose to do nothing if the result is that the values have not changed.</target>
        </segment>
      </unit>
      <unit id="255">
        <segment state="initial">
          <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
          <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
        </segment>
      </unit>
      <unit id="256">
        <segment state="initial">
          <source xml:space="preserve">Best practices</source>
          <target xml:space="preserve">Best practices</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source xml:space="preserve">Keep the following considerations in mind as best practices when as you define your custom dependency property.</source>
          <target xml:space="preserve">Keep the following considerations in mind as best practices when as you define your custom dependency property.</target>
        </segment>
      </unit>
      <unit id="258">
        <segment state="initial">
          <source xml:space="preserve">DependencyObject and threading</source>
          <target xml:space="preserve">DependencyObject and threading</target>
        </segment>
      </unit>
      <unit id="259">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209041)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">All <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> instances must be created on the UI thread which is associated with the current <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Window</pc></pc> that is shown by a Windows Runtime app.</source>
          <target xml:space="preserve">All <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> instances must be created on the UI thread which is associated with the current <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Window</pc></pc> that is shown by a Windows Runtime app.</target>
        </segment>
      </unit>
      <unit id="260">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br230616)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Although each <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Dispatcher</pc></pc>.</source>
          <target xml:space="preserve">Although each <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by calling <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Dispatcher</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="261">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The threading aspects of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property.</source>
          <target xml:space="preserve">The threading aspects of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property.</target>
        </segment>
      </unit>
      <unit id="262">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Threading issues can usually be avoided in typical UI code that makes correct use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> patterns and background worker threads.</source>
          <target xml:space="preserve">Threading issues can usually be avoided in typical UI code that makes correct use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> patterns and background worker threads.</target>
        </segment>
      </unit>
      <unit id="263">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You typically only run into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc>-related threading issues if you are defining your own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc> types and you attempt to use them for data sources or other scenarios where a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc> isn't necessarily appropriate.</source>
          <target xml:space="preserve">You typically only run into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc>-related threading issues if you are defining your own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc> types and you attempt to use them for data sources or other scenarios where a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc> isn't necessarily appropriate.</target>
        </segment>
      </unit>
      <unit id="264">
        <segment state="initial">
          <source xml:space="preserve">Avoiding unintentional singletons</source>
          <target xml:space="preserve">Avoiding unintentional singletons</target>
        </segment>
      </unit>
      <unit id="265">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">An unintentional singleton can happen if you are declaring a dependency property that takes a reference type, and you call a constructor for that reference type as part of the code that establishes your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc>.</source>
          <target xml:space="preserve">An unintentional singleton can happen if you are declaring a dependency property that takes a reference type, and you call a constructor for that reference type as part of the code that establishes your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="266">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">What happens is that all usages of the dependency property share just one instance of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PropertyMetadata</pc> and thus try to share the single reference type you constructed.</source>
          <target xml:space="preserve">What happens is that all usages of the dependency property share just one instance of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">PropertyMetadata</pc> and thus try to share the single reference type you constructed.</target>
        </segment>
      </unit>
      <unit id="267">
        <segment state="initial">
          <source xml:space="preserve">Any subproperties of that value type that you set through your dependency property then propagate to other objects in ways you probably don't intend.</source>
          <target xml:space="preserve">Any subproperties of that value type that you set through your dependency property then propagate to other objects in ways you probably don't intend.</target>
        </segment>
      </unit>
      <unit id="268">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](dependency-properties-overview.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can use class constructors to set initial values for a reference-type dependency property if you want a non-null value, but be aware that this would be considered a local value for purposes of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc>.</source>
          <target xml:space="preserve">You can use class constructors to set initial values for a reference-type dependency property if you want a non-null value, but be aware that this would be considered a local value for purposes of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dependency properties overview</pc>.</target>
        </segment>
      </unit>
      <unit id="269">
        <segment state="initial">
          <source xml:space="preserve">It might be more appropriate to use a template for this purpose, if your class supports templates.</source>
          <target xml:space="preserve">It might be more appropriate to use a template for this purpose, if your class supports templates.</target>
        </segment>
      </unit>
      <unit id="270">
        <segment state="initial">
          <source xml:space="preserve">Another way to avoid a singleton pattern, but still provide a useful default, is to expose a static property on the reference type that provides a suitable default for the values of that class.</source>
          <target xml:space="preserve">Another way to avoid a singleton pattern, but still provide a useful default, is to expose a static property on the reference type that provides a suitable default for the values of that class.</target>
        </segment>
      </unit>
      <unit id="271">
        <segment state="initial">
          <source xml:space="preserve">Collection-type dependency properties</source>
          <target xml:space="preserve">Collection-type dependency properties</target>
        </segment>
      </unit>
      <unit id="272">
        <segment state="initial">
          <source xml:space="preserve">Collection-type dependency properties have some additional implementation issues to consider.</source>
          <target xml:space="preserve">Collection-type dependency properties have some additional implementation issues to consider.</target>
        </segment>
      </unit>
      <unit id="273">
        <segment state="initial">
          <source xml:space="preserve">Collection-type dependency properties are relatively rare in the Windows Runtime API.</source>
          <target xml:space="preserve">Collection-type dependency properties are relatively rare in the Windows Runtime API.</target>
        </segment>
      </unit>
      <unit id="274">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In most cases, you can use collections where the items are a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> subclass, but the collection property itself is implemented as a conventional CLR or C++ property.</source>
          <target xml:space="preserve">In most cases, you can use collections where the items are a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> subclass, but the collection property itself is implemented as a conventional CLR or C++ property.</target>
        </segment>
      </unit>
      <unit id="275">
        <segment state="initial">
          <source xml:space="preserve">This is because collections do not necessarily suit some typical scenarios where dependency properties are involved.</source>
          <target xml:space="preserve">This is because collections do not necessarily suit some typical scenarios where dependency properties are involved.</target>
        </segment>
      </unit>
      <unit id="276">
        <segment state="initial">
          <source xml:space="preserve">For example:</source>
          <target xml:space="preserve">For example:</target>
        </segment>
      </unit>
      <unit id="277">
        <segment state="initial">
          <source xml:space="preserve">You do not typically animate a collection.</source>
          <target xml:space="preserve">You do not typically animate a collection.</target>
        </segment>
      </unit>
      <unit id="278">
        <segment state="initial">
          <source xml:space="preserve">You do not typically prepopulate the items in a collection with styles or a template.</source>
          <target xml:space="preserve">You do not typically prepopulate the items in a collection with styles or a template.</target>
        </segment>
      </unit>
      <unit id="279">
        <segment state="initial">
          <source xml:space="preserve">Although binding to collections is a major scenario, a collection does not need to be a dependency property to be a binding source.</source>
          <target xml:space="preserve">Although binding to collections is a major scenario, a collection does not need to be a dependency property to be a binding source.</target>
        </segment>
      </unit>
      <unit id="280">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242803)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242348)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For binding targets, it is more typical to use subclasses of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DataTemplate</pc></pc> to support collection items, or to use view-model patterns.</source>
          <target xml:space="preserve">For binding targets, it is more typical to use subclasses of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DataTemplate</pc></pc> to support collection items, or to use view-model patterns.</target>
        </segment>
      </unit>
      <unit id="281">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info about binding to and from collections, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</source>
          <target xml:space="preserve">For more info about binding to and from collections, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</target>
        </segment>
      </unit>
      <unit id="282">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](T:System.Collections.ObjectModel.ObservableCollection%601)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Notifications for collection changes are better addressed through interfaces such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">INotifyPropertyChanged</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc>, or by deriving the collection type from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ObservableCollection</pc></pc>.</source>
          <target xml:space="preserve">Notifications for collection changes are better addressed through interfaces such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">INotifyPropertyChanged</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc>, or by deriving the collection type from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ObservableCollection</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source xml:space="preserve">Nevertheless, scenarios for collection-type dependency properties do exist.</source>
          <target xml:space="preserve">Nevertheless, scenarios for collection-type dependency properties do exist.</target>
        </segment>
      </unit>
      <unit id="284">
        <segment state="initial">
          <source xml:space="preserve">The next three sections provide some guidance on how to implement a collection-type dependency property.</source>
          <target xml:space="preserve">The next three sections provide some guidance on how to implement a collection-type dependency property.</target>
        </segment>
      </unit>
      <unit id="285">
        <segment state="initial">
          <source xml:space="preserve">Initializing the collection</source>
          <target xml:space="preserve">Initializing the collection</target>
        </segment>
      </unit>
      <unit id="286">
        <segment state="initial">
          <source xml:space="preserve">When you create a dependency property, you can establish a default value by means of dependency property metadata.</source>
          <target xml:space="preserve">When you create a dependency property, you can establish a default value by means of dependency property metadata.</target>
        </segment>
      </unit>
      <unit id="287">
        <segment state="initial">
          <source xml:space="preserve">But be careful to not use a singleton static collection as the default value.</source>
          <target xml:space="preserve">But be careful to not use a singleton static collection as the default value.</target>
        </segment>
      </unit>
      <unit id="288">
        <segment state="initial">
          <source xml:space="preserve">Instead, you must deliberately set the collection value to a unique (instance) collection as part of class-constructor logic for the owner class of the collection property.</source>
          <target xml:space="preserve">Instead, you must deliberately set the collection value to a unique (instance) collection as part of class-constructor logic for the owner class of the collection property.</target>
        </segment>
      </unit>
      <unit id="289">
        <segment state="initial">
          <source xml:space="preserve">Change notifications</source>
          <target xml:space="preserve">Change notifications</target>
        </segment>
      </unit>
      <unit id="290">
        <segment state="initial">
          <source xml:space="preserve">Defining the collection as a dependency property does not automatically provide change notification for the items in the collection by virtue of the property system invoking the "PropertyChanged" callback method.</source>
          <target xml:space="preserve">Defining the collection as a dependency property does not automatically provide change notification for the items in the collection by virtue of the property system invoking the "PropertyChanged" callback method.</target>
        </segment>
      </unit>
      <unit id="291">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you want notifications for collections or collection items—for example, for a data-binding scenario— implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">INotifyPropertyChanged</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc> interface.</source>
          <target xml:space="preserve">If you want notifications for collections or collection items—for example, for a data-binding scenario— implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">INotifyPropertyChanged</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc> interface.</target>
        </segment>
      </unit>
      <unit id="292">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</target>
        </segment>
      </unit>
      <unit id="293">
        <segment state="initial">
          <source xml:space="preserve">Dependency property security considerations</source>
          <target xml:space="preserve">Dependency property security considerations</target>
        </segment>
      </unit>
      <unit id="294">
        <segment state="initial">
          <source xml:space="preserve">Declare dependency properties as public properties.</source>
          <target xml:space="preserve">Declare dependency properties as public properties.</target>
        </segment>
      </unit>
      <unit id="295">
        <segment state="initial">
          <source xml:space="preserve">Declare dependency property identifiers as public static read-only members.</source>
          <target xml:space="preserve">Declare dependency property identifiers as public static read-only members.</target>
        </segment>
      </unit>
      <unit id="296">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Even if you attempt to declare other access levels permitted by a language (such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">protected</pc>), a dependency property can always be accessed through the identifier in combination with the property-system APIs.</source>
          <target xml:space="preserve">Even if you attempt to declare other access levels permitted by a language (such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">protected</pc>), a dependency property can always be accessed through the identifier in combination with the property-system APIs.</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source xml:space="preserve">Declaring the dependency property identifier as internal or private will not work, because then the property system cannot operate properly.</source>
          <target xml:space="preserve">Declaring the dependency property identifier as internal or private will not work, because then the property system cannot operate properly.</target>
        </segment>
      </unit>
      <unit id="298">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242359)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Wrapper properties are really just for convenience, Security mechanisms applied to the wrappers can be bypassed by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> instead.</source>
          <target xml:space="preserve">Wrapper properties are really just for convenience, Security mechanisms applied to the wrappers can be bypassed by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetValue</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetValue</pc></pc> instead.</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source xml:space="preserve">So keep wrapper properties public; otherwise you just make your property harder for legitimate callers to use without providing any real security benefit.</source>
          <target xml:space="preserve">So keep wrapper properties public; otherwise you just make your property harder for legitimate callers to use without providing any real security benefit.</target>
        </segment>
      </unit>
      <unit id="300">
        <segment state="initial">
          <source xml:space="preserve">The Windows Runtime does not provide a way to register a custom dependency property as read-only.</source>
          <target xml:space="preserve">The Windows Runtime does not provide a way to register a custom dependency property as read-only.</target>
        </segment>
      </unit>
      <unit id="301">
        <segment state="initial">
          <source xml:space="preserve">Dependency properties and class constructors</source>
          <target xml:space="preserve">Dependency properties and class constructors</target>
        </segment>
      </unit>
      <unit id="302">
        <segment state="initial">
          <source xml:space="preserve">There is a general principle that class constructors should not call virtual methods.</source>
          <target xml:space="preserve">There is a general principle that class constructors should not call virtual methods.</target>
        </segment>
      </unit>
      <unit id="303">
        <segment state="initial">
          <source xml:space="preserve">This is because constructors can be called to accomplish base initialization of a derived class constructor, and entering the virtual method through the constructor might occur when the object instance being constructed is not yet completely initialized.</source>
          <target xml:space="preserve">This is because constructors can be called to accomplish base initialization of a derived class constructor, and entering the virtual method through the constructor might occur when the object instance being constructed is not yet completely initialized.</target>
        </segment>
      </unit>
      <unit id="304">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When you derive from any class that already derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>, remember that the property system itself calls and exposes virtual methods internally as part of its services.</source>
          <target xml:space="preserve">When you derive from any class that already derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>, remember that the property system itself calls and exposes virtual methods internally as part of its services.</target>
        </segment>
      </unit>
      <unit id="305">
        <segment state="initial">
          <source xml:space="preserve">To avoid potential problems with run-time initialization, don't set dependency property values within constructors of classes.</source>
          <target xml:space="preserve">To avoid potential problems with run-time initialization, don't set dependency property values within constructors of classes.</target>
        </segment>
      </unit>
      <unit id="306">
        <segment state="initial">
          <source xml:space="preserve">Registering the dependency properties for C++/CX apps</source>
          <target xml:space="preserve">Registering the dependency properties for C++/CX apps</target>
        </segment>
      </unit>
      <unit id="307">
        <segment state="initial">
          <source xml:space="preserve">The implementation for registering a property in C++/CX is trickier than C#C#, both because of the separation into header and implementation file and also because initialization at the root scope of the implementation file is a bad practice.</source>
          <target xml:space="preserve">The implementation for registering a property in C++/CX is trickier than C#C#, both because of the separation into header and implementation file and also because initialization at the root scope of the implementation file is a bad practice.</target>
        </segment>
      </unit>
      <unit id="308">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">(Visual C++ component extensions (C++/CX) puts static initializer code from the root scope directly into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DllMain</pc>, whereas C# compilers assign the static initializers to classes and thus avoid <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DllMain</pc> load lock issues.).</source>
          <target xml:space="preserve">(Visual C++ component extensions (C++/CX) puts static initializer code from the root scope directly into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DllMain</pc>, whereas C# compilers assign the static initializers to classes and thus avoid <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DllMain</pc> load lock issues.).</target>
        </segment>
      </unit>
      <unit id="309">
        <segment state="initial">
          <source xml:space="preserve">The best practice here is to declare a helper function that does all your dependency property registration for a class, one function per class.</source>
          <target xml:space="preserve">The best practice here is to declare a helper function that does all your dependency property registration for a class, one function per class.</target>
        </segment>
      </unit>
      <unit id="310">
        <segment state="initial">
          <source xml:space="preserve">Then for each custom class your app consumes, you'll have to reference the helper registration function that's exposed by each custom class you want to use.</source>
          <target xml:space="preserve">Then for each custom class your app consumes, you'll have to reference the helper registration function that's exposed by each custom class you want to use.</target>
        </segment>
      </unit>
      <unit id="311">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242325)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">`App::App()`</data>
          <data id="id6">`InitializeComponent`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Call each helper registration function once as part of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application constructor</pc></pc> (<ph dataRef="id5" id="ph1" />), prior to <ph dataRef="id6" id="ph2" />.</source>
          <target xml:space="preserve">Call each helper registration function once as part of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application constructor</pc></pc> (<ph dataRef="id5" id="ph1" />), prior to <ph dataRef="id6" id="ph2" />.</target>
        </segment>
      </unit>
      <unit id="312">
        <segment state="initial">
          <source xml:space="preserve">That constructor only runs when the app is really referenced for the first time, it won't run again if a suspended app resumes, for example.</source>
          <target xml:space="preserve">That constructor only runs when the app is really referenced for the first time, it won't run again if a suspended app resumes, for example.</target>
        </segment>
      </unit>
      <unit id="313">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh701829)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Also, as seen in the previous C++ registration example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">nullptr</pc> check around each <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Register</pc></pc> call is important: it's insurance that no caller of the function can register the property twice.</source>
          <target xml:space="preserve">Also, as seen in the previous C++ registration example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">nullptr</pc> check around each <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Register</pc></pc> call is important: it's insurance that no caller of the function can register the property twice.</target>
        </segment>
      </unit>
      <unit id="314">
        <segment state="initial">
          <source xml:space="preserve">A second registration call would probably crash your app without such a check because the property name would be a duplicate.</source>
          <target xml:space="preserve">A second registration call would probably crash your app without such a check because the property name would be a duplicate.</target>
        </segment>
      </unit>
      <unit id="315">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=238581)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can see this implementation pattern in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML user and custom controls sample</pc> if you look at the code for the C++/CX version of the sample.</source>
          <target xml:space="preserve">You can see this implementation pattern in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML user and custom controls sample</pc> if you look at the code for the C++/CX version of the sample.</target>
        </segment>
      </unit>
      <unit id="316">
        <segment state="initial">
          <source xml:space="preserve">Related topics</source>
          <target xml:space="preserve">Related topics</target>
        </segment>
      </unit>
      <unit id="317">
        <segment state="initial">
          <source xml:space="preserve">DependencyObject</source>
          <target xml:space="preserve">DependencyObject</target>
        </segment>
      </unit>
      <unit id="318">
        <segment state="initial">
          <source xml:space="preserve">DependencyProperty.Register</source>
          <target xml:space="preserve">DependencyProperty.Register</target>
        </segment>
      </unit>
      <unit id="319">
        <segment state="initial">
          <source xml:space="preserve">Dependency properties overview</source>
          <target xml:space="preserve">Dependency properties overview</target>
        </segment>
      </unit>
      <unit id="320">
        <segment state="initial">
          <source xml:space="preserve">XAML user and custom controls sample</source>
          <target xml:space="preserve">XAML user and custom controls sample</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>