<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="zh-cn" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">3fa7c0e3360635282968078432798793de8da191</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">Optimize your XAML markup</source>
          <target xml:space="preserve">Optimize your XAML markup</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="103">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">Parsing XAML markup to construct objects in memory is time-consuming for a complex UI.</source>
          <target xml:space="preserve">Parsing XAML markup to construct objects in memory is time-consuming for a complex UI.</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">Here are some things you can do to improve XAML markup parse and load time and memory efficiency for your app.</source>
          <target xml:space="preserve">Here are some things you can do to improve XAML markup parse and load time and memory efficiency for your app.</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source xml:space="preserve">At app startup, limit the XAML markup that is loaded to only what you need for your initial UI.</source>
          <target xml:space="preserve">At app startup, limit the XAML markup that is loaded to only what you need for your initial UI.</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">Examine the markup in your initial page and confirm it contains nothing that it doesn't need.</source>
          <target xml:space="preserve">Examine the markup in your initial page and confirm it contains nothing that it doesn't need.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source xml:space="preserve">If a page references a user control or a resource defined in a different file, then the framework parses that file, too.</source>
          <target xml:space="preserve">If a page references a user control or a resource defined in a different file, then the framework parses that file, too.</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">In this example, because InitialPage.xaml uses one resource from ExampleResourceDictionary.xaml, the whole of ExampleResourceDictionary.xaml must be parsed at startup.</source>
          <target xml:space="preserve">In this example, because InitialPage.xaml uses one resource from ExampleResourceDictionary.xaml, the whole of ExampleResourceDictionary.xaml must be parsed at startup.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">InitialPage.xaml.</source>
          <target xml:space="preserve">InitialPage.xaml.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">ExampleResourceDictionary.xaml.</source>
          <target xml:space="preserve">ExampleResourceDictionary.xaml.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">If you use a resource on many pages throughout your app, then storing it in App.xaml is a good practice, and avoids duplication.</source>
          <target xml:space="preserve">If you use a resource on many pages throughout your app, then storing it in App.xaml is a good practice, and avoids duplication.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">But App.xaml is parsed at app startup so any resource that is used in only one page (unless that page is the initial page) should be put into the page's local resources.</source>
          <target xml:space="preserve">But App.xaml is parsed at app startup so any resource that is used in only one page (unless that page is the initial page) should be put into the page's local resources.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">This counter-example shows App.xaml containing resources that are used by only one page (that's not the initial page).</source>
          <target xml:space="preserve">This counter-example shows App.xaml containing resources that are used by only one page (that's not the initial page).</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source xml:space="preserve">This needlessly increases app startup time.</source>
          <target xml:space="preserve">This needlessly increases app startup time.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">InitialPage.xaml.</source>
          <target xml:space="preserve">InitialPage.xaml.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">SecondPage.xaml.</source>
          <target xml:space="preserve">SecondPage.xaml.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">App.xaml</source>
          <target xml:space="preserve">App.xaml</target>
        </segment>
      </unit>
      <unit id="119">
        <originalData>
          <data id="id1">`SecondPageTextBrush`</data>
          <data id="id2">`ThirdPageTextBrush`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The way to make the above counter-example more efficient is to move <ph dataRef="id1" id="ph1" /> into SecondPage.xaml and to move <ph dataRef="id2" id="ph2" /> into ThirdPage.xaml.</source>
          <target xml:space="preserve">The way to make the above counter-example more efficient is to move <ph dataRef="id1" id="ph1" /> into SecondPage.xaml and to move <ph dataRef="id2" id="ph2" /> into ThirdPage.xaml.</target>
        </segment>
      </unit>
      <unit id="120">
        <originalData>
          <data id="id1">`InitialPageTextBrush`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<ph dataRef="id1" id="ph1" /> can remain in App.xaml because application resources must be parsed at app startup in any case.</source>
          <target xml:space="preserve">
						<ph dataRef="id1" id="ph1" /> can remain in App.xaml because application resources must be parsed at app startup in any case.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">Minimize element count</source>
          <target xml:space="preserve">Minimize element count</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">Although the XAML platform is capable of displaying large numbers of elements, you can make your app lay out and render faster by using the fewest number of elements to achieve the visuals you want.</source>
          <target xml:space="preserve">Although the XAML platform is capable of displaying large numbers of elements, you can make your app lay out and render faster by using the fewest number of elements to achieve the visuals you want.</target>
        </segment>
      </unit>
      <unit id="123">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227512)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243371)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Layout panels have a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Background</pc></pc> property so there's no need to put a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Rectangle</pc></pc> in front of a Panel just to color it.</source>
          <target xml:space="preserve">Layout panels have a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Background</pc></pc> property so there's no need to put a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Rectangle</pc></pc> in front of a Panel just to color it.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">Inefficient.</source>
          <target xml:space="preserve">Inefficient.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">Efficient.</source>
          <target xml:space="preserve">Efficient.</target>
        </segment>
      </unit>
      <unit id="126">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242752)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you reuse the same vector-based element enough times, it becomes more efficient to use an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image</pc></pc> element instead.</source>
          <target xml:space="preserve">If you reuse the same vector-based element enough times, it becomes more efficient to use an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image</pc></pc> element instead.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source xml:space="preserve">Vector-based elements can be more expensive because the CPU must create each individual element separately.</source>
          <target xml:space="preserve">Vector-based elements can be more expensive because the CPU must create each individual element separately.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">The image file needs to be decoded only once.</source>
          <target xml:space="preserve">The image file needs to be decoded only once.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source xml:space="preserve">Consolidate multiple brushes that look the same into one resource</source>
          <target xml:space="preserve">Consolidate multiple brushes that look the same into one resource</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source xml:space="preserve">The XAML platform tries to cache commonly-used objects so that they can be reused as often as possible.</source>
          <target xml:space="preserve">The XAML platform tries to cache commonly-used objects so that they can be reused as often as possible.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source xml:space="preserve">But XAML cannot easily tell if a brush declared in one piece of markup is the same as a brush declared in another.</source>
          <target xml:space="preserve">But XAML cannot easily tell if a brush declared in one piece of markup is the same as a brush declared in another.</target>
        </segment>
      </unit>
      <unit id="132">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242962)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR210068)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The example here uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SolidColorBrush</pc></pc> to demonstrate, but the case is more likely and more important with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GradientBrush</pc></pc>.</source>
          <target xml:space="preserve">The example here uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SolidColorBrush</pc></pc> to demonstrate, but the case is more likely and more important with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GradientBrush</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">Inefficient.</source>
          <target xml:space="preserve">Inefficient.</target>
        </segment>
      </unit>
      <unit id="134">
        <originalData>
          <data id="id1">`"Orange"`</data>
          <data id="id2">`"#FFFFA500"`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Also check for brushes that use predefined colors: <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> are the same color.</source>
          <target xml:space="preserve">Also check for brushes that use predefined colors: <ph dataRef="id1" id="ph1" /> and <ph dataRef="id2" id="ph2" /> are the same color.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">To fix the duplication, define the brush as a resource.</source>
          <target xml:space="preserve">To fix the duplication, define the brush as a resource.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source xml:space="preserve">If controls in other pages use the same brush, move it to App.xaml.</source>
          <target xml:space="preserve">If controls in other pages use the same brush, move it to App.xaml.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">Efficient.</source>
          <target xml:space="preserve">Efficient.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source xml:space="preserve">Minimize overdrawing</source>
          <target xml:space="preserve">Minimize overdrawing</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">Overdrawing is where more than one object is drawn in the same screen pixels.</source>
          <target xml:space="preserve">Overdrawing is where more than one object is drawn in the same screen pixels.</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source xml:space="preserve">Note that there is sometimes a trade-off between this guidance and the desire to minimize element count.</source>
          <target xml:space="preserve">Note that there is sometimes a trade-off between this guidance and the desire to minimize element count.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">If an element isn't visible because it's transparent or hidden behind other elements, and it's not contributing to layout, then delete it.</source>
          <target xml:space="preserve">If an element isn't visible because it's transparent or hidden behind other elements, and it's not contributing to layout, then delete it.</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208992)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If the element is not visible in the initial visual state but it is visible in other visual states then set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visibility</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Collapsed</pc> on the element itself and change the value to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visible</pc> in the appropriate states.</source>
          <target xml:space="preserve">If the element is not visible in the initial visual state but it is visible in other visual states then set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visibility</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Collapsed</pc> on the element itself and change the value to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visible</pc> in the appropriate states.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">There will be exceptions to this heuristic: in general, the value a property has in the major of visual states is best set locally on the element.</source>
          <target xml:space="preserve">There will be exceptions to this heuristic: in general, the value a property has in the major of visual states is best set locally on the element.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">Use a composite element instead of layering multiple elements to create an effect.</source>
          <target xml:space="preserve">Use a composite element instead of layering multiple elements to create an effect.</target>
        </segment>
      </unit>
      <unit id="145">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242704)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243371)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In this example, the result is a two-toned shape where the top half is black (from the background of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Grid</pc></pc>) and the bottom half is gray (from the semi-transparent white <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Rectangle</pc></pc> alpha-blended over the black background of the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Grid</pc>).</source>
          <target xml:space="preserve">In this example, the result is a two-toned shape where the top half is black (from the background of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Grid</pc></pc>) and the bottom half is gray (from the semi-transparent white <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Rectangle</pc></pc> alpha-blended over the black background of the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Grid</pc>).</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source xml:space="preserve">Here, 150% of the pixels necessary to achieve the result are being filled.</source>
          <target xml:space="preserve">Here, 150% of the pixels necessary to achieve the result are being filled.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source xml:space="preserve">Inefficient.</source>
          <target xml:space="preserve">Inefficient.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source xml:space="preserve">Efficient.</source>
          <target xml:space="preserve">Efficient.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source xml:space="preserve">A layout panel can have two purposes: to color an area, and to lay out child elements.</source>
          <target xml:space="preserve">A layout panel can have two purposes: to color an area, and to lay out child elements.</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source xml:space="preserve">If an element further back in z-order is already coloring an area then a layout panel in front does not need to paint that area: instead it can just focus on laying out its children.</source>
          <target xml:space="preserve">If an element further back in z-order is already coloring an area then a layout panel in front does not need to paint that area: instead it can just focus on laying out its children.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source xml:space="preserve">Here's an example.</source>
          <target xml:space="preserve">Here's an example.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source xml:space="preserve">Inefficient.</source>
          <target xml:space="preserve">Inefficient.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source xml:space="preserve">Efficient.</source>
          <target xml:space="preserve">Efficient.</target>
        </segment>
      </unit>
      <unit id="154">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242704)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Grid</pc></pc> has to be hit-testable then set a background value of transparent on it.</source>
          <target xml:space="preserve">If the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Grid</pc></pc> has to be hit-testable then set a background value of transparent on it.</target>
        </segment>
      </unit>
      <unit id="155">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209253)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Border</pc></pc> element to draw a border around an object.</source>
          <target xml:space="preserve">Use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Border</pc></pc> element to draw a border around an object.</target>
        </segment>
      </unit>
      <unit id="156">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242704)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209683)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In this example, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Grid</pc></pc> is used as a makeshift border around a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBox</pc></pc>.</source>
          <target xml:space="preserve">In this example, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Grid</pc></pc> is used as a makeshift border around a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBox</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source xml:space="preserve">But all the pixels in the center cell are overdrawn.</source>
          <target xml:space="preserve">But all the pixels in the center cell are overdrawn.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">Inefficient.</source>
          <target xml:space="preserve">Inefficient.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source xml:space="preserve">Efficient.</source>
          <target xml:space="preserve">Efficient.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source xml:space="preserve">Be aware of margins.</source>
          <target xml:space="preserve">Be aware of margins.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source xml:space="preserve">Two neighboring elements will overlap (possibly accidentally) if negative margins extend into another’s render bounds and cause overdrawing.</source>
          <target xml:space="preserve">Two neighboring elements will overlap (possibly accidentally) if negative margins extend into another’s render bounds and cause overdrawing.</target>
        </segment>
      </unit>
      <unit id="162">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh701823)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DebugSettings.IsOverdrawHeatMapEnabled</pc></pc> as a visual diagnostic.</source>
          <target xml:space="preserve">Use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DebugSettings.IsOverdrawHeatMapEnabled</pc></pc> as a visual diagnostic.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source xml:space="preserve">You may find objects being drawn that you weren't aware were in the scene.</source>
          <target xml:space="preserve">You may find objects being drawn that you weren't aware were in the scene.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source xml:space="preserve">Cache static content</source>
          <target xml:space="preserve">Cache static content</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">Another source of overdrawing is a shape made from many overlapping elements.</source>
          <target xml:space="preserve">Another source of overdrawing is a shape made from many overlapping elements.</target>
        </segment>
      </unit>
      <unit id="166">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228084)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR208911)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CacheMode</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">BitmapCache</pc> on the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">UIElement</pc></pc> that contains the composite shape then the platform renders the element to a bitmap once and then uses that bitmap each frame instead of overdrawing.</source>
          <target xml:space="preserve">If you set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CacheMode</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">BitmapCache</pc> on the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">UIElement</pc></pc> that contains the composite shape then the platform renders the element to a bitmap once and then uses that bitmap each frame instead of overdrawing.</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source xml:space="preserve">Inefficient.</source>
          <target xml:space="preserve">Inefficient.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source xml:space="preserve">Venn diagram with three solid circles</source>
          <target xml:space="preserve">Venn diagram with three solid circles</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source xml:space="preserve">The image above is the result, but here's a map of the overdrawn regions.</source>
          <target xml:space="preserve">The image above is the result, but here's a map of the overdrawn regions.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source xml:space="preserve">Darker red indicates higher amounts of overdraw.</source>
          <target xml:space="preserve">Darker red indicates higher amounts of overdraw.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source xml:space="preserve">Venn diagram that shows overlapping areas</source>
          <target xml:space="preserve">Venn diagram that shows overlapping areas</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">Efficient.</source>
          <target xml:space="preserve">Efficient.</target>
        </segment>
      </unit>
      <unit id="173">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228084)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Note the use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CacheMode</pc></pc>.</source>
          <target xml:space="preserve">Note the use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CacheMode</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source xml:space="preserve">Don't use this technique if any of the sub-shapes animate because the bitmap cache will likely need to be regenerated every frame, defeating the purpose.</source>
          <target xml:space="preserve">Don't use this technique if any of the sub-shapes animate because the bitmap cache will likely need to be regenerated every frame, defeating the purpose.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">ResourceDictionaries</source>
          <target xml:space="preserve">ResourceDictionaries</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source xml:space="preserve">ResourceDictionaries are generally used to store your resources at a somewhat global level.</source>
          <target xml:space="preserve">ResourceDictionaries are generally used to store your resources at a somewhat global level.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source xml:space="preserve">Resources that your app wants to reference in multiple places.</source>
          <target xml:space="preserve">Resources that your app wants to reference in multiple places.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source xml:space="preserve">For example, styles, brushes, templates, and so on.</source>
          <target xml:space="preserve">For example, styles, brushes, templates, and so on.</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source xml:space="preserve">In general, we have optimized ResourceDictionaries to not instantiate resources unless they're asked for.</source>
          <target xml:space="preserve">In general, we have optimized ResourceDictionaries to not instantiate resources unless they're asked for.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source xml:space="preserve">But there are few places where you need to be a little careful.</source>
          <target xml:space="preserve">But there are few places where you need to be a little careful.</target>
        </segment>
      </unit>
      <unit id="181">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Resource with x:Name</pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Resource with x:Name</pc>.</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source xml:space="preserve">Any resource with x:Name will not benefit from the platform optimization, but instead it will be instantiated as soon as the ResourceDictionary is created.</source>
          <target xml:space="preserve">Any resource with x:Name will not benefit from the platform optimization, but instead it will be instantiated as soon as the ResourceDictionary is created.</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source xml:space="preserve">This happens because x:Name tells the platform that your app needs field access to this resource, so the platform needs to create something to create a reference to.</source>
          <target xml:space="preserve">This happens because x:Name tells the platform that your app needs field access to this resource, so the platform needs to create something to create a reference to.</target>
        </segment>
      </unit>
      <unit id="184">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionaries in a UserControl</pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionaries in a UserControl</pc>.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source xml:space="preserve">ResourceDictionaries defined inside of a UserControl carry a penalty.</source>
          <target xml:space="preserve">ResourceDictionaries defined inside of a UserControl carry a penalty.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">The platform will create a copy of such a ResourceDictionary for every instance of the UserControl.</source>
          <target xml:space="preserve">The platform will create a copy of such a ResourceDictionary for every instance of the UserControl.</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source xml:space="preserve">If you have a UserControl that is used a lot, then move the ResourceDictionary out of the UserControl and put it the page level.</source>
          <target xml:space="preserve">If you have a UserControl that is used a lot, then move the ResourceDictionary out of the UserControl and put it the page level.</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source xml:space="preserve">Use XBF2</source>
          <target xml:space="preserve">Use XBF2</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source xml:space="preserve">XBF2 is a binary representation of XAML markup that avoids all text-parsing costs at runtime.</source>
          <target xml:space="preserve">XBF2 is a binary representation of XAML markup that avoids all text-parsing costs at runtime.</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source xml:space="preserve">It also optimizes your binary for load and tree creation, and allows "fast-path" for XAML types to improve heap and object creation costs, for example VSM, ResourceDictionary, Styles, and so on.</source>
          <target xml:space="preserve">It also optimizes your binary for load and tree creation, and allows "fast-path" for XAML types to improve heap and object creation costs, for example VSM, ResourceDictionary, Styles, and so on.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source xml:space="preserve">It is completely memory-mapped so there is no heap footprint for loading and reading a XAML Page.</source>
          <target xml:space="preserve">It is completely memory-mapped so there is no heap footprint for loading and reading a XAML Page.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source xml:space="preserve">In addition, it reduces the disk footprint of stored XAML pages in an appx.</source>
          <target xml:space="preserve">In addition, it reduces the disk footprint of stored XAML pages in an appx.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source xml:space="preserve">XBF2 is a more compact representation and it can reduce disk footprint of comparative XAML/XBF1 files by up to 50%.</source>
          <target xml:space="preserve">XBF2 is a more compact representation and it can reduce disk footprint of comparative XAML/XBF1 files by up to 50%.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source xml:space="preserve">For example, the built-in Photos app saw around a 60% reduction after conversion to XBF2 dropping from around ~1mb of XBF1 assets to ~400kb of XBF2 assets.</source>
          <target xml:space="preserve">For example, the built-in Photos app saw around a 60% reduction after conversion to XBF2 dropping from around ~1mb of XBF1 assets to ~400kb of XBF2 assets.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source xml:space="preserve">We have also seen apps benefit anywhere from 15 to 20% in CPU and 10 to 15% in Win32 heap.</source>
          <target xml:space="preserve">We have also seen apps benefit anywhere from 15 to 20% in CPU and 10 to 15% in Win32 heap.</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source xml:space="preserve">XAML built-in controls and dictionaries that the framework provides are already fully XBF2-enabled.</source>
          <target xml:space="preserve">XAML built-in controls and dictionaries that the framework provides are already fully XBF2-enabled.</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source xml:space="preserve">For your own app, ensure that your project file declares TargetPlatformVersion 8.2 or later.</source>
          <target xml:space="preserve">For your own app, ensure that your project file declares TargetPlatformVersion 8.2 or later.</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source xml:space="preserve">To check whether you have XBF2, open your app in a binary editor; the 12th and 13th bytes are 00 02 if you have XBF2.</source>
          <target xml:space="preserve">To check whether you have XBF2, open your app in a binary editor; the 12th and 13th bytes are 00 02 if you have XBF2.</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>