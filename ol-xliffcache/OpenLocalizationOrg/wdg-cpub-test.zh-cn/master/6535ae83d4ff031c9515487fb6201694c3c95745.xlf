<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="zh-cn" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">6535ae83d4ff031c9515487fb6201694c3c95745</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">description: This topic explains the dependency property system that is available when you write a Windows Runtime app using C++, C#, or Visual Basic along with XAML definitions for UI.</source>
          <target xml:space="preserve">description: This topic explains the dependency property system that is available when you write a Windows Runtime app using C++, C#, or Visual Basic along with XAML definitions for UI.</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">title: Dependency properties overview</source>
          <target xml:space="preserve">title: Dependency properties overview</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: AD649E66-F71C-4DAA-9994-617C886FDA7E</source>
          <target xml:space="preserve">ms.assetid: AD649E66-F71C-4DAA-9994-617C886FDA7E</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">Dependency properties overview</source>
          <target xml:space="preserve">Dependency properties overview</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="106">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">This topic explains the dependency property system that is available when you write a Windows Runtime app using C++, C#, or Visual Basic along with XAML definitions for UI.</source>
          <target xml:space="preserve">This topic explains the dependency property system that is available when you write a Windows Runtime app using C++, C#, or Visual Basic along with XAML definitions for UI.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source xml:space="preserve">What is a dependency property?</source>
          <target xml:space="preserve">What is a dependency property?</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">A dependency property is a specialized type of property.</source>
          <target xml:space="preserve">A dependency property is a specialized type of property.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">Specifically it's a property where the property's value is tracked and influenced by a dedicated property system that is part of the Windows Runtime.</source>
          <target xml:space="preserve">Specifically it's a property where the property's value is tracked and influenced by a dedicated property system that is part of the Windows Runtime.</target>
        </segment>
      </unit>
      <unit id="111">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In order to support a dependency property, the object that defines the property must be a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> (in other words a class that has the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc> base class somewhere in its inheritance).</source>
          <target xml:space="preserve">In order to support a dependency property, the object that defines the property must be a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> (in other words a class that has the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc> base class somewhere in its inheritance).</target>
        </segment>
      </unit>
      <unit id="112">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Many of the types you use for your UI definitions for a Windows Store app with XAML will be a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> subclass, and will support dependency properties.</source>
          <target xml:space="preserve">Many of the types you use for your UI definitions for a Windows Store app with XAML will be a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> subclass, and will support dependency properties.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">However, any type that comes from a Windows Runtime namespace that doesn't have "XAML" in its name won't support dependency properties; properties of such types are ordinary properties that won't have the property system's dependency behavior.</source>
          <target xml:space="preserve">However, any type that comes from a Windows Runtime namespace that doesn't have "XAML" in its name won't support dependency properties; properties of such types are ordinary properties that won't have the property system's dependency behavior.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">The purpose of dependency properties is to provide a systemic way to compute the value of a property based on other inputs (other properties, events and states that occur within your app while it runs).</source>
          <target xml:space="preserve">The purpose of dependency properties is to provide a systemic way to compute the value of a property based on other inputs (other properties, events and states that occur within your app while it runs).</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source xml:space="preserve">These other inputs might include:</source>
          <target xml:space="preserve">These other inputs might include:</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">External input such as user preference</source>
          <target xml:space="preserve">External input such as user preference</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">Just-in-time property determination mechanisms such as data binding, animations and storyboards</source>
          <target xml:space="preserve">Just-in-time property determination mechanisms such as data binding, animations and storyboards</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">Multiple-use templating patterns such as resources and styles</source>
          <target xml:space="preserve">Multiple-use templating patterns such as resources and styles</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">Values known through parent-child relationships with other elements in the object tree</source>
          <target xml:space="preserve">Values known through parent-child relationships with other elements in the object tree</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">A dependency property represents or supports a specific feature of the programming model for defining a Windows Runtime app with XAML for UI and C#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) for code.</source>
          <target xml:space="preserve">A dependency property represents or supports a specific feature of the programming model for defining a Windows Runtime app with XAML for UI and C#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) for code.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">These features include:</source>
          <target xml:space="preserve">These features include:</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">Data binding</source>
          <target xml:space="preserve">Data binding</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">Styles</source>
          <target xml:space="preserve">Styles</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">Storyboarded animations</source>
          <target xml:space="preserve">Storyboarded animations</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">"PropertyChanged" behavior; a dependency property can be implemented to provide callbacks that can propagate changes to other dependency properties</source>
          <target xml:space="preserve">"PropertyChanged" behavior; a dependency property can be implemented to provide callbacks that can propagate changes to other dependency properties</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source xml:space="preserve">Using a default value that comes from property metadata</source>
          <target xml:space="preserve">Using a default value that comes from property metadata</target>
        </segment>
      </unit>
      <unit id="127">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242357)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">General property system utility such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc> and metadata lookup</source>
          <target xml:space="preserve">General property system utility such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc> and metadata lookup</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">Dependency properties and Windows Runtime properties</source>
          <target xml:space="preserve">Dependency properties and Windows Runtime properties</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source xml:space="preserve">Dependency properties extend basic Windows Runtime property functionality by providing a global, internal property store that backs all of the dependency properties in an app at run time.</source>
          <target xml:space="preserve">Dependency properties extend basic Windows Runtime property functionality by providing a global, internal property store that backs all of the dependency properties in an app at run time.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source xml:space="preserve">This is an alternative to the standard pattern of backing a property with a private field that's private in the property-definition class.</source>
          <target xml:space="preserve">This is an alternative to the standard pattern of backing a property with a private field that's private in the property-definition class.</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can think of this internal property store as being a set of property identifiers and values that exist for any particular object (so long as it's a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>).</source>
          <target xml:space="preserve">You can think of this internal property store as being a set of property identifiers and values that exist for any particular object (so long as it's a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>).</target>
        </segment>
      </unit>
      <unit id="132">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Rather than being identified by name, each property in the store is identified by a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> instance.</source>
          <target xml:space="preserve">Rather than being identified by name, each property in the store is identified by a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> instance.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">However, the property system mostly hides this implementation detail: you can usually access dependency properties by using a simple name (the programmatic property name in the code language you're using, or an attribute name when you're writing XAML).</source>
          <target xml:space="preserve">However, the property system mostly hides this implementation detail: you can usually access dependency properties by using a simple name (the programmatic property name in the code language you're using, or an attribute name when you're writing XAML).</target>
        </segment>
      </unit>
      <unit id="134">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The base type that provides the underpinnings of the dependency property system is <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>.</source>
          <target xml:space="preserve">The base type that provides the underpinnings of the dependency property system is <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="135">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> defines methods that can access the dependency property, and instances of a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc> derived class internally support the property store concept we mentioned earlier.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> defines methods that can access the dependency property, and instances of a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc> derived class internally support the property store concept we mentioned earlier.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source xml:space="preserve">Here is a summation of the terminology that we use in the documentation when discussing dependency properties:</source>
          <target xml:space="preserve">Here is a summation of the terminology that we use in the documentation when discussing dependency properties:</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">Term</source>
          <target xml:space="preserve">Term</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source xml:space="preserve">Description</source>
          <target xml:space="preserve">Description</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">Dependency property</source>
          <target xml:space="preserve">Dependency property</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242362)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A property that exists on a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> identifier (see below).</source>
          <target xml:space="preserve">A property that exists on a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyProperty</pc></pc> identifier (see below).</target>
        </segment>
      </unit>
      <unit id="141">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Usually this identifier is available as a static member of the defining <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> derived class.</source>
          <target xml:space="preserve">Usually this identifier is available as a static member of the defining <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> derived class.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source xml:space="preserve">Dependency property identifier</source>
          <target xml:space="preserve">Dependency property identifier</target>
        </segment>
      </unit>
      <unit id="143">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc>, that's why it is typically public even though it is read-only.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetValue</pc></pc>, that's why it is typically public even though it is read-only.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">Property wrapper</source>
          <target xml:space="preserve">Property wrapper</target>
        </segment>
      </unit>
      <unit id="145">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The callable <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> implementations for a Windows Runtime property.</source>
          <target xml:space="preserve">The callable <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">set</pc> implementations for a Windows Runtime property.</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source xml:space="preserve">Or, the language-specific projection of the original definition.</source>
          <target xml:space="preserve">Or, the language-specific projection of the original definition.</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> property wrapper implementation calls <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SetValue</pc></pc>, passing the relevant dependency property identifier as one input and the value to set as the second input.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">get</pc> property wrapper implementation calls <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SetValue</pc></pc>, passing the relevant dependency property identifier as one input and the value to set as the second input.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source xml:space="preserve">The property wrapper is not just convenience for callers, it also exposes the dependency property to any process, tool or projection that uses Windows Runtime definitions for properties.</source>
          <target xml:space="preserve">The property wrapper is not just convenience for callers, it also exposes the dependency property to any process, tool or projection that uses Windows Runtime definitions for properties.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source xml:space="preserve">The following example defines a custom "IsSpinning" dependency property as defined for C#, and shows the relationship of the dependency property identifier to the property wrapper.</source>
          <target xml:space="preserve">The following example defines a custom "IsSpinning" dependency property as defined for C#, and shows the relationship of the dependency property identifier to the property wrapper.</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The preceding example is not intended as the complete example for how to create a custom dependency property.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The preceding example is not intended as the complete example for how to create a custom dependency property.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source xml:space="preserve">It is intended to show dependency property concepts for anyone that prefers learning concepts through code.</source>
          <target xml:space="preserve">It is intended to show dependency property concepts for anyone that prefers learning concepts through code.</target>
        </segment>
      </unit>
      <unit id="152">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](custom-dependency-properties.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For a more complete example, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom dependency properties</pc>.</source>
          <target xml:space="preserve">For a more complete example, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom dependency properties</pc>.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source xml:space="preserve">Dependency property value precedence</source>
          <target xml:space="preserve">Dependency property value precedence</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">When you get the value of a dependency property, you are obtaining a value that was determined for that property through any one of the inputs that participate in the Windows Runtime property system.</source>
          <target xml:space="preserve">When you get the value of a dependency property, you are obtaining a value that was determined for that property through any one of the inputs that participate in the Windows Runtime property system.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">Dependency property value precedence exists so that the Windows Runtime property system can calculate values in a predictable way, and it's important that you be familiar with the basic precedence order too.</source>
          <target xml:space="preserve">Dependency property value precedence exists so that the Windows Runtime property system can calculate values in a predictable way, and it's important that you be familiar with the basic precedence order too.</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source xml:space="preserve">Otherwise, you might find yourself in a situation where you're trying to set a property at one level of precedence but something else (the system, third-party callers, some of your own code) is setting it at another level, and you'll get frustrated trying to figure out which property value is used and where that value came from.</source>
          <target xml:space="preserve">Otherwise, you might find yourself in a situation where you're trying to set a property at one level of precedence but something else (the system, third-party callers, some of your own code) is setting it at another level, and you'll get frustrated trying to figure out which property value is used and where that value came from.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source xml:space="preserve">For example, styles and templates are intended to be a shared starting point for establishing property values and thus appearances of a control.</source>
          <target xml:space="preserve">For example, styles and templates are intended to be a shared starting point for establishing property values and thus appearances of a control.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">But on a particular control instance you might want to change its value versus the common templated value, such as giving that control a different background color or a different text string as content.</source>
          <target xml:space="preserve">But on a particular control instance you might want to change its value versus the common templated value, such as giving that control a different background color or a different text string as content.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source xml:space="preserve">The Windows Runtime property system considers local values at higher precedence than values provided by styles and templates.</source>
          <target xml:space="preserve">The Windows Runtime property system considers local values at higher precedence than values provided by styles and templates.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source xml:space="preserve">That enables the scenario of having app-specific values overwrite the templates so that the controls are useful for your own use of them in app UI.</source>
          <target xml:space="preserve">That enables the scenario of having app-specific values overwrite the templates so that the controls are useful for your own use of them in app UI.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source xml:space="preserve">Dependency property precedence list</source>
          <target xml:space="preserve">Dependency property precedence list</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">The following is the definitive order that the property system uses when assigning the run-time value for a dependency property.</source>
          <target xml:space="preserve">The following is the definitive order that the property system uses when assigning the run-time value for a dependency property.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source xml:space="preserve">Highest precedence is listed first.</source>
          <target xml:space="preserve">Highest precedence is listed first.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source xml:space="preserve">You'll find more detailed explanations just past this list.</source>
          <target xml:space="preserve">You'll find more detailed explanations just past this list.</target>
        </segment>
      </unit>
      <unit id="165">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br210306)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animated values:</pc> Active animations, visual state animations, or animations with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">HoldEnd</pc></pc> behavior.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animated values:</pc> Active animations, visual state animations, or animations with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">HoldEnd</pc></pc> behavior.</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source xml:space="preserve">To have any practical effect, an animation applied to a property must have precedence over the base (unanimated) value, even if that value was set locally.</source>
          <target xml:space="preserve">To have any practical effect, an animation applied to a property must have precedence over the base (unanimated) value, even if that value was set locally.</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br242361)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Local value:</pc> A local value might be set through the convenience of the property wrapper, which also equates to setting as an attribute or property element in XAML, or by a call to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SetValue</pc></pc> method using a property of a specific instance.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Local value:</pc> A local value might be set through the convenience of the property wrapper, which also equates to setting as an attribute or property element in XAML, or by a call to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">SetValue</pc></pc> method using a property of a specific instance.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source xml:space="preserve">If you set a local value by using a binding or a static resource, these each act in the precedence as if a local value was set, and bindings or resource references are erased if a new local value is set.</source>
          <target xml:space="preserve">If you set a local value by using a binding or a static resource, these each act in the precedence as if a local value was set, and bindings or resource references are erased if a new local value is set.</target>
        </segment>
      </unit>
      <unit id="169">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br209391)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br242348)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Templated properties:</pc> An element has these if it was created as part of a template (from a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ControlTemplate</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">DataTemplate</pc></pc>).</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Templated properties:</pc> An element has these if it was created as part of a template (from a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ControlTemplate</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">DataTemplate</pc></pc>).</target>
        </segment>
      </unit>
      <unit id="170">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208817)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Style setters:</pc> Values from a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Setter</pc></pc> within styles from page or application resources.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Style setters:</pc> Values from a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Setter</pc></pc> within styles from page or application resources.</target>
        </segment>
      </unit>
      <unit id="171">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Default value:</pc> A dependency property can have a default value as part of its metadata.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Default value:</pc> A dependency property can have a default value as part of its metadata.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">Templated properties</source>
          <target xml:space="preserve">Templated properties</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source xml:space="preserve">Templated properties as a precedence item do not apply to any property of an element that you declare directly in XAML page markup.</source>
          <target xml:space="preserve">Templated properties as a precedence item do not apply to any property of an element that you declare directly in XAML page markup.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source xml:space="preserve">The templated property concept exists only for objects that are created when the Windows Runtime applies a XAML template to a UI element and thus defines its visuals.</source>
          <target xml:space="preserve">The templated property concept exists only for objects that are created when the Windows Runtime applies a XAML template to a UI element and thus defines its visuals.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">All the properties that are set from a control template have values of some kind.</source>
          <target xml:space="preserve">All the properties that are set from a control template have values of some kind.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source xml:space="preserve">These values are almost like an extended set of default values for the control and are often associated with values you can reset later by setting the property values directly.</source>
          <target xml:space="preserve">These values are almost like an extended set of default values for the control and are often associated with values you can reset later by setting the property values directly.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source xml:space="preserve">Thus the template-set values must be distinguishable from a true local value, so that any new local value can overwrite it.</source>
          <target xml:space="preserve">Thus the template-set values must be distinguishable from a true local value, so that any new local value can overwrite it.</target>
        </segment>
      </unit>
      <unit id="178">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>
					</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>
					</target>
        </segment>
      </unit>
      <unit id="179">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](templatebinding-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In some cases the template might override even local values, if the template failed to expose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{TemplateBinding} markup extension</pc> references for properties that should have been settable on instances.</source>
          <target xml:space="preserve">In some cases the template might override even local values, if the template failed to expose <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{TemplateBinding} markup extension</pc> references for properties that should have been settable on instances.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source xml:space="preserve">This is usually done only if the property is really not intended to be set on instances, for example if it's only relevant to visuals and template behavior and not to the intended function or runtime logic of the control that uses the template.</source>
          <target xml:space="preserve">This is usually done only if the property is really not intended to be set on instances, for example if it's only relevant to visuals and template behavior and not to the intended function or runtime logic of the control that uses the template.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">Bindings and precedence</source>
          <target xml:space="preserve">Bindings and precedence</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source xml:space="preserve">Binding operations have the appropriate precedence for whatever scope they're used for.</source>
          <target xml:space="preserve">Binding operations have the appropriate precedence for whatever scope they're used for.</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](templatebinding-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, a binding applied to a local value acts as local value, and a binding (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{TemplateBinding} markup extension</pc>) for a property setter applies as a style setter does.</source>
          <target xml:space="preserve">For example, a binding applied to a local value acts as local value, and a binding (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{TemplateBinding} markup extension</pc>) for a property setter applies as a style setter does.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source xml:space="preserve">Because bindings must wait until run-time to obtain values from data sources, the process of determining the property value precedence for any property extends into run-time as well.</source>
          <target xml:space="preserve">Because bindings must wait until run-time to obtain values from data sources, the process of determining the property value precedence for any property extends into run-time as well.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source xml:space="preserve">Not only do bindings operate at the same precedence as a local value, they really are a local value, where the binding is the placeholder for a value that is deferred.</source>
          <target xml:space="preserve">Not only do bindings operate at the same precedence as a local value, they really are a local value, where the binding is the placeholder for a value that is deferred.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">If you have a binding in place for a property value, and you set a local value on it at run-time, that replaces the binding entirely.</source>
          <target xml:space="preserve">If you have a binding in place for a property value, and you set a local value on it at run-time, that replaces the binding entirely.</target>
        </segment>
      </unit>
      <unit id="187">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br244257)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Similarly, if you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetBinding</pc></pc> to define a binding that only comes into existence at run-time, you replace any local value you might have applied in XAML or with previously executed code.</source>
          <target xml:space="preserve">Similarly, if you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetBinding</pc></pc> to define a binding that only comes into existence at run-time, you replace any local value you might have applied in XAML or with previously executed code.</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source xml:space="preserve">Storyboarded animations and base value</source>
          <target xml:space="preserve">Storyboarded animations and base value</target>
        </segment>
      </unit>
      <unit id="189">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Storyboarded animations act on a concept of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">base value</pc>.</source>
          <target xml:space="preserve">Storyboarded animations act on a concept of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">base value</pc>.</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source xml:space="preserve">The base value is the value that's determined by the property system using its precedence, but omitting that last step of looking for animations.</source>
          <target xml:space="preserve">The base value is the value that's determined by the property system using its precedence, but omitting that last step of looking for animations.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source xml:space="preserve">For example, a base value might come from a control's template, or it might come from setting a local value on an instance of a control.</source>
          <target xml:space="preserve">For example, a base value might come from a control's template, or it might come from setting a local value on an instance of a control.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source xml:space="preserve">Either way, applying an animation will overwrite this base value and apply the animated value for as long as your animation continues to run.</source>
          <target xml:space="preserve">Either way, applying an animation will overwrite this base value and apply the animated value for as long as your animation continues to run.</target>
        </segment>
      </unit>
      <unit id="193">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For an animated property, the base value can still have an effect on the animation's behavior, if that animation does not explicitly specify both <pc dataRefEnd="id2" dataRefStart="id1" id="p1">From</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">To</pc>, or if the animation reverts the property to its base value when completed.</source>
          <target xml:space="preserve">For an animated property, the base value can still have an effect on the animation's behavior, if that animation does not explicitly specify both <pc dataRefEnd="id2" dataRefStart="id1" id="p1">From</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">To</pc>, or if the animation reverts the property to its base value when completed.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source xml:space="preserve">In these cases, once an animation is no longer running, the rest of the precedence is used again.</source>
          <target xml:space="preserve">In these cases, once an animation is no longer running, the rest of the precedence is used again.</target>
        </segment>
      </unit>
      <unit id="195">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br210306)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">However, an animation that specifies a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">To</pc> with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">HoldEnd</pc></pc> behavior can override a local value until the animation is removed, even when it visually appears to be stopped.</source>
          <target xml:space="preserve">However, an animation that specifies a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">To</pc> with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">HoldEnd</pc></pc> behavior can override a local value until the animation is removed, even when it visually appears to be stopped.</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source xml:space="preserve">Conceptually this is like an animation that's running forever even if there is not a visual animation in the UI.</source>
          <target xml:space="preserve">Conceptually this is like an animation that's running forever even if there is not a visual animation in the UI.</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source xml:space="preserve">Multiple animations can be applied to a single property.</source>
          <target xml:space="preserve">Multiple animations can be applied to a single property.</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source xml:space="preserve">Each of these animations might have been defined to replace base values that came from different points in the value precedence.</source>
          <target xml:space="preserve">Each of these animations might have been defined to replace base values that came from different points in the value precedence.</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source xml:space="preserve">However, these animations will all be running simultaneously at run time, and that often means that they must combine their values because each animation has equal influence on the value.</source>
          <target xml:space="preserve">However, these animations will all be running simultaneously at run time, and that often means that they must combine their values because each animation has equal influence on the value.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source xml:space="preserve">This depends on exactly how the animations are defined, and the type of the value that is being animated.</source>
          <target xml:space="preserve">This depends on exactly how the animations are defined, and the type of the value that is being animated.</target>
        </segment>
      </unit>
      <unit id="201">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187354)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source xml:space="preserve">Default values</source>
          <target xml:space="preserve">Default values</target>
        </segment>
      </unit>
      <unit id="203">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208771)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](custom-dependency-properties.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Establishing the default value for a dependency property with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> value is explained in more detail in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Custom dependency properties</pc> topic.</source>
          <target xml:space="preserve">Establishing the default value for a dependency property with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PropertyMetadata</pc></pc> value is explained in more detail in the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Custom dependency properties</pc> topic.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source xml:space="preserve">Dependency properties still have default values even if those default values weren't explicitly defined in that property's metadata.</source>
          <target xml:space="preserve">Dependency properties still have default values even if those default values weren't explicitly defined in that property's metadata.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source xml:space="preserve">Unless they have been changed by metadata, default values for the Windows Runtime dependency properties are generally one of the following:</source>
          <target xml:space="preserve">Unless they have been changed by metadata, default values for the Windows Runtime dependency properties are generally one of the following:</target>
        </segment>
      </unit>
      <unit id="206">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A property that uses a run-time object or the basic <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Object</pc> type (a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">reference type</pc>) has a default value of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.</source>
          <target xml:space="preserve">A property that uses a run-time object or the basic <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Object</pc> type (a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">reference type</pc>) has a default value of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.</target>
        </segment>
      </unit>
      <unit id="207">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208713)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc> is <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> until it's deliberately set or is inherited.</source>
          <target xml:space="preserve">For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc> is <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> until it's deliberately set or is inherited.</target>
        </segment>
      </unit>
      <unit id="208">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A property that uses a basic value such as numbers or a Boolean value (a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">value type</pc>) uses an expected default for that value.</source>
          <target xml:space="preserve">A property that uses a basic value such as numbers or a Boolean value (a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">value type</pc>) uses an expected default for that value.</target>
        </segment>
      </unit>
      <unit id="209">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, 0 for integers and floating-point numbers, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">false</pc> for a Boolean.</source>
          <target xml:space="preserve">For example, 0 for integers and floating-point numbers, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">false</pc> for a Boolean.</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source xml:space="preserve">A property that uses a Windows Runtime structure has a default value that's obtained by calling that structure's implicit default constructor.</source>
          <target xml:space="preserve">A property that uses a Windows Runtime structure has a default value that's obtained by calling that structure's implicit default constructor.</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source xml:space="preserve">This constructor uses the defaults for each of the basic value fields of the structure.</source>
          <target xml:space="preserve">This constructor uses the defaults for each of the basic value fields of the structure.</target>
        </segment>
      </unit>
      <unit id="212">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br225870)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, a default for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Point</pc></pc> value is initialized with its <pc dataRefEnd="id6" dataRefStart="id5" id="p3">X</pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Y</pc> values as 0.</source>
          <target xml:space="preserve">For example, a default for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Point</pc></pc> value is initialized with its <pc dataRefEnd="id6" dataRefStart="id5" id="p3">X</pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Y</pc> values as 0.</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source xml:space="preserve">A property that uses an enumeration has a default value of the first defined member in that enumeration.</source>
          <target xml:space="preserve">A property that uses an enumeration has a default value of the first defined member in that enumeration.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source xml:space="preserve">Check the reference for specific enumerations to see what the default value is.</source>
          <target xml:space="preserve">Check the reference for specific enumerations to see what the default value is.</target>
        </segment>
      </unit>
      <unit id="215">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/system.string.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A property that uses a string (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.String</pc></pc> for .NET, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Platform::String</pc></pc> for C++/CX) has a default value of an empty string (<pc dataRefEnd="id10" dataRefStart="id9" id="p5">""</pc>).</source>
          <target xml:space="preserve">A property that uses a string (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.String</pc></pc> for .NET, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Platform::String</pc></pc> for C++/CX) has a default value of an empty string (<pc dataRefEnd="id10" dataRefStart="id9" id="p5">""</pc>).</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source xml:space="preserve">Collection properties aren't typically implemented as dependency properties, for reasons discussed further on in this topic.</source>
          <target xml:space="preserve">Collection properties aren't typically implemented as dependency properties, for reasons discussed further on in this topic.</target>
        </segment>
      </unit>
      <unit id="217">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">[</data>
          <data id="id4">](custom-dependency-properties.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But if you implement a custom collection property and you want it to be a dependency property, make sure to avoid an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">unintentional singleton</pc> as described near the end of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Custom dependency properties</pc>.</source>
          <target xml:space="preserve">But if you implement a custom collection property and you want it to be a dependency property, make sure to avoid an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">unintentional singleton</pc> as described near the end of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Custom dependency properties</pc>.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source xml:space="preserve">Property functionality provided by a dependency property</source>
          <target xml:space="preserve">Property functionality provided by a dependency property</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source xml:space="preserve">Data binding</source>
          <target xml:space="preserve">Data binding</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source xml:space="preserve">A dependency property can have its value set through applying a data binding.</source>
          <target xml:space="preserve">A dependency property can have its value set through applying a data binding.</target>
        </segment>
      </unit>
      <unit id="221">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](binding-markup-extension.md)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br209820)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Data binding uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding} markup extension</pc> syntax in XAML, or the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Binding</pc></pc> class in code.</source>
          <target xml:space="preserve">Data binding uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding} markup extension</pc> syntax in XAML, or the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Binding</pc></pc> class in code.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source xml:space="preserve">For a databound property, the final property value determination is deferred until run time.</source>
          <target xml:space="preserve">For a databound property, the final property value determination is deferred until run time.</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source xml:space="preserve">At that time the value is obtained from a data source.</source>
          <target xml:space="preserve">At that time the value is obtained from a data source.</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source xml:space="preserve">The role that the dependency property system plays here is enabling a placeholder behavior for operations like loading XAML when the value is not yet known, and then supplying the value at run time by interacting with the Windows Runtime data binding engine.</source>
          <target xml:space="preserve">The role that the dependency property system plays here is enabling a placeholder behavior for operations like loading XAML when the value is not yet known, and then supplying the value at run time by interacting with the Windows Runtime data binding engine.</target>
        </segment>
      </unit>
      <unit id="225">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209676)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209652)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The following example sets the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Text</pc></pc> value for a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBlock</pc></pc> element, using a binding in XAML.</source>
          <target xml:space="preserve">The following example sets the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Text</pc></pc> value for a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBlock</pc></pc> element, using a binding in XAML.</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source xml:space="preserve">The binding uses an inherited data context and an object data source.</source>
          <target xml:space="preserve">The binding uses an inherited data context and an object data source.</target>
        </segment>
      </unit>
      <unit id="227">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">(Neither of these is shown in the shortened example; for a more complete sample that shows context and source, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.)</source>
          <target xml:space="preserve">(Neither of these is shown in the shortened example; for a more complete sample that shows context and source, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.)</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source xml:space="preserve">You can also establish bindings using code rather than XAML.</source>
          <target xml:space="preserve">You can also establish bindings using code rather than XAML.</target>
        </segment>
      </unit>
      <unit id="229">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br244257)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">See <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetBinding</pc></pc>.</source>
          <target xml:space="preserve">See <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetBinding</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="230">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Bindings like this are treated as a local value for purposes of dependency property value precedence.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Bindings like this are treated as a local value for purposes of dependency property value precedence.</target>
        </segment>
      </unit>
      <unit id="231">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209820)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you set another local value for a property that originally held a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Binding</pc></pc> value, you will overwrite the binding entirely, not just the binding's run-time value.</source>
          <target xml:space="preserve">If you set another local value for a property that originally held a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Binding</pc></pc> value, you will overwrite the binding entirely, not just the binding's run-time value.</target>
        </segment>
      </unit>
      <unit id="232">
        <segment state="initial">
          <source xml:space="preserve">Binding sources, binding targets, the role of FrameworkElement</source>
          <target xml:space="preserve">Binding sources, binding targets, the role of FrameworkElement</target>
        </segment>
      </unit>
      <unit id="233">
        <segment state="initial">
          <source xml:space="preserve">To be the source of a binding, a property does not need to be a dependency property; you can generally use any property as a binding source, although this depends on your programming language and each has certain edge cases.</source>
          <target xml:space="preserve">To be the source of a binding, a property does not need to be a dependency property; you can generally use any property as a binding source, although this depends on your programming language and each has certain edge cases.</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source xml:space="preserve">However, to be the target of a binding, that property must be a dependency property.</source>
          <target xml:space="preserve">However, to be the target of a binding, that property must be a dependency property.</target>
        </segment>
      </unit>
      <unit id="235">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br244257)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you are creating a binding in code, note that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetBinding</pc></pc> API is defined only for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement</pc></pc>.</source>
          <target xml:space="preserve">If you are creating a binding in code, note that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetBinding</pc></pc> API is defined only for <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="236">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209823)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">However, you can create a binding definition using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BindingOperations</pc></pc> instead, and thus reference any <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyObject</pc></pc> property.</source>
          <target xml:space="preserve">However, you can create a binding definition using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BindingOperations</pc></pc> instead, and thus reference any <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DependencyObject</pc></pc> property.</target>
        </segment>
      </unit>
      <unit id="237">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208713)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For either code or XAML, remember that <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc> is a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement</pc></pc> property.</source>
          <target xml:space="preserve">For either code or XAML, remember that <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc> is a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement</pc></pc> property.</target>
        </segment>
      </unit>
      <unit id="238">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">By using a form of parent-child property inheritance (typically established in XAML markup), the binding system can resolve a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> that exists on a parent element.</source>
          <target xml:space="preserve">By using a form of parent-child property inheritance (typically established in XAML markup), the binding system can resolve a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> that exists on a parent element.</target>
        </segment>
      </unit>
      <unit id="239">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This inheritance can evaluate even if the child object (which has the target property) is not a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElement</pc> and therefore does not hold its own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> value.</source>
          <target xml:space="preserve">This inheritance can evaluate even if the child object (which has the target property) is not a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElement</pc> and therefore does not hold its own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> value.</target>
        </segment>
      </unit>
      <unit id="240">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">However, the parent element being inherited must be a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElement</pc> in order to set and hold the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc>.</source>
          <target xml:space="preserve">However, the parent element being inherited must be a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElement</pc> in order to set and hold the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc>.</target>
        </segment>
      </unit>
      <unit id="241">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Alternatively, you must define the binding such that it can function with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> value for <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc>.</source>
          <target xml:space="preserve">Alternatively, you must define the binding such that it can function with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> value for <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc>.</target>
        </segment>
      </unit>
      <unit id="242">
        <segment state="initial">
          <source xml:space="preserve">Wiring the binding is not the only thing that's needed for most data binding scenarios.</source>
          <target xml:space="preserve">Wiring the binding is not the only thing that's needed for most data binding scenarios.</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source xml:space="preserve">For a one-way or two-way binding to be effective, the source property must support change notifications that propagate to the binding system and thus the target.</source>
          <target xml:space="preserve">For a one-way or two-way binding to be effective, the source property must support change notifications that propagate to the binding system and thus the target.</target>
        </segment>
      </unit>
      <unit id="244">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/system.componentmodel.inotifypropertychanged.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For custom binding sources, this means that the property must support <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyPropertyChanged</pc></pc>.</source>
          <target xml:space="preserve">For custom binding sources, this means that the property must support <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyPropertyChanged</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="245">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/system.collections.specialized.inotifycollectionchanged.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Collections should support <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc>.</source>
          <target xml:space="preserve">Collections should support <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="246">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/ms668604.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Certain classes support these interfaces in their implementations so that they are useful as base classes for data binding scenarios; an example of such a class is <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ObservableCollection&amp;lt;T&amp;gt;</pc></pc>.</source>
          <target xml:space="preserve">Certain classes support these interfaces in their implementations so that they are useful as base classes for data binding scenarios; an example of such a class is <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ObservableCollection&amp;lt;T&amp;gt;</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="247">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more information on data binding and how data binding relates to the property system, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</source>
          <target xml:space="preserve">For more information on data binding and how data binding relates to the property system, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</target>
        </segment>
      </unit>
      <unit id="248">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The types listed here support Microsoft .NET data sources.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The types listed here support Microsoft .NET data sources.</target>
        </segment>
      </unit>
      <unit id="249">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">C++/CX data sources use different interfaces for change notification or observable behavior, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</source>
          <target xml:space="preserve">C++/CX data sources use different interfaces for change notification or observable behavior, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source xml:space="preserve">Styles and templates</source>
          <target xml:space="preserve">Styles and templates</target>
        </segment>
      </unit>
      <unit id="251">
        <segment state="initial">
          <source xml:space="preserve">Styles and templates are two of the scenarios for properties being defined as dependency properties.</source>
          <target xml:space="preserve">Styles and templates are two of the scenarios for properties being defined as dependency properties.</target>
        </segment>
      </unit>
      <unit id="252">
        <segment state="initial">
          <source xml:space="preserve">Styles are useful for setting properties that define the app's UI.</source>
          <target xml:space="preserve">Styles are useful for setting properties that define the app's UI.</target>
        </segment>
      </unit>
      <unit id="253">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208740)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Styles are defined as resources in XAML, either as an entry in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Resources</pc></pc> collection, or in separate XAML files such as theme resource dictionaries.</source>
          <target xml:space="preserve">Styles are defined as resources in XAML, either as an entry in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Resources</pc></pc> collection, or in separate XAML files such as theme resource dictionaries.</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source xml:space="preserve">Styles interact with the property system because they contain setters for properties.</source>
          <target xml:space="preserve">Styles interact with the property system because they contain setters for properties.</target>
        </segment>
      </unit>
      <unit id="255">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209465)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209390)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The most important property here is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Template</pc></pc> property of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Control</pc></pc>: it defines most of the visual appearance and visual state for a <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Control</pc>.</source>
          <target xml:space="preserve">The most important property here is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control.Template</pc></pc> property of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Control</pc></pc>: it defines most of the visual appearance and visual state for a <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Control</pc>.</target>
        </segment>
      </unit>
      <unit id="256">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/mt210950)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on styles, and some example XAML that defines a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> and uses setters, see <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Styling controls</pc>.</source>
          <target xml:space="preserve">For more info on styles, and some example XAML that defines a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> and uses setters, see <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Styling controls</pc>.</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source xml:space="preserve">Values that come from styles or templates are deferred values, similar to bindings.</source>
          <target xml:space="preserve">Values that come from styles or templates are deferred values, similar to bindings.</target>
        </segment>
      </unit>
      <unit id="258">
        <segment state="initial">
          <source xml:space="preserve">This is so that control users can re-template controls or redefine styles.</source>
          <target xml:space="preserve">This is so that control users can re-template controls or redefine styles.</target>
        </segment>
      </unit>
      <unit id="259">
        <segment state="initial">
          <source xml:space="preserve">And that's why property setters in styles can only act on dependency properties, not ordinary properties.</source>
          <target xml:space="preserve">And that's why property setters in styles can only act on dependency properties, not ordinary properties.</target>
        </segment>
      </unit>
      <unit id="260">
        <segment state="initial">
          <source xml:space="preserve">Storyboarded animations</source>
          <target xml:space="preserve">Storyboarded animations</target>
        </segment>
      </unit>
      <unit id="261">
        <segment state="initial">
          <source xml:space="preserve">You can animate a dependency property's value using a storyboarded animation.</source>
          <target xml:space="preserve">You can animate a dependency property's value using a storyboarded animation.</target>
        </segment>
      </unit>
      <unit id="262">
        <segment state="initial">
          <source xml:space="preserve">Storyboarded animations in the Windows Runtime are not merely visual decorations.</source>
          <target xml:space="preserve">Storyboarded animations in the Windows Runtime are not merely visual decorations.</target>
        </segment>
      </unit>
      <unit id="263">
        <segment state="initial">
          <source xml:space="preserve">It's more useful to think of animations as being a state machine technique that can set the values of individual properties or of all properties and visuals of a control, and change these values over time.</source>
          <target xml:space="preserve">It's more useful to think of animations as being a state machine technique that can set the values of individual properties or of all properties and visuals of a control, and change these values over time.</target>
        </segment>
      </unit>
      <unit id="264">
        <segment state="initial">
          <source xml:space="preserve">To be animated, the animation's target property must be a dependency property.</source>
          <target xml:space="preserve">To be animated, the animation's target property must be a dependency property.</target>
        </segment>
      </unit>
      <unit id="265">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210517)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Also, to be animated, the target property's value type must be supported by one of the existing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Timeline</pc></pc>-derived animation types.</source>
          <target xml:space="preserve">Also, to be animated, the target property's value type must be supported by one of the existing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Timeline</pc></pc>-derived animation types.</target>
        </segment>
      </unit>
      <unit id="266">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh673723)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](T:System.Double)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/br225870)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Values of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Color</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Double</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Point</pc></pc> can be animated using either interpolation or keyframe techniques.</source>
          <target xml:space="preserve">Values of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Color</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Double</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Point</pc></pc> can be animated using either interpolation or keyframe techniques.</target>
        </segment>
      </unit>
      <unit id="267">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Most other values can be animated using discrete <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Object</pc> key frames.</source>
          <target xml:space="preserve">Most other values can be animated using discrete <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Object</pc> key frames.</target>
        </segment>
      </unit>
      <unit id="268">
        <segment state="initial">
          <source xml:space="preserve">When an animation is applied and running, the animated value operates at a higher precedence than any value (such as a local value) that the property otherwise has.</source>
          <target xml:space="preserve">When an animation is applied and running, the animated value operates at a higher precedence than any value (such as a local value) that the property otherwise has.</target>
        </segment>
      </unit>
      <unit id="269">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br210306)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Animations also have an optional <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">HoldEnd</pc></pc> behavior that can cause animations to apply to property values even if the animation visually appears to be stopped.</source>
          <target xml:space="preserve">Animations also have an optional <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">HoldEnd</pc></pc> behavior that can cause animations to apply to property values even if the animation visually appears to be stopped.</target>
        </segment>
      </unit>
      <unit id="270">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209021)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The state machine principle is embodied by the use of storyboarded animations as part of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualStateManager</pc></pc> state model for controls.</source>
          <target xml:space="preserve">The state machine principle is embodied by the use of storyboarded animations as part of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualStateManager</pc></pc> state model for controls.</target>
        </segment>
      </unit>
      <unit id="271">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187354)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on storyboarded animations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</source>
          <target xml:space="preserve">For more info on storyboarded animations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</target>
        </segment>
      </unit>
      <unit id="272">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/xaml/jj819808)</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VisualStateManager</pc> and defining visual states for controls, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboarded animations for visual states</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Quickstart: Control templates</pc>.</source>
          <target xml:space="preserve">For more info on <pc dataRefEnd="id2" dataRefStart="id1" id="p1">VisualStateManager</pc> and defining visual states for controls, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Storyboarded animations for visual states</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Quickstart: Control templates</pc>.</target>
        </segment>
      </unit>
      <unit id="273">
        <segment state="initial">
          <source xml:space="preserve">Property-changed behavior</source>
          <target xml:space="preserve">Property-changed behavior</target>
        </segment>
      </unit>
      <unit id="274">
        <segment state="initial">
          <source xml:space="preserve">Property-changed behavior is the origin of the "dependency" part of dependency property terminology.</source>
          <target xml:space="preserve">Property-changed behavior is the origin of the "dependency" part of dependency property terminology.</target>
        </segment>
      </unit>
      <unit id="275">
        <segment state="initial">
          <source xml:space="preserve">Maintaining valid values for a property when another property can influence the first property's value is a difficult development problem in many frameworks.</source>
          <target xml:space="preserve">Maintaining valid values for a property when another property can influence the first property's value is a difficult development problem in many frameworks.</target>
        </segment>
      </unit>
      <unit id="276">
        <segment state="initial">
          <source xml:space="preserve">In the Windows Runtime property system, each dependency property can specify a callback that is invoked whenever its property value changes.</source>
          <target xml:space="preserve">In the Windows Runtime property system, each dependency property can specify a callback that is invoked whenever its property value changes.</target>
        </segment>
      </unit>
      <unit id="277">
        <segment state="initial">
          <source xml:space="preserve">This callback can be used to notify or change related property values, in a generally synchronous manner.</source>
          <target xml:space="preserve">This callback can be used to notify or change related property values, in a generally synchronous manner.</target>
        </segment>
      </unit>
      <unit id="278">
        <segment state="initial">
          <source xml:space="preserve">Many existing dependency properties have a property-changed behavior.</source>
          <target xml:space="preserve">Many existing dependency properties have a property-changed behavior.</target>
        </segment>
      </unit>
      <unit id="279">
        <segment state="initial">
          <source xml:space="preserve">You can also add similar callback behavior to custom dependency properties, and implement your own property-changed callbacks.</source>
          <target xml:space="preserve">You can also add similar callback behavior to custom dependency properties, and implement your own property-changed callbacks.</target>
        </segment>
      </unit>
      <unit id="280">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](custom-dependency-properties.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom dependency properties</pc> for an example.</source>
          <target xml:space="preserve">See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom dependency properties</pc> for an example.</target>
        </segment>
      </unit>
      <unit id="281">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Default value and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ClearValue</pc></source>
          <target xml:space="preserve">Default value and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ClearValue</pc></target>
        </segment>
      </unit>
      <unit id="282">
        <segment state="initial">
          <source xml:space="preserve">A dependency property can have a default value defined as part of its property metadata.</source>
          <target xml:space="preserve">A dependency property can have a default value defined as part of its property metadata.</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source xml:space="preserve">For a dependency property, its default value doesn't become irrelevant after the property's been set the first time.</source>
          <target xml:space="preserve">For a dependency property, its default value doesn't become irrelevant after the property's been set the first time.</target>
        </segment>
      </unit>
      <unit id="284">
        <segment state="initial">
          <source xml:space="preserve">The default value might apply again at run-time whenever some other determinant in value precedence disappears.</source>
          <target xml:space="preserve">The default value might apply again at run-time whenever some other determinant in value precedence disappears.</target>
        </segment>
      </unit>
      <unit id="285">
        <segment state="initial">
          <source xml:space="preserve">(Dependency property value precedence is discussed in the next section.) For example, you might deliberately remove a style value or an animation that applies to a property, but you want the value to be a reasonable default after you do so.</source>
          <target xml:space="preserve">(Dependency property value precedence is discussed in the next section.) For example, you might deliberately remove a style value or an animation that applies to a property, but you want the value to be a reasonable default after you do so.</target>
        </segment>
      </unit>
      <unit id="286">
        <segment state="initial">
          <source xml:space="preserve">The dependency property default value can provide this value, without needing to specifically set each property's value as an extra step.</source>
          <target xml:space="preserve">The dependency property default value can provide this value, without needing to specifically set each property's value as an extra step.</target>
        </segment>
      </unit>
      <unit id="287">
        <segment state="initial">
          <source xml:space="preserve">You can deliberately set a property to the default value even after you have already set it with a local value.</source>
          <target xml:space="preserve">You can deliberately set a property to the default value even after you have already set it with a local value.</target>
        </segment>
      </unit>
      <unit id="288">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242357)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To reset a value to be the default again, and also to enable other participants in precedence that might override the default but not a local value, call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc> method (reference the property to clear as a method parameter).</source>
          <target xml:space="preserve">To reset a value to be the default again, and also to enable other participants in precedence that might override the default but not a local value, call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClearValue</pc></pc> method (reference the property to clear as a method parameter).</target>
        </segment>
      </unit>
      <unit id="289">
        <segment state="initial">
          <source xml:space="preserve">You don't always want the property to literally use the default value, but clearing the local value and reverting to the default value might enable another item in precedence that you want to act now, such as using the value that came from a style setter in a control template.</source>
          <target xml:space="preserve">You don't always want the property to literally use the default value, but clearing the local value and reverting to the default value might enable another item in precedence that you want to act now, such as using the value that came from a style setter in a control template.</target>
        </segment>
      </unit>
      <unit id="290">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> and threading</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> and threading</target>
        </segment>
      </unit>
      <unit id="291">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209041)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">All <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> instances must be created on the UI thread which is associated with the current <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Window</pc></pc> that is shown by a Windows Runtime app.</source>
          <target xml:space="preserve">All <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> instances must be created on the UI thread which is associated with the current <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Window</pc></pc> that is shown by a Windows Runtime app.</target>
        </segment>
      </unit>
      <unit id="292">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br230616)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Although each <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by accessing the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Dispatcher</pc></pc> property.</source>
          <target xml:space="preserve">Although each <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc> must be created on the main UI thread, the objects can be accessed using a dispatcher reference from other threads, by accessing the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Dispatcher</pc></pc> property.</target>
        </segment>
      </unit>
      <unit id="293">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh750317)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208211)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Then you can call methods such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RunAsync</pc></pc> on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CoreDispatcher</pc></pc> object, and execute your code within the rules of thread restrictions on the UI thread.</source>
          <target xml:space="preserve">Then you can call methods such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RunAsync</pc></pc> on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">CoreDispatcher</pc></pc> object, and execute your code within the rules of thread restrictions on the UI thread.</target>
        </segment>
      </unit>
      <unit id="294">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The threading aspects of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property.</source>
          <target xml:space="preserve">The threading aspects of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc></pc> are relevant because it generally means that only code that runs on the UI thread can change or even read the value of a dependency property.</target>
        </segment>
      </unit>
      <unit id="295">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Threading issues can usually be avoided in typical UI code that makes correct use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> patterns and background worker threads.</source>
          <target xml:space="preserve">Threading issues can usually be avoided in typical UI code that makes correct use of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> patterns and background worker threads.</target>
        </segment>
      </unit>
      <unit id="296">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You typically only run into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc>-related threading issues if you are defining your own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc> types and you attempt to use them for data sources or other scenarios where a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc> isn't necessarily appropriate.</source>
          <target xml:space="preserve">You typically only run into <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DependencyObject</pc>-related threading issues if you are defining your own <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DependencyObject</pc> types and you attempt to use them for data sources or other scenarios where a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DependencyObject</pc> isn't necessarily appropriate.</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source xml:space="preserve">Related topics</source>
          <target xml:space="preserve">Related topics</target>
        </segment>
      </unit>
      <unit id="298">
        <segment state="initial">
          <source xml:space="preserve">Conceptual material</source>
          <target xml:space="preserve">Conceptual material</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source xml:space="preserve">Custom dependency properties</source>
          <target xml:space="preserve">Custom dependency properties</target>
        </segment>
      </unit>
      <unit id="300">
        <segment state="initial">
          <source xml:space="preserve">Attached properties overview</source>
          <target xml:space="preserve">Attached properties overview</target>
        </segment>
      </unit>
      <unit id="301">
        <segment state="initial">
          <source xml:space="preserve">Data binding in depth</source>
          <target xml:space="preserve">Data binding in depth</target>
        </segment>
      </unit>
      <unit id="302">
        <segment state="initial">
          <source xml:space="preserve">Storyboarded animations</source>
          <target xml:space="preserve">Storyboarded animations</target>
        </segment>
      </unit>
      <unit id="303">
        <segment state="initial">
          <source xml:space="preserve">Creating Windows Runtime components</source>
          <target xml:space="preserve">Creating Windows Runtime components</target>
        </segment>
      </unit>
      <unit id="304">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=238581)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML user and custom controls sample</pc>
					</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML user and custom controls sample</pc>
					</target>
        </segment>
      </unit>
      <unit id="305">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">APIs related to dependency properties</pc>
					</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">APIs related to dependency properties</pc>
					</target>
        </segment>
      </unit>
      <unit id="306">
        <segment state="initial">
          <source xml:space="preserve">DependencyObject</source>
          <target xml:space="preserve">DependencyObject</target>
        </segment>
      </unit>
      <unit id="307">
        <segment state="initial">
          <source xml:space="preserve">DependencyProperty</source>
          <target xml:space="preserve">DependencyProperty</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>