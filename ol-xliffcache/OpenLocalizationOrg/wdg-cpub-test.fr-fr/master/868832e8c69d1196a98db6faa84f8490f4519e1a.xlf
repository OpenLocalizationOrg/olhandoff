<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">868832e8c69d1196a98db6faa84f8490f4519e1a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\port-the-vertex-buffers-and-data-config.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Port the vertex buffers and data</source>
          <target state="new">Port the vertex buffers and data</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.</source>
          <target state="new">In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Port the vertex buffers and data</source>
          <target state="new">Port the vertex buffers and data</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Important APIs</source>
          <target state="new">Important APIs</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>ID3DDevice::CreateBuffer</source>
          <target state="new">ID3DDevice::CreateBuffer</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>ID3DDeviceContext::IASetVertexBuffers</source>
          <target state="new">ID3DDeviceContext::IASetVertexBuffers</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>ID3D11DeviceContext::IASetIndexBuffer</source>
          <target state="new">ID3D11DeviceContext::IASetIndexBuffer</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.</source>
          <target state="new">In this step, you'll define the vertex buffers that will contain your meshes and the index buffers that allow the shaders to traverse the vertices in a specified order.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>At this point, let's examine the hardcoded model for the cube mesh we are using.</source>
          <target state="new">At this point, let's examine the hardcoded model for the cube mesh we are using.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Both representations have the vertices organized as a triangle list (as opposed to a strip or other more efficient triangle layout).</source>
          <target state="new">Both representations have the vertices organized as a triangle list (as opposed to a strip or other more efficient triangle layout).</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>All vertices in both representations also have associated indices and color values.</source>
          <target state="new">All vertices in both representations also have associated indices and color values.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Much of the Direct3D code in this topic refers to variables and objects defined in the Direct3D project.</source>
          <target state="new">Much of the Direct3D code in this topic refers to variables and objects defined in the Direct3D project.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Here's the cube for processing by OpenGL ES 2.0.</source>
          <target state="new">Here's the cube for processing by OpenGL ES 2.0.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>In the sample implementation, each vertex is 7 float values: 3 position coordinates followed by 4 RGBA color values.</source>
          <target state="new">In the sample implementation, each vertex is 7 float values: 3 position coordinates followed by 4 RGBA color values.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>And here's the same cube for processing by Direct3D 11.</source>
          <target state="new">And here's the same cube for processing by Direct3D 11.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Reviewing this code, you notice that the cube in the OpenGL ES 2.0 code is represented in a right-hand coordinate system, whereas the cube in the Direct3D-specific code is represented in a left-hand coordinate system.</source>
          <target state="new">Reviewing this code, you notice that the cube in the OpenGL ES 2.0 code is represented in a right-hand coordinate system, whereas the cube in the Direct3D-specific code is represented in a left-hand coordinate system.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>When importing your own mesh data, you must reverse the z-axis coordinates for your model and change the indices for each mesh accordingly to traverse the triangles according to the change in the coordinate system.</source>
          <target state="new">When importing your own mesh data, you must reverse the z-axis coordinates for your model and change the indices for each mesh accordingly to traverse the triangles according to the change in the coordinate system.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Assuming that we have successfully moved the cube mesh from the right-handed OpenGL ES 2.0 coordinate system to the left-handed Direct3D one, let's see how to load the cube data for processing in both models.</source>
          <target state="new">Assuming that we have successfully moved the cube mesh from the right-handed OpenGL ES 2.0 coordinate system to the left-handed Direct3D one, let's see how to load the cube data for processing in both models.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="new">Instructions</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Step 1: Create an input layout</source>
          <target state="new">Step 1: Create an input layout</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In OpenGL ES 2.0, your vertex data is supplied as attributes that will be supplied to and read by the shader objects.</source>
          <target state="new">In OpenGL ES 2.0, your vertex data is supplied as attributes that will be supplied to and read by the shader objects.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You typically provide a string that contains the attribute name used in the shader's GLSL to the shader program object, and get a memory location back that you can supply to the shader.</source>
          <target state="new">You typically provide a string that contains the attribute name used in the shader's GLSL to the shader program object, and get a memory location back that you can supply to the shader.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>In this example, a vertex buffer object contains a list of custom Vertex structures, defined and formatted as follows:</source>
          <target state="new">In this example, a vertex buffer object contains a list of custom Vertex structures, defined and formatted as follows:</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Configure the attributes that contain the per-vertex information.</source>
          <target state="new">OpenGL ES 2.0: Configure the attributes that contain the per-vertex information.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In OpenGL ES 2.0, input layouts are implicit; you take a general purpose GL\_ELEMENT\_ARRAY\_BUFFER and supply the stride and offset such that the vertex shader can interpret the data after uploading it.</source>
          <target state="new">In OpenGL ES 2.0, input layouts are implicit; you take a general purpose GL\_ELEMENT\_ARRAY\_BUFFER and supply the stride and offset such that the vertex shader can interpret the data after uploading it.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You inform the shader before rendering which attributes map to which portions of each block of vertex data with <bpt id="p1">**</bpt>glVertexAttribPointer<ept id="p1">**</ept>.</source>
          <target state="new">You inform the shader before rendering which attributes map to which portions of each block of vertex data with <bpt id="p1">**</bpt>glVertexAttribPointer<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>In Direct3D, you must provide an input layout to describe the structure of the vertex data in the vertex buffer when you create the buffer, instead of before you draw the geometry.</source>
          <target state="new">In Direct3D, you must provide an input layout to describe the structure of the vertex data in the vertex buffer when you create the buffer, instead of before you draw the geometry.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To do this, you use an input layout which corresponds to layout of the data for our individual vertices in memory.</source>
          <target state="new">To do this, you use an input layout which corresponds to layout of the data for our individual vertices in memory.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>It is very important to specify this accurately!</source>
          <target state="new">It is very important to specify this accurately!</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Here, you create an input description as an array of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_INPUT\_ELEMENT\_DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structures.</source>
          <target state="new">Here, you create an input description as an array of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_INPUT\_ELEMENT\_DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476180)</ept> structures.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Direct3D: Define an input layout description.</source>
          <target state="new">Direct3D: Define an input layout description.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This input description defines a vertex as a pair of 2 3-coordinate vectors: one 3D vector to store the position of the vertex in model coordinates, and another 3D vector to store the RGB color value associated with the vertex.</source>
          <target state="new">This input description defines a vertex as a pair of 2 3-coordinate vectors: one 3D vector to store the position of the vertex in model coordinates, and another 3D vector to store the RGB color value associated with the vertex.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In this case, you use 3x32 bit floating point format, elements of which we represent in code as <ph id="ph1">`XMFLOAT3(X.Xf, X.Xf, X.Xf)`</ph>.</source>
          <target state="new">In this case, you use 3x32 bit floating point format, elements of which we represent in code as <ph id="ph1">`XMFLOAT3(X.Xf, X.Xf, X.Xf)`</ph>.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>You should use types from the <bpt id="p1">[</bpt>DirectXMath<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ee415574)</ept> library whenever you are handling data that will be used by a shader, as it ensure the proper packing and alignment of that data.</source>
          <target state="new">You should use types from the <bpt id="p1">[</bpt>DirectXMath<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ee415574)</ept> library whenever you are handling data that will be used by a shader, as it ensure the proper packing and alignment of that data.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>(For example, use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XMFLOAT3<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ee419475)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>XMFLOAT4<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ee419608)</ept> for vector data, and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>XMFLOAT4X4<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/ee419621)</ept> for matrices.)</source>
          <target state="new">(For example, use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XMFLOAT3<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ee419475)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>XMFLOAT4<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ee419608)</ept> for vector data, and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>XMFLOAT4X4<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/ee419621)</ept> for matrices.)</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>For a list of all the possible format types, refer to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DXGI\_FORMAT<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</ept>.</source>
          <target state="new">For a list of all the possible format types, refer to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DXGI\_FORMAT<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</ept>.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>With the per-vertex input layout defined, you create the layout object.</source>
          <target state="new">With the per-vertex input layout defined, you create the layout object.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the following code, you write it to <bpt id="p1">**</bpt>m\_inputLayout<ept id="p1">**</ept>, a variable of type <bpt id="p2">**</bpt>ComPtr<ept id="p2">**</ept> (which points to an object of type <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11InputLayout<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476575)</ept>).</source>
          <target state="new">In the following code, you write it to <bpt id="p1">**</bpt>m\_inputLayout<ept id="p1">**</ept>, a variable of type <bpt id="p2">**</bpt>ComPtr<ept id="p2">**</ept> (which points to an object of type <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11InputLayout<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476575)</ept>).</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>fileData<ept id="p1">**</ept> contains the compiled vertex shader object from the previous step, <bpt id="p2">[</bpt>Port the shaders<ept id="p2">](port-the-shader-config.md)</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>fileData<ept id="p1">**</ept> contains the compiled vertex shader object from the previous step, <bpt id="p2">[</bpt>Port the shaders<ept id="p2">](port-the-shader-config.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Direct3D: Create the input layout used by the vertex buffer.</source>
          <target state="new">Direct3D: Create the input layout used by the vertex buffer.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>We've defined the input layout.</source>
          <target state="new">We've defined the input layout.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Now, let's create a buffer that uses this layout and load it with the cube mesh data.</source>
          <target state="new">Now, let's create a buffer that uses this layout and load it with the cube mesh data.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Step 2: Create and load the vertex buffer(s)</source>
          <target state="new">Step 2: Create and load the vertex buffer(s)</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In OpenGL ES 2.0, you create a pair of buffers, one for the position data and one for the color data.</source>
          <target state="new">In OpenGL ES 2.0, you create a pair of buffers, one for the position data and one for the color data.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>(You could also create a struct that contains both and a single buffer.) You bind each buffer and write position and color data into them.</source>
          <target state="new">(You could also create a struct that contains both and a single buffer.) You bind each buffer and write position and color data into them.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Later, during your render function, bind the buffers again and provide the shader with the format of the data in the buffer so it can correctly interpret it.</source>
          <target state="new">Later, during your render function, bind the buffers again and provide the shader with the format of the data in the buffer so it can correctly interpret it.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Bind the vertex buffers</source>
          <target state="new">OpenGL ES 2.0: Bind the vertex buffers</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In Direct3D, shader-accessible buffers are represented as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structures.</source>
          <target state="new">In Direct3D, shader-accessible buffers are represented as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structures.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>To bind the location of this buffer to shader object, you need to create a CD3D11\_BUFFER\_DESC structure for each buffer with <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3DDevice::CreateBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept>, and then set the buffer of the Direct3D device context by calling a set method specific to the buffer type, such as <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3DDeviceContext::IASetVertexBuffers<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</ept>.</source>
          <target state="new">To bind the location of this buffer to shader object, you need to create a CD3D11\_BUFFER\_DESC structure for each buffer with <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3DDevice::CreateBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept>, and then set the buffer of the Direct3D device context by calling a set method specific to the buffer type, such as <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3DDeviceContext::IASetVertexBuffers<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476456)</ept>.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>When you set the buffer, you must set the stride (the size of the data element for an individual vertex) as well the offset (where the vertex data array actually starts) from the beginning of the buffer.</source>
          <target state="new">When you set the buffer, you must set the stride (the size of the data element for an individual vertex) as well the offset (where the vertex data array actually starts) from the beginning of the buffer.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Notice that we assign the pointer to the <bpt id="p1">**</bpt>vertexIndices<ept id="p1">**</ept> array to the <bpt id="p2">**</bpt>pSysMem<ept id="p2">**</ept> field of the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure.</source>
          <target state="new">Notice that we assign the pointer to the <bpt id="p1">**</bpt>vertexIndices<ept id="p1">**</ept> array to the <bpt id="p2">**</bpt>pSysMem<ept id="p2">**</ept> field of the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>If this isn't correct, your mesh will be corrupt or empty!</source>
          <target state="new">If this isn't correct, your mesh will be corrupt or empty!</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Direct3D: Create and set the vertex buffer</source>
          <target state="new">Direct3D: Create and set the vertex buffer</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Step 3: Create and load the index buffer</source>
          <target state="new">Step 3: Create and load the index buffer</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Index buffers are an efficient way to allow the vertex shader to look up individual vertices.</source>
          <target state="new">Index buffers are an efficient way to allow the vertex shader to look up individual vertices.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Although they are not required, we use them in this sample renderer.</source>
          <target state="new">Although they are not required, we use them in this sample renderer.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>As with vertex buffers in OpenGL ES 2.0, an index buffer is created and bound as a general purpose buffer and the vertex indices you created earlier are copied into it.</source>
          <target state="new">As with vertex buffers in OpenGL ES 2.0, an index buffer is created and bound as a general purpose buffer and the vertex indices you created earlier are copied into it.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>When you're ready to draw, you bind both the vertex and the index buffer again, and call <bpt id="p1">**</bpt>glDrawElements<ept id="p1">**</ept>.</source>
          <target state="new">When you're ready to draw, you bind both the vertex and the index buffer again, and call <bpt id="p1">**</bpt>glDrawElements<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Send the index order to the draw call.</source>
          <target state="new">OpenGL ES 2.0: Send the index order to the draw call.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>With Direct3D, it's a bit very similar process, albeit a bit more didactic.</source>
          <target state="new">With Direct3D, it's a bit very similar process, albeit a bit more didactic.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Supply the index buffer as a Direct3D subresource to the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> you created when you configured Direct3D.</source>
          <target state="new">Supply the index buffer as a Direct3D subresource to the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept> you created when you configured Direct3D.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You do this by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::IASetIndexBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb173588)</ept> with the configured subresource for the index array, as follows.</source>
          <target state="new">You do this by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::IASetIndexBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb173588)</ept> with the configured subresource for the index array, as follows.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>(Again, notice that you assign the pointer to the <bpt id="p1">**</bpt>cubeIndices<ept id="p1">**</ept> array to the <bpt id="p2">**</bpt>pSysMem<ept id="p2">**</ept> field of the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure.)</source>
          <target state="new">(Again, notice that you assign the pointer to the <bpt id="p1">**</bpt>cubeIndices<ept id="p1">**</ept> array to the <bpt id="p2">**</bpt>pSysMem<ept id="p2">**</ept> field of the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure.)</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Direct3D: Create the index buffer.</source>
          <target state="new">Direct3D: Create the index buffer.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Later, you will draw the triangles with a call to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</ept> (or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::Draw<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476407)</ept> for unindexed vertices), as follows.</source>
          <target state="new">Later, you will draw the triangles with a call to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476409)</ept> (or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::Draw<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476407)</ept> for unindexed vertices), as follows.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>(For more details, jump ahead to <bpt id="p1">[</bpt>Draw to the screen<ept id="p1">](draw-to-the-screen.md)</ept>.)</source>
          <target state="new">(For more details, jump ahead to <bpt id="p1">[</bpt>Draw to the screen<ept id="p1">](draw-to-the-screen.md)</ept>.)</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Direct3D: Draw the indexed vertices.</source>
          <target state="new">Direct3D: Draw the indexed vertices.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Previous step</source>
          <target state="new">Previous step</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Port the shader objects</source>
          <target state="new">Port the shader objects</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Next step</source>
          <target state="new">Next step</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Port the GLSL</source>
          <target state="new">Port the GLSL</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="new">Remarks</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>When structuring your Direct3D, separate the code that calls methods on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</ept> into a method that is called whenever the device resources need to be recreated.</source>
          <target state="new">When structuring your Direct3D, separate the code that calls methods on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</ept> into a method that is called whenever the device resources need to be recreated.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>(In the Direct3D project template, this code is in the renderer object's <bpt id="p1">**</bpt>CreateDeviceResource<ept id="p1">**</ept> methods.</source>
          <target state="new">(In the Direct3D project template, this code is in the renderer object's <bpt id="p1">**</bpt>CreateDeviceResource<ept id="p1">**</ept> methods.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The code that updates the device context (<bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>), on the other hand, is placed in the <bpt id="p3">**</bpt>Render<ept id="p3">**</ept> method, since this is where you actually construct the shader stages and bind the data.</source>
          <target state="new">The code that updates the device context (<bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>), on the other hand, is placed in the <bpt id="p3">**</bpt>Render<ept id="p3">**</ept> method, since this is where you actually construct the shader stages and bind the data.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</source>
          <target state="new">How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Port the shader objects</source>
          <target state="new">Port the shader objects</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Port the vertex buffers and data</source>
          <target state="new">Port the vertex buffers and data</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Port the GLSL</source>
          <target state="new">Port the GLSL</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>