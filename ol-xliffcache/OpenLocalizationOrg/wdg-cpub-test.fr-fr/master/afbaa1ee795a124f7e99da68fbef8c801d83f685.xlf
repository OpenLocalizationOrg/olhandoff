<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">afbaa1ee795a124f7e99da68fbef8c801d83f685</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\port-the-glsl.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Port the GLSL</source>
          <target state="new">Port the GLSL</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Once you've moved over the code that creates and configures your buffers and shader objects, it's time to port the code inside those shaders from OpenGL ES 2.0's GL Shader Language (GLSL) to Direct3D 11's High-level Shader Language (HLSL).</source>
          <target state="new">Once you've moved over the code that creates and configures your buffers and shader objects, it's time to port the code inside those shaders from OpenGL ES 2.0's GL Shader Language (GLSL) to Direct3D 11's High-level Shader Language (HLSL).</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Port the GLSL</source>
          <target state="new">Port the GLSL</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Important APIs</source>
          <target state="new">Important APIs</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>HLSL Semantics</source>
          <target state="new">HLSL Semantics</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Shader Constants (HLSL)</source>
          <target state="new">Shader Constants (HLSL)</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Once you've moved over the code that creates and configures your buffers and shader objects, it's time to port the code inside those shaders from OpenGL ES 2.0's GL Shader Language (GLSL) to Direct3D 11's High-level Shader Language (HLSL).</source>
          <target state="new">Once you've moved over the code that creates and configures your buffers and shader objects, it's time to port the code inside those shaders from OpenGL ES 2.0's GL Shader Language (GLSL) to Direct3D 11's High-level Shader Language (HLSL).</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In OpenGL ES 2.0, shaders return data after execution using intrinsics such as <bpt id="p1">**</bpt>gl\_Position<ept id="p1">**</ept>, <bpt id="p2">**</bpt>gl\_FragColor<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>gl\_FragData\[n\]<ept id="p3">**</ept> (where n is the index for a specific render target).</source>
          <target state="new">In OpenGL ES 2.0, shaders return data after execution using intrinsics such as <bpt id="p1">**</bpt>gl\_Position<ept id="p1">**</ept>, <bpt id="p2">**</bpt>gl\_FragColor<ept id="p2">**</ept>, or <bpt id="p3">**</bpt>gl\_FragData\[n\]<ept id="p3">**</ept> (where n is the index for a specific render target).</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In Direct3D, there are no specific intrinsics, and the shaders return data as the return type of their respective main() functions.</source>
          <target state="new">In Direct3D, there are no specific intrinsics, and the shaders return data as the return type of their respective main() functions.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Data that you want interpolated between shader stages, such as the vertex position or normal, is handled through the use of the <bpt id="p1">**</bpt>varying<ept id="p1">**</ept> declaration.</source>
          <target state="new">Data that you want interpolated between shader stages, such as the vertex position or normal, is handled through the use of the <bpt id="p1">**</bpt>varying<ept id="p1">**</ept> declaration.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>However, Direct3D doesn't have this declaration; rather, any data that you want passed between shader stages must be marked with an <bpt id="p1">[</bpt>HLSL semantic<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb205574)</ept>.</source>
          <target state="new">However, Direct3D doesn't have this declaration; rather, any data that you want passed between shader stages must be marked with an <bpt id="p1">[</bpt>HLSL semantic<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb205574)</ept>.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The specific semantic chosen indicates the purpose of the data, and is.</source>
          <target state="new">The specific semantic chosen indicates the purpose of the data, and is.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, you'd declare vertex data that you want interpolated between the fragment shader as:</source>
          <target state="new">For example, you'd declare vertex data that you want interpolated between the fragment shader as:</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="new">or</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Where POSITION is the semantic used to indicate vertex position data.</source>
          <target state="new">Where POSITION is the semantic used to indicate vertex position data.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>POSITION is also a special case, since after interpolation, it cannot be accessed by the pixel shader.</source>
          <target state="new">POSITION is also a special case, since after interpolation, it cannot be accessed by the pixel shader.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Therefore, you must specify input to the pixel shader with SV\_POSITION and the interpolated vertex data will be placed in that variable.</source>
          <target state="new">Therefore, you must specify input to the pixel shader with SV\_POSITION and the interpolated vertex data will be placed in that variable.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Semantics can be declared on the body (main) methods of shaders.</source>
          <target state="new">Semantics can be declared on the body (main) methods of shaders.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>For pixel shaders, SV\_TARGET\[n\], which indicates a render target, is required on the body method.</source>
          <target state="new">For pixel shaders, SV\_TARGET\[n\], which indicates a render target, is required on the body method.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>(SV\_TARGET without a numeric suffix defaults to render target index 0.)</source>
          <target state="new">(SV\_TARGET without a numeric suffix defaults to render target index 0.)</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Also note that vertex shaders are required to output the SV\_POSITION system value semantic.</source>
          <target state="new">Also note that vertex shaders are required to output the SV\_POSITION system value semantic.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>This semantic resolves the vertex position data to coordinate values where x is between -1 and 1, y is between -1 and 1, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).</source>
          <target state="new">This semantic resolves the vertex position data to coordinate values where x is between -1 and 1, y is between -1 and 1, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Pixel shaders use the SV\_POSITION system value semantic to retrieve the pixel location on the screen, where x is between 0 and the render target width and y is between 0 and the render target height (each offset by 0.5).</source>
          <target state="new">Pixel shaders use the SV\_POSITION system value semantic to retrieve the pixel location on the screen, where x is between 0 and the render target width and y is between 0 and the render target height (each offset by 0.5).</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Feature level 9\_x pixel shaders cannot read from the SV\_POSITION value.</source>
          <target state="new">Feature level 9\_x pixel shaders cannot read from the SV\_POSITION value.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Constant buffers must be declared with <bpt id="p1">**</bpt>cbuffer<ept id="p1">**</ept> and be associated with a specific starting register for lookup.</source>
          <target state="new">Constant buffers must be declared with <bpt id="p1">**</bpt>cbuffer<ept id="p1">**</ept> and be associated with a specific starting register for lookup.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Direct3D 11: An HLSL constant buffer declaration</source>
          <target state="new">Direct3D 11: An HLSL constant buffer declaration</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Here, the constant buffer uses register b0 to hold the packed buffer.</source>
          <target state="new">Here, the constant buffer uses register b0 to hold the packed buffer.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>All registers are referred to in the form b\#.</source>
          <target state="new">All registers are referred to in the form b\#.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>For more information on the HLSL implementation of constant buffers, registers, and data packing, read <bpt id="p1">[</bpt>Shader Constants (HLSL)<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509581)</ept>.</source>
          <target state="new">For more information on the HLSL implementation of constant buffers, registers, and data packing, read <bpt id="p1">[</bpt>Shader Constants (HLSL)<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509581)</ept>.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="new">Instructions</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Step 1: Port the vertex shader</source>
          <target state="new">Step 1: Port the vertex shader</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>In our simple OpenGL ES 2.0 example, the vertex shader has three inputs: a constant model-view-projection 4x4 matrix, and two 4-coordinate vectors.</source>
          <target state="new">In our simple OpenGL ES 2.0 example, the vertex shader has three inputs: a constant model-view-projection 4x4 matrix, and two 4-coordinate vectors.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>These two vectors contain the vertex position and its color.</source>
          <target state="new">These two vectors contain the vertex position and its color.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The shader transforms the position vector to perspective coordinates and assigns it to the gl\_Position intrinsic for rasterization.</source>
          <target state="new">The shader transforms the position vector to perspective coordinates and assigns it to the gl\_Position intrinsic for rasterization.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The vertex color is copied to a varying variable for interpolation during rasterization, as well.</source>
          <target state="new">The vertex color is copied to a varying variable for interpolation during rasterization, as well.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Vertex shader for the cube object (GLSL)</source>
          <target state="new">OpenGL ES 2.0: Vertex shader for the cube object (GLSL)</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Now, in Direct3D, the constant model-view-projection matrix is contained in a constant buffer packed at register b0, and the vertex position and color are specifically marked with the appropriate respective HLSL semantics: POSITION and COLOR.</source>
          <target state="new">Now, in Direct3D, the constant model-view-projection matrix is contained in a constant buffer packed at register b0, and the vertex position and color are specifically marked with the appropriate respective HLSL semantics: POSITION and COLOR.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Since our input layout indicates a specific arrangement of these two vertex values, you create a struct to hold them and declare it as the type for the input parameter on the shader body function (main).</source>
          <target state="new">Since our input layout indicates a specific arrangement of these two vertex values, you create a struct to hold them and declare it as the type for the input parameter on the shader body function (main).</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>(You could also specify them as two individual parameters, but that could get cumbersome.) You also specify an output type for this stage, which contains the interpolated position and color, and declare it as the return value for the body function of the vertex shader.</source>
          <target state="new">(You could also specify them as two individual parameters, but that could get cumbersome.) You also specify an output type for this stage, which contains the interpolated position and color, and declare it as the return value for the body function of the vertex shader.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Vertex shader for the cube object (HLSL)</source>
          <target state="new">Direct3D 11: Vertex shader for the cube object (HLSL)</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The output data type, PixelShaderInput, is populated during rasterization and provided to the fragment (pixel) shader.</source>
          <target state="new">The output data type, PixelShaderInput, is populated during rasterization and provided to the fragment (pixel) shader.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Step 2: Port the fragment shader</source>
          <target state="new">Step 2: Port the fragment shader</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Our example fragment shader in GLSL is extremely simple: provide the gl\_FragColor intrinsic with the interpolated color value.</source>
          <target state="new">Our example fragment shader in GLSL is extremely simple: provide the gl\_FragColor intrinsic with the interpolated color value.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0 will write it to the default render target.</source>
          <target state="new">OpenGL ES 2.0 will write it to the default render target.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Fragment shader for the cube object (GLSL)</source>
          <target state="new">OpenGL ES 2.0: Fragment shader for the cube object (GLSL)</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Direct3D is almost as simple.</source>
          <target state="new">Direct3D is almost as simple.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The only significant difference is that the body function of the pixel shader must return a value.</source>
          <target state="new">The only significant difference is that the body function of the pixel shader must return a value.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Since the color is a 4-coordinate (RGBA) float value, you indicate float4 as the return type, and then specify the default render target as the SV\_TARGET system value semantic.</source>
          <target state="new">Since the color is a 4-coordinate (RGBA) float value, you indicate float4 as the return type, and then specify the default render target as the SV\_TARGET system value semantic.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Pixel shader for the cube object (HLSL)</source>
          <target state="new">Direct3D 11: Pixel shader for the cube object (HLSL)</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The color for the pixel at the position is written to the render target.</source>
          <target state="new">The color for the pixel at the position is written to the render target.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Now, let's see how to display the contents of that render target in <bpt id="p1">[</bpt>Draw to the screen<ept id="p1">](draw-to-the-screen.md)</ept>!</source>
          <target state="new">Now, let's see how to display the contents of that render target in <bpt id="p1">[</bpt>Draw to the screen<ept id="p1">](draw-to-the-screen.md)</ept>!</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Previous step</source>
          <target state="new">Previous step</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Port the vertex buffers and data<ept id="p1">](port-the-vertex-buffers-and-data-config.md)</ept> Next step</source>
          <target state="new"><bpt id="p1">[</bpt>Port the vertex buffers and data<ept id="p1">](port-the-vertex-buffers-and-data-config.md)</ept> Next step</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Draw to the screen<ept id="p1">](draw-to-the-screen.md)</ept> Remarks</source>
          <target state="new"><bpt id="p1">[</bpt>Draw to the screen<ept id="p1">](draw-to-the-screen.md)</ept> Remarks</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Understanding HLSL semantics and the packing of constant buffers can save you a bit of a debugging headache, as well as provide optimization opportunities.</source>
          <target state="new">Understanding HLSL semantics and the packing of constant buffers can save you a bit of a debugging headache, as well as provide optimization opportunities.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>If you get a chance, read through <bpt id="p1">[</bpt>Variable Syntax (HLSL)<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509706)</ept>, <bpt id="p2">[</bpt>Introduction to Buffers in Direct3D 11<ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/ff476898)</ept>, and <bpt id="p3">[</bpt>How to: Create a Constant Buffer<ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476896)</ept>.</source>
          <target state="new">If you get a chance, read through <bpt id="p1">[</bpt>Variable Syntax (HLSL)<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509706)</ept>, <bpt id="p2">[</bpt>Introduction to Buffers in Direct3D 11<ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/ff476898)</ept>, and <bpt id="p3">[</bpt>How to: Create a Constant Buffer<ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476896)</ept>.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>If not, though, here's a few starting tips to keep in mind about semantics and constant buffers:</source>
          <target state="new">If not, though, here's a few starting tips to keep in mind about semantics and constant buffers:</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Always double check your renderer's Direct3D configuration code to make sure that the structures for your constant buffers match the cbuffer struct declarations in your HLSL, and that the component scalar types match across both declarations.</source>
          <target state="new">Always double check your renderer's Direct3D configuration code to make sure that the structures for your constant buffers match the cbuffer struct declarations in your HLSL, and that the component scalar types match across both declarations.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>In your renderer's C++ code, use <bpt id="p1">[</bpt>DirectXMath<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh437833)</ept> types in your constant buffer declarations to ensure proper data packing.</source>
          <target state="new">In your renderer's C++ code, use <bpt id="p1">[</bpt>DirectXMath<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh437833)</ept> types in your constant buffer declarations to ensure proper data packing.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The best way to efficiently use constant buffers is to organize shader variables into constant buffers based on their frequency of update.</source>
          <target state="new">The best way to efficiently use constant buffers is to organize shader variables into constant buffers based on their frequency of update.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For example, if you have some uniform data that is updated once per frame, and other uniform data that is updated only when the camera moves, consider separating that data into two separate constant buffers.</source>
          <target state="new">For example, if you have some uniform data that is updated once per frame, and other uniform data that is updated only when the camera moves, consider separating that data into two separate constant buffers.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Semantics that you have forgotten to apply or which you have applied incorrectly will be your earliest source of shader compilation (FXC) errors.</source>
          <target state="new">Semantics that you have forgotten to apply or which you have applied incorrectly will be your earliest source of shader compilation (FXC) errors.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Double-check them!</source>
          <target state="new">Double-check them!</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The docs can be a bit confusing, as many older pages and samples refer to different versions of HLSL semantics prior to Direct3D 11.</source>
          <target state="new">The docs can be a bit confusing, as many older pages and samples refer to different versions of HLSL semantics prior to Direct3D 11.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Make sure you know which Direct3D feature level you are targeting for each shader.</source>
          <target state="new">Make sure you know which Direct3D feature level you are targeting for each shader.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The semantics for feature level 9\_\* are different from those for 11\_1.</source>
          <target state="new">The semantics for feature level 9\_\* are different from those for 11\_1.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>The SV\_POSITION semantic resolves the associated post-interpolation position data to coordinate values where x is between 0 and the render target width, y is between 0 and the render target height, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).</source>
          <target state="new">The SV\_POSITION semantic resolves the associated post-interpolation position data to coordinate values where x is between 0 and the render target width, y is between 0 and the render target height, z is divided by the original homogeneous coordinate w value (z/w), and w is 1 divided by the original w value (1/w).</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</source>
          <target state="new">How to: port a simple OpenGL ES 2.0 renderer to Direct3D 11</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Port the shader objects</source>
          <target state="new">Port the shader objects</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Port the vertex buffers and data</source>
          <target state="new">Port the vertex buffers and data</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Draw to the screen</source>
          <target state="new">Draw to the screen</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>