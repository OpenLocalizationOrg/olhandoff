<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c8454119f84c6a3ed2aea85cf0b94211dd9e030a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\optimize-performance-for-windows-store-direct3d-11-apps-with-coredispatcher.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Optimize input latency for Universal Windows Platform (UWP) DirectX games</source>
          <target state="new">Optimize input latency for Universal Windows Platform (UWP) DirectX games</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Input latency can significantly impact the experience of a game, and optimizing it can make a game feel more polished.</source>
          <target state="new">Input latency can significantly impact the experience of a game, and optimizing it can make a game feel more polished.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Optimize input latency for Universal Windows Platform (UWP) DirectX games</source>
          <target state="new">Optimize input latency for Universal Windows Platform (UWP) DirectX games</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Input latency can significantly impact the experience of a game, and optimizing it can make a game feel more polished.</source>
          <target state="new">Input latency can significantly impact the experience of a game, and optimizing it can make a game feel more polished.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Additionally, proper input event optimization can improve battery life.</source>
          <target state="new">Additionally, proper input event optimization can improve battery life.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Learn how to choose the right CoreDispatcher input event processing options to make sure your game handles input as smoothly as possible.</source>
          <target state="new">Learn how to choose the right CoreDispatcher input event processing options to make sure your game handles input as smoothly as possible.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Input latency</source>
          <target state="new">Input latency</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Input latency is the time it takes for the system to respond to user input.</source>
          <target state="new">Input latency is the time it takes for the system to respond to user input.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The response is often a change in what's displayed on the screen, or what's heard through audio feedback.</source>
          <target state="new">The response is often a change in what's displayed on the screen, or what's heard through audio feedback.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Every input event, whether it comes from a touch pointer, mouse pointer, or keyboard, generates a message to be processed by an event handler.</source>
          <target state="new">Every input event, whether it comes from a touch pointer, mouse pointer, or keyboard, generates a message to be processed by an event handler.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Modern touch digitizers and gaming peripherals report input events at a minimum of 100 Hz per pointer, which means that apps can receive 100 events or more per second per pointer (or keystroke).</source>
          <target state="new">Modern touch digitizers and gaming peripherals report input events at a minimum of 100 Hz per pointer, which means that apps can receive 100 events or more per second per pointer (or keystroke).</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This rate of updates is amplified if multiple pointers are happening concurrently, or a higher precision input device is used (for example, a gaming mouse).</source>
          <target state="new">This rate of updates is amplified if multiple pointers are happening concurrently, or a higher precision input device is used (for example, a gaming mouse).</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The event message queue can fill up very quickly.</source>
          <target state="new">The event message queue can fill up very quickly.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>It's important to understand the input latency demands of your game so that events are processed in a way that is best for the scenario.</source>
          <target state="new">It's important to understand the input latency demands of your game so that events are processed in a way that is best for the scenario.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>There is no one solution for all games.</source>
          <target state="new">There is no one solution for all games.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Power efficiency</source>
          <target state="new">Power efficiency</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In the context of input latency, "power efficiency" refers to how much a game uses the GPU.</source>
          <target state="new">In the context of input latency, "power efficiency" refers to how much a game uses the GPU.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>A game that uses less GPU resources is more power efficient and allows for longer battery life.</source>
          <target state="new">A game that uses less GPU resources is more power efficient and allows for longer battery life.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This also holds true for the CPU.</source>
          <target state="new">This also holds true for the CPU.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>If a game can draw the whole screen at less than 60 frames per second (currently, the maximum rendering speed on most displays) without degrading the user's experience, it will be more power efficient by drawing less often.</source>
          <target state="new">If a game can draw the whole screen at less than 60 frames per second (currently, the maximum rendering speed on most displays) without degrading the user's experience, it will be more power efficient by drawing less often.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Some games only update the screen in response to user input, so those games should not draw the same content repeatedly at 60 frames per second.</source>
          <target state="new">Some games only update the screen in response to user input, so those games should not draw the same content repeatedly at 60 frames per second.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Choosing what to optimize for</source>
          <target state="new">Choosing what to optimize for</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>When designing a DirectX app, you need to make some choices.</source>
          <target state="new">When designing a DirectX app, you need to make some choices.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Does the app need to render 60 frames per second to present smooth animation, or does it only need to render in response to input?</source>
          <target state="new">Does the app need to render 60 frames per second to present smooth animation, or does it only need to render in response to input?</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Does it need to have the lowest possible input latency, or can it tolerate a little bit of delay?</source>
          <target state="new">Does it need to have the lowest possible input latency, or can it tolerate a little bit of delay?</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Will my users expect my app to be judicious about battery usage?</source>
          <target state="new">Will my users expect my app to be judicious about battery usage?</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The answers to these questions will likely align your app with one of the following scenarios:</source>
          <target state="new">The answers to these questions will likely align your app with one of the following scenarios:</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Render on demand.</source>
          <target state="new">Render on demand.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Games in this category only need to update the screen in response to specific types of input.</source>
          <target state="new">Games in this category only need to update the screen in response to specific types of input.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Power efficiency is excellent because the app doesn’t render identical frames repeatedly, and input latency is low because the app spends most of its time waiting for input.</source>
          <target state="new">Power efficiency is excellent because the app doesn’t render identical frames repeatedly, and input latency is low because the app spends most of its time waiting for input.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Board games and news readers are examples of apps that might fall into this category.</source>
          <target state="new">Board games and news readers are examples of apps that might fall into this category.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Render on demand with transient animations.</source>
          <target state="new">Render on demand with transient animations.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This scenario is similar to the first scenario except that certain types of input will start an animation that isn’t dependent on subsequent input from the user.</source>
          <target state="new">This scenario is similar to the first scenario except that certain types of input will start an animation that isn’t dependent on subsequent input from the user.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Power efficiency is good because the game doesn’t render identical frames repeatedly, and input latency is low while the game is not animating.</source>
          <target state="new">Power efficiency is good because the game doesn’t render identical frames repeatedly, and input latency is low while the game is not animating.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Interactive children’s games and board games that animate each move are examples of apps that might fall into this category.</source>
          <target state="new">Interactive children’s games and board games that animate each move are examples of apps that might fall into this category.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Render 60 frames per second.</source>
          <target state="new">Render 60 frames per second.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In this scenario, the game is constantly updating the screen.</source>
          <target state="new">In this scenario, the game is constantly updating the screen.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Power efficiency is poor because it renders the maximum number of frames the display can present.</source>
          <target state="new">Power efficiency is poor because it renders the maximum number of frames the display can present.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Input latency is high because DirectX blocks the thread while content is being presented.</source>
          <target state="new">Input latency is high because DirectX blocks the thread while content is being presented.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Doing so prevents the thread from sending more frames to the display than it can show to the user.</source>
          <target state="new">Doing so prevents the thread from sending more frames to the display than it can show to the user.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>First person shooters, real-time strategy games, and physics-based games are examples of apps that might fall into this category.</source>
          <target state="new">First person shooters, real-time strategy games, and physics-based games are examples of apps that might fall into this category.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Render 60 frames per second and achieve the lowest possible input latency.</source>
          <target state="new">Render 60 frames per second and achieve the lowest possible input latency.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Similar to scenario 3, the app is constantly updating the screen, so power efficiency will be poor.</source>
          <target state="new">Similar to scenario 3, the app is constantly updating the screen, so power efficiency will be poor.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The difference is that the game responds to input on a separate thread, so that input processing isn’t blocked by presenting graphics to the display.</source>
          <target state="new">The difference is that the game responds to input on a separate thread, so that input processing isn’t blocked by presenting graphics to the display.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Online multiplayer games, fighting games, or rhythm/timing games might fall into this category because they support move inputs within extremely tight event windows.</source>
          <target state="new">Online multiplayer games, fighting games, or rhythm/timing games might fall into this category because they support move inputs within extremely tight event windows.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="new">Implementation</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Most DirectX games are driven by what is known as the game loop.</source>
          <target state="new">Most DirectX games are driven by what is known as the game loop.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The basic algorithm is to perform these steps until the user quits the game or app:</source>
          <target state="new">The basic algorithm is to perform these steps until the user quits the game or app:</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Process input</source>
          <target state="new">Process input</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Update the game state</source>
          <target state="new">Update the game state</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Draw the game content</source>
          <target state="new">Draw the game content</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>When the content of a DirectX game is rendered and ready to be presented to the screen, the game loop waits until the GPU is ready to receive a new frame before waking up to process input again.</source>
          <target state="new">When the content of a DirectX game is rendered and ready to be presented to the screen, the game loop waits until the GPU is ready to receive a new frame before waking up to process input again.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>We’ll show the implementation of the game loop for each of the scenarios mentioned earlier by iterating on a simple jigsaw puzzle game.</source>
          <target state="new">We’ll show the implementation of the game loop for each of the scenarios mentioned earlier by iterating on a simple jigsaw puzzle game.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The decision points, benefits, and tradeoffs discussed with each implementation can serve as a guide to help you optimize your apps for low latency input and power efficiency.</source>
          <target state="new">The decision points, benefits, and tradeoffs discussed with each implementation can serve as a guide to help you optimize your apps for low latency input and power efficiency.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Scenario 1: Render on demand</source>
          <target state="new">Scenario 1: Render on demand</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The first iteration of the jigsaw puzzle game only updates the screen when a user moves a puzzle piece.</source>
          <target state="new">The first iteration of the jigsaw puzzle game only updates the screen when a user moves a puzzle piece.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A user can either drag a puzzle piece into place or snap it into place by selecting it and then touching the correct destination.</source>
          <target state="new">A user can either drag a puzzle piece into place or snap it into place by selecting it and then touching the correct destination.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>In the second case, the puzzle piece will jump to the destination with no animation or effects.</source>
          <target state="new">In the second case, the puzzle piece will jump to the destination with no animation or effects.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>The code has a single-threaded game loop within the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IFrameworkView::Run<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh700505)</ept> method that uses <bpt id="p3">**</bpt>CoreProcessEventsOption::ProcessOneAndAllPending<ept id="p3">**</ept>.</source>
          <target state="new">The code has a single-threaded game loop within the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IFrameworkView::Run<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh700505)</ept> method that uses <bpt id="p3">**</bpt>CoreProcessEventsOption::ProcessOneAndAllPending<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Using this option dispatches all currently available events in the queue.</source>
          <target state="new">Using this option dispatches all currently available events in the queue.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If no events are pending, the game loop waits until one appears.</source>
          <target state="new">If no events are pending, the game loop waits until one appears.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Scenario 2: Render on demand with transient animations</source>
          <target state="new">Scenario 2: Render on demand with transient animations</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>In the second iteration, the game is modified so that when a user selects a puzzle piece and then touches the correct destination for that piece, it animates across the screen until it reaches its destination.</source>
          <target state="new">In the second iteration, the game is modified so that when a user selects a puzzle piece and then touches the correct destination for that piece, it animates across the screen until it reaches its destination.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>As before, the code has a single-threaded game loop that uses <bpt id="p1">**</bpt>ProcessOneAndAllPending<ept id="p1">**</ept> to dispatch input events in the queue.</source>
          <target state="new">As before, the code has a single-threaded game loop that uses <bpt id="p1">**</bpt>ProcessOneAndAllPending<ept id="p1">**</ept> to dispatch input events in the queue.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The difference now is that during an animation, the loop changes to use <bpt id="p1">**</bpt>CoreProcessEventsOption::ProcessAllIfPresent<ept id="p1">**</ept> so that it doesn’t wait for new input events.</source>
          <target state="new">The difference now is that during an animation, the loop changes to use <bpt id="p1">**</bpt>CoreProcessEventsOption::ProcessAllIfPresent<ept id="p1">**</ept> so that it doesn’t wait for new input events.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>If no events are pending, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ProcessEvents<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208215)</ept> returns immediately and allows the app to present the next frame in the animation.</source>
          <target state="new">If no events are pending, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ProcessEvents<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208215)</ept> returns immediately and allows the app to present the next frame in the animation.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>When the animation is complete, the loop switches back to <bpt id="p1">**</bpt>ProcessOneAndAllPending<ept id="p1">**</ept> to limit screen updates.</source>
          <target state="new">When the animation is complete, the loop switches back to <bpt id="p1">**</bpt>ProcessOneAndAllPending<ept id="p1">**</ept> to limit screen updates.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>To support the transition between <bpt id="p1">**</bpt>ProcessOneAndAllPending<ept id="p1">**</ept> and <bpt id="p2">**</bpt>ProcessAllIfPresent<ept id="p2">**</ept>, the app must track state to know if it’s animating.</source>
          <target state="new">To support the transition between <bpt id="p1">**</bpt>ProcessOneAndAllPending<ept id="p1">**</ept> and <bpt id="p2">**</bpt>ProcessAllIfPresent<ept id="p2">**</ept>, the app must track state to know if it’s animating.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In the jigsaw puzzle app, you do this by adding a new method that can be called during the game loop on the GameState class.</source>
          <target state="new">In the jigsaw puzzle app, you do this by adding a new method that can be called during the game loop on the GameState class.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The animation branch of the game loop drives updates in the state of the animation by calling GameState’s new Update method.</source>
          <target state="new">The animation branch of the game loop drives updates in the state of the animation by calling GameState’s new Update method.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Scenario 3: Render 60 frames per second</source>
          <target state="new">Scenario 3: Render 60 frames per second</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In the third iteration, the app displays a timer that shows the user how long they’ve been working on the puzzle.</source>
          <target state="new">In the third iteration, the app displays a timer that shows the user how long they’ve been working on the puzzle.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Because it displays the elapsed time up to the millisecond, it must render 60 frames per second to keep the display up to date.</source>
          <target state="new">Because it displays the elapsed time up to the millisecond, it must render 60 frames per second to keep the display up to date.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>As in scenarios 1 and 2, the app has a single-threaded game loop.</source>
          <target state="new">As in scenarios 1 and 2, the app has a single-threaded game loop.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The difference with this scenario is that because it’s always rendering, it no longer needs to track changes in the game state as was done in the first two scenarios.</source>
          <target state="new">The difference with this scenario is that because it’s always rendering, it no longer needs to track changes in the game state as was done in the first two scenarios.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>As a result, it can default to use <bpt id="p1">**</bpt>ProcessAllIfPresent<ept id="p1">**</ept> for processing events.</source>
          <target state="new">As a result, it can default to use <bpt id="p1">**</bpt>ProcessAllIfPresent<ept id="p1">**</ept> for processing events.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>If no events are pending, <bpt id="p1">**</bpt>ProcessEvents<ept id="p1">**</ept> returns immediately and proceeds to render the next frame.</source>
          <target state="new">If no events are pending, <bpt id="p1">**</bpt>ProcessEvents<ept id="p1">**</ept> returns immediately and proceeds to render the next frame.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>This approach is the easiest way to write a game because there’s no need to track additional state to determine when to render.</source>
          <target state="new">This approach is the easiest way to write a game because there’s no need to track additional state to determine when to render.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>It achieves the fastest rendering possible along with reasonable input responsiveness on a timer interval.</source>
          <target state="new">It achieves the fastest rendering possible along with reasonable input responsiveness on a timer interval.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>However, this ease of development comes with a price.</source>
          <target state="new">However, this ease of development comes with a price.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Rendering at 60 frames per second uses more power than rendering on demand.</source>
          <target state="new">Rendering at 60 frames per second uses more power than rendering on demand.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>It’s best to use <bpt id="p1">**</bpt>ProcessAllIfPresent<ept id="p1">**</ept> when the game is changing what is displayed every frame.</source>
          <target state="new">It’s best to use <bpt id="p1">**</bpt>ProcessAllIfPresent<ept id="p1">**</ept> when the game is changing what is displayed every frame.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>It also increases input latency by as much as 16.7 ms because the app is now blocking the game loop on the display’s sync interval instead of on <bpt id="p1">**</bpt>ProcessEvents<ept id="p1">**</ept>.</source>
          <target state="new">It also increases input latency by as much as 16.7 ms because the app is now blocking the game loop on the display’s sync interval instead of on <bpt id="p1">**</bpt>ProcessEvents<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Some input events might be dropped because the queue is only processed once per frame (60 Hz).</source>
          <target state="new">Some input events might be dropped because the queue is only processed once per frame (60 Hz).</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Scenario 4: Render 60 frames per second and achieve the lowest possible input latency</source>
          <target state="new">Scenario 4: Render 60 frames per second and achieve the lowest possible input latency</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Some games may be able to ignore or compensate for the increase in input latency seen in scenario 3.</source>
          <target state="new">Some games may be able to ignore or compensate for the increase in input latency seen in scenario 3.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>However, if low input latency is critical to the game’s experience and sense of player feedback, games that render 60 frames per second need to process input on a separate thread.</source>
          <target state="new">However, if low input latency is critical to the game’s experience and sense of player feedback, games that render 60 frames per second need to process input on a separate thread.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>The fourth iteration of the jigsaw puzzle game builds on scenario 3 by splitting the input processing and graphics rendering from the game loop into separate threads.</source>
          <target state="new">The fourth iteration of the jigsaw puzzle game builds on scenario 3 by splitting the input processing and graphics rendering from the game loop into separate threads.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Having separate threads for each ensures that input is never delayed by graphics output; however, the code becomes more complex as a result.</source>
          <target state="new">Having separate threads for each ensures that input is never delayed by graphics output; however, the code becomes more complex as a result.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>In scenario 4, the input thread calls <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ProcessEvents<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208215)</ept> with <bpt id="p3">[</bpt><bpt id="p4">**</bpt>CoreProcessEventsOption::ProcessUntilQuit<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208217)</ept>, which waits for new events and dispatches all available events.</source>
          <target state="new">In scenario 4, the input thread calls <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ProcessEvents<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208215)</ept> with <bpt id="p3">[</bpt><bpt id="p4">**</bpt>CoreProcessEventsOption::ProcessUntilQuit<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208217)</ept>, which waits for new events and dispatches all available events.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>It continues this behavior until the window is closed or the game calls <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindow::Close<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208260)</ept>.</source>
          <target state="new">It continues this behavior until the window is closed or the game calls <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindow::Close<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208260)</ept>.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>DirectX 11 and XAML App (Universal Windows)<ept id="p1">**</ept> template in Microsoft Visual Studio 2015 splits the game loop into multiple threads in a similar fashion.</source>
          <target state="new">The <bpt id="p1">**</bpt>DirectX 11 and XAML App (Universal Windows)<ept id="p1">**</ept> template in Microsoft Visual Studio 2015 splits the game loop into multiple threads in a similar fashion.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>It uses the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows::UI::Core::CoreIndependentInputSource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn298460)</ept> object to start a thread dedicated to handling input and also creates a rendering thread independent of the XAML UI thread.</source>
          <target state="new">It uses the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows::UI::Core::CoreIndependentInputSource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn298460)</ept> object to start a thread dedicated to handling input and also creates a rendering thread independent of the XAML UI thread.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>For more details on these templates, read <bpt id="p1">[</bpt>Create a Universal Windows Platform and DirectX game project from a template<ept id="p1">](user-interface.md)</ept>.</source>
          <target state="new">For more details on these templates, read <bpt id="p1">[</bpt>Create a Universal Windows Platform and DirectX game project from a template<ept id="p1">](user-interface.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Additional ways to reduce input latency</source>
          <target state="new">Additional ways to reduce input latency</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Use waitable swap chains</source>
          <target state="new">Use waitable swap chains</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>DirectX games respond to user input by updating what the user sees on-screen.</source>
          <target state="new">DirectX games respond to user input by updating what the user sees on-screen.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>On a 60 Hz display, the screen refreshes every 16.7 ms (1 second/60 frames).</source>
          <target state="new">On a 60 Hz display, the screen refreshes every 16.7 ms (1 second/60 frames).</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Figure 1 shows the approximate life cycle and response to an input event relative to the 16.7 ms refresh signal (VBlank) for an app that renders 60 frames per second:</source>
          <target state="new">Figure 1 shows the approximate life cycle and response to an input event relative to the 16.7 ms refresh signal (VBlank) for an app that renders 60 frames per second:</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Figure 1</source>
          <target state="new">Figure 1</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>figure 1 input latency in directx</source>
          <target state="new">figure 1 input latency in directx</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In Windows 8.1, DXGI introduced the <bpt id="p1">**</bpt>DXGI\_SWAP\_CHAIN\_FLAG\_FRAME\_LATENCY\_WAITABLE\_OBJECT<ept id="p1">**</ept> flag for the swap chain, which allows apps to easily reduce this latency without requiring them to implement heuristics to keep the Present queue empty.</source>
          <target state="new">In Windows 8.1, DXGI introduced the <bpt id="p1">**</bpt>DXGI\_SWAP\_CHAIN\_FLAG\_FRAME\_LATENCY\_WAITABLE\_OBJECT<ept id="p1">**</ept> flag for the swap chain, which allows apps to easily reduce this latency without requiring them to implement heuristics to keep the Present queue empty.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Swap chains created with this flag are referred to as waitable swap chains.</source>
          <target state="new">Swap chains created with this flag are referred to as waitable swap chains.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Figure 2 shows the approximate life cycle and response to an input event when using waitable swap chains:</source>
          <target state="new">Figure 2 shows the approximate life cycle and response to an input event when using waitable swap chains:</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Figure 2</source>
          <target state="new">Figure 2</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>figure2 input latency in directx waitable</source>
          <target state="new">figure2 input latency in directx waitable</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>What we see from these diagrams is that games can potentially reduce input latency by two full frames if they are capable of rendering and presenting each frame within the 16.7 ms budget defined by the display’s refresh rate.</source>
          <target state="new">What we see from these diagrams is that games can potentially reduce input latency by two full frames if they are capable of rendering and presenting each frame within the 16.7 ms budget defined by the display’s refresh rate.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The jigsaw puzzle sample uses waitable swap chains and controls the Present queue limit by calling:</source>
          <target state="new">The jigsaw puzzle sample uses waitable swap chains and controls the Present queue limit by calling:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>