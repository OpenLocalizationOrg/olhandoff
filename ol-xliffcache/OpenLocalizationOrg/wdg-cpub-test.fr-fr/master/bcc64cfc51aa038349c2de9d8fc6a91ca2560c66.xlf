<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">bcc64cfc51aa038349c2de9d8fc6a91ca2560c66</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci1\xaml-platform\events-and-routed-events-overview.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>We describe the programming concept of events in a Windows Runtime app, when using C#, Visual Basic or Visual C++ component extensions (C++/CX) as your programming language, and XAML for your UI definition.</source>
          <target state="new">We describe the programming concept of events in a Windows Runtime app, when using C#, Visual Basic or Visual C++ component extensions (C++/CX) as your programming language, and XAML for your UI definition.</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Events and routed events overview</source>
          <target state="new">Events and routed events overview</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Events and routed events overview</source>
          <target state="new">Events and routed events overview</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Important APIs</source>
          <target state="new">Important APIs</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>UIElement</source>
          <target state="new">UIElement</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>RoutedEventArgs</source>
          <target state="new">RoutedEventArgs</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>We describe the programming concept of events in a Windows Runtime app, when using C#, Visual Basic or Visual C++ component extensions (C++/CX) as your programming language, and XAML for your UI definition.</source>
          <target state="new">We describe the programming concept of events in a Windows Runtime app, when using C#, Visual Basic or Visual C++ component extensions (C++/CX) as your programming language, and XAML for your UI definition.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You can assign handlers for events as part of the declarations for UI elements in XAML, or you can add the handlers in code.</source>
          <target state="new">You can assign handlers for events as part of the declarations for UI elements in XAML, or you can add the handlers in code.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Windows Runtime supports <bpt id="p1">*</bpt>routed events<ept id="p1">*</ept>: certain input events and data events can be handled by objects beyond the object that fired the event.</source>
          <target state="new">Windows Runtime supports <bpt id="p1">*</bpt>routed events<ept id="p1">*</ept>: certain input events and data events can be handled by objects beyond the object that fired the event.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Routed events are useful when you define control templates, or use pages or layout containers.</source>
          <target state="new">Routed events are useful when you define control templates, or use pages or layout containers.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Events as a programming concept</source>
          <target state="new">Events as a programming concept</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Generally speaking, event concepts when programming a Windows Runtime app are similar to the event model in most popular programming languages.</source>
          <target state="new">Generally speaking, event concepts when programming a Windows Runtime app are similar to the event model in most popular programming languages.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>If you know how to work with Microsoft .NET or C++ events already, you have a head start.</source>
          <target state="new">If you know how to work with Microsoft .NET or C++ events already, you have a head start.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>But you don't need to know that much about event model concepts to perform some basic tasks, such as attaching handlers.</source>
          <target state="new">But you don't need to know that much about event model concepts to perform some basic tasks, such as attaching handlers.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>When you use C#, Visual Basic or C++/CX as your programming language, the UI is defined in markup (XAML).</source>
          <target state="new">When you use C#, Visual Basic or C++/CX as your programming language, the UI is defined in markup (XAML).</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>In XAML markup syntax, some of the principles of connecting events between markup elements and runtime code entities are similar to other Web technologies, such as ASP.NET, or HTML5.</source>
          <target state="new">In XAML markup syntax, some of the principles of connecting events between markup elements and runtime code entities are similar to other Web technologies, such as ASP.NET, or HTML5.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  The code that provides the runtime logic for a XAML-defined UI is often referred to as <bpt id="p2">*</bpt>code-behind<ept id="p2">*</ept> or the code-behind file.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  The code that provides the runtime logic for a XAML-defined UI is often referred to as <bpt id="p2">*</bpt>code-behind<ept id="p2">*</ept> or the code-behind file.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>In the Microsoft Visual Studio solution views, this relationship is shown graphically, with the code-behind file being a dependent and nested file versus the XAML page it refers to.</source>
          <target state="new">In the Microsoft Visual Studio solution views, this relationship is shown graphically, with the code-behind file being a dependent and nested file versus the XAML page it refers to.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Button.Click: an introduction to events and XAML</source>
          <target state="new">Button.Click: an introduction to events and XAML</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>One of the most common programming tasks for a Windows Runtime app is to capture user input to the UI.</source>
          <target state="new">One of the most common programming tasks for a Windows Runtime app is to capture user input to the UI.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>For example, your UI might have a button that the user must click to submit info or to change state.</source>
          <target state="new">For example, your UI might have a button that the user must click to submit info or to change state.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You define the UI for your Windows Runtime app by generating XAML.</source>
          <target state="new">You define the UI for your Windows Runtime app by generating XAML.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This XAML is usually the output from a design surface in Visual Studio.</source>
          <target state="new">This XAML is usually the output from a design surface in Visual Studio.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>You can also write the XAML in a plain-text editor or a third-party XAML editor.</source>
          <target state="new">You can also write the XAML in a plain-text editor or a third-party XAML editor.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>While generating that XAML, you can wire event handlers for individual UI elements at the same time that you define all the other XAML attributes that establish property values of that UI element.</source>
          <target state="new">While generating that XAML, you can wire event handlers for individual UI elements at the same time that you define all the other XAML attributes that establish property values of that UI element.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>To wire the events in XAML, you specify the string-form name of the handler method that you've already defined or will define later in your code-behind.</source>
          <target state="new">To wire the events in XAML, you specify the string-form name of the handler method that you've already defined or will define later in your code-behind.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>For example, this XAML defines a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Button<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> object with other properties (<bpt id="p3">[</bpt>x:Name attribute<ept id="p3">](x-name-attribute.md)</ept>, <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Content<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br209366)</ept>) assigned as attributes, and wires a handler for the button's <bpt id="p6">[</bpt><bpt id="p7">**</bpt>Click<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/br227737)</ept> event by referencing a method named <ph id="ph1">`showUpdatesButton_Click`</ph>:</source>
          <target state="new">For example, this XAML defines a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Button<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> object with other properties (<bpt id="p3">[</bpt>x:Name attribute<ept id="p3">](x-name-attribute.md)</ept>, <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Content<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br209366)</ept>) assigned as attributes, and wires a handler for the button's <bpt id="p6">[</bpt><bpt id="p7">**</bpt>Click<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/br227737)</ept> event by referencing a method named <ph id="ph1">`showUpdatesButton_Click`</ph>:</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>  <bpt id="p2">*</bpt>Event wiring<ept id="p2">*</ept> is a programming term.</source>
          <target state="new"><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>  <bpt id="p2">*</bpt>Event wiring<ept id="p2">*</ept> is a programming term.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>It refers to the process or code whereby you indicate that occurrences of an event should invoke a named handler method.</source>
          <target state="new">It refers to the process or code whereby you indicate that occurrences of an event should invoke a named handler method.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In most procedural code models, event wiring is implicit or explicit "AddHandler" code that names both the event and method, and usually involves a target object instance.</source>
          <target state="new">In most procedural code models, event wiring is implicit or explicit "AddHandler" code that names both the event and method, and usually involves a target object instance.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In XAML, the "AddHandler" is implicit, and event wiring consists entirely of naming the event as the attribute name of an object element, and naming the handler as that attribute's value.</source>
          <target state="new">In XAML, the "AddHandler" is implicit, and event wiring consists entirely of naming the event as the attribute name of an object element, and naming the handler as that attribute's value.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>You write the actual handler in the programming language that you're using for all your app's code and code-behind.</source>
          <target state="new">You write the actual handler in the programming language that you're using for all your app's code and code-behind.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>With the attribute <ph id="ph1">`Click="showUpdatesButton_Click"`</ph>, you have created a contract that when the XAML is markup-compiled and parsed, both the XAML markup compile step in your IDE's build action and the eventual XAML parse when the app loads can find a method named <ph id="ph2">`showUpdatesButton_Click`</ph> as part of the app's code.</source>
          <target state="new">With the attribute <ph id="ph1">`Click="showUpdatesButton_Click"`</ph>, you have created a contract that when the XAML is markup-compiled and parsed, both the XAML markup compile step in your IDE's build action and the eventual XAML parse when the app loads can find a method named <ph id="ph2">`showUpdatesButton_Click`</ph> as part of the app's code.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>must be a method that implements a compatible method signature (based on a delegate) for any handler of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Click<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227737)</ept> event.</source>
          <target state="new">must be a method that implements a compatible method signature (based on a delegate) for any handler of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Click<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227737)</ept> event.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>For example, this code defines the <ph id="ph1">`showUpdatesButton_Click`</ph> handler.</source>
          <target state="new">For example, this code defines the <ph id="ph1">`showUpdatesButton_Click`</ph> handler.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>In this example, the <ph id="ph1">`showUpdatesButton_Click`</ph> method is based on the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>RoutedEventHandler<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208812)</ept> delegate.</source>
          <target state="new">In this example, the <ph id="ph1">`showUpdatesButton_Click`</ph> method is based on the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>RoutedEventHandler<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208812)</ept> delegate.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>You'd know that this is the delegate to use because you'll see that delegate named in the syntax for the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Click<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227737)</ept> method on the MSDN reference page.</source>
          <target state="new">You'd know that this is the delegate to use because you'll see that delegate named in the syntax for the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Click<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227737)</ept> method on the MSDN reference page.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>  Visual Studio provides a convenient way to name the event handler and define the handler method while you're editing XAML.</source>
          <target state="new"><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>  Visual Studio provides a convenient way to name the event handler and define the handler method while you're editing XAML.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When you provide the attribute name of the event in the XAML text editor, wait a moment until a Microsoft IntelliSense list displays.</source>
          <target state="new">When you provide the attribute name of the event in the XAML text editor, wait a moment until a Microsoft IntelliSense list displays.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If you click <bpt id="p1">**</bpt><ph id="ph1">&amp;lt;</ph>New Event Handler<ph id="ph2">&amp;gt;</ph><ept id="p1">**</ept> from the list, Microsoft Visual Studio will suggest a method name based on the element's <bpt id="p2">**</bpt>x:Name<ept id="p2">**</ept> (or type name), the event name, and a numeric suffix.</source>
          <target state="new">If you click <bpt id="p1">**</bpt><ph id="ph1">&amp;lt;</ph>New Event Handler<ph id="ph2">&amp;gt;</ph><ept id="p1">**</ept> from the list, Microsoft Visual Studio will suggest a method name based on the element's <bpt id="p2">**</bpt>x:Name<ept id="p2">**</ept> (or type name), the event name, and a numeric suffix.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can then right-click the selected event handler name and click <bpt id="p1">**</bpt>Navigate to Event Handler<ept id="p1">**</ept>.</source>
          <target state="new">You can then right-click the selected event handler name and click <bpt id="p1">**</bpt>Navigate to Event Handler<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>This will navigate directly to the newly inserted event handler definition, as seen in the code editor view of your code-behind file for the XAML page.</source>
          <target state="new">This will navigate directly to the newly inserted event handler definition, as seen in the code editor view of your code-behind file for the XAML page.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The event handler already has the correct signature, including the <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> parameter and the event data class that the event uses.</source>
          <target state="new">The event handler already has the correct signature, including the <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> parameter and the event data class that the event uses.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Also, if a handler method with the correct signature already exists in your code-behind, that method's name appears in the auto-complete drop-down along with the <bpt id="p1">**</bpt><ph id="ph1">&amp;lt;</ph>New Event Handler<ph id="ph2">&amp;gt;</ph><ept id="p1">**</ept> option.</source>
          <target state="new">Also, if a handler method with the correct signature already exists in your code-behind, that method's name appears in the auto-complete drop-down along with the <bpt id="p1">**</bpt><ph id="ph1">&amp;lt;</ph>New Event Handler<ph id="ph2">&amp;gt;</ph><ept id="p1">**</ept> option.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You can also press the Tab key as a shortcut instead of clicking the IntelliSense list items.</source>
          <target state="new">You can also press the Tab key as a shortcut instead of clicking the IntelliSense list items.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Defining an event handler</source>
          <target state="new">Defining an event handler</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>For objects that are UI elements and declared in XAML, event handler code is defined in the partial class that serves as the code-behind for a XAML page.</source>
          <target state="new">For objects that are UI elements and declared in XAML, event handler code is defined in the partial class that serves as the code-behind for a XAML page.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Event handlers are methods that you write as part of the partial class that is associated with your XAML.</source>
          <target state="new">Event handlers are methods that you write as part of the partial class that is associated with your XAML.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>These event handlers are based on the delegates that a particular event uses.</source>
          <target state="new">These event handlers are based on the delegates that a particular event uses.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Your event handler methods can be public or private.</source>
          <target state="new">Your event handler methods can be public or private.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Private access works because the handler and instance created by the XAML are ultimately joined by code generation.</source>
          <target state="new">Private access works because the handler and instance created by the XAML are ultimately joined by code generation.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>In general, we recommend that you make your event handler methods private in the class.</source>
          <target state="new">In general, we recommend that you make your event handler methods private in the class.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Event handlers for C++ don't get defined in partial classes, they are declared in the header as a private class member.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Event handlers for C++ don't get defined in partial classes, they are declared in the header as a private class member.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The build actions for a C++ project take care of generating code that supports the XAML type system and code-behind model for C++.</source>
          <target state="new">The build actions for a C++ project take care of generating code that supports the XAML type system and code-behind model for C++.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> parameter and event data</source>
          <target state="new">The <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> parameter and event data</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The handler you write for the event can access two values that are available as input for each case where your handler is invoked.</source>
          <target state="new">The handler you write for the event can access two values that are available as input for each case where your handler is invoked.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>The first such value is <bpt id="p1">*</bpt>sender<ept id="p1">*</ept>, which is a reference to the object where the handler is attached.</source>
          <target state="new">The first such value is <bpt id="p1">*</bpt>sender<ept id="p1">*</ept>, which is a reference to the object where the handler is attached.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> parameter is typed as the base <bpt id="p2">**</bpt>Object<ept id="p2">**</ept> type.</source>
          <target state="new">The <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> parameter is typed as the base <bpt id="p2">**</bpt>Object<ept id="p2">**</ept> type.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>A common technique is to cast <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> to a more precise type.</source>
          <target state="new">A common technique is to cast <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> to a more precise type.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>This technique is useful if you expect to check or change state on the <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> object itself.</source>
          <target state="new">This technique is useful if you expect to check or change state on the <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> object itself.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Based on your own app design, you usually know a type that is safe to cast <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> to, based on where the handler is attached or other design specifics.</source>
          <target state="new">Based on your own app design, you usually know a type that is safe to cast <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> to, based on where the handler is attached or other design specifics.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The second value is event data, which generally appears in syntax definitions as the <bpt id="p1">*</bpt>e<ept id="p1">*</ept> parameter.</source>
          <target state="new">The second value is event data, which generally appears in syntax definitions as the <bpt id="p1">*</bpt>e<ept id="p1">*</ept> parameter.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>You can discover which properties for event data are available by looking at the <bpt id="p1">*</bpt>e<ept id="p1">*</ept> parameter of the delegate that is assigned for the specific event you are handling, and then using IntelliSense or Object Browser in Visual Studio.</source>
          <target state="new">You can discover which properties for event data are available by looking at the <bpt id="p1">*</bpt>e<ept id="p1">*</ept> parameter of the delegate that is assigned for the specific event you are handling, and then using IntelliSense or Object Browser in Visual Studio.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Or you can use the Windows Runtime reference documentation.</source>
          <target state="new">Or you can use the Windows Runtime reference documentation.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For some events, the event data's specific property values are as important as knowing that the event occurred.</source>
          <target state="new">For some events, the event data's specific property values are as important as knowing that the event occurred.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>This is especially true of the input events.</source>
          <target state="new">This is especially true of the input events.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For pointer events, the position of the pointer when the event occurred might be important.</source>
          <target state="new">For pointer events, the position of the pointer when the event occurred might be important.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For keyboard events, all possible key presses fire a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>KeyDown<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>KeyUp<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> event.</source>
          <target state="new">For keyboard events, all possible key presses fire a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>KeyDown<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208941)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>KeyUp<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208942)</ept> event.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>To determine which key a user pressed, you must access the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>KeyRoutedEventArgs<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh943072)</ept> that is available to the event handler.</source>
          <target state="new">To determine which key a user pressed, you must access the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>KeyRoutedEventArgs<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh943072)</ept> that is available to the event handler.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>For more info about handling input events, see <bpt id="p1">[</bpt>Keyboard interactions<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/mt185607)</ept> and <bpt id="p2">[</bpt>Handle pointer input<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/mt404610)</ept>.</source>
          <target state="new">For more info about handling input events, see <bpt id="p1">[</bpt>Keyboard interactions<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/mt185607)</ept> and <bpt id="p2">[</bpt>Handle pointer input<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/mt404610)</ept>.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Input events and input scenarios often have additional considerations that are not covered in this topic, such as pointer capture for pointer events, and modifier keys and platform key codes for keyboard events.</source>
          <target state="new">Input events and input scenarios often have additional considerations that are not covered in this topic, such as pointer capture for pointer events, and modifier keys and platform key codes for keyboard events.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Event handlers that use the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> pattern</source>
          <target state="new">Event handlers that use the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> pattern</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In some cases you'll want to use APIs that use an <bpt id="p1">**</bpt>async<ept id="p1">**</ept> pattern within an event handler.</source>
          <target state="new">In some cases you'll want to use APIs that use an <bpt id="p1">**</bpt>async<ept id="p1">**</ept> pattern within an event handler.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For example, you might use a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Button<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> in an <bpt id="p3">[</bpt><bpt id="p4">**</bpt>AppBar<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh701927)</ept> to display a file picker and interact with it.</source>
          <target state="new">For example, you might use a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Button<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> in an <bpt id="p3">[</bpt><bpt id="p4">**</bpt>AppBar<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh701927)</ept> to display a file picker and interact with it.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>However, many of the file picker APIs are asynchronous.</source>
          <target state="new">However, many of the file picker APIs are asynchronous.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>They have to be called within an <bpt id="p1">**</bpt>async<ept id="p1">**</ept>/awaitable scope, and the compiler will enforce this.</source>
          <target state="new">They have to be called within an <bpt id="p1">**</bpt>async<ept id="p1">**</ept>/awaitable scope, and the compiler will enforce this.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>So what you can do is add the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> keyword to your event handler such that the handler is now <bpt id="p2">**</bpt>async<ept id="p2">**</ept> <bpt id="p3">**</bpt>void<ept id="p3">**</ept>.</source>
          <target state="new">So what you can do is add the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> keyword to your event handler such that the handler is now <bpt id="p2">**</bpt>async<ept id="p2">**</ept> <bpt id="p3">**</bpt>void<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Now your event handler is permitted to make <bpt id="p1">**</bpt>async<ept id="p1">**</ept>/awaitable calls.</source>
          <target state="new">Now your event handler is permitted to make <bpt id="p1">**</bpt>async<ept id="p1">**</ept>/awaitable calls.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>For an example of user-interaction event handling using the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> pattern, see <bpt id="p2">[</bpt>File access and pickers<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/jj655411)</ept> (part of the<bpt id="p3">[</bpt>Create your first Windows Runtime app using C# or Visual Basic<ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh974581)</ept> series).</source>
          <target state="new">For an example of user-interaction event handling using the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> pattern, see <bpt id="p2">[</bpt>File access and pickers<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/jj655411)</ept> (part of the<bpt id="p3">[</bpt>Create your first Windows Runtime app using C# or Visual Basic<ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh974581)</ept> series).</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>See also [Call asynchronous APIs in C).</source>
          <target state="new">See also [Call asynchronous APIs in C).</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Adding event handlers in code</source>
          <target state="new">Adding event handlers in code</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>XAML is not the only way to assign an event handler to an object.</source>
          <target state="new">XAML is not the only way to assign an event handler to an object.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>To add event handlers to any given object in code, including to objects that are not usable in XAML, you can use the language-specific syntax for adding event handlers.</source>
          <target state="new">To add event handlers to any given object in code, including to objects that are not usable in XAML, you can use the language-specific syntax for adding event handlers.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>In C#, the syntax is to use the <ph id="ph1">`+=`</ph> operator.</source>
          <target state="new">In C#, the syntax is to use the <ph id="ph1">`+=`</ph> operator.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>You register the handler by referencing the event handler method name on the right side of the operator.</source>
          <target state="new">You register the handler by referencing the event handler method name on the right side of the operator.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If you use code to add event handlers to objects that appear in the run-time UI, a common practice is to add such handlers in response to an object lifetime event or callback, such as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Loaded<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208723)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>OnApplyTemplate<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208737)</ept>, so that the event handlers on the relevant object are ready for user-initiated events at run time.</source>
          <target state="new">If you use code to add event handlers to objects that appear in the run-time UI, a common practice is to add such handlers in response to an object lifetime event or callback, such as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Loaded<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208723)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>OnApplyTemplate<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208737)</ept>, so that the event handlers on the relevant object are ready for user-initiated events at run time.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>This example shows a XAML outline of the page structure and then provides the C# language syntax for adding an event handler to an object.</source>
          <target state="new">This example shows a XAML outline of the page structure and then provides the C# language syntax for adding an event handler to an object.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  A more verbose syntax exists.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  A more verbose syntax exists.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>In 2005, C# added a feature called delegate inference, which enables a compiler to infer the new delegate instance and enables the previous, simpler syntax.</source>
          <target state="new">In 2005, C# added a feature called delegate inference, which enables a compiler to infer the new delegate instance and enables the previous, simpler syntax.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The verbose syntax is functionally identical to the previous example, but explicitly creates a new delegate instance before registering it, thus not taking advantage of delegate inference.</source>
          <target state="new">The verbose syntax is functionally identical to the previous example, but explicitly creates a new delegate instance before registering it, thus not taking advantage of delegate inference.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>This explicit syntax is less common, but you might still see it in some code examples.</source>
          <target state="new">This explicit syntax is less common, but you might still see it in some code examples.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>There are two possibilities for Visual Basic syntax.</source>
          <target state="new">There are two possibilities for Visual Basic syntax.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>One is to parallel the C# syntax and attach handlers directly to instances.</source>
          <target state="new">One is to parallel the C# syntax and attach handlers directly to instances.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>This requires the <bpt id="p1">**</bpt>AddHandler<ept id="p1">**</ept> keyword and also the <bpt id="p2">**</bpt>AddressOf<ept id="p2">**</ept> operator that dereferences the handler method name.</source>
          <target state="new">This requires the <bpt id="p1">**</bpt>AddHandler<ept id="p1">**</ept> keyword and also the <bpt id="p2">**</bpt>AddressOf<ept id="p2">**</ept> operator that dereferences the handler method name.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The other option for Visual Basic syntax is to use the <bpt id="p1">**</bpt>Handles<ept id="p1">**</ept> keyword on event handlers.</source>
          <target state="new">The other option for Visual Basic syntax is to use the <bpt id="p1">**</bpt>Handles<ept id="p1">**</ept> keyword on event handlers.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This technique is appropriate for cases where handlers are expected to exist on objects at load time and persist throughout the object lifetime.</source>
          <target state="new">This technique is appropriate for cases where handlers are expected to exist on objects at load time and persist throughout the object lifetime.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Using <bpt id="p1">**</bpt>Handles<ept id="p1">**</ept> on an object that is defined in XAML requires that you provide a <bpt id="p2">**</bpt>Name<ept id="p2">**</ept><ph id="ph1"> / </ph><bpt id="p3">**</bpt>x:Name<ept id="p3">**</ept>.</source>
          <target state="new">Using <bpt id="p1">**</bpt>Handles<ept id="p1">**</ept> on an object that is defined in XAML requires that you provide a <bpt id="p2">**</bpt>Name<ept id="p2">**</ept><ph id="ph1"> / </ph><bpt id="p3">**</bpt>x:Name<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>This name becomes the instance qualifier that is needed for the <bpt id="p1">*</bpt>Instance.Event<ept id="p1">*</ept> part of the <bpt id="p2">**</bpt>Handles<ept id="p2">**</ept> syntax.</source>
          <target state="new">This name becomes the instance qualifier that is needed for the <bpt id="p1">*</bpt>Instance.Event<ept id="p1">*</ept> part of the <bpt id="p2">**</bpt>Handles<ept id="p2">**</ept> syntax.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In this case you don't need an object lifetime-based event handler to initiate attaching the other event handlers; the <bpt id="p1">**</bpt>Handles<ept id="p1">**</ept> connections are created when you compile your XAML page.</source>
          <target state="new">In this case you don't need an object lifetime-based event handler to initiate attaching the other event handlers; the <bpt id="p1">**</bpt>Handles<ept id="p1">**</ept> connections are created when you compile your XAML page.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Visual Studio and its XAML design surface generally promote the instance-handling technique instead of the <bpt id="p2">**</bpt>Handles<ept id="p2">**</ept> keyword.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Visual Studio and its XAML design surface generally promote the instance-handling technique instead of the <bpt id="p2">**</bpt>Handles<ept id="p2">**</ept> keyword.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>This is because establishing the event handler wiring in XAML is part of typical designer-developer workflow, and the <bpt id="p1">**</bpt>Handles<ept id="p1">**</ept> keyword technique is incompatible with wiring the event handlers in XAML.</source>
          <target state="new">This is because establishing the event handler wiring in XAML is part of typical designer-developer workflow, and the <bpt id="p1">**</bpt>Handles<ept id="p1">**</ept> keyword technique is incompatible with wiring the event handlers in XAML.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>In C++, you also use the <bpt id="p1">**</bpt><ph id="ph1">+=</ph><ept id="p1">**</ept> syntax, but there are differences from the basic C# form:</source>
          <target state="new">In C++, you also use the <bpt id="p1">**</bpt><ph id="ph1">+=</ph><ept id="p1">**</ept> syntax, but there are differences from the basic C# form:</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>No delegate inference exists, so you must use <bpt id="p1">**</bpt>ref new<ept id="p1">**</ept> for the delegate instance.</source>
          <target state="new">No delegate inference exists, so you must use <bpt id="p1">**</bpt>ref new<ept id="p1">**</ept> for the delegate instance.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The delegate constructor has two parameters, and requires the target object as the first parameter.</source>
          <target state="new">The delegate constructor has two parameters, and requires the target object as the first parameter.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Typically you specify <bpt id="p1">**</bpt>this<ept id="p1">**</ept>.</source>
          <target state="new">Typically you specify <bpt id="p1">**</bpt>this<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The delegate constructor requires the method address as the second parameter, so the <bpt id="p1">**</bpt><ph id="ph1">&amp;</ph><ept id="p1">**</ept> reference operator precedes the method name.</source>
          <target state="new">The delegate constructor requires the method address as the second parameter, so the <bpt id="p1">**</bpt><ph id="ph1">&amp;</ph><ept id="p1">**</ept> reference operator precedes the method name.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Removing event handlers in code</source>
          <target state="new">Removing event handlers in code</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>It's not usually necessary to remove event handlers in code, even if you added them in code.</source>
          <target state="new">It's not usually necessary to remove event handlers in code, even if you added them in code.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The object lifetime behavior for most Windows Runtime objects such as pages and controls will destroy the objects when they are disconnected from the main <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Window<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209041)</ept> and its visual tree, and any delegate references are destroyed too.</source>
          <target state="new">The object lifetime behavior for most Windows Runtime objects such as pages and controls will destroy the objects when they are disconnected from the main <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Window<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209041)</ept> and its visual tree, and any delegate references are destroyed too.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>.NET does this through garbage collection and Windows Runtime with C++/CX uses weak references by default.</source>
          <target state="new">.NET does this through garbage collection and Windows Runtime with C++/CX uses weak references by default.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>There are some rare cases where you do want to remove event handlers explicitly.</source>
          <target state="new">There are some rare cases where you do want to remove event handlers explicitly.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>These include:</source>
          <target state="new">These include:</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Handlers you added for static events, which can't get garbage-collected in a conventional way.</source>
          <target state="new">Handlers you added for static events, which can't get garbage-collected in a conventional way.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Examples of static events in the Windows Runtime API are the events of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CompositionTarget<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228126)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Clipboard<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br205867)</ept> classes.</source>
          <target state="new">Examples of static events in the Windows Runtime API are the events of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CompositionTarget<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228126)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Clipboard<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br205867)</ept> classes.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Test code where you want the timing of handler removal to be immediate, or code where you what to swap old/new event handlers for an event at run time.</source>
          <target state="new">Test code where you want the timing of handler removal to be immediate, or code where you what to swap old/new event handlers for an event at run time.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The implementation of a custom <bpt id="p1">**</bpt>remove<ept id="p1">**</ept> accessor.</source>
          <target state="new">The implementation of a custom <bpt id="p1">**</bpt>remove<ept id="p1">**</ept> accessor.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Custom static events.</source>
          <target state="new">Custom static events.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Handlers for page navigations.</source>
          <target state="new">Handlers for page navigations.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><bpt id="p2">**</bpt>FrameworkElement.Unloaded<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208748)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Page.NavigatedFrom<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227507)</ept> are possible event triggers that have appropriate positions in state management and object lifetime such that you can use them for removing handlers for other events.</source>
          <target state="new"><bpt id="p1">[</bpt><bpt id="p2">**</bpt>FrameworkElement.Unloaded<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208748)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Page.NavigatedFrom<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227507)</ept> are possible event triggers that have appropriate positions in state management and object lifetime such that you can use them for removing handlers for other events.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>For example, you can remove an event handler named <bpt id="p1">**</bpt>textBlock1\_PointerEntered<ept id="p1">**</ept> from the target object <bpt id="p2">**</bpt>textBlock1<ept id="p2">**</ept> using this code.</source>
          <target state="new">For example, you can remove an event handler named <bpt id="p1">**</bpt>textBlock1\_PointerEntered<ept id="p1">**</ept> from the target object <bpt id="p2">**</bpt>textBlock1<ept id="p2">**</ept> using this code.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>You can also remove handlers for cases where the event was added through a XAML attribute, which means that the handler was added in generated code.</source>
          <target state="new">You can also remove handlers for cases where the event was added through a XAML attribute, which means that the handler was added in generated code.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>This is easier to do if you provided a <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> value for the element where the handler was attached, because that provides an object reference for code later; however, you could also walk the object tree in order to find the necessary object reference in cases where the object has no <bpt id="p2">**</bpt>Name<ept id="p2">**</ept>.</source>
          <target state="new">This is easier to do if you provided a <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> value for the element where the handler was attached, because that provides an object reference for code later; however, you could also walk the object tree in order to find the necessary object reference in cases where the object has no <bpt id="p2">**</bpt>Name<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>If you need to remove an event handler in C++/CX, you'll need a registration token, which you should've received from the return value of the <ph id="ph1">`+=`</ph> event handler registration.</source>
          <target state="new">If you need to remove an event handler in C++/CX, you'll need a registration token, which you should've received from the return value of the <ph id="ph1">`+=`</ph> event handler registration.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>That's because the value you use for the right side of the <ph id="ph1">`-=`</ph> deregistration in the C++/CX syntax is the token, not the method name.</source>
          <target state="new">That's because the value you use for the right side of the <ph id="ph1">`-=`</ph> deregistration in the C++/CX syntax is the token, not the method name.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>For C++/CX, you can't remove handlers that were added as a XAML attribute because the C++/CX generated code doesn't save a token.</source>
          <target state="new">For C++/CX, you can't remove handlers that were added as a XAML attribute because the C++/CX generated code doesn't save a token.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Routed events</source>
          <target state="new">Routed events</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The Windows Runtime with C#, Microsoft Visual Basic or C++/CX supports the concept of a routed event for a set of events that are present on most UI elements.</source>
          <target state="new">The Windows Runtime with C#, Microsoft Visual Basic or C++/CX supports the concept of a routed event for a set of events that are present on most UI elements.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>These events are for input and user interaction scenarios, and they are implemented on the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElement<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> base class.</source>
          <target state="new">These events are for input and user interaction scenarios, and they are implemented on the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElement<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> base class.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Here's a list of input events that are routed events:</source>
          <target state="new">Here's a list of input events that are routed events:</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>DoubleTapped</source>
          <target state="new">DoubleTapped</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>DragEnter</source>
          <target state="new">DragEnter</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>DragLeave</source>
          <target state="new">DragLeave</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>DragOver</source>
          <target state="new">DragOver</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Drop</source>
          <target state="new">Drop</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Holding</source>
          <target state="new">Holding</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>KeyDown</source>
          <target state="new">KeyDown</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>KeyUp</source>
          <target state="new">KeyUp</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>ManipulationCompleted</source>
          <target state="new">ManipulationCompleted</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>ManipulationDelta</source>
          <target state="new">ManipulationDelta</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>ManipulationInertiaStarting</source>
          <target state="new">ManipulationInertiaStarting</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>ManipulationStarted</source>
          <target state="new">ManipulationStarted</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>ManipulationStarting</source>
          <target state="new">ManipulationStarting</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>PointerCanceled</source>
          <target state="new">PointerCanceled</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>PointerCaptureLost</source>
          <target state="new">PointerCaptureLost</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>PointerEntered</source>
          <target state="new">PointerEntered</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>PointerExited</source>
          <target state="new">PointerExited</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>PointerMoved</source>
          <target state="new">PointerMoved</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>PointerPressed</source>
          <target state="new">PointerPressed</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>PointerReleased</source>
          <target state="new">PointerReleased</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>PointerWheelChanged</source>
          <target state="new">PointerWheelChanged</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>RightTapped</source>
          <target state="new">RightTapped</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Tapped</source>
          <target state="new">Tapped</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>GotFocus</source>
          <target state="new">GotFocus</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>LostFocus</source>
          <target state="new">LostFocus</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>A routed event is an event that is potentially passed on (<bpt id="p1">*</bpt>routed<ept id="p1">*</ept>) from a child object to each of its successive parent objects in an object tree.</source>
          <target state="new">A routed event is an event that is potentially passed on (<bpt id="p1">*</bpt>routed<ept id="p1">*</ept>) from a child object to each of its successive parent objects in an object tree.</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The XAML structure of your UI approximates this tree, with the root of that tree being the root element in XAML.</source>
          <target state="new">The XAML structure of your UI approximates this tree, with the root of that tree being the root element in XAML.</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The true object tree might vary somewhat from the XAML element nesting, because the object tree doesn't include XAML language features such as property element tags.</source>
          <target state="new">The true object tree might vary somewhat from the XAML element nesting, because the object tree doesn't include XAML language features such as property element tags.</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>You can conceive of the routed event as <bpt id="p1">*</bpt>bubbling<ept id="p1">*</ept> from any XAML object element child element that fires the event, toward the parent object element that contains it.</source>
          <target state="new">You can conceive of the routed event as <bpt id="p1">*</bpt>bubbling<ept id="p1">*</ept> from any XAML object element child element that fires the event, toward the parent object element that contains it.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The event and its event data can be handled on multiple objects along the event route.</source>
          <target state="new">The event and its event data can be handled on multiple objects along the event route.</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>If no element has handlers, the route potentially keeps going until the root element is reached.</source>
          <target state="new">If no element has handlers, the route potentially keeps going until the root element is reached.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If you know Web technologies such as Dynamic HTML (DHTML) or HTML5, you might already be familiar with the <bpt id="p1">*</bpt>bubbling<ept id="p1">*</ept> event concept.</source>
          <target state="new">If you know Web technologies such as Dynamic HTML (DHTML) or HTML5, you might already be familiar with the <bpt id="p1">*</bpt>bubbling<ept id="p1">*</ept> event concept.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>When a routed event bubbles through its event route, any attached event handlers all access a shared instance of event data.</source>
          <target state="new">When a routed event bubbles through its event route, any attached event handlers all access a shared instance of event data.</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Therefore, if any of the event data is writeable by a handler, any changes made to event data will be passed on to the next handler, and may no longer represent the original event data from the event.</source>
          <target state="new">Therefore, if any of the event data is writeable by a handler, any changes made to event data will be passed on to the next handler, and may no longer represent the original event data from the event.</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>When an event has a routed event behavior, the reference documentation will include remarks or other notations about the routed behavior.</source>
          <target state="new">When an event has a routed event behavior, the reference documentation will include remarks or other notations about the routed behavior.</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>OriginalSource<ept id="p1">**</ept> property of <bpt id="p2">**</bpt>RoutedEventArgs<ept id="p2">**</ept></source>
          <target state="new">The <bpt id="p1">**</bpt>OriginalSource<ept id="p1">**</ept> property of <bpt id="p2">**</bpt>RoutedEventArgs<ept id="p2">**</ept></target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>When an event bubbles up an event route, <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> is no longer the same object as the event-raising object.</source>
          <target state="new">When an event bubbles up an event route, <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> is no longer the same object as the event-raising object.</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Instead, <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> is the object where the handler that is being invoked is attached.</source>
          <target state="new">Instead, <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> is the object where the handler that is being invoked is attached.</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>In some cases, <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> is not interesting, and you are instead interested in info such as which of the possible child objects the pointer is over when a pointer event fired, or which object in a larger UI held focus when a user pressed a keyboard key.</source>
          <target state="new">In some cases, <bpt id="p1">*</bpt>sender<ept id="p1">*</ept> is not interesting, and you are instead interested in info such as which of the possible child objects the pointer is over when a pointer event fired, or which object in a larger UI held focus when a user pressed a keyboard key.</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>For these cases, you can use the value of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>OriginalSource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208810)</ept> property.</source>
          <target state="new">For these cases, you can use the value of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>OriginalSource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208810)</ept> property.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>At all points on the route, <bpt id="p1">**</bpt>OriginalSource<ept id="p1">**</ept> reports the original object that fired the event, instead of the object where the handler is attached.</source>
          <target state="new">At all points on the route, <bpt id="p1">**</bpt>OriginalSource<ept id="p1">**</ept> reports the original object that fired the event, instead of the object where the handler is attached.</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>However, for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElement<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> input events, that original object is often an object that is not immediately visible in the page-level UI definition XAML.</source>
          <target state="new">However, for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElement<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> input events, that original object is often an object that is not immediately visible in the page-level UI definition XAML.</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>Instead, that original source object might be a templated part of a control.</source>
          <target state="new">Instead, that original source object might be a templated part of a control.</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>For example, if the user hovers the pointer over the very edge of a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Button<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept>, for most pointer events the <bpt id="p3">**</bpt>OriginalSource<ept id="p3">**</ept> is a <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Border<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br209250)</ept> template part in the <bpt id="p6">[</bpt><bpt id="p7">**</bpt>Template<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/br209465)</ept>, not the <bpt id="p8">**</bpt>Button<ept id="p8">**</ept> itself.</source>
          <target state="new">For example, if the user hovers the pointer over the very edge of a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Button<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept>, for most pointer events the <bpt id="p3">**</bpt>OriginalSource<ept id="p3">**</ept> is a <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Border<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br209250)</ept> template part in the <bpt id="p6">[</bpt><bpt id="p7">**</bpt>Template<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/br209465)</ept>, not the <bpt id="p8">**</bpt>Button<ept id="p8">**</ept> itself.</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>  Input event bubbling is especially useful if you are creating a templated control.</source>
          <target state="new"><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>  Input event bubbling is especially useful if you are creating a templated control.</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Any control that has a template can have a new template applied by its consumer.</source>
          <target state="new">Any control that has a template can have a new template applied by its consumer.</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The consumer that's trying to recreate a working template might unintentionally eliminate some event handling declared in the default template.</source>
          <target state="new">The consumer that's trying to recreate a working template might unintentionally eliminate some event handling declared in the default template.</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>You can still provide control-level event handling by attaching handlers as part of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>OnApplyTemplate<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208737)</ept> override in the class definition.</source>
          <target state="new">You can still provide control-level event handling by attaching handlers as part of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>OnApplyTemplate<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208737)</ept> override in the class definition.</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Then you can catch the input events that bubble up to the control's root on instantiation.</source>
          <target state="new">Then you can catch the input events that bubble up to the control's root on instantiation.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> property</source>
          <target state="new">The <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> property</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Several event data classes for specific routed events contain a property named <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept>.</source>
          <target state="new">Several event data classes for specific routed events contain a property named <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>For examples, see <bpt id="p1">[</bpt><bpt id="p2">**</bpt>PointerRoutedEventArgs.Handled<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh943079)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>KeyRoutedEventArgs.Handled<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh943073)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>DragEventArgs.Handled<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br242375)</ept>.</source>
          <target state="new">For examples, see <bpt id="p1">[</bpt><bpt id="p2">**</bpt>PointerRoutedEventArgs.Handled<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh943079)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>KeyRoutedEventArgs.Handled<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh943073)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>DragEventArgs.Handled<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br242375)</ept>.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>In all cases <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> is a settable Boolean property.</source>
          <target state="new">In all cases <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> is a settable Boolean property.</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Setting the <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> property to <bpt id="p2">**</bpt>true<ept id="p2">**</ept> influences the event system behavior.</source>
          <target state="new">Setting the <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> property to <bpt id="p2">**</bpt>true<ept id="p2">**</ept> influences the event system behavior.</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>When <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> is <bpt id="p2">**</bpt>true<ept id="p2">**</ept>, the routing stops for most event handlers; the event doesn't continue along the route to notify other attached handlers of that particular event case.</source>
          <target state="new">When <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> is <bpt id="p2">**</bpt>true<ept id="p2">**</ept>, the routing stops for most event handlers; the event doesn't continue along the route to notify other attached handlers of that particular event case.</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>What "handled" means in the context of the event and how your app responds to it is up to you.</source>
          <target state="new">What "handled" means in the context of the event and how your app responds to it is up to you.</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Basically, <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> is a simple protocol that enables app code to state that an occurrence of an event doesn't need to bubble to any containers, your app logic has taken care of what needs done.</source>
          <target state="new">Basically, <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> is a simple protocol that enables app code to state that an occurrence of an event doesn't need to bubble to any containers, your app logic has taken care of what needs done.</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Conversely though, you do have to be careful that you aren't handling events that probably should bubble so that built-in system or control behaviors can act.</source>
          <target state="new">Conversely though, you do have to be careful that you aren't handling events that probably should bubble so that built-in system or control behaviors can act.</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>For example, handling low-level events within the parts or items of a selection control can be detrimental.</source>
          <target state="new">For example, handling low-level events within the parts or items of a selection control can be detrimental.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>The selection control might be looking for input events to know that the selection should change.</source>
          <target state="new">The selection control might be looking for input events to know that the selection should change.</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Not all of the routed events can cancel a route in this way, and you can tell that because they won't have a <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> property.</source>
          <target state="new">Not all of the routed events can cancel a route in this way, and you can tell that because they won't have a <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> property.</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>GotFocus<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208927)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>LostFocus<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208943)</ept> do bubble, but they always bubble all the way to the root, and their event data classes don't have a <bpt id="p5">**</bpt>Handled<ept id="p5">**</ept> property that can influence that behavior.</source>
          <target state="new">For example, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>GotFocus<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208927)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>LostFocus<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208943)</ept> do bubble, but they always bubble all the way to the root, and their event data classes don't have a <bpt id="p5">**</bpt>Handled<ept id="p5">**</ept> property that can influence that behavior.</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Input event handlers in controls</source>
          <target state="new">Input event handlers in controls</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Specific Windows Runtime controls sometimes use the <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> concept for input events internally.</source>
          <target state="new">Specific Windows Runtime controls sometimes use the <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> concept for input events internally.</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>This can make it seem like an input event never occurs, because your user code can't handle it.</source>
          <target state="new">This can make it seem like an input event never occurs, because your user code can't handle it.</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Button<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> class includes logic that deliberately handles the general input event <bpt id="p3">[</bpt><bpt id="p4">**</bpt>PointerPressed<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208971)</ept>.</source>
          <target state="new">For example, the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Button<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> class includes logic that deliberately handles the general input event <bpt id="p3">[</bpt><bpt id="p4">**</bpt>PointerPressed<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208971)</ept>.</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>It does so because buttons fire a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Click<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227737)</ept> event that is initiated by pointer-pressed input, as well as by other input modes such as handling keys like the Enter key that can invoke the button when it's focused.</source>
          <target state="new">It does so because buttons fire a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Click<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227737)</ept> event that is initiated by pointer-pressed input, as well as by other input modes such as handling keys like the Enter key that can invoke the button when it's focused.</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>For purposes of the class design of <bpt id="p1">**</bpt>Button<ept id="p1">**</ept>, the raw input event is conceptually handled, and class consumers such as your user code can instead interact with the control-relevant <bpt id="p2">**</bpt>Click<ept id="p2">**</ept> event.</source>
          <target state="new">For purposes of the class design of <bpt id="p1">**</bpt>Button<ept id="p1">**</ept>, the raw input event is conceptually handled, and class consumers such as your user code can instead interact with the control-relevant <bpt id="p2">**</bpt>Click<ept id="p2">**</ept> event.</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Topics for specific control classes in the Windows Runtime API reference often note the event handling behavior that the class implements.</source>
          <target state="new">Topics for specific control classes in the Windows Runtime API reference often note the event handling behavior that the class implements.</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>In some cases, you can change the behavior by overriding <bpt id="p1">**</bpt>On<ept id="p1">**</ept><bpt id="p2">*</bpt>Event<ept id="p2">*</ept> methods.</source>
          <target state="new">In some cases, you can change the behavior by overriding <bpt id="p1">**</bpt>On<ept id="p1">**</ept><bpt id="p2">*</bpt>Event<ept id="p2">*</ept> methods.</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>For example, you can change how your <bpt id="p1">[</bpt><bpt id="p2">**</bpt>TextBox<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209683)</ept> derived class reacts to key input by overriding <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Control.OnKeyDown<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh967982)</ept>.</source>
          <target state="new">For example, you can change how your <bpt id="p1">[</bpt><bpt id="p2">**</bpt>TextBox<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209683)</ept> derived class reacts to key input by overriding <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Control.OnKeyDown<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh967982)</ept>.</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>Registering handlers for already-handled routed events</source>
          <target state="new">Registering handlers for already-handled routed events</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Earlier we said that setting <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> to <bpt id="p2">**</bpt>true<ept id="p2">**</ept> prevents most handlers from being called.</source>
          <target state="new">Earlier we said that setting <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> to <bpt id="p2">**</bpt>true<ept id="p2">**</ept> prevents most handlers from being called.</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>But the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AddHandler<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh702399)</ept> method provides a technique where you can attach a handler that is always invoked for the route, even if some other handler earlier in the route has set <bpt id="p3">**</bpt>Handled<ept id="p3">**</ept> to <bpt id="p4">**</bpt>true<ept id="p4">**</ept> in the shared event data.</source>
          <target state="new">But the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AddHandler<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh702399)</ept> method provides a technique where you can attach a handler that is always invoked for the route, even if some other handler earlier in the route has set <bpt id="p3">**</bpt>Handled<ept id="p3">**</ept> to <bpt id="p4">**</bpt>true<ept id="p4">**</ept> in the shared event data.</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>This technique is useful if a control you are using has handled the event in its internal compositing or for control-specific logic.</source>
          <target state="new">This technique is useful if a control you are using has handled the event in its internal compositing or for control-specific logic.</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>but you still want to respond to it from a control instance, or your app UI.</source>
          <target state="new">but you still want to respond to it from a control instance, or your app UI.</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>But use this technique with caution, because it can contradict the purpose of <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> and possibly break a control's intended interactions.</source>
          <target state="new">But use this technique with caution, because it can contradict the purpose of <bpt id="p1">**</bpt>Handled<ept id="p1">**</ept> and possibly break a control's intended interactions.</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Only the routed events that have a corresponding routed event identifier can use the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AddHandler<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh702399)</ept> event handling technique, because the identifier is a required input of the <bpt id="p3">**</bpt>AddHandler<ept id="p3">**</ept> method.</source>
          <target state="new">Only the routed events that have a corresponding routed event identifier can use the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AddHandler<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh702399)</ept> event handling technique, because the identifier is a required input of the <bpt id="p3">**</bpt>AddHandler<ept id="p3">**</ept> method.</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>See the reference documentation for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AddHandler<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh702399)</ept> for a list of events that have routed event identifiers available.</source>
          <target state="new">See the reference documentation for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>AddHandler<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh702399)</ept> for a list of events that have routed event identifiers available.</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>For the most part this is the same list of routed events we showed you earlier.</source>
          <target state="new">For the most part this is the same list of routed events we showed you earlier.</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The exception is that the last two in the list: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>GotFocus<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208927)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>LostFocus<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208943)</ept> don't have a routed event identifier, so you can't use <bpt id="p5">**</bpt>AddHandler<ept id="p5">**</ept> for those.</source>
          <target state="new">The exception is that the last two in the list: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>GotFocus<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208927)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>LostFocus<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208943)</ept> don't have a routed event identifier, so you can't use <bpt id="p5">**</bpt>AddHandler<ept id="p5">**</ept> for those.</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>Routed events outside the visual tree</source>
          <target state="new">Routed events outside the visual tree</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Certain objects participate in a relationship with the primary visual tree that is conceptually like having an overlay over the main visuals.</source>
          <target state="new">Certain objects participate in a relationship with the primary visual tree that is conceptually like having an overlay over the main visuals.</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>These objects are not part of the usual parent-child relationships that connect all tree elements to the visual root.</source>
          <target state="new">These objects are not part of the usual parent-child relationships that connect all tree elements to the visual root.</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>This is the case for any displayed <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Popup<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227842)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ToolTip<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227608)</ept>.</source>
          <target state="new">This is the case for any displayed <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Popup<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227842)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ToolTip<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227608)</ept>.</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>If you want to handle routed events from a <bpt id="p1">**</bpt>Popup<ept id="p1">**</ept> or <bpt id="p2">**</bpt>ToolTip<ept id="p2">**</ept>, place the handlers on specific UI elements that are within the <bpt id="p3">**</bpt>Popup<ept id="p3">**</ept> or <bpt id="p4">**</bpt>ToolTip<ept id="p4">**</ept> and not the <bpt id="p5">**</bpt>Popup<ept id="p5">**</ept> or <bpt id="p6">**</bpt>ToolTip<ept id="p6">**</ept> elements themselves.</source>
          <target state="new">If you want to handle routed events from a <bpt id="p1">**</bpt>Popup<ept id="p1">**</ept> or <bpt id="p2">**</bpt>ToolTip<ept id="p2">**</ept>, place the handlers on specific UI elements that are within the <bpt id="p3">**</bpt>Popup<ept id="p3">**</ept> or <bpt id="p4">**</bpt>ToolTip<ept id="p4">**</ept> and not the <bpt id="p5">**</bpt>Popup<ept id="p5">**</ept> or <bpt id="p6">**</bpt>ToolTip<ept id="p6">**</ept> elements themselves.</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Don't rely on routing inside any compositing that is performed for <bpt id="p1">**</bpt>Popup<ept id="p1">**</ept> or <bpt id="p2">**</bpt>ToolTip<ept id="p2">**</ept> content.</source>
          <target state="new">Don't rely on routing inside any compositing that is performed for <bpt id="p1">**</bpt>Popup<ept id="p1">**</ept> or <bpt id="p2">**</bpt>ToolTip<ept id="p2">**</ept> content.</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>This is because event routing for routed events works only along the main visual tree.</source>
          <target state="new">This is because event routing for routed events works only along the main visual tree.</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>Popup<ept id="p1">**</ept> or <bpt id="p2">**</bpt>ToolTip<ept id="p2">**</ept> is not considered a parent of subsidiary UI elements and never receives the routed event, even if it is trying to use something like the <bpt id="p3">**</bpt>Popup<ept id="p3">**</ept> default background as the capture area for input events.</source>
          <target state="new">A <bpt id="p1">**</bpt>Popup<ept id="p1">**</ept> or <bpt id="p2">**</bpt>ToolTip<ept id="p2">**</ept> is not considered a parent of subsidiary UI elements and never receives the routed event, even if it is trying to use something like the <bpt id="p3">**</bpt>Popup<ept id="p3">**</ept> default background as the capture area for input events.</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Hit testing and input events</source>
          <target state="new">Hit testing and input events</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>Determining whether and where in UI an element is visible to mouse, touch, and stylus input is called <bpt id="p1">*</bpt>hit testing<ept id="p1">*</ept>.</source>
          <target state="new">Determining whether and where in UI an element is visible to mouse, touch, and stylus input is called <bpt id="p1">*</bpt>hit testing<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>For touch actions and also for interaction-specific or manipulation events that are consequences of a touch action, an element must be hit-test visible in order to be the event source and fire the event that is associated with the action.</source>
          <target state="new">For touch actions and also for interaction-specific or manipulation events that are consequences of a touch action, an element must be hit-test visible in order to be the event source and fire the event that is associated with the action.</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Otherwise, the action passes through the element to any underlying elements or parent elements in the visual tree that could interact with that input.</source>
          <target state="new">Otherwise, the action passes through the element to any underlying elements or parent elements in the visual tree that could interact with that input.</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>There are several factors that affect hit testing, but you can determine whether a given element can fire input events by checking its <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IsHitTestVisible<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208933)</ept> property.</source>
          <target state="new">There are several factors that affect hit testing, but you can determine whether a given element can fire input events by checking its <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IsHitTestVisible<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208933)</ept> property.</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>This property returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> only if the element meets these criteria:</source>
          <target state="new">This property returns <bpt id="p1">**</bpt>true<ept id="p1">**</ept> only if the element meets these criteria:</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The element's <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Visibility<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208992)</ept> property value is <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Visible<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209006)</ept>.</source>
          <target state="new">The element's <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Visibility<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208992)</ept> property value is <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Visible<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209006)</ept>.</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>The element's <bpt id="p1">**</bpt>Background<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Fill<ept id="p2">**</ept> property value is not <bpt id="p3">**</bpt>null<ept id="p3">**</ept>.</source>
          <target state="new">The element's <bpt id="p1">**</bpt>Background<ept id="p1">**</ept> or <bpt id="p2">**</bpt>Fill<ept id="p2">**</ept> property value is not <bpt id="p3">**</bpt>null<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">**</bpt>null<ept id="p1">**</ept> <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Brush<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br228076)</ept> value results in transparency and hit test invisibility.</source>
          <target state="new">A <bpt id="p1">**</bpt>null<ept id="p1">**</ept> <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Brush<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br228076)</ept> value results in transparency and hit test invisibility.</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>(To make an element transparent but also hit testable, use a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Transparent<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh748061)</ept> brush instead of <bpt id="p3">**</bpt>null<ept id="p3">**</ept>.)</source>
          <target state="new">(To make an element transparent but also hit testable, use a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Transparent<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh748061)</ept> brush instead of <bpt id="p3">**</bpt>null<ept id="p3">**</ept>.)</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  <bpt id="p2">**</bpt>Background<ept id="p2">**</ept> and <bpt id="p3">**</bpt>Fill<ept id="p3">**</ept> aren't defined by <bpt id="p4">[</bpt><bpt id="p5">**</bpt>UIElement<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept>, and are instead defined by different derived classes such as <bpt id="p6">[</bpt><bpt id="p7">**</bpt>Control<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/br209390)</ept> and <bpt id="p8">[</bpt><bpt id="p9">**</bpt>Shape<ept id="p9">**</ept><ept id="p8">](https://msdn.microsoft.com/library/windows/apps/br243377)</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  <bpt id="p2">**</bpt>Background<ept id="p2">**</ept> and <bpt id="p3">**</bpt>Fill<ept id="p3">**</ept> aren't defined by <bpt id="p4">[</bpt><bpt id="p5">**</bpt>UIElement<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept>, and are instead defined by different derived classes such as <bpt id="p6">[</bpt><bpt id="p7">**</bpt>Control<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/br209390)</ept> and <bpt id="p8">[</bpt><bpt id="p9">**</bpt>Shape<ept id="p9">**</ept><ept id="p8">](https://msdn.microsoft.com/library/windows/apps/br243377)</ept>.</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>But the implications of brushes you use for foreground and background properties are the same for hit testing and input events, no matter which subclass implements the properties.</source>
          <target state="new">But the implications of brushes you use for foreground and background properties are the same for hit testing and input events, no matter which subclass implements the properties.</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>If the element is a control, its <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IsEnabled<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209419)</ept> property value must be <bpt id="p3">**</bpt>true<ept id="p3">**</ept>.</source>
          <target state="new">If the element is a control, its <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IsEnabled<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209419)</ept> property value must be <bpt id="p3">**</bpt>true<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The element must have actual dimensions in layout.</source>
          <target state="new">The element must have actual dimensions in layout.</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>An element where either <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ActualHeight<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208707)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ActualWidth<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208709)</ept> are 0 won't fire input events.</source>
          <target state="new">An element where either <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ActualHeight<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208707)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ActualWidth<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208709)</ept> are 0 won't fire input events.</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Some controls have special rules for hit testing.</source>
          <target state="new">Some controls have special rules for hit testing.</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>TextBlock<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209652)</ept> has no <bpt id="p3">**</bpt>Background<ept id="p3">**</ept> property, but is still hit testable within the entire region of its dimensions.</source>
          <target state="new">For example, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>TextBlock<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209652)</ept> has no <bpt id="p3">**</bpt>Background<ept id="p3">**</ept> property, but is still hit testable within the entire region of its dimensions.</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><bpt id="p2">**</bpt>Image<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242752)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>MediaElement<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br242926)</ept> controls are hit testable over their defined rectangle dimensions, regardless of transparent content such as alpha channel in the media source file being displayed.</source>
          <target state="new"><bpt id="p1">[</bpt><bpt id="p2">**</bpt>Image<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242752)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>MediaElement<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br242926)</ept> controls are hit testable over their defined rectangle dimensions, regardless of transparent content such as alpha channel in the media source file being displayed.</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><bpt id="p2">**</bpt>WebView<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227702)</ept> controls have special hit testing behavior because the input can be handled by the hosted HTML and fire script events.</source>
          <target state="new"><bpt id="p1">[</bpt><bpt id="p2">**</bpt>WebView<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227702)</ept> controls have special hit testing behavior because the input can be handled by the hosted HTML and fire script events.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Most <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Panel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> classes and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Border<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209250)</ept> are not hit-testable in their own background, but can still handle the user input events that are routed from the elements that they contain.</source>
          <target state="new">Most <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Panel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> classes and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Border<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209250)</ept> are not hit-testable in their own background, but can still handle the user input events that are routed from the elements that they contain.</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>You can determine which elements are located at the same position as a user input event, regardless of whether the elements are hit-testable.</source>
          <target state="new">You can determine which elements are located at the same position as a user input event, regardless of whether the elements are hit-testable.</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>To do this, call the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindElementsInHostCoordinates<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br243039)</ept> method.</source>
          <target state="new">To do this, call the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindElementsInHostCoordinates<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br243039)</ept> method.</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>As the name implies, this method finds the elements at a location relative to a specified host element.</source>
          <target state="new">As the name implies, this method finds the elements at a location relative to a specified host element.</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>However, applied transforms and layout changes can adjust the relative coordinate system of an element, and therefore affect which elements are found at a given location.</source>
          <target state="new">However, applied transforms and layout changes can adjust the relative coordinate system of an element, and therefore affect which elements are found at a given location.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Commanding</source>
          <target state="new">Commanding</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>A small number of UI elements support <bpt id="p1">*</bpt>commanding<ept id="p1">*</ept>.</source>
          <target state="new">A small number of UI elements support <bpt id="p1">*</bpt>commanding<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Commanding uses input-related routed events in its underlying implementation and enables processing of related UI input (a certain pointer action, a specific accelerator key) by invoking a single command handler.</source>
          <target state="new">Commanding uses input-related routed events in its underlying implementation and enables processing of related UI input (a certain pointer action, a specific accelerator key) by invoking a single command handler.</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>If commanding is available for a UI element, consider using its commanding APIs instead of any discrete input events.</source>
          <target state="new">If commanding is available for a UI element, consider using its commanding APIs instead of any discrete input events.</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>You typically use a <bpt id="p1">**</bpt>Binding<ept id="p1">**</ept> reference into properties of a class that defines the view model for data.</source>
          <target state="new">You typically use a <bpt id="p1">**</bpt>Binding<ept id="p1">**</ept> reference into properties of a class that defines the view model for data.</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The properties hold named commands that implement the language-specific <bpt id="p1">**</bpt>ICommand<ept id="p1">**</ept> commanding pattern.</source>
          <target state="new">The properties hold named commands that implement the language-specific <bpt id="p1">**</bpt>ICommand<ept id="p1">**</ept> commanding pattern.</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>For more info, see <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ButtonBase.Command<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227740)</ept>.</source>
          <target state="new">For more info, see <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ButtonBase.Command<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227740)</ept>.</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Custom events in the Windows Runtime</source>
          <target state="new">Custom events in the Windows Runtime</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>For purposes of defining custom events, how you add the event and what that means for your class design is highly dependent on which programming language you are using.</source>
          <target state="new">For purposes of defining custom events, how you add the event and what that means for your class design is highly dependent on which programming language you are using.</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>For C# and Visual Basic, you are defining a CLR event.</source>
          <target state="new">For C# and Visual Basic, you are defining a CLR event.</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>You can use the standard .NET event pattern, so long as you aren't using custom accessors (<bpt id="p1">**</bpt>add<ept id="p1">**</ept><ph id="ph1">/</ph><bpt id="p2">**</bpt>remove<ept id="p2">**</ept>).</source>
          <target state="new">You can use the standard .NET event pattern, so long as you aren't using custom accessors (<bpt id="p1">**</bpt>add<ept id="p1">**</ept><ph id="ph1">/</ph><bpt id="p2">**</bpt>remove<ept id="p2">**</ept>).</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Additional tips:</source>
          <target state="new">Additional tips:</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>For the event handler it's a good idea to use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>System.EventHandler<ph id="ph1">&lt;TEventArgs&gt;</ph><ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/db0etb8x.aspx)</ept> because it has built-in translation to the Windows Runtime generic event delegate <bpt id="p3">[</bpt><bpt id="p4">**</bpt>EventHandler<ph id="ph2">&lt;T&gt;</ph><ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br206577)</ept>.</source>
          <target state="new">For the event handler it's a good idea to use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>System.EventHandler<ph id="ph1">&lt;TEventArgs&gt;</ph><ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/db0etb8x.aspx)</ept> because it has built-in translation to the Windows Runtime generic event delegate <bpt id="p3">[</bpt><bpt id="p4">**</bpt>EventHandler<ph id="ph2">&lt;T&gt;</ph><ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br206577)</ept>.</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Don't base your event data class on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>System.EventArgs<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/system.eventargs.aspx)</ept> because it doesn't translate to the Windows Runtime.</source>
          <target state="new">Don't base your event data class on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>System.EventArgs<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/system.eventargs.aspx)</ept> because it doesn't translate to the Windows Runtime.</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Use an existing event data class or no base class at all.</source>
          <target state="new">Use an existing event data class or no base class at all.</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>If you are using custom accessors, see <bpt id="p1">[</bpt>Custom events and event accessors in Windows Runtime Components<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh972883.aspx)</ept>.</source>
          <target state="new">If you are using custom accessors, see <bpt id="p1">[</bpt>Custom events and event accessors in Windows Runtime Components<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh972883.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>If you're not clear on what the standard .NET event pattern is, see <bpt id="p1">[</bpt>Defining Events for Custom Silverlight Classes<ept id="p1">](http://msdn.microsoft.com/library/dd833067.aspx)</ept>.</source>
          <target state="new">If you're not clear on what the standard .NET event pattern is, see <bpt id="p1">[</bpt>Defining Events for Custom Silverlight Classes<ept id="p1">](http://msdn.microsoft.com/library/dd833067.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>This is written for Microsoft Silverlight but it's still a good summation of the code and concepts for the standard .NET event pattern.</source>
          <target state="new">This is written for Microsoft Silverlight but it's still a good summation of the code and concepts for the standard .NET event pattern.</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>For C++/CX, see <bpt id="p1">[</bpt>Events (C++/CX)<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755799.aspx)</ept>.</source>
          <target state="new">For C++/CX, see <bpt id="p1">[</bpt>Events (C++/CX)<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755799.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>Use named references even for your own usages of custom events.</source>
          <target state="new">Use named references even for your own usages of custom events.</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Don't use lambda for custom events, it can create a circular reference.</source>
          <target state="new">Don't use lambda for custom events, it can create a circular reference.</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>You can't declare a custom routed event for Windows Runtime; routed events are limited to the set that comes from the Windows Runtime.</source>
          <target state="new">You can't declare a custom routed event for Windows Runtime; routed events are limited to the set that comes from the Windows Runtime.</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>Defining a custom event is usually done as part of the exercise of defining a custom control.</source>
          <target state="new">Defining a custom event is usually done as part of the exercise of defining a custom control.</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>It's a common pattern to have a dependency property that has a property-changed callback, and to also define a custom event that's fired by the dependency property callback in some or all cases.</source>
          <target state="new">It's a common pattern to have a dependency property that has a property-changed callback, and to also define a custom event that's fired by the dependency property callback in some or all cases.</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>Consumers of your control don't have access to the property-changed callback you defined, but having a notification event available is the next best thing.</source>
          <target state="new">Consumers of your control don't have access to the property-changed callback you defined, but having a notification event available is the next best thing.</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>For more info, see <bpt id="p1">[</bpt>Custom dependency properties<ept id="p1">](custom-dependency-properties.md)</ept>.</source>
          <target state="new">For more info, see <bpt id="p1">[</bpt>Custom dependency properties<ept id="p1">](custom-dependency-properties.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>XAML overview</source>
          <target state="new">XAML overview</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>Quickstart: Touch input</source>
          <target state="new">Quickstart: Touch input</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>Keyboard interactions</source>
          <target state="new">Keyboard interactions</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>.NET events and delegates</source>
          <target state="new">.NET events and delegates</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>Creating Windows Runtime components</source>
          <target state="new">Creating Windows Runtime components</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>AddHandler</source>
          <target state="new">AddHandler</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>