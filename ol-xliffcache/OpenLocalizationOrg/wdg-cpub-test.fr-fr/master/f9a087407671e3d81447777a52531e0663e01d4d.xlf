<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9a087407671e3d81447777a52531e0663e01d4d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci1\data-binding\displaying-data-in-the-designer.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Sample data on the design surface, and for prototyping</source>
          <target state="new">Sample data on the design surface, and for prototyping</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.</source>
          <target state="new">It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Sample data on the design surface, and for prototyping</source>
          <target state="new">Sample data on the design surface, and for prototyping</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  The degree to which you need sample data—and how much it will help you—depends on whether your bindings use the <bpt id="p2">[</bpt>{Binding} markup extension<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</ept> or the <bpt id="p3">[</bpt>{x:Bind} markup extension<ept id="p3">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  The degree to which you need sample data—and how much it will help you—depends on whether your bindings use the <bpt id="p2">[</bpt>{Binding} markup extension<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</ept> or the <bpt id="p3">[</bpt>{x:Bind} markup extension<ept id="p3">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</ept>.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The techniques described in this topic are based on the use of a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR208713)</ept>, so they're only appropriate for <bpt id="p3">**</bpt>{Binding}<ept id="p3">**</ept>.</source>
          <target state="new">The techniques described in this topic are based on the use of a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR208713)</ept>, so they're only appropriate for <bpt id="p3">**</bpt>{Binding}<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>But if you're using <bpt id="p1">**</bpt>{x:Bind}<ept id="p1">**</ept> then your bindings at least show placeholder values on the design surface (even for items controls), so you don't have quite the same need for sample data.</source>
          <target state="new">But if you're using <bpt id="p1">**</bpt>{x:Bind}<ept id="p1">**</ept> then your bindings at least show placeholder values on the design surface (even for items controls), so you don't have quite the same need for sample data.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.</source>
          <target state="new">It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>In order to have your controls populated with data (so that you can work on your app's layout, templates, and other visual properties), there are various ways in which you can use design-time sample data.</source>
          <target state="new">In order to have your controls populated with data (so that you can work on your app's layout, templates, and other visual properties), there are various ways in which you can use design-time sample data.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Sample data can also be really useful and time-saving if you're building a sketch (or prototype) app.</source>
          <target state="new">Sample data can also be really useful and time-saving if you're building a sketch (or prototype) app.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>You can use sample data in your sketch or prototype at run-time to illustrate your ideas without going as far as connecting to real, live data.</source>
          <target state="new">You can use sample data in your sketch or prototype at run-time to illustrate your ideas without going as far as connecting to real, live data.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Setting DataContext in markup</source>
          <target state="new">Setting DataContext in markup</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>It's a fairly common developer practice to use imperative code (in code-behind) to set a page or user control's <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR208713)</ept> to a view model instance.</source>
          <target state="new">It's a fairly common developer practice to use imperative code (in code-behind) to set a page or user control's <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR208713)</ept> to a view model instance.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>But if you do that then your page isn't as "designable" as it could be.</source>
          <target state="new">But if you do that then your page isn't as "designable" as it could be.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The reason is that when your XAML page is opened in Visual Studio or Blend for Visual Studio, the imperative code that assigns the <bpt id="p1">**</bpt>DataContext<ept id="p1">**</ept> value is never run (in fact, none of your code-behind is executed).</source>
          <target state="new">The reason is that when your XAML page is opened in Visual Studio or Blend for Visual Studio, the imperative code that assigns the <bpt id="p1">**</bpt>DataContext<ept id="p1">**</ept> value is never run (in fact, none of your code-behind is executed).</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The XAML tools do of course parse your markup and instantiate any objects declared in it, but they don't actually instantiate your page's type itself.</source>
          <target state="new">The XAML tools do of course parse your markup and instantiate any objects declared in it, but they don't actually instantiate your page's type itself.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The result is that you won't see any data in your controls or in the <bpt id="p1">**</bpt>Create Data Binding<ept id="p1">**</ept> dialog, and your page will be more challenging to style and to lay out.</source>
          <target state="new">The result is that you won't see any data in your controls or in the <bpt id="p1">**</bpt>Create Data Binding<ept id="p1">**</ept> dialog, and your page will be more challenging to style and to lay out.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Sparse design UI.</source>
          <target state="new">Sparse design UI.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The first remedy to try is to comment out that <bpt id="p1">**</bpt>DataContext<ept id="p1">**</ept> assignment and set the <bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept> in your page markup instead.</source>
          <target state="new">The first remedy to try is to comment out that <bpt id="p1">**</bpt>DataContext<ept id="p1">**</ept> assignment and set the <bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept> in your page markup instead.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>That way, your live data shows up at design-time as well as at run-time.</source>
          <target state="new">That way, your live data shows up at design-time as well as at run-time.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>To do this, first open your XAML page.</source>
          <target state="new">To do this, first open your XAML page.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Then, in the <bpt id="p1">**</bpt>Document Outline<ept id="p1">**</ept> window, click the root designable element (usually with the label <bpt id="p2">**</bpt>\[Page\]<ept id="p2">**</ept>) to select it.</source>
          <target state="new">Then, in the <bpt id="p1">**</bpt>Document Outline<ept id="p1">**</ept> window, click the root designable element (usually with the label <bpt id="p2">**</bpt>\[Page\]<ept id="p2">**</ept>) to select it.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window, find the <bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept> property (inside the Common category), and then click <bpt id="p3">**</bpt>New<ept id="p3">**</ept>.</source>
          <target state="new">In the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window, find the <bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept> property (inside the Common category), and then click <bpt id="p3">**</bpt>New<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Click your view model type from the <bpt id="p1">**</bpt>Select Object<ept id="p1">**</ept> dialog box, and then click <bpt id="p2">**</bpt>OK<ept id="p2">**</ept>.</source>
          <target state="new">Click your view model type from the <bpt id="p1">**</bpt>Select Object<ept id="p1">**</ept> dialog box, and then click <bpt id="p2">**</bpt>OK<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>UI for setting DataContext.</source>
          <target state="new">UI for setting DataContext.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Here's what the resulting markup looks like.</source>
          <target state="new">Here's what the resulting markup looks like.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>And here’s what the design surface looks like now that your bindings can resolve.</source>
          <target state="new">And here’s what the design surface looks like now that your bindings can resolve.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Notice that the <bpt id="p1">**</bpt>Path<ept id="p1">**</ept> picker in the <bpt id="p2">**</bpt>Create Data Binding<ept id="p2">**</ept> dialog is now populated, based on the <bpt id="p3">**</bpt>DataContext<ept id="p3">**</ept> type and the properties that you can bind to.</source>
          <target state="new">Notice that the <bpt id="p1">**</bpt>Path<ept id="p1">**</ept> picker in the <bpt id="p2">**</bpt>Create Data Binding<ept id="p2">**</ept> dialog is now populated, based on the <bpt id="p3">**</bpt>DataContext<ept id="p3">**</ept> type and the properties that you can bind to.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Designable UI.</source>
          <target state="new">Designable UI.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Create Data Binding<ept id="p1">**</ept> dialog only needs a type to work from, but the bindings need the properties to be initialized with values.</source>
          <target state="new">The <bpt id="p1">**</bpt>Create Data Binding<ept id="p1">**</ept> dialog only needs a type to work from, but the bindings need the properties to be initialized with values.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>If you don't want to reach out to your cloud service at design-time (due to performance, paying for data transfer, privacy issues, that kind of thing) then your initialization code can check to see whether your app is running in a design tool (such as Visual Studio or Blend for Visual Studio) and in that case load sample data for use at design-time only.</source>
          <target state="new">If you don't want to reach out to your cloud service at design-time (due to performance, paying for data transfer, privacy issues, that kind of thing) then your initialization code can check to see whether your app is running in a design tool (such as Visual Studio or Blend for Visual Studio) and in that case load sample data for use at design-time only.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>You could use a view model locator if you need to pass parameters to your initialization code.</source>
          <target state="new">You could use a view model locator if you need to pass parameters to your initialization code.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A view model locator is a class that you can put into app resources.</source>
          <target state="new">A view model locator is a class that you can put into app resources.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>It has a property that exposes the view model, and your page's <bpt id="p1">**</bpt>DataContext<ept id="p1">**</ept> binds to that property.</source>
          <target state="new">It has a property that exposes the view model, and your page's <bpt id="p1">**</bpt>DataContext<ept id="p1">**</ept> binds to that property.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Another pattern that the locator or the view model can use is dependency injection, which can construct a design-time or a run-time data provider (each of which implements a common interface), as applicable.</source>
          <target state="new">Another pattern that the locator or the view model can use is dependency injection, which can construct a design-time or a run-time data provider (each of which implements a common interface), as applicable.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>"Sample data from class", and design-time attributes</source>
          <target state="new">"Sample data from class", and design-time attributes</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If for whatever reason none of the options in the previous section work for you then you still have plenty of design-time data options available via XAML tools features and design-time attributes.</source>
          <target state="new">If for whatever reason none of the options in the previous section work for you then you still have plenty of design-time data options available via XAML tools features and design-time attributes.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>One good option is the <bpt id="p1">**</bpt>Create Sample Data from Class<ept id="p1">**</ept> feature in Blend for Visual Studio.</source>
          <target state="new">One good option is the <bpt id="p1">**</bpt>Create Sample Data from Class<ept id="p1">**</ept> feature in Blend for Visual Studio.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can find that command on one of the buttons at the top of the <bpt id="p1">**</bpt>Data<ept id="p1">**</ept> panel.</source>
          <target state="new">You can find that command on one of the buttons at the top of the <bpt id="p1">**</bpt>Data<ept id="p1">**</ept> panel.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>All you need to do is to specify a class for the command to use.</source>
          <target state="new">All you need to do is to specify a class for the command to use.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The command then does two important things for you.</source>
          <target state="new">The command then does two important things for you.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>First, it generates a XAML file that contains sample data suitable for hydrating an instance of your chosen class and all of its members, recursively (in fact, the tooling works equally well with XAML or JSON files).</source>
          <target state="new">First, it generates a XAML file that contains sample data suitable for hydrating an instance of your chosen class and all of its members, recursively (in fact, the tooling works equally well with XAML or JSON files).</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Second, it populates the <bpt id="p1">**</bpt>Data<ept id="p1">**</ept> panel with the schema of your chosen class.</source>
          <target state="new">Second, it populates the <bpt id="p1">**</bpt>Data<ept id="p1">**</ept> panel with the schema of your chosen class.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can then drag members from the <bpt id="p1">**</bpt>Data<ept id="p1">**</ept> panel onto the design surface to perform various tasks.</source>
          <target state="new">You can then drag members from the <bpt id="p1">**</bpt>Data<ept id="p1">**</ept> panel onto the design surface to perform various tasks.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Depending on what you drag and where you drop it, you can add bindings to existing controls (using <bpt id="p1">**</bpt>{Binding}<ept id="p1">**</ept>), or create new controls and bind them at the same time.</source>
          <target state="new">Depending on what you drag and where you drop it, you can add bindings to existing controls (using <bpt id="p1">**</bpt>{Binding}<ept id="p1">**</ept>), or create new controls and bind them at the same time.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>In either case, the operation also sets a design-time data context (<bpt id="p1">**</bpt>d:DataContext<ept id="p1">**</ept>) for you (if one is not already set) on the layout root of your page.</source>
          <target state="new">In either case, the operation also sets a design-time data context (<bpt id="p1">**</bpt>d:DataContext<ept id="p1">**</ept>) for you (if one is not already set) on the layout root of your page.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>That design-time data context uses the <bpt id="p1">**</bpt>d:DesignData<ept id="p1">**</ept> attribute to get its sample data from the XAML file that was generated (which, by the way, you are free to find in your project and edit so that it contains the sample data you want).</source>
          <target state="new">That design-time data context uses the <bpt id="p1">**</bpt>d:DesignData<ept id="p1">**</ept> attribute to get its sample data from the XAML file that was generated (which, by the way, you are free to find in your project and edit so that it contains the sample data you want).</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The various xmlns declarations mean that attributes with the <bpt id="p1">**</bpt>d:<ept id="p1">**</ept> prefix are interpreted only at design-time and are ignored at run-time.</source>
          <target state="new">The various xmlns declarations mean that attributes with the <bpt id="p1">**</bpt>d:<ept id="p1">**</ept> prefix are interpreted only at design-time and are ignored at run-time.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>So the <bpt id="p1">**</bpt>d:DataContext<ept id="p1">**</ept> attribute only affects the value of the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DataContext<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/BR208713)</ept> property at design-time; it has no effect at run-time.</source>
          <target state="new">So the <bpt id="p1">**</bpt>d:DataContext<ept id="p1">**</ept> attribute only affects the value of the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DataContext<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/BR208713)</ept> property at design-time; it has no effect at run-time.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You can even set both <bpt id="p1">**</bpt>d:DataContext<ept id="p1">**</ept> and <bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept> in markup if you like.</source>
          <target state="new">You can even set both <bpt id="p1">**</bpt>d:DataContext<ept id="p1">**</ept> and <bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept> in markup if you like.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>d:DataContext<ept id="p1">**</ept> will override at design-time, and <bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept> will override at run-time.</source>
          <target state="new"><bpt id="p1">**</bpt>d:DataContext<ept id="p1">**</ept> will override at design-time, and <bpt id="p2">**</bpt>DataContext<ept id="p2">**</ept> will override at run-time.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>These same override rules apply to all design-time and run-time attributes.</source>
          <target state="new">These same override rules apply to all design-time and run-time attributes.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>d:DataContext<ept id="p1">**</ept> attribute, and all other design-time attributes, are documented in the <bpt id="p2">[</bpt>Design-Time Attributes<ept id="p2">](http://go.microsoft.com/fwlink/p/?LinkId=272504)</ept> topic, which is still valid for Universal Windows Platform (UWP) apps.</source>
          <target state="new">The <bpt id="p1">**</bpt>d:DataContext<ept id="p1">**</ept> attribute, and all other design-time attributes, are documented in the <bpt id="p2">[</bpt>Design-Time Attributes<ept id="p2">](http://go.microsoft.com/fwlink/p/?LinkId=272504)</ept> topic, which is still valid for Universal Windows Platform (UWP) apps.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><bpt id="p2">**</bpt>CollectionViewSource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR209833)</ept> doesn't have a <bpt id="p3">**</bpt>DataContext<ept id="p3">**</ept> property, but it does have a <bpt id="p4">**</bpt>Source<ept id="p4">**</ept> property.</source>
          <target state="new"><bpt id="p1">[</bpt><bpt id="p2">**</bpt>CollectionViewSource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR209833)</ept> doesn't have a <bpt id="p3">**</bpt>DataContext<ept id="p3">**</ept> property, but it does have a <bpt id="p4">**</bpt>Source<ept id="p4">**</ept> property.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Consequently, there's a <bpt id="p1">**</bpt>d:Source<ept id="p1">**</ept> property that you can use to set design-time-only sample data on a <bpt id="p2">**</bpt>CollectionViewSource<ept id="p2">**</ept>.</source>
          <target state="new">Consequently, there's a <bpt id="p1">**</bpt>d:Source<ept id="p1">**</ept> property that you can use to set design-time-only sample data on a <bpt id="p2">**</bpt>CollectionViewSource<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For this to work, you would have a class named <ph id="ph1">`Recordings : ObservableCollection&lt;Recording&gt;`</ph>, and you would edit the sample data XAML file so that it contains only a <bpt id="p1">**</bpt>Recordings<ept id="p1">**</ept> object (with <bpt id="p2">**</bpt>Recording<ept id="p2">**</ept> objects inside that), as shown here.</source>
          <target state="new">For this to work, you would have a class named <ph id="ph1">`Recordings : ObservableCollection&lt;Recording&gt;`</ph>, and you would edit the sample data XAML file so that it contains only a <bpt id="p1">**</bpt>Recordings<ept id="p1">**</ept> object (with <bpt id="p2">**</bpt>Recording<ept id="p2">**</ept> objects inside that), as shown here.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>If you use a JSON sample data file instead of XAML, you must set the <bpt id="p1">**</bpt>Type<ept id="p1">**</ept> property.</source>
          <target state="new">If you use a JSON sample data file instead of XAML, you must set the <bpt id="p1">**</bpt>Type<ept id="p1">**</ept> property.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>So far, we've been using <bpt id="p1">**</bpt>d:DesignData<ept id="p1">**</ept> to load design-time sample data from a XAML or JSON file.</source>
          <target state="new">So far, we've been using <bpt id="p1">**</bpt>d:DesignData<ept id="p1">**</ept> to load design-time sample data from a XAML or JSON file.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>An alternative to that is the <bpt id="p1">**</bpt>d:DesignInstance<ept id="p1">**</ept> markup extension, which indicates that the design-time source is based on the class specified by the <bpt id="p2">**</bpt>Type<ept id="p2">**</ept> property.</source>
          <target state="new">An alternative to that is the <bpt id="p1">**</bpt>d:DesignInstance<ept id="p1">**</ept> markup extension, which indicates that the design-time source is based on the class specified by the <bpt id="p2">**</bpt>Type<ept id="p2">**</ept> property.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Here's an example.</source>
          <target state="new">Here's an example.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>