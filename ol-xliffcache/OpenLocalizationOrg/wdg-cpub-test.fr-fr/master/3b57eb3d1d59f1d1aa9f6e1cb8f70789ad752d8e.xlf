<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3b57eb3d1d59f1d1aa9f6e1cb8f70789ad752d8e</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\winrt-components\raising-events-in-windows-runtime-components.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Raising Events in Windows Runtime Components</source>
          <target state="new">Raising Events in Windows Runtime Components</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Raising Events in Windows Runtime Components</source>
          <target state="new">Raising Events in Windows Runtime Components</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>\[Some information relates to pre-released product which may be substantially modified before it's commercially released.</source>
          <target state="new">\[Some information relates to pre-released product which may be substantially modified before it's commercially released.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Microsoft makes no warranties, express or implied, with respect to the information provided here.\]</source>
          <target state="new">Microsoft makes no warranties, express or implied, with respect to the information provided here.\]</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>If your Windows Runtime component raises an event of a user-defined delegate type on a background thread (worker thread) and you want JavaScript to be able to receive the event, you can implement and/or raise it in one of these ways:</source>
          <target state="new">If your Windows Runtime component raises an event of a user-defined delegate type on a background thread (worker thread) and you want JavaScript to be able to receive the event, you can implement and/or raise it in one of these ways:</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>(Option 1) Raise the event through the <bpt id="p1">[</bpt>Windows.UI.Core.CoreDispatcher<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.aspx)</ept> to marshal the event to the JavaScript thread context.</source>
          <target state="new">(Option 1) Raise the event through the <bpt id="p1">[</bpt>Windows.UI.Core.CoreDispatcher<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.aspx)</ept> to marshal the event to the JavaScript thread context.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Although typically this is the best option, in some scenarios it might not provide the fastest performance.</source>
          <target state="new">Although typically this is the best option, in some scenarios it might not provide the fastest performance.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>(Option 2) Use <bpt id="p1">[</bpt>Windows.Foundation.EventHandler<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br206577.aspx)</ept><ph id="ph1">&amp;lt;</ph>Object<ph id="ph2">&amp;gt;</ph> but lose type information (but lose the event type information).</source>
          <target state="new">(Option 2) Use <bpt id="p1">[</bpt>Windows.Foundation.EventHandler<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br206577.aspx)</ept><ph id="ph1">&amp;lt;</ph>Object<ph id="ph2">&amp;gt;</ph> but lose type information (but lose the event type information).</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If Option 1 is not feasible or its performance is not adequate, then this is a good second choice if loss of type information is acceptable.</source>
          <target state="new">If Option 1 is not feasible or its performance is not adequate, then this is a good second choice if loss of type information is acceptable.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>(Option 3) Create your own proxy and stub for the component.</source>
          <target state="new">(Option 3) Create your own proxy and stub for the component.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This option is the most difficult to implement, but it preserves type information and might provide better performance compared to Option 1 in demanding scenarios.</source>
          <target state="new">This option is the most difficult to implement, but it preserves type information and might provide better performance compared to Option 1 in demanding scenarios.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>If you just raise an event on a background thread without using one of these options, a JavaScript client will not receive the event.</source>
          <target state="new">If you just raise an event on a background thread without using one of these options, a JavaScript client will not receive the event.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="new">Background</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>All Windows Runtime components and apps are fundamentally COM objects, no matter what language you use to create them.</source>
          <target state="new">All Windows Runtime components and apps are fundamentally COM objects, no matter what language you use to create them.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In the Windows API, most of the components are agile COM objects that can communicate equally well with objects on the background thread and on the UI thread.</source>
          <target state="new">In the Windows API, most of the components are agile COM objects that can communicate equally well with objects on the background thread and on the UI thread.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If a COM object can’t be made agile, then it requires helper objects known as proxies and stubs to communicate with other COM objects across the UI thread-background thread boundary.</source>
          <target state="new">If a COM object can’t be made agile, then it requires helper objects known as proxies and stubs to communicate with other COM objects across the UI thread-background thread boundary.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>(In COM terms, this is known as communication between thread apartments.)</source>
          <target state="new">(In COM terms, this is known as communication between thread apartments.)</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Most of the objects in the Windows API are either agile or have proxies and stubs built in.</source>
          <target state="new">Most of the objects in the Windows API are either agile or have proxies and stubs built in.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>However, proxies and stubs can’t be created for generic types such as Windows.Foundation.<bpt id="p1">[</bpt>TypedEventHandler<ph id="ph1">&amp;lt;</ph>TSender, TResult<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225997.aspx)</ept> because they are not complete types until you provide the type argument.</source>
          <target state="new">However, proxies and stubs can’t be created for generic types such as Windows.Foundation.<bpt id="p1">[</bpt>TypedEventHandler<ph id="ph1">&amp;lt;</ph>TSender, TResult<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225997.aspx)</ept> because they are not complete types until you provide the type argument.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>It's only with JavaScript clients that the lack of proxies or stubs becomes an issue, but if you want your component to be usable from JavaScript as well as from C++ or a .NET language, then you must use one of the following three options.</source>
          <target state="new">It's only with JavaScript clients that the lack of proxies or stubs becomes an issue, but if you want your component to be usable from JavaScript as well as from C++ or a .NET language, then you must use one of the following three options.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>(Option 1) Raise the event through the CoreDispatcher</source>
          <target state="new">(Option 1) Raise the event through the CoreDispatcher</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You can send events of any user-defined delegate type by using the <bpt id="p1">[</bpt>Windows.UI.Core.CoreDispatcher<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.aspx)</ept>, and JavaScript will be able to receive them.</source>
          <target state="new">You can send events of any user-defined delegate type by using the <bpt id="p1">[</bpt>Windows.UI.Core.CoreDispatcher<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.ui.core.coredispatcher.aspx)</ept>, and JavaScript will be able to receive them.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>If you are unsure which option to use, try this one first.</source>
          <target state="new">If you are unsure which option to use, try this one first.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If latency between the event firing and the event handling becomes an issue, then try one of the other options.</source>
          <target state="new">If latency between the event firing and the event handling becomes an issue, then try one of the other options.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The following example shows how to use the CoreDispatcher to raise a strongly-typed event.</source>
          <target state="new">The following example shows how to use the CoreDispatcher to raise a strongly-typed event.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Notice that the type argument is Toast, not Object.</source>
          <target state="new">Notice that the type argument is Toast, not Object.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>(Option 2) Use EventHandler<ph id="ph1">&amp;lt;</ph>Object<ph id="ph2">&amp;gt;</ph> but lose type information</source>
          <target state="new">(Option 2) Use EventHandler<ph id="ph1">&amp;lt;</ph>Object<ph id="ph2">&amp;gt;</ph> but lose type information</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Another way to send an event from a background thread is to use <bpt id="p1">[</bpt>Windows.Foundation.EventHandler<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br206577.aspx)</ept><ph id="ph1">&amp;lt;</ph>Object<ph id="ph2">&amp;gt;</ph> as the type of the event.</source>
          <target state="new">Another way to send an event from a background thread is to use <bpt id="p1">[</bpt>Windows.Foundation.EventHandler<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br206577.aspx)</ept><ph id="ph1">&amp;lt;</ph>Object<ph id="ph2">&amp;gt;</ph> as the type of the event.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Windows provides this concrete instantiation of the generic type and provides a proxy and stub for it.</source>
          <target state="new">Windows provides this concrete instantiation of the generic type and provides a proxy and stub for it.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The downside is that the type information of your event args and sender is lost.</source>
          <target state="new">The downside is that the type information of your event args and sender is lost.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>C++ and .NET clients must know through documentation what type to cast back to when the event is received.</source>
          <target state="new">C++ and .NET clients must know through documentation what type to cast back to when the event is received.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>JavaScript clients don’t need the original type information.</source>
          <target state="new">JavaScript clients don’t need the original type information.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>They find the arg properties, based on their names in the metadata.</source>
          <target state="new">They find the arg properties, based on their names in the metadata.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>This example shows how to use Windows.Foundation.EventHandler<ph id="ph1">&amp;lt;</ph>Object<ph id="ph2">&amp;gt;</ph> in C#:</source>
          <target state="new">This example shows how to use Windows.Foundation.EventHandler<ph id="ph1">&amp;lt;</ph>Object<ph id="ph2">&amp;gt;</ph> in C#:</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>You consume this event on the JavaScript side like this:</source>
          <target state="new">You consume this event on the JavaScript side like this:</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>(Option 3) Create your own proxy and stub</source>
          <target state="new">(Option 3) Create your own proxy and stub</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>For potential performance gains on user-defined event types that have fully-preserved type information, you have to create your own proxy and stub objects and embed them in your app package.</source>
          <target state="new">For potential performance gains on user-defined event types that have fully-preserved type information, you have to create your own proxy and stub objects and embed them in your app package.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Typically, you have to use this option only in rare situations where neither of the other two options are adequate.</source>
          <target state="new">Typically, you have to use this option only in rare situations where neither of the other two options are adequate.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Also, there is no guarantee that this option will provide better performance than the other two options.</source>
          <target state="new">Also, there is no guarantee that this option will provide better performance than the other two options.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Actual performance depends on many factors.</source>
          <target state="new">Actual performance depends on many factors.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Use the Visual Studio profiler or other profiling tools to measure actual performance in your application and determine whether the event is in fact a bottleneck.</source>
          <target state="new">Use the Visual Studio profiler or other profiling tools to measure actual performance in your application and determine whether the event is in fact a bottleneck.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>The rest of this article shows how to use C# to create a basic Windows Runtime component, and then use C++ to create a DLL for the proxy and stub that will enable JavaScript to consume a Windows.Foundation.TypedEventHandler<ph id="ph1">&amp;lt;</ph>TSender, TResult<ph id="ph2">&amp;gt;</ph> event that's raised by the component in an async operation.</source>
          <target state="new">The rest of this article shows how to use C# to create a basic Windows Runtime component, and then use C++ to create a DLL for the proxy and stub that will enable JavaScript to consume a Windows.Foundation.TypedEventHandler<ph id="ph1">&amp;lt;</ph>TSender, TResult<ph id="ph2">&amp;gt;</ph> event that's raised by the component in an async operation.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>(You can also use C++ or Visual Basic to create the component.</source>
          <target state="new">(You can also use C++ or Visual Basic to create the component.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The steps that are related to creating the proxies and stubs are the same.) This walkthrough is based on Creating a Windows Runtime in-process component sample (C++/CX) and helps explain its purposes.</source>
          <target state="new">The steps that are related to creating the proxies and stubs are the same.) This walkthrough is based on Creating a Windows Runtime in-process component sample (C++/CX) and helps explain its purposes.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This walkthrough has these parts:</source>
          <target state="new">This walkthrough has these parts:</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Here you will create two basic Windows Runtime classes.</source>
          <target state="new">Here you will create two basic Windows Runtime classes.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>One class exposes an event of type <bpt id="p1">[</bpt>Windows.Foundation.TypedEventHandler<ph id="ph1">&amp;lt;</ph>TSender, TResult<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225997.aspx)</ept> and the other class is the type that's returned to JavaScript as the argument for TValue.</source>
          <target state="new">One class exposes an event of type <bpt id="p1">[</bpt>Windows.Foundation.TypedEventHandler<ph id="ph1">&amp;lt;</ph>TSender, TResult<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225997.aspx)</ept> and the other class is the type that's returned to JavaScript as the argument for TValue.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>These classes can't communicate with JavaScript until you complete the later steps.</source>
          <target state="new">These classes can't communicate with JavaScript until you complete the later steps.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This app activates the main class object, calls a method, and handles an event that's raised by the Windows Runtime component.</source>
          <target state="new">This app activates the main class object, calls a method, and handles an event that's raised by the Windows Runtime component.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>These are required by the tools that generate the proxy and stub classes.</source>
          <target state="new">These are required by the tools that generate the proxy and stub classes.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You then use the IDL file to generate the C source code for the proxy and stub.</source>
          <target state="new">You then use the IDL file to generate the C source code for the proxy and stub.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Register the proxy-stub objects so that the COM runtime can find them, and reference the proxy-stub DLL in the app project.</source>
          <target state="new">Register the proxy-stub objects so that the COM runtime can find them, and reference the proxy-stub DLL in the app project.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>To create the Windows Runtime component</source>
          <target state="new">To create the Windows Runtime component</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>1n Visual Studio, on the menu bar, choose <bpt id="p1">**</bpt>File <ph id="ph1">&amp;gt;</ph> New Project<ept id="p1">**</ept>.</source>
          <target state="new">1n Visual Studio, on the menu bar, choose <bpt id="p1">**</bpt>File <ph id="ph1">&amp;gt;</ph> New Project<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>New Project<ept id="p1">**</ept> dialog box, expand <bpt id="p2">**</bpt>JavaScript <ph id="ph1">&amp;gt;</ph> Universal Windows<ept id="p2">**</ept> and then select <bpt id="p3">**</bpt>Blank App<ept id="p3">**</ept>.</source>
          <target state="new">In the <bpt id="p1">**</bpt>New Project<ept id="p1">**</ept> dialog box, expand <bpt id="p2">**</bpt>JavaScript <ph id="ph1">&amp;gt;</ph> Universal Windows<ept id="p2">**</ept> and then select <bpt id="p3">**</bpt>Blank App<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Name the project ToasterApplication and then choose the <bpt id="p1">**</bpt>OK<ept id="p1">**</ept> button.</source>
          <target state="new">Name the project ToasterApplication and then choose the <bpt id="p1">**</bpt>OK<ept id="p1">**</ept> button.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Add a C# Windows Runtime component to the solution: In Solution Explorer, open the shortcut menu for the solution and then choose <bpt id="p1">**</bpt>Add <ph id="ph1">&amp;gt;</ph> New Project<ept id="p1">**</ept>.</source>
          <target state="new">Add a C# Windows Runtime component to the solution: In Solution Explorer, open the shortcut menu for the solution and then choose <bpt id="p1">**</bpt>Add <ph id="ph1">&amp;gt;</ph> New Project<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Expand <bpt id="p1">**</bpt>Visual C# <ph id="ph1">&amp;gt;</ph> Windows Store<ept id="p1">**</ept> and then select <bpt id="p2">**</bpt>Windows Runtime Component<ept id="p2">**</ept>.</source>
          <target state="new">Expand <bpt id="p1">**</bpt>Visual C# <ph id="ph1">&amp;gt;</ph> Windows Store<ept id="p1">**</ept> and then select <bpt id="p2">**</bpt>Windows Runtime Component<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Name the project ToasterComponent and then choose the <bpt id="p1">**</bpt>OK<ept id="p1">**</ept> button.</source>
          <target state="new">Name the project ToasterComponent and then choose the <bpt id="p1">**</bpt>OK<ept id="p1">**</ept> button.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>ToasterComponent will be the root namespace for the components you will create in later steps.</source>
          <target state="new">ToasterComponent will be the root namespace for the components you will create in later steps.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In Solution Explorer, open the shortcut menu for the solution and then choose <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept>.</source>
          <target state="new">In Solution Explorer, open the shortcut menu for the solution and then choose <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Property Pages<ept id="p1">**</ept> dialog box, select <bpt id="p2">**</bpt>Configuration Properties<ept id="p2">**</ept> in the left pane, and then at the top of the dialog box, set <bpt id="p3">**</bpt>Configuration<ept id="p3">**</ept> to <bpt id="p4">**</bpt>Debug<ept id="p4">**</ept> and <bpt id="p5">**</bpt>Platform<ept id="p5">**</ept> to x86, x64, or ARM.</source>
          <target state="new">In the <bpt id="p1">**</bpt>Property Pages<ept id="p1">**</ept> dialog box, select <bpt id="p2">**</bpt>Configuration Properties<ept id="p2">**</ept> in the left pane, and then at the top of the dialog box, set <bpt id="p3">**</bpt>Configuration<ept id="p3">**</ept> to <bpt id="p4">**</bpt>Debug<ept id="p4">**</ept> and <bpt id="p5">**</bpt>Platform<ept id="p5">**</ept> to x86, x64, or ARM.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Choose the <bpt id="p1">**</bpt>OK<ept id="p1">**</ept> button.</source>
          <target state="new">Choose the <bpt id="p1">**</bpt>OK<ept id="p1">**</ept> button.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>  Platform = Any CPU won’t work because it's not valid for the native-code Win32 DLL that you'll add to the solution later.</source>
          <target state="new"><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>  Platform = Any CPU won’t work because it's not valid for the native-code Win32 DLL that you'll add to the solution later.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>In Solution Explorer, rename class1.cs to ToasterComponent.cs so that it matches the name of the project.</source>
          <target state="new">In Solution Explorer, rename class1.cs to ToasterComponent.cs so that it matches the name of the project.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Visual Studio automatically renames the class in the file to match the new file name.</source>
          <target state="new">Visual Studio automatically renames the class in the file to match the new file name.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In the .cs file, add a using directive for the Windows.Foundation namespace to bring TypedEventHandler into scope.</source>
          <target state="new">In the .cs file, add a using directive for the Windows.Foundation namespace to bring TypedEventHandler into scope.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>When you require proxies and stubs, your component must use interfaces to expose its public members.</source>
          <target state="new">When you require proxies and stubs, your component must use interfaces to expose its public members.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In ToasterComponent.cs, define an interface for the toaster, and another one for the Toast that the toaster produces.</source>
          <target state="new">In ToasterComponent.cs, define an interface for the toaster, and another one for the Toast that the toaster produces.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  In C# you can skip this step.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  In C# you can skip this step.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Instead, first create a class, and then open its shortcut menu and choose <bpt id="p1">**</bpt>Refactor <ph id="ph1">&amp;gt;</ph> Extract Interface<ept id="p1">**</ept>.</source>
          <target state="new">Instead, first create a class, and then open its shortcut menu and choose <bpt id="p1">**</bpt>Refactor <ph id="ph1">&amp;gt;</ph> Extract Interface<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In the code that's generated, manually give the interfaces public accessibility.</source>
          <target state="new">In the code that's generated, manually give the interfaces public accessibility.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The IToast interface has a string that can be retrieved to describe the type of toast.</source>
          <target state="new">The IToast interface has a string that can be retrieved to describe the type of toast.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The IToaster interface has a method to make toast, and an event to indicate that the toast is made.</source>
          <target state="new">The IToaster interface has a method to make toast, and an event to indicate that the toast is made.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Because this event returns the particular piece (that is, type) of toast, it's known as a typed event.</source>
          <target state="new">Because this event returns the particular piece (that is, type) of toast, it's known as a typed event.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Next, we need classes that implement these interfaces, and are public and sealed so that they are accessible from the JavaScript app that you'll program later.</source>
          <target state="new">Next, we need classes that implement these interfaces, and are public and sealed so that they are accessible from the JavaScript app that you'll program later.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>In the preceding code, we create the toast and then spin up a thread-pool work item to fire the notification.</source>
          <target state="new">In the preceding code, we create the toast and then spin up a thread-pool work item to fire the notification.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Although the IDE might suggest that you apply the await keyword to the async call, it isn’t necessary in this case because the method doesn’t do any work that depends on the results of the operation.</source>
          <target state="new">Although the IDE might suggest that you apply the await keyword to the async call, it isn’t necessary in this case because the method doesn’t do any work that depends on the results of the operation.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  The async call in the preceding code uses ThreadPool.RunAsync solely to demonstrate a simple way to fire the event on a background thread.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  The async call in the preceding code uses ThreadPool.RunAsync solely to demonstrate a simple way to fire the event on a background thread.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You could write this particular method as shown in the following example, and it would work fine because the .NET Task scheduler automatically marshals async/await calls back to the UI thread.</source>
          <target state="new">You could write this particular method as shown in the following example, and it would work fine because the .NET Task scheduler automatically marshals async/await calls back to the UI thread.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>