<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">31e3676ada281ba902c95965859638d5a23d7c5b</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\supporting-screen-rotation-directx-and-cpp.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Supporting screen orientation (DirectX and C++)</source>
          <target state="new">Supporting screen orientation (DirectX and C++)</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.</source>
          <target state="new">Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Supporting screen orientation (DirectX and C++)</source>
          <target state="new">Supporting screen orientation (DirectX and C++)</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Your Universal Windows Platform (UWP) app can support multiple screen orientations when you handle the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event.</source>
          <target state="new">Your Universal Windows Platform (UWP) app can support multiple screen orientations when you handle the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.</source>
          <target state="new">Here, we'll discuss best practices for handling screen rotation in your UWP DirectX app, so that the Windows 10 device's graphics hardware are used efficiently and effectively.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Before you start, remember that graphics hardware always outputs pixel data in the same way, regardless of the orientation of the device.</source>
          <target state="new">Before you start, remember that graphics hardware always outputs pixel data in the same way, regardless of the orientation of the device.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Windows 10 devices can determine their current display orientation (with some sort of sensor, or with a software toggle) and allow users to change the display settings.</source>
          <target state="new">Windows 10 devices can determine their current display orientation (with some sort of sensor, or with a software toggle) and allow users to change the display settings.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Because of this, Windows 10 itself handles the rotation of the images to ensure they are "upright" based on the orientation of the device.</source>
          <target state="new">Because of this, Windows 10 itself handles the rotation of the images to ensure they are "upright" based on the orientation of the device.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>By default, your app receives the notification that something has changed in orientation, for example, a window size.</source>
          <target state="new">By default, your app receives the notification that something has changed in orientation, for example, a window size.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>When this happens, Windows 10 immediately rotates the image for final display.</source>
          <target state="new">When this happens, Windows 10 immediately rotates the image for final display.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>For three of the four specific screen orientations (discussed later), Windows 10 uses additional graphic resources and computation to display the final image.</source>
          <target state="new">For three of the four specific screen orientations (discussed later), Windows 10 uses additional graphic resources and computation to display the final image.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>For UWP DirectX apps, the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264258)</ept> object provides basic display orientation data that your app can query.</source>
          <target state="new">For UWP DirectX apps, the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264258)</ept> object provides basic display orientation data that your app can query.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The default orientation is <bpt id="p1">*</bpt>landscape<ept id="p1">*</ept>, where the pixel width of the display is greater than the height; the alternative orientation is <bpt id="p2">*</bpt>portrait<ept id="p2">*</ept>, where the display is rotated 90 degrees in either direction and the width becomes less than the height.</source>
          <target state="new">The default orientation is <bpt id="p1">*</bpt>landscape<ept id="p1">*</ept>, where the pixel width of the display is greater than the height; the alternative orientation is <bpt id="p2">*</bpt>portrait<ept id="p2">*</ept>, where the display is rotated 90 degrees in either direction and the width becomes less than the height.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Windows 10 defines four specific display orientation modes:</source>
          <target state="new">Windows 10 defines four specific display orientation modes:</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Landscape—the default display orientation for Windows 10, and is considered the base or identity angle for rotation (0 degrees).</source>
          <target state="new">Landscape—the default display orientation for Windows 10, and is considered the base or identity angle for rotation (0 degrees).</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Portrait—the display has been rotated clockwise 90 degrees (or counter-clockwise 270 degrees).</source>
          <target state="new">Portrait—the display has been rotated clockwise 90 degrees (or counter-clockwise 270 degrees).</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Landscape, flipped—the display has been rotated 180 degrees (turned upside-down).</source>
          <target state="new">Landscape, flipped—the display has been rotated 180 degrees (turned upside-down).</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Portrait, flipped—the display has been rotated clockwise 270 degrees (or counter-clockwise 90 degrees).</source>
          <target state="new">Portrait, flipped—the display has been rotated clockwise 270 degrees (or counter-clockwise 90 degrees).</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>When the display rotates from one orientation to another, Windows 10 internally performs a rotation operation to align the drawn image with the new orientation, and the user sees an upright image on the screen.</source>
          <target state="new">When the display rotates from one orientation to another, Windows 10 internally performs a rotation operation to align the drawn image with the new orientation, and the user sees an upright image on the screen.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Also, Windows 10 displays automatic transition animations to create a smooth user experience when shifting from one orientation to another.</source>
          <target state="new">Also, Windows 10 displays automatic transition animations to create a smooth user experience when shifting from one orientation to another.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>As the display orientation shifts, the user sees these shifts as a fixed zoom and rotation animation of the displayed screen image.</source>
          <target state="new">As the display orientation shifts, the user sees these shifts as a fixed zoom and rotation animation of the displayed screen image.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Time is allocated by Windows 10 to the app for layout in the new orientation.</source>
          <target state="new">Time is allocated by Windows 10 to the app for layout in the new orientation.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Overall, this is the general process for handling changes in screen orientation:</source>
          <target state="new">Overall, this is the general process for handling changes in screen orientation:</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Use a combination of the window bounds values and the display orientation data to keep the swap chain aligned with the native display orientation of the device.</source>
          <target state="new">Use a combination of the window bounds values and the display orientation data to keep the swap chain aligned with the native display orientation of the device.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Notify Windows 10 of the orientation of the swap chain using <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain1::SetRotation<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept>.</source>
          <target state="new">Notify Windows 10 of the orientation of the swap chain using <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain1::SetRotation<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept>.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Change the rendering code to generate images aligned with the user orientation of the device.</source>
          <target state="new">Change the rendering code to generate images aligned with the user orientation of the device.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Resizing the swap chain and pre-rotating its contents</source>
          <target state="new">Resizing the swap chain and pre-rotating its contents</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>To perform a basic display resize and pre-rotate its contents in your UWP DirectX app , implement these steps:</source>
          <target state="new">To perform a basic display resize and pre-rotate its contents in your UWP DirectX app , implement these steps:</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Handle the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event.</source>
          <target state="new">Handle the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Resize the swap chain to the new dimensions of the window.</source>
          <target state="new">Resize the swap chain to the new dimensions of the window.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain1::SetRotation<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept> to set the orientation of the swap chain.</source>
          <target state="new">Call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain1::SetRotation<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept> to set the orientation of the swap chain.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Recreate any window size dependent resources, such as your render targets and other pixel data buffers.</source>
          <target state="new">Recreate any window size dependent resources, such as your render targets and other pixel data buffers.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Now's let's look at those steps in a bit more detail.</source>
          <target state="new">Now's let's look at those steps in a bit more detail.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Your first step is to register a handler for the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event.</source>
          <target state="new">Your first step is to register a handler for the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This event is raised in your app every time the screen orientation changes, such as when the display is rotated.</source>
          <target state="new">This event is raised in your app every time the screen orientation changes, such as when the display is rotated.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>To handle the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event, you connect your handler for <bpt id="p3">**</bpt>DisplayInformation::OrientationChanged<ept id="p3">**</ept> in the required <bpt id="p4">[</bpt><bpt id="p5">**</bpt>SetWindow<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/hh700509)</ept> method, which is one of the methods of the <bpt id="p6">[</bpt><bpt id="p7">**</bpt>IFrameworkView<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/hh700478)</ept> interface that your view provider must implement.</source>
          <target state="new">To handle the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event, you connect your handler for <bpt id="p3">**</bpt>DisplayInformation::OrientationChanged<ept id="p3">**</ept> in the required <bpt id="p4">[</bpt><bpt id="p5">**</bpt>SetWindow<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/hh700509)</ept> method, which is one of the methods of the <bpt id="p6">[</bpt><bpt id="p7">**</bpt>IFrameworkView<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/hh700478)</ept> interface that your view provider must implement.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In this code example, the event handler for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> is a method called <bpt id="p3">**</bpt>OnOrientationChanged<ept id="p3">**</ept>.</source>
          <target state="new">In this code example, the event handler for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> is a method called <bpt id="p3">**</bpt>OnOrientationChanged<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When <bpt id="p1">**</bpt>DisplayInformation::OrientationChanged<ept id="p1">**</ept> is raised, it in turn calls a method called <bpt id="p2">**</bpt>SetCurrentOrientation<ept id="p2">**</ept> which then calls <bpt id="p3">**</bpt>CreateWindowSizeDependentResources<ept id="p3">**</ept>.</source>
          <target state="new">When <bpt id="p1">**</bpt>DisplayInformation::OrientationChanged<ept id="p1">**</ept> is raised, it in turn calls a method called <bpt id="p2">**</bpt>SetCurrentOrientation<ept id="p2">**</ept> which then calls <bpt id="p3">**</bpt>CreateWindowSizeDependentResources<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Next, you resize the swap chain for the new screen orientation and prepare it to rotate the contents of the graphic pipeline when the rendering is performed.</source>
          <target state="new">Next, you resize the swap chain for the new screen orientation and prepare it to rotate the contents of the graphic pipeline when the rendering is performed.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>In this example, <bpt id="p1">**</bpt>DirectXBase::CreateWindowSizeDependentResources<ept id="p1">**</ept> is a method that handles calling IDXGISwapChain::ResizeBuffers, setting a 3D and a 2D rotation matrix, calling SetRotation, and recreating your resources.</source>
          <target state="new">In this example, <bpt id="p1">**</bpt>DirectXBase::CreateWindowSizeDependentResources<ept id="p1">**</ept> is a method that handles calling IDXGISwapChain::ResizeBuffers, setting a 3D and a 2D rotation matrix, calling SetRotation, and recreating your resources.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>After saving the current height and width values of the window for the next time this method is called, convert the device independent pixel (DIP) values for the display bounds to pixels.</source>
          <target state="new">After saving the current height and width values of the window for the next time this method is called, convert the device independent pixel (DIP) values for the display bounds to pixels.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>In the sample, you call <bpt id="p1">**</bpt>ConvertDipsToPixels<ept id="p1">**</ept>, which is a simple function that runs this code:</source>
          <target state="new">In the sample, you call <bpt id="p1">**</bpt>ConvertDipsToPixels<ept id="p1">**</ept>, which is a simple function that runs this code:</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You add the 0.5f to ensure rounding to the nearest integer value.</source>
          <target state="new">You add the 0.5f to ensure rounding to the nearest integer value.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>As an aside, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindow<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> coordinates are always defined in DIPs.</source>
          <target state="new">As an aside, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindow<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> coordinates are always defined in DIPs.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For Windows 10 and earlier versions of Windows, a DIP is defined as 1/96th of an inch, and aligned to the OS's definition of <bpt id="p1">*</bpt>up<ept id="p1">*</ept>.</source>
          <target state="new">For Windows 10 and earlier versions of Windows, a DIP is defined as 1/96th of an inch, and aligned to the OS's definition of <bpt id="p1">*</bpt>up<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>When the display orientation rotates to portrait mode, the app flips the width and height of the <bpt id="p1">**</bpt>CoreWindow<ept id="p1">**</ept>, and the render target size (bounds) must change accordingly.</source>
          <target state="new">When the display orientation rotates to portrait mode, the app flips the width and height of the <bpt id="p1">**</bpt>CoreWindow<ept id="p1">**</ept>, and the render target size (bounds) must change accordingly.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Because Direct3D’s coordinates are always in physical pixels, you must convert from <bpt id="p1">**</bpt>CoreWindow<ept id="p1">**</ept>'s DIP values to integer pixel values before you pass these values to Direct3D to set up the swap chain.</source>
          <target state="new">Because Direct3D’s coordinates are always in physical pixels, you must convert from <bpt id="p1">**</bpt>CoreWindow<ept id="p1">**</ept>'s DIP values to integer pixel values before you pass these values to Direct3D to set up the swap chain.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Process-wise, you're doing a bit more work than you would if you simply resized the swap chain: you're actually rotating the Direct2D and Direct3D components of your image before you composite them for presentation, and you're telling the swap chain that you've rendered the results in a new orientation.</source>
          <target state="new">Process-wise, you're doing a bit more work than you would if you simply resized the swap chain: you're actually rotating the Direct2D and Direct3D components of your image before you composite them for presentation, and you're telling the swap chain that you've rendered the results in a new orientation.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Here's a little more detail on this process, as shown in the code example for <bpt id="p1">**</bpt>DX::DeviceResources::CreateWindowSizeDependentResources<ept id="p1">**</ept>:</source>
          <target state="new">Here's a little more detail on this process, as shown in the code example for <bpt id="p1">**</bpt>DX::DeviceResources::CreateWindowSizeDependentResources<ept id="p1">**</ept>:</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Determine the new orientation of the display.</source>
          <target state="new">Determine the new orientation of the display.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>If the display has flipped from landscape to portrait, or vice versa, swap the height and width values—changed from DIP values to pixels, of course—for the display bounds.</source>
          <target state="new">If the display has flipped from landscape to portrait, or vice versa, swap the height and width values—changed from DIP values to pixels, of course—for the display bounds.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Then, check to see if the swap chain has been created.</source>
          <target state="new">Then, check to see if the swap chain has been created.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>If it hasn't been created, create it by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGIFactory2::CreateSwapChainForCoreWindow<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh404559)</ept>.</source>
          <target state="new">If it hasn't been created, create it by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGIFactory2::CreateSwapChainForCoreWindow<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh404559)</ept>.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Otherwise, resize the existing swap chain's buffers to the new display dimensions by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapchain:ResizeBuffers<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb174577)</ept>.</source>
          <target state="new">Otherwise, resize the existing swap chain's buffers to the new display dimensions by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapchain:ResizeBuffers<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb174577)</ept>.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Although you don't need to resize the swap chain for the rotation event—you're outputting the content already rotated by your rendering pipeline, after all—there are other size change events, such as snap and fill events, that require resizing.</source>
          <target state="new">Although you don't need to resize the swap chain for the rotation event—you're outputting the content already rotated by your rendering pipeline, after all—there are other size change events, such as snap and fill events, that require resizing.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>After that, set the appropriate 2-D or 3-D matrix transformation to apply to the pixels or the vertices (respectively) in the graphics pipeline when rendering them to the swap chain.</source>
          <target state="new">After that, set the appropriate 2-D or 3-D matrix transformation to apply to the pixels or the vertices (respectively) in the graphics pipeline when rendering them to the swap chain.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>We have 4 possible rotation matrices:</source>
          <target state="new">We have 4 possible rotation matrices:</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>landscape (DXGI\_MODE\_ROTATION\_IDENTITY)</source>
          <target state="new">landscape (DXGI\_MODE\_ROTATION\_IDENTITY)</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>portrait (DXGI\_MODE\_ROTATION\_ROTATE270)</source>
          <target state="new">portrait (DXGI\_MODE\_ROTATION\_ROTATE270)</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>landscape, flipped (DXGI\_MODE\_ROTATION\_ROTATE180)</source>
          <target state="new">landscape, flipped (DXGI\_MODE\_ROTATION\_ROTATE180)</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>portrait, flipped (DXGI\_MODE\_ROTATION\_ROTATE90)</source>
          <target state="new">portrait, flipped (DXGI\_MODE\_ROTATION\_ROTATE90)</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The correct matrix is selected based on the data provided by Windows 10 (such as the results of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept>) for determining display orientation, and it will be multiplied by the coordinates of each pixel (Direct2D) or vertex (Direct3D) in the scene, effectively rotating them to align to the orientation of the screen.</source>
          <target state="new">The correct matrix is selected based on the data provided by Windows 10 (such as the results of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept>) for determining display orientation, and it will be multiplied by the coordinates of each pixel (Direct2D) or vertex (Direct3D) in the scene, effectively rotating them to align to the orientation of the screen.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>(Note that in Direct2D, the screen origin is defined as the upper-left corner, while in Direct3D the origin is defined as the logical center of the window.)</source>
          <target state="new">(Note that in Direct2D, the screen origin is defined as the upper-left corner, while in Direct3D the origin is defined as the logical center of the window.)</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   For more info about the 2-D transformations used for rotation and how to define them, see <bpt id="p2">[</bpt>Defining matrices for screen rotation (2-D)<ept id="p2">](#defining_matrices_2d)</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   For more info about the 2-D transformations used for rotation and how to define them, see <bpt id="p2">[</bpt>Defining matrices for screen rotation (2-D)<ept id="p2">](#defining_matrices_2d)</ept>.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>For more info about the 3-D transformations used for rotation, see <bpt id="p1">[</bpt>Defining matrices for screen rotation (3-D)<ept id="p1">](#defining_matrices_3d)</ept>.</source>
          <target state="new">For more info about the 3-D transformations used for rotation, see <bpt id="p1">[</bpt>Defining matrices for screen rotation (3-D)<ept id="p1">](#defining_matrices_3d)</ept>.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Now, here's the important bit: call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain1::SetRotation<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept> and provide it with your updated rotation matrix, like this:</source>
          <target state="new">Now, here's the important bit: call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain1::SetRotation<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept> and provide it with your updated rotation matrix, like this:</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>You also store the selected rotation matrix where your render method can get it when it computes the new projection.</source>
          <target state="new">You also store the selected rotation matrix where your render method can get it when it computes the new projection.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>You'll use this matrix when you render your final 3-D projection or composite your final 2-D layout.</source>
          <target state="new">You'll use this matrix when you render your final 3-D projection or composite your final 2-D layout.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>(It doesn't automatically apply it for you.)</source>
          <target state="new">(It doesn't automatically apply it for you.)</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>After that, create a new render target for the rotated 3-D view, as well as a new depth stencil buffer for the view.</source>
          <target state="new">After that, create a new render target for the rotated 3-D view, as well as a new depth stencil buffer for the view.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Set the 3-D rendering viewport for the rotated scene by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext:RSSetViewports<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476480)</ept>.</source>
          <target state="new">Set the 3-D rendering viewport for the rotated scene by calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext:RSSetViewports<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476480)</ept>.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Lastly, if you have 2-D images to rotate or lay out, create a 2-D render target as a writable bitmap for the resized swap chain using <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID2D1DeviceContext::CreateBitmapFromDxgiSurface<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh404482)</ept> and composite your new layout for the updated orientation.</source>
          <target state="new">Lastly, if you have 2-D images to rotate or lay out, create a 2-D render target as a writable bitmap for the resized swap chain using <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID2D1DeviceContext::CreateBitmapFromDxgiSurface<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh404482)</ept> and composite your new layout for the updated orientation.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Set any properties you need to on the render target, such as the anti-aliasing mode (as seen in the code example).</source>
          <target state="new">Set any properties you need to on the render target, such as the anti-aliasing mode (as seen in the code example).</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Now, present the swap chain.</source>
          <target state="new">Now, present the swap chain.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Reduce the rotation delay by using CoreWindowResizeManager</source>
          <target state="new">Reduce the rotation delay by using CoreWindowResizeManager</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>By default, Windows 10 provides a short but noticeable window of time for any app, regardless of app model or language, to complete the rotation of the image.</source>
          <target state="new">By default, Windows 10 provides a short but noticeable window of time for any app, regardless of app model or language, to complete the rotation of the image.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>However, chances are that when your app performs the rotation calculation using one of the techniques described here, it will be done well before this window of time has closed.</source>
          <target state="new">However, chances are that when your app performs the rotation calculation using one of the techniques described here, it will be done well before this window of time has closed.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You'd like to get that time back and complete the rotation animation, right?</source>
          <target state="new">You'd like to get that time back and complete the rotation animation, right?</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>That's where <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindowResizeManager<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/jj215603)</ept> comes in.</source>
          <target state="new">That's where <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindowResizeManager<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/jj215603)</ept> comes in.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Here's how to use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindowResizeManager<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/jj215603)</ept>: when a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>DisplayInformation::OrientationChanged<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event is raised, call <bpt id="p5">[</bpt><bpt id="p6">**</bpt>CoreWindowResizeManager::GetForCurrentView<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/hh404170)</ept> within the handler for the event to obtain an instance of <bpt id="p7">**</bpt>CoreWindowResizeManager<ept id="p7">**</ept> and, when the layout for the new orientation is complete and presented, call the <bpt id="p8">[</bpt><bpt id="p9">**</bpt>NotifyLayoutCompleted<ept id="p9">**</ept><ept id="p8">](https://msdn.microsoft.com/library/windows/apps/jj215605)</ept> to let Windows know that it can complete the rotation animation and display the app screen.</source>
          <target state="new">Here's how to use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindowResizeManager<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/jj215603)</ept>: when a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>DisplayInformation::OrientationChanged<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> event is raised, call <bpt id="p5">[</bpt><bpt id="p6">**</bpt>CoreWindowResizeManager::GetForCurrentView<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/hh404170)</ept> within the handler for the event to obtain an instance of <bpt id="p7">**</bpt>CoreWindowResizeManager<ept id="p7">**</ept> and, when the layout for the new orientation is complete and presented, call the <bpt id="p8">[</bpt><bpt id="p9">**</bpt>NotifyLayoutCompleted<ept id="p9">**</ept><ept id="p8">](https://msdn.microsoft.com/library/windows/apps/jj215605)</ept> to let Windows know that it can complete the rotation animation and display the app screen.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Here's what the code in your event handler for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> might look like:</source>
          <target state="new">Here's what the code in your event handler for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DisplayInformation::OrientationChanged<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/dn264268)</ept> might look like:</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>When a user rotates the orientation of the display, Windows 10 shows an animation independent of your app as feedback to the user.</source>
          <target state="new">When a user rotates the orientation of the display, Windows 10 shows an animation independent of your app as feedback to the user.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>There are three parts to that animation that happen in the following order:</source>
          <target state="new">There are three parts to that animation that happen in the following order:</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Windows 10 shrinks the original image.</source>
          <target state="new">Windows 10 shrinks the original image.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Windows 10 holds the image for the time it takes to rebuild the new layout.</source>
          <target state="new">Windows 10 holds the image for the time it takes to rebuild the new layout.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>This is the window of time that you'd like to reduce, because your app probably doesn't need all of it.</source>
          <target state="new">This is the window of time that you'd like to reduce, because your app probably doesn't need all of it.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>When the layout window expires, or when a notification of layout completion is received, Windows rotates the image and then cross-fade zooms to new orientation.</source>
          <target state="new">When the layout window expires, or when a notification of layout completion is received, Windows rotates the image and then cross-fade zooms to new orientation.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>As suggested in the third bullet, when an app calls <bpt id="p1">[</bpt><bpt id="p2">**</bpt>NotifyLayoutCompleted<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/jj215605)</ept>, Windows 10 stops the timeout window, completes the rotation animation and returns control to your app, which is now drawing in the new display orientation.</source>
          <target state="new">As suggested in the third bullet, when an app calls <bpt id="p1">[</bpt><bpt id="p2">**</bpt>NotifyLayoutCompleted<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/jj215605)</ept>, Windows 10 stops the timeout window, completes the rotation animation and returns control to your app, which is now drawing in the new display orientation.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The overall effect is that your app now feels a little bit more fluid and responsive, and works a little more efficiently!</source>
          <target state="new">The overall effect is that your app now feels a little bit more fluid and responsive, and works a little more efficiently!</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Appendix A: Applying matrices for screen rotation (2-D)</source>
          <target state="new">Appendix A: Applying matrices for screen rotation (2-D)</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>In the sample in <bpt id="p1">[</bpt>Optimizing the rotation process<ept id="p1">](#rotation)</ept> (and in the <bpt id="p2">[</bpt>DXGI swap chain rotation sample<ept id="p2">](http://go.microsoft.com/fwlink/p/?linkid=257600)</ept>), you might have noticed that we had separate rotation matrices for Direct2D output and Direct3D output.</source>
          <target state="new">In the sample in <bpt id="p1">[</bpt>Optimizing the rotation process<ept id="p1">](#rotation)</ept> (and in the <bpt id="p2">[</bpt>DXGI swap chain rotation sample<ept id="p2">](http://go.microsoft.com/fwlink/p/?linkid=257600)</ept>), you might have noticed that we had separate rotation matrices for Direct2D output and Direct3D output.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Let's look at the 2-D matrices, first.</source>
          <target state="new">Let's look at the 2-D matrices, first.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>There are two reasons that we can't apply the same rotation matrices to Direct2D and Direct3D content:</source>
          <target state="new">There are two reasons that we can't apply the same rotation matrices to Direct2D and Direct3D content:</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>One, they use different Cartesian coordinate models.</source>
          <target state="new">One, they use different Cartesian coordinate models.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>Direct2D uses the right-handed rule, where the y-coordinate increases in positive value moving upward from the origin.</source>
          <target state="new">Direct2D uses the right-handed rule, where the y-coordinate increases in positive value moving upward from the origin.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>However, Direct3D uses the left-handed rule, where the y-coordinate increases in positive value rightward from the origin.</source>
          <target state="new">However, Direct3D uses the left-handed rule, where the y-coordinate increases in positive value rightward from the origin.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The result is the origin for the screen coordinates is located in the upper-left for Direct2D, while the origin for the screen (the projection plane) is in the lower-left for Direct3D.</source>
          <target state="new">The result is the origin for the screen coordinates is located in the upper-left for Direct2D, while the origin for the screen (the projection plane) is in the lower-left for Direct3D.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>3-D coordinate systems<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/bb324490.aspx)</ept> for more info.)</source>
          <target state="new">(See <bpt id="p1">[</bpt>3-D coordinate systems<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/bb324490.aspx)</ept> for more info.)</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>direct3d coordinate system.</source>
          <target state="new">direct3d coordinate system.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>direct2d coordinate system.</source>
          <target state="new">direct2d coordinate system.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Two, the 3-D rotation matrices must be specified explicitly to avoid rounding errors.</source>
          <target state="new">Two, the 3-D rotation matrices must be specified explicitly to avoid rounding errors.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The swap chain assumes that the origin is located in the lower-left, so you must perform a rotation to align the right-handed Direct2D coordinate system with the left-handed one used by the swap chain.</source>
          <target state="new">The swap chain assumes that the origin is located in the lower-left, so you must perform a rotation to align the right-handed Direct2D coordinate system with the left-handed one used by the swap chain.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>Specifically, you reposition the image under the new left-handed orientation by multiplying the rotation matrix with a translation matrix for the rotated coordinate system origin, and transform the image from the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindow<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept>'s coordinate space to the swap chain's coordinate space.</source>
          <target state="new">Specifically, you reposition the image under the new left-handed orientation by multiplying the rotation matrix with a translation matrix for the rotated coordinate system origin, and transform the image from the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindow<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept>'s coordinate space to the swap chain's coordinate space.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Your app also must consistently apply this transform when the Direct2D render target is connected with the swap chain.</source>
          <target state="new">Your app also must consistently apply this transform when the Direct2D render target is connected with the swap chain.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>However, if your app is drawing to intermediate surfaces that are not associated directly with the swap chain, don't apply this coordinate space transformation.</source>
          <target state="new">However, if your app is drawing to intermediate surfaces that are not associated directly with the swap chain, don't apply this coordinate space transformation.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Your code to select the correct matrix from the four possible rotations might look like this (be aware of the translation to the new coordinate system origin):</source>
          <target state="new">Your code to select the correct matrix from the four possible rotations might look like this (be aware of the translation to the new coordinate system origin):</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>After you have the correct rotation matrix and origin for the 2-D image, set it with a call to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID2D1DeviceContext::SetTransform<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/dd742857)</ept> between your calls to <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID2D1DeviceContext::BeginDraw<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/dd371768)</ept> and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>ID2D1DeviceContext::EndDraw<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/dd371924)</ept>.</source>
          <target state="new">After you have the correct rotation matrix and origin for the 2-D image, set it with a call to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID2D1DeviceContext::SetTransform<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/dd742857)</ept> between your calls to <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID2D1DeviceContext::BeginDraw<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/dd371768)</ept> and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>ID2D1DeviceContext::EndDraw<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/dd371924)</ept>.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Warning<ept id="p1">**</ept>   Direct2D doesn't have a transformation stack.</source>
          <target state="new"><bpt id="p1">**</bpt>Warning<ept id="p1">**</ept>   Direct2D doesn't have a transformation stack.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If your app is also using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID2D1DeviceContext::SetTransform<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/dd742857)</ept> as a part of its drawing code, this matrix needs to be post-multiplied to any other transform you have applied.</source>
          <target state="new">If your app is also using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID2D1DeviceContext::SetTransform<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/dd742857)</ept> as a part of its drawing code, this matrix needs to be post-multiplied to any other transform you have applied.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>The next time you present the swap chain, your 2-D image will be rotated to match the new display orientation.</source>
          <target state="new">The next time you present the swap chain, your 2-D image will be rotated to match the new display orientation.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Appendix B: Applying matrices for screen rotation (3-D)</source>
          <target state="new">Appendix B: Applying matrices for screen rotation (3-D)</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>In the sample in <bpt id="p1">[</bpt>Optimizing the rotation process<ept id="p1">](#rotation)</ept> (and in the <bpt id="p2">[</bpt>DXGI swap chain rotation sample<ept id="p2">](http://go.microsoft.com/fwlink/p/?linkid=257600)</ept>), we defined a specific transformation matrix for each possible screen orientation.</source>
          <target state="new">In the sample in <bpt id="p1">[</bpt>Optimizing the rotation process<ept id="p1">](#rotation)</ept> (and in the <bpt id="p2">[</bpt>DXGI swap chain rotation sample<ept id="p2">](http://go.microsoft.com/fwlink/p/?linkid=257600)</ept>), we defined a specific transformation matrix for each possible screen orientation.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Now, let's look at the matrixes for rotating 3-D scenes.</source>
          <target state="new">Now, let's look at the matrixes for rotating 3-D scenes.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>As before, you create a set of matrices for each of the 4 possible orientations.</source>
          <target state="new">As before, you create a set of matrices for each of the 4 possible orientations.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>To prevent rounding errors and thus minor visual artifacts, declare the matrices explicitly in your code.</source>
          <target state="new">To prevent rounding errors and thus minor visual artifacts, declare the matrices explicitly in your code.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>You set up these 3-D rotation matrices as follows.</source>
          <target state="new">You set up these 3-D rotation matrices as follows.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>The matrices shown in the following code example are standard rotation matrices for 0, 90, 180, and 270 degree rotations of the vertices that define points in the camera's 3-D scene space.</source>
          <target state="new">The matrices shown in the following code example are standard rotation matrices for 0, 90, 180, and 270 degree rotations of the vertices that define points in the camera's 3-D scene space.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Each vertex's \[x, y, z\] coordinate value in the scene is multiplied by this rotation matrix when the 2-D projection of the scene is computed.</source>
          <target state="new">Each vertex's \[x, y, z\] coordinate value in the scene is multiplied by this rotation matrix when the 2-D projection of the scene is computed.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You set the rotation type on the swap chain with a call to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain1::SetRotation<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept>, like this:</source>
          <target state="new">You set the rotation type on the swap chain with a call to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain1::SetRotation<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh446801)</ept>, like this:</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Now, in your render method, implement some code similar to this:</source>
          <target state="new">Now, in your render method, implement some code similar to this:</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Now, when you call your render method, it multiplies the current rotation matrix (as specified by the class variable <bpt id="p1">**</bpt>m\_orientationTransform3D<ept id="p1">**</ept>) with the current projection matrix, and assigns the results of that operation as the new projection matrix for your renderer.</source>
          <target state="new">Now, when you call your render method, it multiplies the current rotation matrix (as specified by the class variable <bpt id="p1">**</bpt>m\_orientationTransform3D<ept id="p1">**</ept>) with the current projection matrix, and assigns the results of that operation as the new projection matrix for your renderer.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Present the swap chain to see the scene in the updated display orientation.</source>
          <target state="new">Present the swap chain to see the scene in the updated display orientation.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>