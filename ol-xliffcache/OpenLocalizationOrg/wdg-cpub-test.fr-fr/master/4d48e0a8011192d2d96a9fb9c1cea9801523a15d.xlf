<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4d48e0a8011192d2d96a9fb9c1cea9801523a15d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci1\debug-test-perf\improve-garbage-collection-performance.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Improve garbage collection performance</source>
          <target state="new">Improve garbage collection performance</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Universal Windows Platform (UWP) apps written in C# and Visual Basic get automatic memory management from the .NET garbage collector.</source>
          <target state="new">Universal Windows Platform (UWP) apps written in C# and Visual Basic get automatic memory management from the .NET garbage collector.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</source>
          <target state="new">This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Improve garbage collection performance</source>
          <target state="new">Improve garbage collection performance</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Universal Windows Platform (UWP) apps written in C# and Visual Basic get automatic memory management from the .NET garbage collector.</source>
          <target state="new">Universal Windows Platform (UWP) apps written in C# and Visual Basic get automatic memory management from the .NET garbage collector.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</source>
          <target state="new">This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>For more info on how the .NET garbage collector works and tools for debugging and analyzing garbage collector performance, see <bpt id="p1">[</bpt>Garbage collection<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/0xy59wtx.aspx)</ept>.</source>
          <target state="new">For more info on how the .NET garbage collector works and tools for debugging and analyzing garbage collector performance, see <bpt id="p1">[</bpt>Garbage collection<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/0xy59wtx.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Needing to intervene in the default behavior of the garbage collector is strongly indicative of general memory issues with your app.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Needing to intervene in the default behavior of the garbage collector is strongly indicative of general memory issues with your app.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>For more info, see <bpt id="p1">[</bpt>Memory Usage Tool while debugging in Visual Studio 2015<ept id="p1">](http://blogs.msdn.com/b/visualstudioalm/archive/2014/11/13/memory-usage-tool-while-debugging-in-visual-studio-2015.aspx)</ept>.</source>
          <target state="new">For more info, see <bpt id="p1">[</bpt>Memory Usage Tool while debugging in Visual Studio 2015<ept id="p1">](http://blogs.msdn.com/b/visualstudioalm/archive/2014/11/13/memory-usage-tool-while-debugging-in-visual-studio-2015.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This topic applies to C# and Visual Basic only.</source>
          <target state="new">This topic applies to C# and Visual Basic only.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The garbage collector determines when to run by balancing the memory consumption of the managed heap with the amount of work a garbage collection needs to do.</source>
          <target state="new">The garbage collector determines when to run by balancing the memory consumption of the managed heap with the amount of work a garbage collection needs to do.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>One of the ways the garbage collector does this is by dividing the heap into generations and collecting only part of the heap most of the time.</source>
          <target state="new">One of the ways the garbage collector does this is by dividing the heap into generations and collecting only part of the heap most of the time.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>There are three generations in the managed heap:</source>
          <target state="new">There are three generations in the managed heap:</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Generation 0.</source>
          <target state="new">Generation 0.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>This generation contains newly allocated objects unless they are 85KB or larger, in which case they are part of the large object heap.</source>
          <target state="new">This generation contains newly allocated objects unless they are 85KB or larger, in which case they are part of the large object heap.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The large object heap is collected with generation 2 collections.</source>
          <target state="new">The large object heap is collected with generation 2 collections.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Generation 0 collections are the most frequently occurring type of collection and clean up short-lived objects such as local variables.</source>
          <target state="new">Generation 0 collections are the most frequently occurring type of collection and clean up short-lived objects such as local variables.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Generation 1.</source>
          <target state="new">Generation 1.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This generation contains objects that have survived generation 0 collections.</source>
          <target state="new">This generation contains objects that have survived generation 0 collections.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>It serves as a buffer between generation 0 and generation 2.</source>
          <target state="new">It serves as a buffer between generation 0 and generation 2.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Generation 1 collections occur less frequently than generation 0 collections and clean up temporary objects that were active during previous generation 0 collections.</source>
          <target state="new">Generation 1 collections occur less frequently than generation 0 collections and clean up temporary objects that were active during previous generation 0 collections.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A generation 1 collection also collects generation 0.</source>
          <target state="new">A generation 1 collection also collects generation 0.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Generation 2.</source>
          <target state="new">Generation 2.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This generation contains long-lived objects that have survived generation 0 and generation 1 collections.</source>
          <target state="new">This generation contains long-lived objects that have survived generation 0 and generation 1 collections.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Generation 2 collections are the least frequent and collect the entire managed heap, including the large object heap which contains objects that are 85KB or larger.</source>
          <target state="new">Generation 2 collections are the least frequent and collect the entire managed heap, including the large object heap which contains objects that are 85KB or larger.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>You can measure the performance of the garbage collector in 2 aspects: the time it takes to do the garbage collection, and the memory consumption of the managed heap.</source>
          <target state="new">You can measure the performance of the garbage collector in 2 aspects: the time it takes to do the garbage collection, and the memory consumption of the managed heap.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If you have a small app with a heap size less than 100MB then focus on reducing memory consumption.</source>
          <target state="new">If you have a small app with a heap size less than 100MB then focus on reducing memory consumption.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>If you have an app with a managed heap larger than 100MB then focus on reducing the garbage collection time only.</source>
          <target state="new">If you have an app with a managed heap larger than 100MB then focus on reducing the garbage collection time only.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Here's how you can help the .NET garbage collector achieve better performance.</source>
          <target state="new">Here's how you can help the .NET garbage collector achieve better performance.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Reduce memory consumption</source>
          <target state="new">Reduce memory consumption</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Release references</source>
          <target state="new">Release references</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A reference to an object in your app prevents that object, and all of the objects it references, from being collected.</source>
          <target state="new">A reference to an object in your app prevents that object, and all of the objects it references, from being collected.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The .NET compiler does a good job of detecting when a variable is no longer in use so objects held onto by that variable will be eligible for collection.</source>
          <target state="new">The .NET compiler does a good job of detecting when a variable is no longer in use so objects held onto by that variable will be eligible for collection.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>But in some cases it may not be obvious that some objects have a reference to other objects because part of the object graph might be owned by libraries your app uses.</source>
          <target state="new">But in some cases it may not be obvious that some objects have a reference to other objects because part of the object graph might be owned by libraries your app uses.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>To learn about the tools and techniques to find out which objects survive a garbage collection, see <bpt id="p1">[</bpt>Garbage collection and performance<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/ee851764.aspx)</ept>.</source>
          <target state="new">To learn about the tools and techniques to find out which objects survive a garbage collection, see <bpt id="p1">[</bpt>Garbage collection and performance<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/ee851764.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Induce a garbage collection if it’s useful</source>
          <target state="new">Induce a garbage collection if it’s useful</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Induce a garbage collection only after you have measured your app's performance and have determined that inducing a collection will improve its performance.</source>
          <target state="new">Induce a garbage collection only after you have measured your app's performance and have determined that inducing a collection will improve its performance.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>You can induce a garbage collection of a generation by calling [<bpt id="p1">**</bpt>GC.Collect(n)<ept id="p1">**</ept>]https://msdn.microsoft.com/en-us/library/windows/apps/xaml/y46kxc5e.aspx), where n is the generation you want to collect (0, 1, or 2).</source>
          <target state="new">You can induce a garbage collection of a generation by calling [<bpt id="p1">**</bpt>GC.Collect(n)<ept id="p1">**</ept>]https://msdn.microsoft.com/en-us/library/windows/apps/xaml/y46kxc5e.aspx), where n is the generation you want to collect (0, 1, or 2).</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  We recommend that you don't force a garbage collection in your app because the garbage collector uses many heuristics to determine the best time to perform a collection, and forcing a collection is in many cases an unnecessary use of the CPU.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  We recommend that you don't force a garbage collection in your app because the garbage collector uses many heuristics to determine the best time to perform a collection, and forcing a collection is in many cases an unnecessary use of the CPU.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>But if you know that you have a large number of objects in your app that are no longer used and you want to return this memory to the system, then it may be appropriate to force a garbage collection.</source>
          <target state="new">But if you know that you have a large number of objects in your app that are no longer used and you want to return this memory to the system, then it may be appropriate to force a garbage collection.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For example, you can induce a collection at the end of a loading sequence in a game to free up memory before gameplay starts.</source>
          <target state="new">For example, you can induce a collection at the end of a loading sequence in a game to free up memory before gameplay starts.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>To avoid inadvertently inducing too many garbage collections, you can set the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>GCCollectionMode<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/bb495757.aspx)</ept> to <bpt id="p3">**</bpt>Optimized<ept id="p3">**</ept>.</source>
          <target state="new">To avoid inadvertently inducing too many garbage collections, you can set the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>GCCollectionMode<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/bb495757.aspx)</ept> to <bpt id="p3">**</bpt>Optimized<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This instructs the garbage collector to start a collection only if it determines that the collection would be productive enough to be justified.</source>
          <target state="new">This instructs the garbage collector to start a collection only if it determines that the collection would be productive enough to be justified.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Reduce garbage collection time</source>
          <target state="new">Reduce garbage collection time</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>This section applies if you've analyzed your app and observed large garbage collection times.</source>
          <target state="new">This section applies if you've analyzed your app and observed large garbage collection times.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Garbage collection-related pause times include: the time it takes to run a single garbage collection pass; and the total time your app spends doing garbage collections.</source>
          <target state="new">Garbage collection-related pause times include: the time it takes to run a single garbage collection pass; and the total time your app spends doing garbage collections.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The amount of time it takes to do a collection depends on how much live data the collector has to analyze.</source>
          <target state="new">The amount of time it takes to do a collection depends on how much live data the collector has to analyze.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Generation 0 and generation 1 are bounded in size, but generation 2 continues to grow as more long-lived objects are active in your app.</source>
          <target state="new">Generation 0 and generation 1 are bounded in size, but generation 2 continues to grow as more long-lived objects are active in your app.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This means that the collection times for generation 0 and generation 1 are bounded, while generation 2 collections can take longer.</source>
          <target state="new">This means that the collection times for generation 0 and generation 1 are bounded, while generation 2 collections can take longer.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>How often garbage collections run depends mostly on how much memory you allocate, because a garbage collection frees up memory to satisfy allocation requests.</source>
          <target state="new">How often garbage collections run depends mostly on how much memory you allocate, because a garbage collection frees up memory to satisfy allocation requests.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The garbage collector occasionally pauses your app to perform work, but doesn't necessarily pause your app the entire time it is doing a collection.</source>
          <target state="new">The garbage collector occasionally pauses your app to perform work, but doesn't necessarily pause your app the entire time it is doing a collection.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Pause times are usually not user-perceivable in your app, especially for generation 0 and generation 1 collections.</source>
          <target state="new">Pause times are usually not user-perceivable in your app, especially for generation 0 and generation 1 collections.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>Background garbage collection<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/ee787088.aspx#background-garbage-collection)</ept> feature of the .NET garbage collector allows Generation 2 collections to be performed concurrently while your app is running and will only pause your app for short periods of time.</source>
          <target state="new">The <bpt id="p1">[</bpt>Background garbage collection<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/ee787088.aspx#background-garbage-collection)</ept> feature of the .NET garbage collector allows Generation 2 collections to be performed concurrently while your app is running and will only pause your app for short periods of time.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>But it is not always possible to do a Generation 2 collection as a background collection.</source>
          <target state="new">But it is not always possible to do a Generation 2 collection as a background collection.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>In that case, the pause can be user-perceivable if you have a large enough heap (more than 100MB).</source>
          <target state="new">In that case, the pause can be user-perceivable if you have a large enough heap (more than 100MB).</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Frequent garbage collections can contribute to increased CPU (and therefore power) consumption, longer loading times, or decreased frame rates in your application.</source>
          <target state="new">Frequent garbage collections can contribute to increased CPU (and therefore power) consumption, longer loading times, or decreased frame rates in your application.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Below are some techniques you can use to reduce garbage collection time and collection-related pauses in your managed UWP app.</source>
          <target state="new">Below are some techniques you can use to reduce garbage collection time and collection-related pauses in your managed UWP app.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Reduce memory allocations</source>
          <target state="new">Reduce memory allocations</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>If you don’t allocate any objects then the garbage collector doesn’t run unless there is a low memory condition in the system.</source>
          <target state="new">If you don’t allocate any objects then the garbage collector doesn’t run unless there is a low memory condition in the system.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Reducing the amount of memory you allocate directly translates to less frequent garbage collections.</source>
          <target state="new">Reducing the amount of memory you allocate directly translates to less frequent garbage collections.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If in some sections of your app pauses are completely undesirable, then you can pre-allocate the necessary objects beforehand during a less performance-critical time.</source>
          <target state="new">If in some sections of your app pauses are completely undesirable, then you can pre-allocate the necessary objects beforehand during a less performance-critical time.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>For example, a game might allocate all of the objects needed for gameplay during the loading screen of a level and not make any allocations during gameplay.</source>
          <target state="new">For example, a game might allocate all of the objects needed for gameplay during the loading screen of a level and not make any allocations during gameplay.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>This avoids pauses while the user is playing the game and can result in a higher and more consistent frame rate.</source>
          <target state="new">This avoids pauses while the user is playing the game and can result in a higher and more consistent frame rate.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Reduce generation 2 collections by avoiding objects with a medium-length lifetime</source>
          <target state="new">Reduce generation 2 collections by avoiding objects with a medium-length lifetime</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Generational garbage collections perform best when you have really short-lived and/or really long-lived objects in your app.</source>
          <target state="new">Generational garbage collections perform best when you have really short-lived and/or really long-lived objects in your app.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Short lived objects are collected in the cheaper generation 0 and generation 1 collections, and objects that are long-lived get promoted to generation 2, which is collected infrequently.</source>
          <target state="new">Short lived objects are collected in the cheaper generation 0 and generation 1 collections, and objects that are long-lived get promoted to generation 2, which is collected infrequently.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Long-lived objects are those that are in use for the entire duration of your app, or during a significant period of your app, such as during a specific page or game level.</source>
          <target state="new">Long-lived objects are those that are in use for the entire duration of your app, or during a significant period of your app, such as during a specific page or game level.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>If you frequently create objects that have a temporary lifetime but live long enough to be promoted to generation 2, then more of the expensive generation 2 collections happen.</source>
          <target state="new">If you frequently create objects that have a temporary lifetime but live long enough to be promoted to generation 2, then more of the expensive generation 2 collections happen.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>You may be able to reduce generation 2 collections by recycling existing objects or releasing objects more quickly.</source>
          <target state="new">You may be able to reduce generation 2 collections by recycling existing objects or releasing objects more quickly.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>A common example of objects with medium-term lifetime is objects that are used for displaying items in a list that a user scrolls through.</source>
          <target state="new">A common example of objects with medium-term lifetime is objects that are used for displaying items in a list that a user scrolls through.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If objects are created when items in the list are scrolled into view, and are no longer referenced as items in the list are scrolled out of view, then your app typically has a large number of generation 2 collections.</source>
          <target state="new">If objects are created when items in the list are scrolled into view, and are no longer referenced as items in the list are scrolled out of view, then your app typically has a large number of generation 2 collections.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In situations like this you can pre-allocate and reuse a set of objects for the data that is actively shown to the user, and use short-lived objects to load info as items in the list come into view.</source>
          <target state="new">In situations like this you can pre-allocate and reuse a set of objects for the data that is actively shown to the user, and use short-lived objects to load info as items in the list come into view.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Reduce generation 2 collections by avoiding large-sized objects with short lifetimes</source>
          <target state="new">Reduce generation 2 collections by avoiding large-sized objects with short lifetimes</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Any object that is 85KB or larger is allocated on the large object heap (LOH) and gets collected as part of generation 2.</source>
          <target state="new">Any object that is 85KB or larger is allocated on the large object heap (LOH) and gets collected as part of generation 2.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If you have temporary variables, such as buffers, that are greater than 85KB, then a generation 2 collection cleans them up.</source>
          <target state="new">If you have temporary variables, such as buffers, that are greater than 85KB, then a generation 2 collection cleans them up.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Limiting temporary variables to less than 85KB reduces the number of generation 2 collections in your app.</source>
          <target state="new">Limiting temporary variables to less than 85KB reduces the number of generation 2 collections in your app.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>One common technique is to create a buffer pool and reuse objects from the pool to avoid large temporary allocations.</source>
          <target state="new">One common technique is to create a buffer pool and reuse objects from the pool to avoid large temporary allocations.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Avoid reference-rich objects</source>
          <target state="new">Avoid reference-rich objects</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The garbage collector determines which objects are live by following references between objects, starting from roots in your app.</source>
          <target state="new">The garbage collector determines which objects are live by following references between objects, starting from roots in your app.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>For more info, see <bpt id="p1">[</bpt>What happens during a garbage collection<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/ee787088.aspx#what-happens-during-a-garbage-collection)</ept>.</source>
          <target state="new">For more info, see <bpt id="p1">[</bpt>What happens during a garbage collection<ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/ee787088.aspx#what-happens-during-a-garbage-collection)</ept>.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>If an object contains many references, then there is more work for the garbage collector to do.</source>
          <target state="new">If an object contains many references, then there is more work for the garbage collector to do.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>A common technique (especially with large objects) is to convert reference rich objects into objects with no references (e.g., instead of storing a reference, store an index).</source>
          <target state="new">A common technique (especially with large objects) is to convert reference rich objects into objects with no references (e.g., instead of storing a reference, store an index).</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Of course this technique works only when it is logically possible to do so.</source>
          <target state="new">Of course this technique works only when it is logically possible to do so.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Replacing object references with indexes can be a disruptive and complicated change to your app and is most effective for large objects with a large number of references.</source>
          <target state="new">Replacing object references with indexes can be a disruptive and complicated change to your app and is most effective for large objects with a large number of references.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Do this only if you are noticing large garbage collection times in your app related to reference-heavy objects.</source>
          <target state="new">Do this only if you are noticing large garbage collection times in your app related to reference-heavy objects.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>