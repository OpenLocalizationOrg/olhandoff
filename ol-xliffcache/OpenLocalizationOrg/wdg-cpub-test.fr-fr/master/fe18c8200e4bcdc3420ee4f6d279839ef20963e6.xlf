<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">fe18c8200e4bcdc3420ee4f6d279839ef20963e6</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\winrt-components\creating-windows-runtime-components-in-csharp-and-visual-basic.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Creating Windows Runtime Components in C# and Visual Basic</source>
          <target state="new">Creating Windows Runtime Components in C# and Visual Basic</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types, packaged in a Windows Runtime component.</source>
          <target state="new">Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types, packaged in a Windows Runtime component.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Creating Windows Runtime Components in C# and Visual Basic</source>
          <target state="new">Creating Windows Runtime Components in C# and Visual Basic</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>\[Some information relates to pre-released product which may be substantially modified before it's commercially released.</source>
          <target state="new">\[Some information relates to pre-released product which may be substantially modified before it's commercially released.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Microsoft makes no warranties, express or implied, with respect to the information provided here.\]</source>
          <target state="new">Microsoft makes no warranties, express or implied, with respect to the information provided here.\]</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types, packaged in a Windows Runtime component.</source>
          <target state="new">Starting with the .NET Framework 4.5, you can use managed code to create your own Windows Runtime types, packaged in a Windows Runtime component.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>You can use your component in Universal Windows Platform (UWP) apps with C++, JavaScript, Visual Basic, or C#.</source>
          <target state="new">You can use your component in Universal Windows Platform (UWP) apps with C++, JavaScript, Visual Basic, or C#.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>This article outlines the rules for creating a component, and discusses some aspects of .NET Framework support for the Windows Runtime.</source>
          <target state="new">This article outlines the rules for creating a component, and discusses some aspects of .NET Framework support for the Windows Runtime.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In general, that support is designed to be transparent to the .NET Framework programmer.</source>
          <target state="new">In general, that support is designed to be transparent to the .NET Framework programmer.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>However, when you create a component to use with JavaScript or C++, you need to be aware of differences in the way those languages support the Windows Runtime.</source>
          <target state="new">However, when you create a component to use with JavaScript or C++, you need to be aware of differences in the way those languages support the Windows Runtime.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>If you are creating a component for use only in UWP apps with Visual Basic or C#, and the component does not contain UWP controls, consider using the <bpt id="p1">**</bpt>Class Library<ept id="p1">**</ept> template instead of the <bpt id="p2">**</bpt>Windows Runtime Component<ept id="p2">**</ept> template.</source>
          <target state="new">If you are creating a component for use only in UWP apps with Visual Basic or C#, and the component does not contain UWP controls, consider using the <bpt id="p1">**</bpt>Class Library<ept id="p1">**</ept> template instead of the <bpt id="p2">**</bpt>Windows Runtime Component<ept id="p2">**</ept> template.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>There are fewer restrictions on a simple class library.</source>
          <target state="new">There are fewer restrictions on a simple class library.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This article contains the following sections:</source>
          <target state="new">This article contains the following sections:</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Declaring types in Windows Runtime Components</source>
          <target state="new">Declaring types in Windows Runtime Components</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Internally, the Windows Runtime types in your component can use any .NET Framework functionality that's allowed in a Universal Windows app.</source>
          <target state="new">Internally, the Windows Runtime types in your component can use any .NET Framework functionality that's allowed in a Universal Windows app.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">[</bpt>.NET for UWP apps<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx)</ept> overview for more information.) Externally, the members of your types can expose only Windows Runtime types for their parameters and return values.</source>
          <target state="new">(See <bpt id="p1">[</bpt>.NET for UWP apps<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/mt185501.aspx)</ept> overview for more information.) Externally, the members of your types can expose only Windows Runtime types for their parameters and return values.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The following list describes the limitations on .NET Framework types that are exposed from Windows Runtime Components.</source>
          <target state="new">The following list describes the limitations on .NET Framework types that are exposed from Windows Runtime Components.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The fields, parameters, and return values of all the public types and members in your component must be Windows Runtime types.</source>
          <target state="new">The fields, parameters, and return values of all the public types and members in your component must be Windows Runtime types.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>This restriction includes the Windows Runtime types that you create as well as types that are provided by the Windows Runtime itself.</source>
          <target state="new">This restriction includes the Windows Runtime types that you create as well as types that are provided by the Windows Runtime itself.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>It also includes a number of .NET Framework types.</source>
          <target state="new">It also includes a number of .NET Framework types.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>The inclusion of these types is part of the support the .NET Framework provides to enable the natural use of the Windows Runtime in managed code: Your code appears to use familiar .NET Framework types instead of the underlying Windows Runtime types.</source>
          <target state="new">The inclusion of these types is part of the support the .NET Framework provides to enable the natural use of the Windows Runtime in managed code: Your code appears to use familiar .NET Framework types instead of the underlying Windows Runtime types.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>For example, you can use .NET Framework primitive types such as Int32 and Double, certain fundamental types such as DateTimeOffset and Uri, and some commonly used generic interface types such as IEnumerable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> (IEnumerable(Of T) in Visual Basic) and IDictionary<ph id="ph3">&amp;lt;</ph>TKey,TValue<ph id="ph4">&amp;gt;</ph>.</source>
          <target state="new">For example, you can use .NET Framework primitive types such as Int32 and Double, certain fundamental types such as DateTimeOffset and Uri, and some commonly used generic interface types such as IEnumerable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> (IEnumerable(Of T) in Visual Basic) and IDictionary<ph id="ph3">&amp;lt;</ph>TKey,TValue<ph id="ph4">&amp;gt;</ph>.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>(Note that the type arguments of these generic types must be Windows Runtime types.) This is discussed in the sections Passing Windows Runtime types to managed code and Passing managed types to the Windows Runtime, later in this article.</source>
          <target state="new">(Note that the type arguments of these generic types must be Windows Runtime types.) This is discussed in the sections Passing Windows Runtime types to managed code and Passing managed types to the Windows Runtime, later in this article.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Public classes and interfaces can contain methods, properties, and events.</source>
          <target state="new">Public classes and interfaces can contain methods, properties, and events.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>You can declare delegates for your events, or use the EventHandler<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> delegate.</source>
          <target state="new">You can declare delegates for your events, or use the EventHandler<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> delegate.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>A public class or interface cannot:</source>
          <target state="new">A public class or interface cannot:</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Be generic.</source>
          <target state="new">Be generic.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Implement an interface that is not a Windows Runtime interface.</source>
          <target state="new">Implement an interface that is not a Windows Runtime interface.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>(However, you can create your own Windows Runtime interfaces and implement them.)</source>
          <target state="new">(However, you can create your own Windows Runtime interfaces and implement them.)</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Derive from types that are not in the Windows Runtime, such as System.Exception and System.EventArgs.</source>
          <target state="new">Derive from types that are not in the Windows Runtime, such as System.Exception and System.EventArgs.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>All public types must have a root namespace that matches the assembly name, and the assembly name must not begin with "Windows".</source>
          <target state="new">All public types must have a root namespace that matches the assembly name, and the assembly name must not begin with "Windows".</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>  By default, Visual Studio projects have namespace names that match the assembly name.</source>
          <target state="new"><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>  By default, Visual Studio projects have namespace names that match the assembly name.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>In Visual Basic, the Namespace statement for this default namespace is not shown in your code.</source>
          <target state="new">In Visual Basic, the Namespace statement for this default namespace is not shown in your code.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Public structures can't have any members other than public fields, and those fields must be value types or strings.</source>
          <target state="new">Public structures can't have any members other than public fields, and those fields must be value types or strings.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Public classes must be <bpt id="p1">**</bpt>sealed<ept id="p1">**</ept> (<bpt id="p2">**</bpt>NotInheritable<ept id="p2">**</ept> in Visual Basic).</source>
          <target state="new">Public classes must be <bpt id="p1">**</bpt>sealed<ept id="p1">**</ept> (<bpt id="p2">**</bpt>NotInheritable<ept id="p2">**</ept> in Visual Basic).</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>If your programming model requires polymorphism, you can create a public interface and implement that interface on the classes that must be polymorphic.</source>
          <target state="new">If your programming model requires polymorphism, you can create a public interface and implement that interface on the classes that must be polymorphic.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>Debugging your component</source>
          <target state="new">Debugging your component</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>If both your Universal Windows app and your component are built with managed code, you can debug them at the same time.</source>
          <target state="new">If both your Universal Windows app and your component are built with managed code, you can debug them at the same time.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>When you're testing your component as part of a Universal Windows app using C++, you can debug managed and native code at the same time.</source>
          <target state="new">When you're testing your component as part of a Universal Windows app using C++, you can debug managed and native code at the same time.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>The default is native code only.</source>
          <target state="new">The default is native code only.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>To debug both native C++ code and managed code</source>
          <target state="new">To debug both native C++ code and managed code</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Open the shortcut menu for your Visual C++ project, and choose <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept>.</source>
          <target state="new">Open the shortcut menu for your Visual C++ project, and choose <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>In the property pages, under <bpt id="p1">**</bpt>Configuration Properties<ept id="p1">**</ept>, choose <bpt id="p2">**</bpt>Debugging<ept id="p2">**</ept>.</source>
          <target state="new">In the property pages, under <bpt id="p1">**</bpt>Configuration Properties<ept id="p1">**</ept>, choose <bpt id="p2">**</bpt>Debugging<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Choose <bpt id="p1">**</bpt>Debugger Type<ept id="p1">**</ept>, and in the drop-down list box change <bpt id="p2">**</bpt>Native Only<ept id="p2">**</ept> to <bpt id="p3">**</bpt>Mixed (Managed and Native)<ept id="p3">**</ept>.</source>
          <target state="new">Choose <bpt id="p1">**</bpt>Debugger Type<ept id="p1">**</ept>, and in the drop-down list box change <bpt id="p2">**</bpt>Native Only<ept id="p2">**</ept> to <bpt id="p3">**</bpt>Mixed (Managed and Native)<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Choose <bpt id="p1">**</bpt>OK<ept id="p1">**</ept>.</source>
          <target state="new">Choose <bpt id="p1">**</bpt>OK<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Set breakpoints in native and managed code.</source>
          <target state="new">Set breakpoints in native and managed code.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>When you're testing your component as part of a Universal Windows app using JavaScript, by default the solution is in JavaScript debugging mode.</source>
          <target state="new">When you're testing your component as part of a Universal Windows app using JavaScript, by default the solution is in JavaScript debugging mode.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>In Visual Studio, you can't debug JavaScript and managed code at the same time.</source>
          <target state="new">In Visual Studio, you can't debug JavaScript and managed code at the same time.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>To debug managed code instead of JavaScript</source>
          <target state="new">To debug managed code instead of JavaScript</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Open the shortcut menu for your JavaScript project, and choose <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept>.</source>
          <target state="new">Open the shortcut menu for your JavaScript project, and choose <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In the property pages, under <bpt id="p1">**</bpt>Configuration Properties<ept id="p1">**</ept>, choose <bpt id="p2">**</bpt>Debugging<ept id="p2">**</ept>.</source>
          <target state="new">In the property pages, under <bpt id="p1">**</bpt>Configuration Properties<ept id="p1">**</ept>, choose <bpt id="p2">**</bpt>Debugging<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Choose <bpt id="p1">**</bpt>Debugger Type<ept id="p1">**</ept>, and in the drop-down list box change <bpt id="p2">**</bpt>Script Only<ept id="p2">**</ept> to <bpt id="p3">**</bpt>Managed Only<ept id="p3">**</ept>.</source>
          <target state="new">Choose <bpt id="p1">**</bpt>Debugger Type<ept id="p1">**</ept>, and in the drop-down list box change <bpt id="p2">**</bpt>Script Only<ept id="p2">**</ept> to <bpt id="p3">**</bpt>Managed Only<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Choose <bpt id="p1">**</bpt>OK<ept id="p1">**</ept>.</source>
          <target state="new">Choose <bpt id="p1">**</bpt>OK<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Set breakpoints in managed code and debug as usual.</source>
          <target state="new">Set breakpoints in managed code and debug as usual.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Passing Windows Runtime types to managed code</source>
          <target state="new">Passing Windows Runtime types to managed code</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>As mentioned previously in the section Declaring types in Windows Runtime Components, certain .NET Framework types can appear in the signatures of members of public classes.</source>
          <target state="new">As mentioned previously in the section Declaring types in Windows Runtime Components, certain .NET Framework types can appear in the signatures of members of public classes.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This is part of the support that the .NET Framework provides to enable the natural use of the Windows Runtime in managed code.</source>
          <target state="new">This is part of the support that the .NET Framework provides to enable the natural use of the Windows Runtime in managed code.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>It includes primitive types and some classes and interfaces.</source>
          <target state="new">It includes primitive types and some classes and interfaces.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>When your component is used from JavaScript or from C++ code, it's important to know how your .NET Framework types appear to the caller.</source>
          <target state="new">When your component is used from JavaScript or from C++ code, it's important to know how your .NET Framework types appear to the caller.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript<ept id="p1">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</ept> for examples with JavaScript.</source>
          <target state="new">See <bpt id="p1">[</bpt>Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript<ept id="p1">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</ept> for examples with JavaScript.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>This section discusses commonly used types.</source>
          <target state="new">This section discusses commonly used types.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In the .NET Framework, primitive types like the Int32 structure have many useful properties and methods, such as the TryParse method.</source>
          <target state="new">In the .NET Framework, primitive types like the Int32 structure have many useful properties and methods, such as the TryParse method.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>By contrast, primitive types and structures in the Windows Runtime only have fields.</source>
          <target state="new">By contrast, primitive types and structures in the Windows Runtime only have fields.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>When you pass these types to managed code, they appear to be .NET Framework types, and you can use the properties and methods of the .NET Framework types as you normally would.</source>
          <target state="new">When you pass these types to managed code, they appear to be .NET Framework types, and you can use the properties and methods of the .NET Framework types as you normally would.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The following list summarizes the substitutions that are made automatically in the IDE:</source>
          <target state="new">The following list summarizes the substitutions that are made automatically in the IDE:</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>For the Windows Runtime primitives Int32, Int64, Single, Double, Boolean, String (an immutable collection of Unicode characters), Enum, UInt32, UInt64, and Guid, use the type of the same name in the System namespace.</source>
          <target state="new">For the Windows Runtime primitives Int32, Int64, Single, Double, Boolean, String (an immutable collection of Unicode characters), Enum, UInt32, UInt64, and Guid, use the type of the same name in the System namespace.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>For UInt8, use System.Byte.</source>
          <target state="new">For UInt8, use System.Byte.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>For Char16, use System.Char.</source>
          <target state="new">For Char16, use System.Char.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For the IInspectable interface, use System.Object.</source>
          <target state="new">For the IInspectable interface, use System.Object.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>If C# or Visual Basic provides a language keyword for any of these types, you can use the language keyword instead.</source>
          <target state="new">If C# or Visual Basic provides a language keyword for any of these types, you can use the language keyword instead.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>In addition to primitive types, some basic, commonly used Windows Runtime types appear in managed code as their .NET Framework equivalents.</source>
          <target state="new">In addition to primitive types, some basic, commonly used Windows Runtime types appear in managed code as their .NET Framework equivalents.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>For example, suppose your JavaScript code uses the Windows.Foundation.Uri class, and you want to pass it to a C# or Visual Basic method.</source>
          <target state="new">For example, suppose your JavaScript code uses the Windows.Foundation.Uri class, and you want to pass it to a C# or Visual Basic method.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The equivalent type in managed code is the .NET Framework System.Uri class, and that's the type to use for the method parameter.</source>
          <target state="new">The equivalent type in managed code is the .NET Framework System.Uri class, and that's the type to use for the method parameter.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>You can tell when a Windows Runtime type appears as a .NET Framework type, because IntelliSense in Visual Studio hides the Windows Runtime type when you're writing managed code, and presents the equivalent .NET Framework type.</source>
          <target state="new">You can tell when a Windows Runtime type appears as a .NET Framework type, because IntelliSense in Visual Studio hides the Windows Runtime type when you're writing managed code, and presents the equivalent .NET Framework type.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>(Usually the two types have the same name.</source>
          <target state="new">(Usually the two types have the same name.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>However, note that the Windows.Foundation.DateTime structure appears in managed code as System.DateTimeOffset and not as System.DateTime.)</source>
          <target state="new">However, note that the Windows.Foundation.DateTime structure appears in managed code as System.DateTimeOffset and not as System.DateTime.)</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>For some commonly used collection types, the mapping is between the interfaces that are implemented by a Windows Runtime type and the interfaces that are implemented by the corresponding .NET Framework type.</source>
          <target state="new">For some commonly used collection types, the mapping is between the interfaces that are implemented by a Windows Runtime type and the interfaces that are implemented by the corresponding .NET Framework type.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>As with the types mentioned above, you declare parameter types by using the .NET Framework type.</source>
          <target state="new">As with the types mentioned above, you declare parameter types by using the .NET Framework type.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>This hides some differences between the types and makes writing .NET Framework code more natural.</source>
          <target state="new">This hides some differences between the types and makes writing .NET Framework code more natural.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The following table lists the most common of these generic interface types, along with other common class and interface mappings.</source>
          <target state="new">The following table lists the most common of these generic interface types, along with other common class and interface mappings.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>For a complete list of Windows Runtime types that the .NET Framework maps, see .NET Framework mappings of Windows Runtime types.</source>
          <target state="new">For a complete list of Windows Runtime types that the .NET Framework maps, see .NET Framework mappings of Windows Runtime types.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Windows Runtime</source>
          <target state="new">Windows Runtime</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>.NET Framework</source>
          <target state="new">.NET Framework</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>IIterable<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">IIterable<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>IEnumerable<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">IEnumerable<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>IVector<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">IVector<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>IList<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">IList<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>IVectorView<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">IVectorView<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>IReadOnlyList<ph id="ph1">&amp;lt;</ph>T</source>
          <target state="new">IReadOnlyList<ph id="ph1">&amp;lt;</ph>T</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>IMap<ph id="ph1">&amp;lt;</ph>K, V</source>
          <target state="new">IMap<ph id="ph1">&amp;lt;</ph>K, V</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>IDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue</source>
          <target state="new">IDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>IMapView<ph id="ph1">&amp;lt;</ph>K, V</source>
          <target state="new">IMapView<ph id="ph1">&amp;lt;</ph>K, V</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>IReadOnlyDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue</source>
          <target state="new">IReadOnlyDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>IKeyValuePair<ph id="ph1">&amp;lt;</ph>K, V</source>
          <target state="new">IKeyValuePair<ph id="ph1">&amp;lt;</ph>K, V</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>KeyValuePair<ph id="ph1">&amp;lt;</ph>TKey, TValue</source>
          <target state="new">KeyValuePair<ph id="ph1">&amp;lt;</ph>TKey, TValue</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>IBindableIterable</source>
          <target state="new">IBindableIterable</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>IEnumerable</source>
          <target state="new">IEnumerable</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>IBindableVector</source>
          <target state="new">IBindableVector</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>IList</source>
          <target state="new">IList</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Windows.UI.Xaml.Data.INotifyPropertyChanged</source>
          <target state="new">Windows.UI.Xaml.Data.INotifyPropertyChanged</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>System.ComponentModel.INotifyPropertyChanged</source>
          <target state="new">System.ComponentModel.INotifyPropertyChanged</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Windows.UI.Xaml.Data.PropertyChangedEventHandler</source>
          <target state="new">Windows.UI.Xaml.Data.PropertyChangedEventHandler</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>System.ComponentModel.PropertyChangedEventHandler</source>
          <target state="new">System.ComponentModel.PropertyChangedEventHandler</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>Windows.UI.Xaml.Data.PropertyChangedEventArgs</source>
          <target state="new">Windows.UI.Xaml.Data.PropertyChangedEventArgs</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>System.ComponentModel.PropertyChangedEventArgs</source>
          <target state="new">System.ComponentModel.PropertyChangedEventArgs</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>When a type implements more than one interface, you can use any of the interfaces it implements as a parameter type or return type of a member.</source>
          <target state="new">When a type implements more than one interface, you can use any of the interfaces it implements as a parameter type or return type of a member.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>For example, you can pass or return a Dictionary<ph id="ph1">&amp;lt;</ph>int, string<ph id="ph2">&amp;gt;</ph> (Dictionary(Of Integer, String) in Visual Basic) as IDictionary<ph id="ph3">&amp;lt;</ph>int, string<ph id="ph4">&amp;gt;</ph>, IReadOnlyDictionary<ph id="ph5">&amp;lt;</ph>int, string<ph id="ph6">&amp;gt;</ph>, or IEnumerable<ph id="ph7">&amp;lt;</ph>System.Collections.Generic.KeyValuePair<ph id="ph8">&amp;lt;</ph>TKey, TValue<ph id="ph9">&amp;gt;&amp;gt;</ph>.</source>
          <target state="new">For example, you can pass or return a Dictionary<ph id="ph1">&amp;lt;</ph>int, string<ph id="ph2">&amp;gt;</ph> (Dictionary(Of Integer, String) in Visual Basic) as IDictionary<ph id="ph3">&amp;lt;</ph>int, string<ph id="ph4">&amp;gt;</ph>, IReadOnlyDictionary<ph id="ph5">&amp;lt;</ph>int, string<ph id="ph6">&amp;gt;</ph>, or IEnumerable<ph id="ph7">&amp;lt;</ph>System.Collections.Generic.KeyValuePair<ph id="ph8">&amp;lt;</ph>TKey, TValue<ph id="ph9">&amp;gt;&amp;gt;</ph>.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>  JavaScript uses the interface that appears first in the list of interfaces that a managed type implements.</source>
          <target state="new"><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>  JavaScript uses the interface that appears first in the list of interfaces that a managed type implements.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>For example, if you return Dictionary<ph id="ph1">&amp;lt;</ph>int, string<ph id="ph2">&amp;gt;</ph> to JavaScript code, it appears as IDictionary<ph id="ph3">&amp;lt;</ph>int, string<ph id="ph4">&amp;gt;</ph> no matter which interface you specify as the return type.</source>
          <target state="new">For example, if you return Dictionary<ph id="ph1">&amp;lt;</ph>int, string<ph id="ph2">&amp;gt;</ph> to JavaScript code, it appears as IDictionary<ph id="ph3">&amp;lt;</ph>int, string<ph id="ph4">&amp;gt;</ph> no matter which interface you specify as the return type.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>This means that if the first interface doesn't include a member that appears on later interfaces, that member isn't visible to JavaScript.</source>
          <target state="new">This means that if the first interface doesn't include a member that appears on later interfaces, that member isn't visible to JavaScript.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>In the Windows Runtime, IMap<ph id="ph1">&amp;lt;</ph>K, V<ph id="ph2">&amp;gt;</ph> and IMapView<ph id="ph3">&amp;lt;</ph>K, V<ph id="ph4">&amp;gt;</ph> are iterated by using IKeyValuePair.</source>
          <target state="new">In the Windows Runtime, IMap<ph id="ph1">&amp;lt;</ph>K, V<ph id="ph2">&amp;gt;</ph> and IMapView<ph id="ph3">&amp;lt;</ph>K, V<ph id="ph4">&amp;gt;</ph> are iterated by using IKeyValuePair.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>When you pass them to managed code, they appear as IDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph> and IReadOnlyDictionary<ph id="ph3">&amp;lt;</ph>TKey, TValue<ph id="ph4">&amp;gt;</ph>, so naturally you use System.Collections.Generic.KeyValuePair<ph id="ph5">&amp;lt;</ph>TKey, TValue<ph id="ph6">&amp;gt;</ph> to enumerate them.</source>
          <target state="new">When you pass them to managed code, they appear as IDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph> and IReadOnlyDictionary<ph id="ph3">&amp;lt;</ph>TKey, TValue<ph id="ph4">&amp;gt;</ph>, so naturally you use System.Collections.Generic.KeyValuePair<ph id="ph5">&amp;lt;</ph>TKey, TValue<ph id="ph6">&amp;gt;</ph> to enumerate them.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The way interfaces appear in managed code affects the way types that implement these interfaces appear.</source>
          <target state="new">The way interfaces appear in managed code affects the way types that implement these interfaces appear.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>For example, the PropertySet class implements IMap<ph id="ph1">&amp;lt;</ph>K, V<ph id="ph2">&amp;gt;</ph>, which appears in managed code as IDictionary<ph id="ph3">&amp;lt;</ph>TKey, TValue<ph id="ph4">&amp;gt;</ph>.</source>
          <target state="new">For example, the PropertySet class implements IMap<ph id="ph1">&amp;lt;</ph>K, V<ph id="ph2">&amp;gt;</ph>, which appears in managed code as IDictionary<ph id="ph3">&amp;lt;</ph>TKey, TValue<ph id="ph4">&amp;gt;</ph>.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>PropertySet appears as if it implemented IDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph> instead of IMap<ph id="ph3">&amp;lt;</ph>K, V<ph id="ph4">&amp;gt;</ph>, so in managed code it appears to have an Add method, which behaves like the Add method on .NET Framework dictionaries.</source>
          <target state="new">PropertySet appears as if it implemented IDictionary<ph id="ph1">&amp;lt;</ph>TKey, TValue<ph id="ph2">&amp;gt;</ph> instead of IMap<ph id="ph3">&amp;lt;</ph>K, V<ph id="ph4">&amp;gt;</ph>, so in managed code it appears to have an Add method, which behaves like the Add method on .NET Framework dictionaries.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>It doesn't appear to have an Insert method.</source>
          <target state="new">It doesn't appear to have an Insert method.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>You can see this example in the article <bpt id="p1">[</bpt>Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript<ept id="p1">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</ept>.</source>
          <target state="new">You can see this example in the article <bpt id="p1">[</bpt>Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript<ept id="p1">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Passing managed types to the Windows Runtime</source>
          <target state="new">Passing managed types to the Windows Runtime</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>As discussed in the previous section, some Windows Runtime types can appear as .NET Framework types in the signatures of your component's members, or in the signatures of Windows Runtime members when you use them in the IDE.</source>
          <target state="new">As discussed in the previous section, some Windows Runtime types can appear as .NET Framework types in the signatures of your component's members, or in the signatures of Windows Runtime members when you use them in the IDE.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>When you pass .NET Framework types to these members or use them as the return values of your component's members, they appear to the code on the other side as the corresponding Windows Runtime type.</source>
          <target state="new">When you pass .NET Framework types to these members or use them as the return values of your component's members, they appear to the code on the other side as the corresponding Windows Runtime type.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>For examples of the effects this can have when your component is called from JavaScript, see the "Returning managed types from your component" section in <bpt id="p1">[</bpt>Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript<ept id="p1">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</ept>.</source>
          <target state="new">For examples of the effects this can have when your component is called from JavaScript, see the "Returning managed types from your component" section in <bpt id="p1">[</bpt>Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript<ept id="p1">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>Overloaded methods</source>
          <target state="new">Overloaded methods</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>In the Windows Runtime, methods can be overloaded.</source>
          <target state="new">In the Windows Runtime, methods can be overloaded.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>However, if you declare multiple overloads with the same number of parameters, you must apply the <bpt id="p1">[</bpt>Windows.Foundation.Metadata.DefaultOverloadAttribute<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx)</ept> attribute to only one of those overloads.</source>
          <target state="new">However, if you declare multiple overloads with the same number of parameters, you must apply the <bpt id="p1">[</bpt>Windows.Foundation.Metadata.DefaultOverloadAttribute<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.defaultoverloadattribute.aspx)</ept> attribute to only one of those overloads.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>That overload is the only one you can call from JavaScript.</source>
          <target state="new">That overload is the only one you can call from JavaScript.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>For example, in the following code the overload that takes an <bpt id="p1">**</bpt>int<ept id="p1">**</ept> (<bpt id="p2">**</bpt>Integer<ept id="p2">**</ept> in Visual Basic) is the default overload.</source>
          <target state="new">For example, in the following code the overload that takes an <bpt id="p1">**</bpt>int<ept id="p1">**</ept> (<bpt id="p2">**</bpt>Integer<ept id="p2">**</ept> in Visual Basic) is the default overload.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Caution<ept id="p1">**</ept>  JavaScript allows you to pass any value to OverloadExample, and coerces the value to the type that is required by the parameter.</source>
          <target state="new"><bpt id="p1">**</bpt>Caution<ept id="p1">**</ept>  JavaScript allows you to pass any value to OverloadExample, and coerces the value to the type that is required by the parameter.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>You can call OverloadExample with "forty-two", "42", or 42.3, but all those values are passed to the default overload.</source>
          <target state="new">You can call OverloadExample with "forty-two", "42", or 42.3, but all those values are passed to the default overload.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The default overload in the previous example returns 0, 42, and 42 respectively.</source>
          <target state="new">The default overload in the previous example returns 0, 42, and 42 respectively.</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>You cannot apply the DefaultOverloadAttribute attribute to constructors.</source>
          <target state="new">You cannot apply the DefaultOverloadAttribute attribute to constructors.</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>All the constructors in a class must have different numbers of parameters.</source>
          <target state="new">All the constructors in a class must have different numbers of parameters.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Implementing IStringable</source>
          <target state="new">Implementing IStringable</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Starting with Windows 8.1, the Windows Runtime includes an IStringable interface whose single method, IStringable.ToString, provides basic formatting support comparable to that provided by Object.ToString.</source>
          <target state="new">Starting with Windows 8.1, the Windows Runtime includes an IStringable interface whose single method, IStringable.ToString, provides basic formatting support comparable to that provided by Object.ToString.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>If you do choose to implement IStringable in a public managed type that is exported in a Windows Runtime component, the following restrictions apply:</source>
          <target state="new">If you do choose to implement IStringable in a public managed type that is exported in a Windows Runtime component, the following restrictions apply:</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>You can define the IStringable interface only in a "class implements" relationship, such as the following code in C#:</source>
          <target state="new">You can define the IStringable interface only in a "class implements" relationship, such as the following code in C#:</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Or the following Visual Basic code:</source>
          <target state="new">Or the following Visual Basic code:</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>You cannot implement IStringable on an interface.</source>
          <target state="new">You cannot implement IStringable on an interface.</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>You cannot declare a parameter to be of type IStringable.</source>
          <target state="new">You cannot declare a parameter to be of type IStringable.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>IStringable cannot be the return type of a method, property, or field.</source>
          <target state="new">IStringable cannot be the return type of a method, property, or field.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>You cannot hide your IStringable implementation from base classes by using a method definition such as the following:</source>
          <target state="new">You cannot hide your IStringable implementation from base classes by using a method definition such as the following:</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Instead, the IStringable.ToString implementation must always override the base class implementation.</source>
          <target state="new">Instead, the IStringable.ToString implementation must always override the base class implementation.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>You can hide a ToString implementation only by invoking it on a strongly typed class instance.</source>
          <target state="new">You can hide a ToString implementation only by invoking it on a strongly typed class instance.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Note that under a variety of conditions, calls from native code to a managed type that implements IStringable or hides its ToString implementation can produce unexpected behavior.</source>
          <target state="new">Note that under a variety of conditions, calls from native code to a managed type that implements IStringable or hides its ToString implementation can produce unexpected behavior.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>Asynchronous operations</source>
          <target state="new">Asynchronous operations</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>To implement an asynchronous method in your component, add "Async" to the end of the method name and return one of the Windows Runtime interfaces that represent asynchronous actions or operations: IAsyncAction, IAsyncActionWithProgress<ph id="ph1">&amp;lt;</ph>TProgress<ph id="ph2">&amp;gt;</ph>, IAsyncOperation<ph id="ph3">&amp;lt;</ph>TResult<ph id="ph4">&amp;gt;</ph>, or IAsyncOperationWithProgress<ph id="ph5">&amp;lt;</ph>TResult, TProgress<ph id="ph6">&amp;gt;</ph>.</source>
          <target state="new">To implement an asynchronous method in your component, add "Async" to the end of the method name and return one of the Windows Runtime interfaces that represent asynchronous actions or operations: IAsyncAction, IAsyncActionWithProgress<ph id="ph1">&amp;lt;</ph>TProgress<ph id="ph2">&amp;gt;</ph>, IAsyncOperation<ph id="ph3">&amp;lt;</ph>TResult<ph id="ph4">&amp;gt;</ph>, or IAsyncOperationWithProgress<ph id="ph5">&amp;lt;</ph>TResult, TProgress<ph id="ph6">&amp;gt;</ph>.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>You can use .NET Framework tasks (the <bpt id="p1">[</bpt>Task<ept id="p1">](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx)</ept> class and generic <bpt id="p2">[</bpt>Task<ph id="ph1">&amp;lt;</ph>TResult<ph id="ph2">&amp;gt;</ph><ept id="p2">](https://msdn.microsoft.com/library/dd321424.aspx)</ept> class) to implement your asynchronous method.</source>
          <target state="new">You can use .NET Framework tasks (the <bpt id="p1">[</bpt>Task<ept id="p1">](https://msdn.microsoft.com/library/system.threading.tasks.task.aspx)</ept> class and generic <bpt id="p2">[</bpt>Task<ph id="ph1">&amp;lt;</ph>TResult<ph id="ph2">&amp;gt;</ph><ept id="p2">](https://msdn.microsoft.com/library/dd321424.aspx)</ept> class) to implement your asynchronous method.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>You must return a task that represents an ongoing operation, such as a task that is returned from an asynchronous method written in C# or Visual Basic, or a task that is returned from the <bpt id="p1">[</bpt>Task.Run<ept id="p1">](https://msdn.microsoft.com/library/system.threading.tasks.task.run.aspx)</ept> method.</source>
          <target state="new">You must return a task that represents an ongoing operation, such as a task that is returned from an asynchronous method written in C# or Visual Basic, or a task that is returned from the <bpt id="p1">[</bpt>Task.Run<ept id="p1">](https://msdn.microsoft.com/library/system.threading.tasks.task.run.aspx)</ept> method.</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>If you use a constructor to create the task, you must call its <bpt id="p1">[</bpt>Task.Start<ept id="p1">](https://msdn.microsoft.com/library/system.threading.tasks.task.start.aspx)</ept> method before returning it.</source>
          <target state="new">If you use a constructor to create the task, you must call its <bpt id="p1">[</bpt>Task.Start<ept id="p1">](https://msdn.microsoft.com/library/system.threading.tasks.task.start.aspx)</ept> method before returning it.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>A method that uses await (Await in Visual Basic) requires the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> keyword (<bpt id="p2">**</bpt>Async<ept id="p2">**</ept> in Visual Basic).</source>
          <target state="new">A method that uses await (Await in Visual Basic) requires the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> keyword (<bpt id="p2">**</bpt>Async<ept id="p2">**</ept> in Visual Basic).</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>If you expose such a method from a Windows Runtime component, apply the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> keyword to the delegate that you pass to the Run method.</source>
          <target state="new">If you expose such a method from a Windows Runtime component, apply the <bpt id="p1">**</bpt>async<ept id="p1">**</ept> keyword to the delegate that you pass to the Run method.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>For asynchronous actions and operations that do not support cancellation or progress reporting, you can use the <bpt id="p1">[</bpt>WindowsRuntimeSystemExtensions.AsAsyncAction<ept id="p1">](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx)</ept> or <bpt id="p2">[</bpt>AsAsyncOperation<ph id="ph1">&amp;lt;</ph>TResult<ph id="ph2">&amp;gt;</ph><ept id="p2">](https://msdn.microsoft.com/library/hh779745.aspx)</ept> extension method to wrap the task in the appropriate interface.</source>
          <target state="new">For asynchronous actions and operations that do not support cancellation or progress reporting, you can use the <bpt id="p1">[</bpt>WindowsRuntimeSystemExtensions.AsAsyncAction<ept id="p1">](https://msdn.microsoft.com/library/system.windowsruntimesystemextensions.asasyncaction.aspx)</ept> or <bpt id="p2">[</bpt>AsAsyncOperation<ph id="ph1">&amp;lt;</ph>TResult<ph id="ph2">&amp;gt;</ph><ept id="p2">](https://msdn.microsoft.com/library/hh779745.aspx)</ept> extension method to wrap the task in the appropriate interface.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>For example, the following code implements an asynchronous method by using the Task.Run<ph id="ph1">&amp;lt;</ph>TResult<ph id="ph2">&amp;gt;</ph> method to start a task.</source>
          <target state="new">For example, the following code implements an asynchronous method by using the Task.Run<ph id="ph1">&amp;lt;</ph>TResult<ph id="ph2">&amp;gt;</ph> method to start a task.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The AsAsyncOperation<ph id="ph1">&amp;lt;</ph>TResult<ph id="ph2">&amp;gt;</ph> extension method returns the task as a Windows Runtime asynchronous operation.</source>
          <target state="new">The AsAsyncOperation<ph id="ph1">&amp;lt;</ph>TResult<ph id="ph2">&amp;gt;</ph> extension method returns the task as a Windows Runtime asynchronous operation.</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>The following JavaScript code shows how the method could be called by using a <bpt id="p1">[</bpt>WinJS.Promise<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br211867.aspx)</ept> object.</source>
          <target state="new">The following JavaScript code shows how the method could be called by using a <bpt id="p1">[</bpt>WinJS.Promise<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br211867.aspx)</ept> object.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>The function that is passed to the then method is executed when the asynchronous call completes.</source>
          <target state="new">The function that is passed to the then method is executed when the asynchronous call completes.</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The stringList parameter contains the list of strings that is returned by the DownloadAsStringAsync method, and the function does whatever processing is required.</source>
          <target state="new">The stringList parameter contains the list of strings that is returned by the DownloadAsStringAsync method, and the function does whatever processing is required.</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>For asynchronous actions and operations that support cancellation or progress reporting, use the <bpt id="p1">[</bpt>AsyncInfo<ept id="p1">](https://msdn.microsoft.com/library/system.runtime.interopservices.windowsruntime.asyncinfo.aspx)</ept> class to generate a started task and to hook up the cancellation and progress reporting features of the task with the cancellation and progress reporting features of the appropriate Windows Runtime interface.</source>
          <target state="new">For asynchronous actions and operations that support cancellation or progress reporting, use the <bpt id="p1">[</bpt>AsyncInfo<ept id="p1">](https://msdn.microsoft.com/library/system.runtime.interopservices.windowsruntime.asyncinfo.aspx)</ept> class to generate a started task and to hook up the cancellation and progress reporting features of the task with the cancellation and progress reporting features of the appropriate Windows Runtime interface.</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>For an example that supports both cancellation and progress reporting, see <bpt id="p1">[</bpt>Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript<ept id="p1">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</ept>.</source>
          <target state="new">For an example that supports both cancellation and progress reporting, see <bpt id="p1">[</bpt>Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript<ept id="p1">](walkthrough-creating-a-simple-windows-runtime-component-and-calling-it-from-javascript.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Note that you can use the methods of the AsyncInfo class even if your asynchronous method doesn't support cancellation or progress reporting.</source>
          <target state="new">Note that you can use the methods of the AsyncInfo class even if your asynchronous method doesn't support cancellation or progress reporting.</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>If you use a Visual Basic lambda function or a C# anonymous method, don't supply parameters for the token and <bpt id="p1">[</bpt>IProgress<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/hh138298.aspx)</ept> interface.</source>
          <target state="new">If you use a Visual Basic lambda function or a C# anonymous method, don't supply parameters for the token and <bpt id="p1">[</bpt>IProgress<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/hh138298.aspx)</ept> interface.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>If you use a C# lambda function, supply a token parameter but ignore it.</source>
          <target state="new">If you use a C# lambda function, supply a token parameter but ignore it.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The previous example, which used the AsAsyncOperation<ph id="ph1">&amp;lt;</ph>TResult<ph id="ph2">&amp;gt;</ph> method, looks like this when you use the <bpt id="p1">[</bpt>AsyncInfo.Run<ph id="ph3">&amp;lt;</ph>TResult<ph id="ph4">&amp;gt;</ph>(Func<ph id="ph5">&amp;lt;</ph>CancellationToken, Task<ph id="ph6">&amp;lt;</ph>TResult<ph id="ph7">&amp;gt;&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/hh779740.aspx)</ept>) method overload instead:</source>
          <target state="new">The previous example, which used the AsAsyncOperation<ph id="ph1">&amp;lt;</ph>TResult<ph id="ph2">&amp;gt;</ph> method, looks like this when you use the <bpt id="p1">[</bpt>AsyncInfo.Run<ph id="ph3">&amp;lt;</ph>TResult<ph id="ph4">&amp;gt;</ph>(Func<ph id="ph5">&amp;lt;</ph>CancellationToken, Task<ph id="ph6">&amp;lt;</ph>TResult<ph id="ph7">&amp;gt;&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/hh779740.aspx)</ept>) method overload instead:</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>If you create an asynchronous method that optionally supports cancellation or progress reporting, consider adding overloads that don't have parameters for a cancellation token or the IProgress<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> interface.</source>
          <target state="new">If you create an asynchronous method that optionally supports cancellation or progress reporting, consider adding overloads that don't have parameters for a cancellation token or the IProgress<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> interface.</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>Throwing exceptions</source>
          <target state="new">Throwing exceptions</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>You can throw any exception type that is included in the .NET for Windows apps.</source>
          <target state="new">You can throw any exception type that is included in the .NET for Windows apps.</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>You can't declare your own public exception types in a Windows Runtime component, but you can declare and throw non-public types.</source>
          <target state="new">You can't declare your own public exception types in a Windows Runtime component, but you can declare and throw non-public types.</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>If your component doesn't handle the exception, a corresponding exception is raised in the code that called your component.</source>
          <target state="new">If your component doesn't handle the exception, a corresponding exception is raised in the code that called your component.</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>The way the exception appears to the caller depends on the way the calling language supports the Windows Runtime.</source>
          <target state="new">The way the exception appears to the caller depends on the way the calling language supports the Windows Runtime.</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>In JavaScript, the exception appears as an object in which the exception message is replaced by a stack trace.</source>
          <target state="new">In JavaScript, the exception appears as an object in which the exception message is replaced by a stack trace.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>When you debug your app in Visual Studio, you can see the original message text displayed in the debugger exception dialog box, identified as "WinRT Information".</source>
          <target state="new">When you debug your app in Visual Studio, you can see the original message text displayed in the debugger exception dialog box, identified as "WinRT Information".</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>You can't access the original message text from JavaScript code.</source>
          <target state="new">You can't access the original message text from JavaScript code.</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>  Currently, the stack trace contains the managed exception type, but we don't recommend parsing the trace to identify the exception type.</source>
          <target state="new"><bpt id="p1">**</bpt>Tip<ept id="p1">**</ept>  Currently, the stack trace contains the managed exception type, but we don't recommend parsing the trace to identify the exception type.</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Instead, use an HRESULT value as described later in this section.</source>
          <target state="new">Instead, use an HRESULT value as described later in this section.</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>In C++, the exception appears as a platform exception.</source>
          <target state="new">In C++, the exception appears as a platform exception.</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>If the managed exception's HResult property can be mapped to the HRESULT of a specific platform exception, the specific exception is used; otherwise, a <bpt id="p1">[</bpt>Platform::COMException<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx)</ept> exception is thrown.</source>
          <target state="new">If the managed exception's HResult property can be mapped to the HRESULT of a specific platform exception, the specific exception is used; otherwise, a <bpt id="p1">[</bpt>Platform::COMException<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710414.aspx)</ept> exception is thrown.</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>The message text of the managed exception is not available to C++ code.</source>
          <target state="new">The message text of the managed exception is not available to C++ code.</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>If a specific platform exception was thrown, the default message text for that exception type appears; otherwise, no message text appears.</source>
          <target state="new">If a specific platform exception was thrown, the default message text for that exception type appears; otherwise, no message text appears.</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Exceptions (C++/CX)<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx)</ept>.</source>
          <target state="new">See <bpt id="p1">[</bpt>Exceptions (C++/CX)<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh699896.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>In C# or Visual Basic, the exception is a normal managed exception.</source>
          <target state="new">In C# or Visual Basic, the exception is a normal managed exception.</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>When you throw an exception from your component, you can make it easier for a JavaScript or C++ caller to handle the exception by throwing a non-public exception type whose HResult property value is specific to your component.</source>
          <target state="new">When you throw an exception from your component, you can make it easier for a JavaScript or C++ caller to handle the exception by throwing a non-public exception type whose HResult property value is specific to your component.</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>The HRESULT is available to a JavaScript caller through the exception object's number property, and to a C++ caller through the <bpt id="p1">[</bpt>COMException::HResult<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx)</ept> property.</source>
          <target state="new">The HRESULT is available to a JavaScript caller through the exception object's number property, and to a C++ caller through the <bpt id="p1">[</bpt>COMException::HResult<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710415.aspx)</ept> property.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Use a negative value for your HRESULT.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Use a negative value for your HRESULT.</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>A positive value is interpreted as success, and no exception is thrown in the JavaScript or C++ caller.</source>
          <target state="new">A positive value is interpreted as success, and no exception is thrown in the JavaScript or C++ caller.</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>Declaring and raising events</source>
          <target state="new">Declaring and raising events</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>When you declare a type to hold the data for your event, derive from Object instead of from EventArgs, because EventArgs is not a Windows Runtime type.</source>
          <target state="new">When you declare a type to hold the data for your event, derive from Object instead of from EventArgs, because EventArgs is not a Windows Runtime type.</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Use <bpt id="p1">[</bpt>EventHandler<ph id="ph1">&amp;lt;</ph>TEventArgs<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/db0etb8x.aspx)</ept> as the type of the event, and use your event argument type as the generic type argument.</source>
          <target state="new">Use <bpt id="p1">[</bpt>EventHandler<ph id="ph1">&amp;lt;</ph>TEventArgs<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/db0etb8x.aspx)</ept> as the type of the event, and use your event argument type as the generic type argument.</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Raise the event just as you would in a .NET Framework application.</source>
          <target state="new">Raise the event just as you would in a .NET Framework application.</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>When your Windows Runtime component is used from JavaScript or C++, the event follows the Windows Runtime event pattern that those languages expect.</source>
          <target state="new">When your Windows Runtime component is used from JavaScript or C++, the event follows the Windows Runtime event pattern that those languages expect.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>When you use the component from C# or Visual Basic, the event appears as an ordinary .NET Framework event.</source>
          <target state="new">When you use the component from C# or Visual Basic, the event appears as an ordinary .NET Framework event.</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>An example is provided in <bpt id="p1">[</bpt>Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript<ept id="p1">]()</ept>.</source>
          <target state="new">An example is provided in <bpt id="p1">[</bpt>Walkthrough: Creating a simple component in C# or Visual Basic and calling it from JavaScript<ept id="p1">]()</ept>.</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>If you implement custom event accessors (declare an event with the <bpt id="p1">**</bpt>Custom<ept id="p1">**</ept> keyword, in Visual Basic), you must follow the Windows Runtime event pattern in your implementation.</source>
          <target state="new">If you implement custom event accessors (declare an event with the <bpt id="p1">**</bpt>Custom<ept id="p1">**</ept> keyword, in Visual Basic), you must follow the Windows Runtime event pattern in your implementation.</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Custom events and event accessors in Windows Runtime Components<ept id="p1">](custom-events-and-event-accessors-in-windows-runtime-components.md)</ept>.</source>
          <target state="new">See <bpt id="p1">[</bpt>Custom events and event accessors in Windows Runtime Components<ept id="p1">](custom-events-and-event-accessors-in-windows-runtime-components.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Note that when you handle the event from C# or Visual Basic code, it still appears to be an ordinary .NET Framework event.</source>
          <target state="new">Note that when you handle the event from C# or Visual Basic code, it still appears to be an ordinary .NET Framework event.</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>After you’ve created a Windows Runtime component for your own use, you may find that the functionality it encapsulates is useful to other developers.</source>
          <target state="new">After you’ve created a Windows Runtime component for your own use, you may find that the functionality it encapsulates is useful to other developers.</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>You have two options for packaging a component for distribution to other developers.</source>
          <target state="new">You have two options for packaging a component for distribution to other developers.</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>See <bpt id="p1">[</bpt>Distributing a managed Windows Runtime component<ept id="p1">](https://msdn.microsoft.com/library/jj614475.aspx)</ept>.</source>
          <target state="new">See <bpt id="p1">[</bpt>Distributing a managed Windows Runtime component<ept id="p1">](https://msdn.microsoft.com/library/jj614475.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>For more information about Visual Basic and C# language features, and .NET Framework support for the Windows Runtime, see <bpt id="p1">[</bpt>Visual Basic and C# language reference<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx)</ept>.</source>
          <target state="new">For more information about Visual Basic and C# language features, and .NET Framework support for the Windows Runtime, see <bpt id="p1">[</bpt>Visual Basic and C# language reference<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/br212458.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>.NET for Windows Store Apps Overview</source>
          <target state="new">.NET for Windows Store Apps Overview</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>.NET for UWP apps</source>
          <target state="new">.NET for UWP apps</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</source>
          <target state="new">Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>