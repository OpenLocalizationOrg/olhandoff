<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-us" trgLang="de-de" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">7a6f02b929b55b11323fa326ee56b46379ea9b6c</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <group id="101">
        <unit id="101">
          <segment state="initial" id="101">
            <source xml:space="preserve">Optimize file access</source>
            <target xml:space="preserve">Optimize file access</target>
          </segment>
        </unit>
        <unit id="102">
          <segment state="initial" id="102">
            <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
            <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
          </segment>
        </unit>
        <unit id="103">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="103">
            <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</source>
            <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</target>
          </segment>
        </unit>
        <unit id="104">
          <segment state="initial" id="104">
            <source xml:space="preserve">Create Universal Windows Platform (UWP) apps that access the file system efficiently, avoiding performance issues due to disk latency and memory/CPU cycles.</source>
            <target xml:space="preserve">Create Universal Windows Platform (UWP) apps that access the file system efficiently, avoiding performance issues due to disk latency and memory/CPU cycles.</target>
          </segment>
        </unit>
        <unit id="105">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="105">
            <source xml:space="preserve">When you want to access a large collection of files and you want to access property values other than the typical Name, FileType, and Path properties, access them by creating <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**QueryOptions**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and calling <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**SetPropertyPrefetch**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">When you want to access a large collection of files and you want to access property values other than the typical Name, FileType, and Path properties, access them by creating <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**QueryOptions**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and calling <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**SetPropertyPrefetch**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="106">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="106">
            <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">SetPropertyPrefetch</pc> method can dramatically improve the performance of apps that display a collection of items obtained from the file system, such as a collection of images.</source>
            <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">SetPropertyPrefetch</pc> method can dramatically improve the performance of apps that display a collection of items obtained from the file system, such as a collection of images.</target>
          </segment>
        </unit>
        <unit id="107">
          <segment state="initial" id="107">
            <source xml:space="preserve">The next set of examples shows a few ways to access multiple files.</source>
            <target xml:space="preserve">The next set of examples shows a few ways to access multiple files.</target>
          </segment>
        </unit>
        <unit id="108">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="108">
            <source xml:space="preserve">The first example uses <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Windows.Storage.StorageFolder.GetFilesAsync**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> to retrieve the name info for a set of files.</source>
            <target xml:space="preserve">The first example uses <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Windows.Storage.StorageFolder.GetFilesAsync**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> to retrieve the name info for a set of files.</target>
          </segment>
        </unit>
        <unit id="109">
          <segment state="initial" id="109">
            <source xml:space="preserve">This approach provides good performance, because the example accesses only the name property.</source>
            <target xml:space="preserve">This approach provides good performance, because the example accesses only the name property.</target>
          </segment>
        </unit>
        <unit id="110">
          <segment state="initial" id="110">
            <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
            <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
          </segment>
        </unit>
        <unit id="111">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="111">
            <source xml:space="preserve">The second example uses <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Windows.Storage.StorageFolder.GetFilesAsync**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and then retrieves the image properties for each file.</source>
            <target xml:space="preserve">The second example uses <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Windows.Storage.StorageFolder.GetFilesAsync**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and then retrieves the image properties for each file.</target>
          </segment>
        </unit>
        <unit id="112">
          <segment state="initial" id="112">
            <source xml:space="preserve">This approach provides poor performance.</source>
            <target xml:space="preserve">This approach provides poor performance.</target>
          </segment>
        </unit>
        <unit id="113">
          <segment state="initial" id="113">
            <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
            <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
          </segment>
        </unit>
        <unit id="114">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="114">
            <source xml:space="preserve">The third example uses <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**QueryOptions**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> to get info about a set of files.</source>
            <target xml:space="preserve">The third example uses <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**QueryOptions**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> to get info about a set of files.</target>
          </segment>
        </unit>
        <unit id="115">
          <segment state="initial" id="115">
            <source xml:space="preserve">This approach provides much better performance than the previous example.</source>
            <target xml:space="preserve">This approach provides much better performance than the previous example.</target>
          </segment>
        </unit>
        <unit id="116">
          <segment state="initial" id="116">
            <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
            <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
          </segment>
        </unit>
        <unit id="117">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="117">
            <source xml:space="preserve">If you're performing multiple operations on Windows.Storage objects such as <pc dataRefEnd="id2" dataRefStart="id1" id="2">Windows.Storage.ApplicationData.Current.LocalFolder</pc>, create a local variable to reference that storage source so that you don't recreate intermediate objects each time you access it.</source>
            <target xml:space="preserve">If you're performing multiple operations on Windows.Storage objects such as <pc dataRefEnd="id2" dataRefStart="id1" id="2">Windows.Storage.ApplicationData.Current.LocalFolder</pc>, create a local variable to reference that storage source so that you don't recreate intermediate objects each time you access it.</target>
          </segment>
        </unit>
        <unit id="118">
          <segment state="initial" id="118">
            <source xml:space="preserve">Stream performance in C\# and Visual Basic</source>
            <target xml:space="preserve">Stream performance in C\# and Visual Basic</target>
          </segment>
        </unit>
        <unit id="119">
          <segment state="initial" id="119">
            <source xml:space="preserve">Buffering between UWP and .NET streams</source>
            <target xml:space="preserve">Buffering between UWP and .NET streams</target>
          </segment>
        </unit>
        <unit id="120">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="120">
            <source xml:space="preserve">There are many scenarios when you might want to convert a UWP stream (such as a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Windows.Storage.Streams.IInputStream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**IOutputStream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> to a .NET stream (<pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**System.IO.Stream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">There are many scenarios when you might want to convert a UWP stream (such as a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Windows.Storage.Streams.IInputStream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**IOutputStream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> to a .NET stream (<pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**System.IO.Stream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="121">
          <segment state="initial" id="121">
            <source xml:space="preserve">For example, this is useful when you are writing a UWP app and want to use existing .NET code that works on streams with the UWP file system.</source>
            <target xml:space="preserve">For example, this is useful when you are writing a UWP app and want to use existing .NET code that works on streams with the UWP file system.</target>
          </segment>
        </unit>
        <unit id="122">
          <segment state="initial" id="122">
            <source xml:space="preserve">In order to enable this, .NET APIs for Windows Store apps provides extension methods that allow you to convert between .NET and UWP stream types.</source>
            <target xml:space="preserve">In order to enable this, .NET APIs for Windows Store apps provides extension methods that allow you to convert between .NET and UWP stream types.</target>
          </segment>
        </unit>
        <unit id="123">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="123">
            <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**WindowsRuntimeStreamExtensions**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**WindowsRuntimeStreamExtensions**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="124">
          <segment state="initial" id="124">
            <source xml:space="preserve">When you convert a UWP stream to a .NET stream, you effectively create an adapter for the underlying UWP stream.</source>
            <target xml:space="preserve">When you convert a UWP stream to a .NET stream, you effectively create an adapter for the underlying UWP stream.</target>
          </segment>
        </unit>
        <unit id="125">
          <segment state="initial" id="125">
            <source xml:space="preserve">Under some circumstances, there is a runtime cost associated with invoking methods on UWP streams.</source>
            <target xml:space="preserve">Under some circumstances, there is a runtime cost associated with invoking methods on UWP streams.</target>
          </segment>
        </unit>
        <unit id="126">
          <segment state="initial" id="126">
            <source xml:space="preserve">This may affect the speed of your app, especially in scenarios where you perform many small, frequent read or write operations.</source>
            <target xml:space="preserve">This may affect the speed of your app, especially in scenarios where you perform many small, frequent read or write operations.</target>
          </segment>
        </unit>
        <unit id="127">
          <segment state="initial" id="127">
            <source xml:space="preserve">In order to speed up apps, the UWP stream adapters contain a data buffer.</source>
            <target xml:space="preserve">In order to speed up apps, the UWP stream adapters contain a data buffer.</target>
          </segment>
        </unit>
        <unit id="128">
          <segment state="initial" id="128">
            <source xml:space="preserve">The following code sample demonstrates small consecutive reads using a UWP stream adapter with a default buffer size.</source>
            <target xml:space="preserve">The following code sample demonstrates small consecutive reads using a UWP stream adapter with a default buffer size.</target>
          </segment>
        </unit>
        <unit id="129">
          <segment state="initial" id="129">
            <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
            <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
          </segment>
        </unit>
        <unit id="130">
          <segment state="initial" id="130">
            <source xml:space="preserve">This default buffering behavior is desirable in most scenarios where you convert a UWP stream to a .NET stream.</source>
            <target xml:space="preserve">This default buffering behavior is desirable in most scenarios where you convert a UWP stream to a .NET stream.</target>
          </segment>
        </unit>
        <unit id="131">
          <segment state="initial" id="131">
            <source xml:space="preserve">However, in some scenarios you may want to tweak the buffering behavior in order to increase performance.</source>
            <target xml:space="preserve">However, in some scenarios you may want to tweak the buffering behavior in order to increase performance.</target>
          </segment>
        </unit>
        <unit id="132">
          <segment state="initial" id="132">
            <source xml:space="preserve">Working with large data sets</source>
            <target xml:space="preserve">Working with large data sets</target>
          </segment>
        </unit>
        <unit id="133">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="133">
            <source xml:space="preserve">When reading or writing larger sets of data you may be able to increase your read or write throughput by providing a large buffer size to the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**AsStreamForRead**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**AsStreamForWrite**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, and <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**AsStream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> extension methods.</source>
            <target xml:space="preserve">When reading or writing larger sets of data you may be able to increase your read or write throughput by providing a large buffer size to the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**AsStreamForRead**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**AsStreamForWrite**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, and <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**AsStream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> extension methods.</target>
          </segment>
        </unit>
        <unit id="134">
          <segment state="initial" id="134">
            <source xml:space="preserve">This gives the stream adapter a larger internal buffer size.</source>
            <target xml:space="preserve">This gives the stream adapter a larger internal buffer size.</target>
          </segment>
        </unit>
        <unit id="135">
          <segment state="initial" id="135">
            <source xml:space="preserve">For instance, when passing a stream that comes from a large file to an XML parser, the parser can make many sequential small reads from the stream.</source>
            <target xml:space="preserve">For instance, when passing a stream that comes from a large file to an XML parser, the parser can make many sequential small reads from the stream.</target>
          </segment>
        </unit>
        <unit id="136">
          <segment state="initial" id="136">
            <source xml:space="preserve">A large buffer can reduce the number of calls to the underlying UWP stream and boost performance.</source>
            <target xml:space="preserve">A large buffer can reduce the number of calls to the underlying UWP stream and boost performance.</target>
          </segment>
        </unit>
        <unit id="137">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="137">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>   You should be careful when setting a buffer size that is larger than approximately 80 KB, as this may cause fragmentation on the garbage collector heap (see <pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId2">Improve garbage collection performance</pc><pc dataRefEnd="id6" dataRefStart="id5" id="3CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>   You should be careful when setting a buffer size that is larger than approximately 80 KB, as this may cause fragmentation on the garbage collector heap (see <pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId2">Improve garbage collection performance</pc><pc dataRefEnd="id6" dataRefStart="id5" id="3CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="138">
          <segment state="initial" id="138">
            <source xml:space="preserve">The following code example creates a managed stream adapter with an 81,920 byte buffer.</source>
            <target xml:space="preserve">The following code example creates a managed stream adapter with an 81,920 byte buffer.</target>
          </segment>
        </unit>
        <unit id="139">
          <segment state="initial" id="139">
            <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
            <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
          </segment>
        </unit>
        <unit id="140">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="140">
            <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Stream.CopyTo**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**CopyToAsync**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> methods also allocate a local buffer for copying between streams.</source>
            <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Stream.CopyTo**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**CopyToAsync**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> methods also allocate a local buffer for copying between streams.</target>
          </segment>
        </unit>
        <unit id="141">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="141">
            <source xml:space="preserve">As with the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**AsStreamForRead**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> extension method, you may be able to get better performance for large stream copies by overriding the default buffer size.</source>
            <target xml:space="preserve">As with the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**AsStreamForRead**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> extension method, you may be able to get better performance for large stream copies by overriding the default buffer size.</target>
          </segment>
        </unit>
        <unit id="142">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="142">
            <source xml:space="preserve">The following code example demonstrates changing the default buffer size of a <pc dataRefEnd="id2" dataRefStart="id1" id="2">CopyToAsync</pc> call.</source>
            <target xml:space="preserve">The following code example demonstrates changing the default buffer size of a <pc dataRefEnd="id2" dataRefStart="id1" id="2">CopyToAsync</pc> call.</target>
          </segment>
        </unit>
        <unit id="143">
          <segment state="initial" id="143">
            <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
            <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
          </segment>
        </unit>
        <unit id="144">
          <segment state="initial" id="144">
            <source xml:space="preserve">This example uses a buffer size of 1 MB, which is greater than the 80 KB previously recommended.</source>
            <target xml:space="preserve">This example uses a buffer size of 1 MB, which is greater than the 80 KB previously recommended.</target>
          </segment>
        </unit>
        <unit id="145">
          <segment state="initial" id="145">
            <source xml:space="preserve">Using such a large buffer can improve throughput of the copy operation for very large data sets (that is, several hundred megabytes).</source>
            <target xml:space="preserve">Using such a large buffer can improve throughput of the copy operation for very large data sets (that is, several hundred megabytes).</target>
          </segment>
        </unit>
        <unit id="146">
          <segment state="initial" id="146">
            <source xml:space="preserve">However, this buffer is allocated on the large object heap and could potentially degrade garbage collection performance.</source>
            <target xml:space="preserve">However, this buffer is allocated on the large object heap and could potentially degrade garbage collection performance.</target>
          </segment>
        </unit>
        <unit id="147">
          <segment state="initial" id="147">
            <source xml:space="preserve">You should only use large buffer sizes if it will noticeably improve the performance of your app.</source>
            <target xml:space="preserve">You should only use large buffer sizes if it will noticeably improve the performance of your app.</target>
          </segment>
        </unit>
        <unit id="148">
          <segment state="initial" id="148">
            <source xml:space="preserve">When you are working with a large number of streams simultaneously, you might want to reduce or eliminate the memory overhead of the buffer.</source>
            <target xml:space="preserve">When you are working with a large number of streams simultaneously, you might want to reduce or eliminate the memory overhead of the buffer.</target>
          </segment>
        </unit>
        <unit id="149">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="149">
            <source xml:space="preserve">You can specify a smaller buffer, or set the <pc dataRefEnd="id2" dataRefStart="id1" id="2">bufferSize</pc> parameter to 0 to turn off buffering entirely for that stream adapter.</source>
            <target xml:space="preserve">You can specify a smaller buffer, or set the <pc dataRefEnd="id2" dataRefStart="id1" id="2">bufferSize</pc> parameter to 0 to turn off buffering entirely for that stream adapter.</target>
          </segment>
        </unit>
        <unit id="150">
          <segment state="initial" id="150">
            <source xml:space="preserve">You can still achieve good throughput performance without buffering if you perform large reads and writes to the managed stream.</source>
            <target xml:space="preserve">You can still achieve good throughput performance without buffering if you perform large reads and writes to the managed stream.</target>
          </segment>
        </unit>
        <unit id="151">
          <segment state="initial" id="151">
            <source xml:space="preserve">Performing latency-sensitive operations</source>
            <target xml:space="preserve">Performing latency-sensitive operations</target>
          </segment>
        </unit>
        <unit id="152">
          <segment state="initial" id="152">
            <source xml:space="preserve">You might also want to avoid buffering if you want low-latency reads and writes and do not want to read in large blocks out of the underlying UWP stream.</source>
            <target xml:space="preserve">You might also want to avoid buffering if you want low-latency reads and writes and do not want to read in large blocks out of the underlying UWP stream.</target>
          </segment>
        </unit>
        <unit id="153">
          <segment state="initial" id="153">
            <source xml:space="preserve">For example, you might want low-latency reads and writes if you are using the stream for network communications.</source>
            <target xml:space="preserve">For example, you might want low-latency reads and writes if you are using the stream for network communications.</target>
          </segment>
        </unit>
        <unit id="154">
          <segment state="initial" id="154">
            <source xml:space="preserve">In a chat app you might use a stream over a network interface to send messages back in forth.</source>
            <target xml:space="preserve">In a chat app you might use a stream over a network interface to send messages back in forth.</target>
          </segment>
        </unit>
        <unit id="155">
          <segment state="initial" id="155">
            <source xml:space="preserve">In this case you want to send messages as soon as they are ready and not wait for the buffer to fill up.</source>
            <target xml:space="preserve">In this case you want to send messages as soon as they are ready and not wait for the buffer to fill up.</target>
          </segment>
        </unit>
        <unit id="156">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="156">
            <source xml:space="preserve">If you set the buffer size to 0 when calling the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**AsStreamForRead**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**AsStreamForWrite**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, and <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**AsStream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> extension methods, then the resulting adapter will not allocate a buffer, and all calls will manipulate the underlying UWP stream directly.</source>
            <target xml:space="preserve">If you set the buffer size to 0 when calling the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**AsStreamForRead**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**AsStreamForWrite**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, and <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**AsStream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> extension methods, then the resulting adapter will not allocate a buffer, and all calls will manipulate the underlying UWP stream directly.</target>
          </segment>
        </unit>
      </group>
    </group>
  </file>
</xliff>