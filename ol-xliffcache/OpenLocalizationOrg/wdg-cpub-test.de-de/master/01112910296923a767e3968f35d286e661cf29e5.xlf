<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-us" trgLang="de-de" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">01112910296923a767e3968f35d286e661cf29e5</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <group id="101">
        <unit id="101">
          <segment state="initial" id="101">
            <source xml:space="preserve">XAML and whitespace</source>
            <target xml:space="preserve">XAML and whitespace</target>
          </segment>
        </unit>
        <unit id="102">
          <segment state="initial" id="102">
            <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
            <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
          </segment>
        </unit>
        <unit id="103">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="103">
            <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</source>
            <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</target>
          </segment>
        </unit>
        <unit id="104">
          <segment state="initial" id="104">
            <source xml:space="preserve">Learn about the whitespace processing rules as used by XAML.</source>
            <target xml:space="preserve">Learn about the whitespace processing rules as used by XAML.</target>
          </segment>
        </unit>
        <unit id="105">
          <segment state="initial" id="105">
            <source xml:space="preserve">Whitespace processing</source>
            <target xml:space="preserve">Whitespace processing</target>
          </segment>
        </unit>
        <unit id="106">
          <segment state="initial" id="106">
            <source xml:space="preserve">Consistent with XML, whitespace characters in XAML are space, linefeed, and tab.</source>
            <target xml:space="preserve">Consistent with XML, whitespace characters in XAML are space, linefeed, and tab.</target>
          </segment>
        </unit>
        <unit id="107">
          <segment state="initial" id="107">
            <source xml:space="preserve">These correspond to the Unicode values 0020, 000A, and 0009 respectively.</source>
            <target xml:space="preserve">These correspond to the Unicode values 0020, 000A, and 0009 respectively.</target>
          </segment>
        </unit>
        <unit id="108">
          <segment state="initial" id="108">
            <source xml:space="preserve">By default this whitespace normalization occurs when a XAML processor encounters any inner text found between elements in a XAML file:</source>
            <target xml:space="preserve">By default this whitespace normalization occurs when a XAML processor encounters any inner text found between elements in a XAML file:</target>
          </segment>
        </unit>
        <unit id="109">
          <segment state="initial" id="109">
            <source xml:space="preserve">Linefeed characters between East Asian characters are removed.</source>
            <target xml:space="preserve">Linefeed characters between East Asian characters are removed.</target>
          </segment>
        </unit>
        <unit id="110">
          <segment state="initial" id="110">
            <source xml:space="preserve">All whitespace characters (space, linefeed, tab) are converted into spaces.</source>
            <target xml:space="preserve">All whitespace characters (space, linefeed, tab) are converted into spaces.</target>
          </segment>
        </unit>
        <unit id="111">
          <segment state="initial" id="111">
            <source xml:space="preserve">All consecutive spaces are deleted and replaced by one space.</source>
            <target xml:space="preserve">All consecutive spaces are deleted and replaced by one space.</target>
          </segment>
        </unit>
        <unit id="112">
          <segment state="initial" id="112">
            <source xml:space="preserve">A space immediately following the start tag is deleted.</source>
            <target xml:space="preserve">A space immediately following the start tag is deleted.</target>
          </segment>
        </unit>
        <unit id="113">
          <segment state="initial" id="113">
            <source xml:space="preserve">A space immediately before the end tag is deleted.</source>
            <target xml:space="preserve">A space immediately before the end tag is deleted.</target>
          </segment>
        </unit>
        <unit id="114">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="114">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">East Asian characters</pc> is defined as a set of Unicode character ranges U+20000 to U+2FFFD and U+30000 to U+3FFFD.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">East Asian characters</pc> is defined as a set of Unicode character ranges U+20000 to U+2FFFD and U+30000 to U+3FFFD.</target>
          </segment>
        </unit>
        <unit id="115">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="115">
            <source xml:space="preserve">This subset is also sometimes referred to as <pc dataRefEnd="id2" dataRefStart="id1" id="2">CJK ideographs</pc>.</source>
            <target xml:space="preserve">This subset is also sometimes referred to as <pc dataRefEnd="id2" dataRefStart="id1" id="2">CJK ideographs</pc>.</target>
          </segment>
        </unit>
        <unit id="116">
          <segment state="initial" id="116">
            <source xml:space="preserve">For more information, see http://www.unicode.org.</source>
            <target xml:space="preserve">For more information, see http://www.unicode.org.</target>
          </segment>
        </unit>
        <unit id="117">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="117">
            <source xml:space="preserve">"Default" corresponds to the state denoted by the default value of the <pc dataRefEnd="id2" dataRefStart="id1" id="2">xml:space</pc> attribute.</source>
            <target xml:space="preserve">"Default" corresponds to the state denoted by the default value of the <pc dataRefEnd="id2" dataRefStart="id1" id="2">xml:space</pc> attribute.</target>
          </segment>
        </unit>
        <unit id="118">
          <segment state="initial" id="118">
            <source xml:space="preserve">Whitespace in inner text, and string primitives</source>
            <target xml:space="preserve">Whitespace in inner text, and string primitives</target>
          </segment>
        </unit>
        <unit id="119">
          <segment state="initial" id="119">
            <source xml:space="preserve">The above normalization rules apply to inner text within XAML elements.</source>
            <target xml:space="preserve">The above normalization rules apply to inner text within XAML elements.</target>
          </segment>
        </unit>
        <unit id="120">
          <segment state="initial" id="120">
            <source xml:space="preserve">After normalization, a XAML processor converts any inner text into an appropriate type like this:</source>
            <target xml:space="preserve">After normalization, a XAML processor converts any inner text into an appropriate type like this:</target>
          </segment>
        </unit>
        <unit id="121">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="121">
            <source xml:space="preserve">If the type of the property is not a collection, but is not directly an <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc> type, the XAML processor tries to convert to that type using its type converter.</source>
            <target xml:space="preserve">If the type of the property is not a collection, but is not directly an <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc> type, the XAML processor tries to convert to that type using its type converter.</target>
          </segment>
        </unit>
        <unit id="122">
          <segment state="initial" id="122">
            <source xml:space="preserve">A failed conversion here results in a XAML parse error.</source>
            <target xml:space="preserve">A failed conversion here results in a XAML parse error.</target>
          </segment>
        </unit>
        <unit id="123">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="123">
            <source xml:space="preserve">If the type of the property is a collection, and the inner text is contiguous (no intervening element tags), the inner text is parsed as a single <pc dataRefEnd="id2" dataRefStart="id1" id="2">String</pc>.</source>
            <target xml:space="preserve">If the type of the property is a collection, and the inner text is contiguous (no intervening element tags), the inner text is parsed as a single <pc dataRefEnd="id2" dataRefStart="id1" id="2">String</pc>.</target>
          </segment>
        </unit>
        <unit id="124">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="124">
            <source xml:space="preserve">If the collection type cannot accept <pc dataRefEnd="id2" dataRefStart="id1" id="2">String</pc>, this also results in a XAML parser error.</source>
            <target xml:space="preserve">If the collection type cannot accept <pc dataRefEnd="id2" dataRefStart="id1" id="2">String</pc>, this also results in a XAML parser error.</target>
          </segment>
        </unit>
        <unit id="125">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="125">
            <source xml:space="preserve">If the type of the property is <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc>, then the inner text is parsed as a single <pc dataRefEnd="id4" dataRefStart="id3" id="4">String</pc>.</source>
            <target xml:space="preserve">If the type of the property is <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc>, then the inner text is parsed as a single <pc dataRefEnd="id4" dataRefStart="id3" id="4">String</pc>.</target>
          </segment>
        </unit>
        <unit id="126">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="126">
            <source xml:space="preserve">If there are intervening element tags, this results in a XAML parser error, because the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc> type implies a single object (<pc dataRefEnd="id4" dataRefStart="id3" id="4">String</pc> or otherwise).</source>
            <target xml:space="preserve">If there are intervening element tags, this results in a XAML parser error, because the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc> type implies a single object (<pc dataRefEnd="id4" dataRefStart="id3" id="4">String</pc> or otherwise).</target>
          </segment>
        </unit>
        <unit id="127">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="127">
            <source xml:space="preserve">If the type of the property is a collection, and the inner text is not contiguous, then the first substring is converted into a <pc dataRefEnd="id2" dataRefStart="id1" id="2">String</pc> and added as a collection item, the intervening element is added as a collection item, and finally the trailing substring (if any) is added to the collection as a third <pc dataRefEnd="id4" dataRefStart="id3" id="4">String</pc> item.</source>
            <target xml:space="preserve">If the type of the property is a collection, and the inner text is not contiguous, then the first substring is converted into a <pc dataRefEnd="id2" dataRefStart="id1" id="2">String</pc> and added as a collection item, the intervening element is added as a collection item, and finally the trailing substring (if any) is added to the collection as a third <pc dataRefEnd="id4" dataRefStart="id3" id="4">String</pc> item.</target>
          </segment>
        </unit>
        <unit id="128">
          <segment state="initial" id="128">
            <source xml:space="preserve">Whitespace and text content models</source>
            <target xml:space="preserve">Whitespace and text content models</target>
          </segment>
        </unit>
        <unit id="129">
          <segment state="initial" id="129">
            <source xml:space="preserve">In practice, preserving whitespace is of concern only for a subset of all possible content models.</source>
            <target xml:space="preserve">In practice, preserving whitespace is of concern only for a subset of all possible content models.</target>
          </segment>
        </unit>
        <unit id="130">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
            <data id="id5">&lt;strong&gt;</data>
            <data id="id6">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="130">
            <source xml:space="preserve">That subset is composed of content models that can take a singleton <pc dataRefEnd="id2" dataRefStart="id1" id="2">String</pc> type in some form, a dedicated <pc dataRefEnd="id4" dataRefStart="id3" id="4">String</pc> collection, or a mixture of <pc dataRefEnd="id6" dataRefStart="id5" id="6">String</pc> and other types in lists, collections, or dictionaries.</source>
            <target xml:space="preserve">That subset is composed of content models that can take a singleton <pc dataRefEnd="id2" dataRefStart="id1" id="2">String</pc> type in some form, a dedicated <pc dataRefEnd="id4" dataRefStart="id3" id="4">String</pc> collection, or a mixture of <pc dataRefEnd="id6" dataRefStart="id5" id="6">String</pc> and other types in lists, collections, or dictionaries.</target>
          </segment>
        </unit>
        <unit id="131">
          <segment state="initial" id="131">
            <source xml:space="preserve">Even for content models that can take strings, the default behavior within these content models is that any whitespace that remains is not treated as significant.</source>
            <target xml:space="preserve">Even for content models that can take strings, the default behavior within these content models is that any whitespace that remains is not treated as significant.</target>
          </segment>
        </unit>
        <unit id="132">
          <segment state="initial" id="132">
            <source xml:space="preserve">Preserving whitespace</source>
            <target xml:space="preserve">Preserving whitespace</target>
          </segment>
        </unit>
        <unit id="133">
          <segment state="initial" id="133">
            <source xml:space="preserve">Several techniques for preserving whitespace in the source XAML for eventual presentation are not affected by XAML processor whitespace normalization.</source>
            <target xml:space="preserve">Several techniques for preserving whitespace in the source XAML for eventual presentation are not affected by XAML processor whitespace normalization.</target>
          </segment>
        </unit>
        <unit id="134">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="134">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">xml:space="preserve"</pc>: Specify this attribute at the level of the element where whitespace needs to be preserved.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">xml:space="preserve"</pc>: Specify this attribute at the level of the element where whitespace needs to be preserved.</target>
          </segment>
        </unit>
        <unit id="135">
          <segment state="initial" id="135">
            <source xml:space="preserve">Note that this preserves all whitespace, including the spaces that might be added by code editors or design surfaces to align markup elements as a visually intuitive nesting.</source>
            <target xml:space="preserve">Note that this preserves all whitespace, including the spaces that might be added by code editors or design surfaces to align markup elements as a visually intuitive nesting.</target>
          </segment>
        </unit>
        <unit id="136">
          <segment state="initial" id="136">
            <source xml:space="preserve">Whether those spaces render is again a matter of the content model for the containing element.</source>
            <target xml:space="preserve">Whether those spaces render is again a matter of the content model for the containing element.</target>
          </segment>
        </unit>
        <unit id="137">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="137">
            <source xml:space="preserve">We don't recommend that you specify <pc dataRefEnd="id2" dataRefStart="id1" id="2">xml:space="preserve"</pc> at the root level, because the majority of object models don't consider whitespace as significant one way or another.</source>
            <target xml:space="preserve">We don't recommend that you specify <pc dataRefEnd="id2" dataRefStart="id1" id="2">xml:space="preserve"</pc> at the root level, because the majority of object models don't consider whitespace as significant one way or another.</target>
          </segment>
        </unit>
        <unit id="138">
          <segment state="initial" id="138">
            <source xml:space="preserve">It is a better practice to only set the attribute specifically at the level of elements that render whitespace within strings, or are whitespace significant collections.</source>
            <target xml:space="preserve">It is a better practice to only set the attribute specifically at the level of elements that render whitespace within strings, or are whitespace significant collections.</target>
          </segment>
        </unit>
        <unit id="139">
          <segment state="initial" id="139">
            <source xml:space="preserve">Entities and nonbreaking spaces: XAML supports placing any Unicode entity within a text object model.</source>
            <target xml:space="preserve">Entities and nonbreaking spaces: XAML supports placing any Unicode entity within a text object model.</target>
          </segment>
        </unit>
        <unit id="140">
          <segment state="initial" id="140">
            <source xml:space="preserve">You can use dedicated entities such as nonbreaking space (in UTF-8 encoding).</source>
            <target xml:space="preserve">You can use dedicated entities such as nonbreaking space (in UTF-8 encoding).</target>
          </segment>
        </unit>
        <unit id="141">
          <segment state="initial" id="141">
            <source xml:space="preserve">You can also use rich text controls that support nonbreaking space characters.</source>
            <target xml:space="preserve">You can also use rich text controls that support nonbreaking space characters.</target>
          </segment>
        </unit>
        <unit id="142">
          <segment state="initial" id="142">
            <source xml:space="preserve">Be cautious if you are using entities to simulate layout characteristics such as indents, because the run-time output of the entities vary based on a greater number of factors than would the general layout facilities, such as proper use of panels and margins.</source>
            <target xml:space="preserve">Be cautious if you are using entities to simulate layout characteristics such as indents, because the run-time output of the entities vary based on a greater number of factors than would the general layout facilities, such as proper use of panels and margins.</target>
          </segment>
        </unit>
      </group>
    </group>
  </file>
</xliff>