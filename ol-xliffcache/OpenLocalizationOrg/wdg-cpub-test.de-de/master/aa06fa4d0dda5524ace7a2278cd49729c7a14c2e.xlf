<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-us" trgLang="de-de" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">aa06fa4d0dda5524ace7a2278cd49729c7a14c2e</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <group id="101">
        <unit id="101">
          <segment state="initial" id="101">
            <source xml:space="preserve">Composition native DirectX and Direct2D interoperation with BeginDraw and EndDraw</source>
            <target xml:space="preserve">Composition native DirectX and Direct2D interoperation with BeginDraw and EndDraw</target>
          </segment>
        </unit>
        <unit id="102">
          <segment state="initial" id="102">
            <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
            <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
          </segment>
        </unit>
        <unit id="103">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="103">
            <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</source>
            <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</target>
          </segment>
        </unit>
        <unit id="104">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="104">
            <source xml:space="preserve">The Windows.UI.Composition API provides the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ICompositorInterop**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**ICompositionDrawingSurfaceInterop**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, and <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**ICompositionGraphicsDeviceInterop**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> native interoperation interfaces allowing content to be moved directly into the compositor.</source>
            <target xml:space="preserve">The Windows.UI.Composition API provides the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ICompositorInterop**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**ICompositionDrawingSurfaceInterop**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, and <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**ICompositionGraphicsDeviceInterop**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> native interoperation interfaces allowing content to be moved directly into the compositor.</target>
          </segment>
        </unit>
        <unit id="105">
          <segment state="initial" id="105">
            <source xml:space="preserve">Native interoperation is structured around surface objects that are backed by DirectX textures.</source>
            <target xml:space="preserve">Native interoperation is structured around surface objects that are backed by DirectX textures.</target>
          </segment>
        </unit>
        <unit id="106">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="106">
            <source xml:space="preserve">The surfaces are created from a factory object called <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CompositionGraphicsDevice**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">The surfaces are created from a factory object called <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CompositionGraphicsDevice**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="107">
          <segment state="initial" id="107">
            <source xml:space="preserve">This object is backed by an underlying Direct2D or Direct3D device object, which it uses to allocate video memory for surfaces.</source>
            <target xml:space="preserve">This object is backed by an underlying Direct2D or Direct3D device object, which it uses to allocate video memory for surfaces.</target>
          </segment>
        </unit>
        <unit id="108">
          <segment state="initial" id="108">
            <source xml:space="preserve">The composition API never creates the underlying DirectX device.</source>
            <target xml:space="preserve">The composition API never creates the underlying DirectX device.</target>
          </segment>
        </unit>
        <unit id="109">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="109">
            <source xml:space="preserve">It is the responsibility of the application to create one and pass it to the <pc dataRefEnd="id2" dataRefStart="id1" id="2">CompositionGraphicsDevice</pc> object.</source>
            <target xml:space="preserve">It is the responsibility of the application to create one and pass it to the <pc dataRefEnd="id2" dataRefStart="id1" id="2">CompositionGraphicsDevice</pc> object.</target>
          </segment>
        </unit>
        <unit id="110">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="110">
            <source xml:space="preserve">An application may create more than one <pc dataRefEnd="id2" dataRefStart="id1" id="2">CompositionGraphicsDevice</pc> object at a time, and it may use the same DirectX device as the rendering device for multiple <pc dataRefEnd="id4" dataRefStart="id3" id="4">CompositionGraphicsDevice</pc> objects.</source>
            <target xml:space="preserve">An application may create more than one <pc dataRefEnd="id2" dataRefStart="id1" id="2">CompositionGraphicsDevice</pc> object at a time, and it may use the same DirectX device as the rendering device for multiple <pc dataRefEnd="id4" dataRefStart="id3" id="4">CompositionGraphicsDevice</pc> objects.</target>
          </segment>
        </unit>
        <unit id="111">
          <segment state="initial" id="111">
            <source xml:space="preserve">Creating a surface</source>
            <target xml:space="preserve">Creating a surface</target>
          </segment>
        </unit>
        <unit id="112">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="112">
            <source xml:space="preserve">Each <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CompositionGraphicsDevice**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> serves as a surface factory.</source>
            <target xml:space="preserve">Each <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CompositionGraphicsDevice**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> serves as a surface factory.</target>
          </segment>
        </unit>
        <unit id="113">
          <segment state="initial" id="113">
            <source xml:space="preserve">Each surface is created with an initial size (which may be 0,0), but no valid pixels.</source>
            <target xml:space="preserve">Each surface is created with an initial size (which may be 0,0), but no valid pixels.</target>
          </segment>
        </unit>
        <unit id="114">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="114">
            <source xml:space="preserve">A surface in its initial state may be immediately consumed in a visual tree, for example, via a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CompositionSurfaceBrush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and a <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**SpriteVisual**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, but in its initial state the surface has no effect on screen output.</source>
            <target xml:space="preserve">A surface in its initial state may be immediately consumed in a visual tree, for example, via a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CompositionSurfaceBrush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and a <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**SpriteVisual**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, but in its initial state the surface has no effect on screen output.</target>
          </segment>
        </unit>
        <unit id="115">
          <segment state="initial" id="115">
            <source xml:space="preserve">It is, for all purposes, entirely transparent, even if the specified alpha mode is “opaque”.</source>
            <target xml:space="preserve">It is, for all purposes, entirely transparent, even if the specified alpha mode is “opaque”.</target>
          </segment>
        </unit>
        <unit id="116">
          <segment state="initial" id="116">
            <source xml:space="preserve">Occasionally, DirectX devices may be rendered unusable.</source>
            <target xml:space="preserve">Occasionally, DirectX devices may be rendered unusable.</target>
          </segment>
        </unit>
        <unit id="117">
          <segment state="initial" id="117">
            <source xml:space="preserve">This may happen, amongst other reasons, if the application passes invalid arguments to certain DirectX APIs, or if the graphics adapter is reset by the system, or if the driver is updated.</source>
            <target xml:space="preserve">This may happen, amongst other reasons, if the application passes invalid arguments to certain DirectX APIs, or if the graphics adapter is reset by the system, or if the driver is updated.</target>
          </segment>
        </unit>
        <unit id="118">
          <segment state="initial" id="118">
            <source xml:space="preserve">Direct3D has an API that an application may use to discover, asynchronously, if the device is lost for any reason.</source>
            <target xml:space="preserve">Direct3D has an API that an application may use to discover, asynchronously, if the device is lost for any reason.</target>
          </segment>
        </unit>
        <unit id="119">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="119">
            <source xml:space="preserve">When a DirectX device is lost, the application must discard it, create a new one, and pass it to any <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CompositionGraphicsDevice**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> objects previously associated with the bad DirectX device.</source>
            <target xml:space="preserve">When a DirectX device is lost, the application must discard it, create a new one, and pass it to any <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CompositionGraphicsDevice**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> objects previously associated with the bad DirectX device.</target>
          </segment>
        </unit>
        <unit id="120">
          <segment state="initial" id="120">
            <source xml:space="preserve">Loading pixels into a surface</source>
            <target xml:space="preserve">Loading pixels into a surface</target>
          </segment>
        </unit>
        <unit id="121">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="121">
            <source xml:space="preserve">To load pixels into the surface, the application must call the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**BeginDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method, which returns a DirectX interface representing a texture or Direct2D context, depending on what the application requests.</source>
            <target xml:space="preserve">To load pixels into the surface, the application must call the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**BeginDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method, which returns a DirectX interface representing a texture or Direct2D context, depending on what the application requests.</target>
          </segment>
        </unit>
        <unit id="122">
          <segment state="initial" id="122">
            <source xml:space="preserve">The application must then render or upload pixels into that texture.</source>
            <target xml:space="preserve">The application must then render or upload pixels into that texture.</target>
          </segment>
        </unit>
        <unit id="123">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="123">
            <source xml:space="preserve">When the application is done, it must call the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**EndDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method.</source>
            <target xml:space="preserve">When the application is done, it must call the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**EndDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method.</target>
          </segment>
        </unit>
        <unit id="124">
          <segment state="initial" id="124">
            <source xml:space="preserve">Only at that point are the new pixels available for composition, but they still don't show up on screen until the next time all changes to the visual tree are committed.</source>
            <target xml:space="preserve">Only at that point are the new pixels available for composition, but they still don't show up on screen until the next time all changes to the visual tree are committed.</target>
          </segment>
        </unit>
        <unit id="125">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="125">
            <source xml:space="preserve">If the visual tree is committed before <pc dataRefEnd="id2" dataRefStart="id1" id="2">EndDraw</pc> is called, then the update that is in progress is not visible on screen and the surface continues to display the contents it had prior to <pc dataRefEnd="id4" dataRefStart="id3" id="4">BeginDraw</pc>.</source>
            <target xml:space="preserve">If the visual tree is committed before <pc dataRefEnd="id2" dataRefStart="id1" id="2">EndDraw</pc> is called, then the update that is in progress is not visible on screen and the surface continues to display the contents it had prior to <pc dataRefEnd="id4" dataRefStart="id3" id="4">BeginDraw</pc>.</target>
          </segment>
        </unit>
        <unit id="126">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="126">
            <source xml:space="preserve">When <pc dataRefEnd="id2" dataRefStart="id1" id="2">EndDraw</pc> is called, the texture or Direct2D context pointer returned by BeginDraw is invalidated.</source>
            <target xml:space="preserve">When <pc dataRefEnd="id2" dataRefStart="id1" id="2">EndDraw</pc> is called, the texture or Direct2D context pointer returned by BeginDraw is invalidated.</target>
          </segment>
        </unit>
        <unit id="127">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="127">
            <source xml:space="preserve">An application should never cache that pointer beyond the <pc dataRefEnd="id2" dataRefStart="id1" id="2">EndDraw</pc> call.</source>
            <target xml:space="preserve">An application should never cache that pointer beyond the <pc dataRefEnd="id2" dataRefStart="id1" id="2">EndDraw</pc> call.</target>
          </segment>
        </unit>
        <unit id="128">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="128">
            <source xml:space="preserve">The application may only call BeginDraw on one surface at a time, for any given <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CompositionGraphicsDevice**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">The application may only call BeginDraw on one surface at a time, for any given <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CompositionGraphicsDevice**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="129">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;strong&gt;</data>
            <data id="id14">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="129">
            <source xml:space="preserve">After calling <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**BeginDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, the application must call <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**EndDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> on that surface before calling <pc dataRefEnd="id14" dataRefStart="id13" id="6">BeginDraw</pc> on another.</source>
            <target xml:space="preserve">After calling <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**BeginDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, the application must call <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**EndDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> on that surface before calling <pc dataRefEnd="id14" dataRefStart="id13" id="6">BeginDraw</pc> on another.</target>
          </segment>
        </unit>
        <unit id="130">
          <segment state="initial" id="130">
            <source xml:space="preserve">As the API is agile, the application is responsible for synchronizing these calls if it wishes to perform rendering from multiple worker threads.</source>
            <target xml:space="preserve">As the API is agile, the application is responsible for synchronizing these calls if it wishes to perform rendering from multiple worker threads.</target>
          </segment>
        </unit>
        <unit id="131">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="131">
            <source xml:space="preserve">If an application wants to interrupt rendering one surface and switch to another temporarily, the application may use the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**SuspendDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method.</source>
            <target xml:space="preserve">If an application wants to interrupt rendering one surface and switch to another temporarily, the application may use the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**SuspendDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method.</target>
          </segment>
        </unit>
        <unit id="132">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="132">
            <source xml:space="preserve">This allows another <pc dataRefEnd="id2" dataRefStart="id1" id="2">BeginDraw</pc> to succeed, but does not make the first surface update available for on-screen composition.</source>
            <target xml:space="preserve">This allows another <pc dataRefEnd="id2" dataRefStart="id1" id="2">BeginDraw</pc> to succeed, but does not make the first surface update available for on-screen composition.</target>
          </segment>
        </unit>
        <unit id="133">
          <segment state="initial" id="133">
            <source xml:space="preserve">This allows the application to perform multiple updates in a transactional manner.</source>
            <target xml:space="preserve">This allows the application to perform multiple updates in a transactional manner.</target>
          </segment>
        </unit>
        <unit id="134">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;strong&gt;</data>
            <data id="id8">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="134">
            <source xml:space="preserve">Once a surface is suspended, the application may continue the update by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ResumeDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method, or it may declare that the update is done by calling <pc dataRefEnd="id8" dataRefStart="id7" id="4">EndDraw</pc>.</source>
            <target xml:space="preserve">Once a surface is suspended, the application may continue the update by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ResumeDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method, or it may declare that the update is done by calling <pc dataRefEnd="id8" dataRefStart="id7" id="4">EndDraw</pc>.</target>
          </segment>
        </unit>
        <unit id="135">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="135">
            <source xml:space="preserve">This means only one surface can be actively updated at a time for any given <pc dataRefEnd="id2" dataRefStart="id1" id="2">CompositionGraphicsDevice</pc>.</source>
            <target xml:space="preserve">This means only one surface can be actively updated at a time for any given <pc dataRefEnd="id2" dataRefStart="id1" id="2">CompositionGraphicsDevice</pc>.</target>
          </segment>
        </unit>
        <unit id="136">
          <segment state="initial" id="136">
            <source xml:space="preserve">Each graphics device keeps this state independently of the others, so an application may render to two surfaces simultaneously if they belong to different graphics devices.</source>
            <target xml:space="preserve">Each graphics device keeps this state independently of the others, so an application may render to two surfaces simultaneously if they belong to different graphics devices.</target>
          </segment>
        </unit>
        <unit id="137">
          <segment state="initial" id="137">
            <source xml:space="preserve">However, this precludes the video memory for those two surfaces from being pooled together and, as such, is less memory efficient.</source>
            <target xml:space="preserve">However, this precludes the video memory for those two surfaces from being pooled together and, as such, is less memory efficient.</target>
          </segment>
        </unit>
        <unit id="138">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id19">&lt;link&gt;</data>
            <data id="id20">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id25">&lt;strong&gt;</data>
            <data id="id26">&lt;/strong&gt;</data>
            <data id="id27">&lt;strong&gt;</data>
            <data id="id28">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="138">
            <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**BeginDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**SuspendDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**ResumeDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> and <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**EndDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc> methods return failures if the application performs an incorrect operation (such as passing invalid arguments, or calling <pc dataRefEnd="id26" dataRefStart="id25" id="10">BeginDraw</pc> on a surface before calling <pc dataRefEnd="id28" dataRefStart="id27" id="12">EndDraw</pc> on another).</source>
            <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**BeginDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**SuspendDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**ResumeDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> and <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**EndDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc> methods return failures if the application performs an incorrect operation (such as passing invalid arguments, or calling <pc dataRefEnd="id26" dataRefStart="id25" id="10">BeginDraw</pc> on a surface before calling <pc dataRefEnd="id28" dataRefStart="id27" id="12">EndDraw</pc> on another).</target>
          </segment>
        </unit>
        <unit id="139">
          <segment state="initial" id="139">
            <source xml:space="preserve">These types of failures represent application bugs and, as such, the expectation is that they are handled with a fail fast.</source>
            <target xml:space="preserve">These types of failures represent application bugs and, as such, the expectation is that they are handled with a fail fast.</target>
          </segment>
        </unit>
        <unit id="140">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="140">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">BeginDraw</pc> may also return a failure if the underlying DirectX device is lost.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">BeginDraw</pc> may also return a failure if the underlying DirectX device is lost.</target>
          </segment>
        </unit>
        <unit id="141">
          <segment state="initial" id="141">
            <source xml:space="preserve">This failure is not fatal as the application can recreate its DirectX device and try again.</source>
            <target xml:space="preserve">This failure is not fatal as the application can recreate its DirectX device and try again.</target>
          </segment>
        </unit>
        <unit id="142">
          <segment state="initial" id="142">
            <source xml:space="preserve">As such, the application is expected to handle device loss by simply skipping rendering.</source>
            <target xml:space="preserve">As such, the application is expected to handle device loss by simply skipping rendering.</target>
          </segment>
        </unit>
        <unit id="143">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="143">
            <source xml:space="preserve">If <pc dataRefEnd="id2" dataRefStart="id1" id="2">BeginDraw</pc> fails for any reason, the application should also not call <pc dataRefEnd="id4" dataRefStart="id3" id="4">EndDraw</pc>, as the begin never succeeded in the first place.</source>
            <target xml:space="preserve">If <pc dataRefEnd="id2" dataRefStart="id1" id="2">BeginDraw</pc> fails for any reason, the application should also not call <pc dataRefEnd="id4" dataRefStart="id3" id="4">EndDraw</pc>, as the begin never succeeded in the first place.</target>
          </segment>
        </unit>
        <unit id="144">
          <segment state="initial" id="144">
            <source xml:space="preserve">Scrolling</source>
            <target xml:space="preserve">Scrolling</target>
          </segment>
        </unit>
        <unit id="145">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="145">
            <source xml:space="preserve">For performance reasons, when an application calls <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**BeginDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> the contents of the returned texture are not guaranteed to be the previous contents of the surface.</source>
            <target xml:space="preserve">For performance reasons, when an application calls <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**BeginDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> the contents of the returned texture are not guaranteed to be the previous contents of the surface.</target>
          </segment>
        </unit>
        <unit id="146">
          <segment state="initial" id="146">
            <source xml:space="preserve">The application must assume that the contents are random and, as such, the application must ensure that all pixels are touched, either by clearing the surface before rendering or by drawing enough opaque contents to cover the entire updated rectangle.</source>
            <target xml:space="preserve">The application must assume that the contents are random and, as such, the application must ensure that all pixels are touched, either by clearing the surface before rendering or by drawing enough opaque contents to cover the entire updated rectangle.</target>
          </segment>
        </unit>
        <unit id="147">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="147">
            <source xml:space="preserve">This, combined with the fact that the texture pointer is only valid between <pc dataRefEnd="id2" dataRefStart="id1" id="2">BeginDraw</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**EndDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> calls, makes it impossible for the application to copy previous contents out of the surface.</source>
            <target xml:space="preserve">This, combined with the fact that the texture pointer is only valid between <pc dataRefEnd="id2" dataRefStart="id1" id="2">BeginDraw</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**EndDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> calls, makes it impossible for the application to copy previous contents out of the surface.</target>
          </segment>
        </unit>
        <unit id="148">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="148">
            <source xml:space="preserve">For this reason, we offer a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Scroll**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method, which allows the application to perform a same-surface pixel copy.</source>
            <target xml:space="preserve">For this reason, we offer a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Scroll**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method, which allows the application to perform a same-surface pixel copy.</target>
          </segment>
        </unit>
        <unit id="149">
          <segment state="initial" id="149">
            <source xml:space="preserve">Usage Example</source>
            <target xml:space="preserve">Usage Example</target>
          </segment>
        </unit>
        <unit id="150">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="150">
            <source xml:space="preserve">The following sample illustrates a very simple scenario where an application creates drawing surfaces, and uses <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**BeginDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**EndDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> to populate the surfaces with text.</source>
            <target xml:space="preserve">The following sample illustrates a very simple scenario where an application creates drawing surfaces, and uses <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**BeginDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**EndDraw**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> to populate the surfaces with text.</target>
          </segment>
        </unit>
        <unit id="151">
          <segment state="initial" id="151">
            <source xml:space="preserve">The application uses DirectWrite to layout the text (details not shown) and then uses Direct2D to render it.</source>
            <target xml:space="preserve">The application uses DirectWrite to layout the text (details not shown) and then uses Direct2D to render it.</target>
          </segment>
        </unit>
        <unit id="152">
          <segment state="initial" id="152">
            <source xml:space="preserve">The composition graphics device accepts the Direct2D device directly at initialization time.</source>
            <target xml:space="preserve">The composition graphics device accepts the Direct2D device directly at initialization time.</target>
          </segment>
        </unit>
        <unit id="153">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="153">
            <source xml:space="preserve">This allows <pc dataRefEnd="id2" dataRefStart="id1" id="2">BeginDraw</pc> to return an ID2D1DeviceContext interface pointer, which is considerably more efficient than having the application create a Direct2D context to wrap a returned ID3D11Texture2D interface at each drawing operation.</source>
            <target xml:space="preserve">This allows <pc dataRefEnd="id2" dataRefStart="id1" id="2">BeginDraw</pc> to return an ID2D1DeviceContext interface pointer, which is considerably more efficient than having the application create a Direct2D context to wrap a returned ID3D11Texture2D interface at each drawing operation.</target>
          </segment>
        </unit>
      </group>
    </group>
  </file>
</xliff>