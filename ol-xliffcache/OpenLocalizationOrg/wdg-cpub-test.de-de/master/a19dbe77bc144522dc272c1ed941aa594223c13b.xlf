<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-us" trgLang="de-de" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">a19dbe77bc144522dc272c1ed941aa594223c13b</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <group id="101">
        <unit id="101">
          <segment state="initial" id="101">
            <source xml:space="preserve">Custom attached properties</source>
            <target xml:space="preserve">Custom attached properties</target>
          </segment>
        </unit>
        <unit id="102">
          <segment state="initial" id="102">
            <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
            <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
          </segment>
        </unit>
        <unit id="103">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="103">
            <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</source>
            <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</target>
          </segment>
        </unit>
        <unit id="104">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="104">
            <source xml:space="preserve">An <pc dataRefEnd="id2" dataRefStart="id1" id="2">attached property</pc> is a XAML concept.</source>
            <target xml:space="preserve">An <pc dataRefEnd="id2" dataRefStart="id1" id="2">attached property</pc> is a XAML concept.</target>
          </segment>
        </unit>
        <unit id="105">
          <segment state="initial" id="105">
            <source xml:space="preserve">Attached properties are typically defined as a specialized form of dependency property.</source>
            <target xml:space="preserve">Attached properties are typically defined as a specialized form of dependency property.</target>
          </segment>
        </unit>
        <unit id="106">
          <segment state="initial" id="106">
            <source xml:space="preserve">This topic explains how to implement an attached property as a dependency property and how to define the accessor convention that is necessary for your attached property to be usable in XAML.</source>
            <target xml:space="preserve">This topic explains how to implement an attached property as a dependency property and how to define the accessor convention that is necessary for your attached property to be usable in XAML.</target>
          </segment>
        </unit>
        <unit id="107">
          <segment state="initial" id="107">
            <source xml:space="preserve">Prerequisites</source>
            <target xml:space="preserve">Prerequisites</target>
          </segment>
        </unit>
        <unit id="108">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="108">
            <source xml:space="preserve">We assume that you understand dependency properties from the perspective of a consumer of existing dependency properties, and that you have read the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Dependency properties overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">We assume that you understand dependency properties from the perspective of a consumer of existing dependency properties, and that you have read the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Dependency properties overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="109">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="109">
            <source xml:space="preserve">You should also have read <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Attached properties overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">You should also have read <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Attached properties overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="110">
          <segment state="initial" id="110">
            <source xml:space="preserve">To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C\#, or Visual Basic.</source>
            <target xml:space="preserve">To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C\#, or Visual Basic.</target>
          </segment>
        </unit>
        <unit id="111">
          <segment state="initial" id="111">
            <source xml:space="preserve">Scenarios for attached properties</source>
            <target xml:space="preserve">Scenarios for attached properties</target>
          </segment>
        </unit>
        <unit id="112">
          <segment state="initial" id="112">
            <source xml:space="preserve">You might create an attached property when there is a reason to have a property-setting mechanism available for classes other than the defining class.</source>
            <target xml:space="preserve">You might create an attached property when there is a reason to have a property-setting mechanism available for classes other than the defining class.</target>
          </segment>
        </unit>
        <unit id="113">
          <segment state="initial" id="113">
            <source xml:space="preserve">The most common scenarios for this are layout and services support.</source>
            <target xml:space="preserve">The most common scenarios for this are layout and services support.</target>
          </segment>
        </unit>
        <unit id="114">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="114">
            <source xml:space="preserve">Examples of existing layout properties are <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas.ZIndex**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Canvas.Top**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Examples of existing layout properties are <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas.ZIndex**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Canvas.Top**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="115">
          <segment state="initial" id="115">
            <source xml:space="preserve">In a layout scenario, elements that exist as child elements to layout-controlling elements can express layout requirements to their parent elements individually, each setting a property value that the parent defines as an attached property.</source>
            <target xml:space="preserve">In a layout scenario, elements that exist as child elements to layout-controlling elements can express layout requirements to their parent elements individually, each setting a property value that the parent defines as an attached property.</target>
          </segment>
        </unit>
        <unit id="116">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="116">
            <source xml:space="preserve">An example of the services-support scenario in the Windows Runtime API is set of the attached properties of <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ScrollViewer**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, such as <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**ScrollViewer.IsZoomChainingEnabled**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">An example of the services-support scenario in the Windows Runtime API is set of the attached properties of <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ScrollViewer**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, such as <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**ScrollViewer.IsZoomChainingEnabled**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="117">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="117">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Caution</pc>  An existing limitation of the Windows Runtime XAML implementation is that you cannot animate your custom attached property.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Caution</pc>  An existing limitation of the Windows Runtime XAML implementation is that you cannot animate your custom attached property.</target>
          </segment>
        </unit>
        <unit id="118">
          <segment state="initial" id="118">
            <source xml:space="preserve">Registering a custom attached property</source>
            <target xml:space="preserve">Registering a custom attached property</target>
          </segment>
        </unit>
        <unit id="119">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="119">
            <source xml:space="preserve">If you are defining the attached property strictly for use on other types, the class where the property is registered does not have to derive from <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**DependencyObject**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">If you are defining the attached property strictly for use on other types, the class where the property is registered does not have to derive from <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**DependencyObject**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="120">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="120">
            <source xml:space="preserve">But you do need to have the target parameter for accessors use <pc dataRefEnd="id2" dataRefStart="id1" id="2">DependencyObject</pc> if you follow the typical model of having your attached property also be a dependency property, so that you can use the backing property store.</source>
            <target xml:space="preserve">But you do need to have the target parameter for accessors use <pc dataRefEnd="id2" dataRefStart="id1" id="2">DependencyObject</pc> if you follow the typical model of having your attached property also be a dependency property, so that you can use the backing property store.</target>
          </segment>
        </unit>
        <unit id="121">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
            <data id="id5">&lt;strong&gt;</data>
            <data id="id6">&lt;/strong&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="121">
            <source xml:space="preserve">Define your attached property as a dependency property by declaring a <pc dataRefEnd="id2" dataRefStart="id1" id="2">public</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="4">static</pc> <pc dataRefEnd="id6" dataRefStart="id5" id="6">readonly</pc> property of type <pc dataRefEnd="id8" dataRefStart="id7" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**DependencyProperty**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Define your attached property as a dependency property by declaring a <pc dataRefEnd="id2" dataRefStart="id1" id="2">public</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="4">static</pc> <pc dataRefEnd="id6" dataRefStart="id5" id="6">readonly</pc> property of type <pc dataRefEnd="id8" dataRefStart="id7" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**DependencyProperty**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="122">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="122">
            <source xml:space="preserve">You define this property by using the return value of the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**RegisterAttached**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method.</source>
            <target xml:space="preserve">You define this property by using the return value of the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**RegisterAttached**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method.</target>
          </segment>
        </unit>
        <unit id="123">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="123">
            <source xml:space="preserve">The property name must match the attached property name you specify as the <pc dataRefEnd="id2" dataRefStart="id1" id="2">RegisterAttached</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="4">name</pc> parameter, with the string "Property" added to the end.</source>
            <target xml:space="preserve">The property name must match the attached property name you specify as the <pc dataRefEnd="id2" dataRefStart="id1" id="2">RegisterAttached</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="4">name</pc> parameter, with the string "Property" added to the end.</target>
          </segment>
        </unit>
        <unit id="124">
          <segment state="initial" id="124">
            <source xml:space="preserve">This is the established convention for naming the identifiers of dependency properties in relation to the properties that they represent.</source>
            <target xml:space="preserve">This is the established convention for naming the identifiers of dependency properties in relation to the properties that they represent.</target>
          </segment>
        </unit>
        <unit id="125">
          <segment state="initial" id="125">
            <source xml:space="preserve">The main area where defining a custom attached property differs from a custom dependency property is in how you define the accessors or wrappers.</source>
            <target xml:space="preserve">The main area where defining a custom attached property differs from a custom dependency property is in how you define the accessors or wrappers.</target>
          </segment>
        </unit>
        <unit id="126">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;strong&gt;</data>
            <data id="id8">&lt;/strong&gt;</data>
            <data id="id9">&lt;strong&gt;</data>
            <data id="id10">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="126">
            <source xml:space="preserve">Instead of the using the wrapper technique described in <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Custom dependency properties</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, you must also provide static <pc dataRefEnd="id8" dataRefStart="id7" id="4">Get*</pc>PropertyName* and <pc dataRefEnd="id10" dataRefStart="id9" id="6">Set*</pc>PropertyName* methods as accessors for the attached property.</source>
            <target xml:space="preserve">Instead of the using the wrapper technique described in <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Custom dependency properties</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, you must also provide static <pc dataRefEnd="id8" dataRefStart="id7" id="4">Get*</pc>PropertyName* and <pc dataRefEnd="id10" dataRefStart="id9" id="6">Set*</pc>PropertyName* methods as accessors for the attached property.</target>
          </segment>
        </unit>
        <unit id="127">
          <segment state="initial" id="127">
            <source xml:space="preserve">The accessors are used mostly by the XAML parser, although any other caller can also use them to set values in non-XAML scenarios.</source>
            <target xml:space="preserve">The accessors are used mostly by the XAML parser, although any other caller can also use them to set values in non-XAML scenarios.</target>
          </segment>
        </unit>
        <unit id="128">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="128">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Important</pc>  If you don't define the accessors correctly, the XAML processor can't access your attached property and anyone who tries to use it will probably get a XAML parser error.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Important</pc>  If you don't define the accessors correctly, the XAML processor can't access your attached property and anyone who tries to use it will probably get a XAML parser error.</target>
          </segment>
        </unit>
        <unit id="129">
          <segment state="initial" id="129">
            <source xml:space="preserve">Also, design and coding tools often rely on the "\*Property" conventions for naming identifiers when they encounter a custom dependency property in a referenced assembly.</source>
            <target xml:space="preserve">Also, design and coding tools often rely on the "\*Property" conventions for naming identifiers when they encounter a custom dependency property in a referenced assembly.</target>
          </segment>
        </unit>
        <unit id="130">
          <segment state="initial" id="130">
            <source xml:space="preserve">Accessors</source>
            <target xml:space="preserve">Accessors</target>
          </segment>
        </unit>
        <unit id="131">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="131">
            <source xml:space="preserve">The signature for the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Get</pc><pc dataRefEnd="id4" dataRefStart="id3" id="3">PropertyName</pc> accessor must be this.</source>
            <target xml:space="preserve">The signature for the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Get</pc><pc dataRefEnd="id4" dataRefStart="id3" id="3">PropertyName</pc> accessor must be this.</target>
          </segment>
        </unit>
        <unit id="132">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;strong&gt;</data>
            <data id="id6">&lt;/strong&gt;</data>
            <data id="id7">&lt;em&gt;</data>
            <data id="id8">&lt;/em&gt;</data>
            <data id="id9">&lt;code&gt;</data>
            <data id="id10">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="132">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">public static</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="3">valueType</pc> <pc dataRefEnd="id6" dataRefStart="id5" id="5">Get</pc><pc dataRefEnd="id8" dataRefStart="id7" id="6">PropertyName</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="8">(DependencyObject target)</pc></source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">public static</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="3">valueType</pc> <pc dataRefEnd="id6" dataRefStart="id5" id="5">Get</pc><pc dataRefEnd="id8" dataRefStart="id7" id="6">PropertyName</pc> <pc dataRefEnd="id10" dataRefStart="id9" id="8">(DependencyObject target)</pc></target>
          </segment>
        </unit>
        <unit id="133">
          <segment state="initial" id="133">
            <source xml:space="preserve">For Microsoft Visual Basic, it is this.</source>
            <target xml:space="preserve">For Microsoft Visual Basic, it is this.</target>
          </segment>
        </unit>
        <unit id="134">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;code&gt;</data>
            <data id="id6">&lt;/code&gt;</data>
            <data id="id7">&lt;em&gt;</data>
            <data id="id8">&lt;/em&gt;</data>
            <data id="id9">&lt;code&gt;</data>
            <data id="id10">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="134">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1"> Public Shared Function Get</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">PropertyName</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3">(ByVal target As DependencyObject) As </pc>
							<pc dataRefEnd="id8" dataRefStart="id7" id="4">valueType</pc>
							<pc dataRefEnd="id10" dataRefStart="id9" id="5">)</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1"> Public Shared Function Get</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">PropertyName</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3">(ByVal target As DependencyObject) As </pc>
							<pc dataRefEnd="id8" dataRefStart="id7" id="4">valueType</pc>
							<pc dataRefEnd="id10" dataRefStart="id9" id="5">)</pc>
						</target>
          </segment>
        </unit>
        <unit id="135">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="135">
            <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">target</pc> object can be of a more specific type in your implementation, but must derive from <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**DependencyObject**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">target</pc> object can be of a more specific type in your implementation, but must derive from <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**DependencyObject**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="136">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="136">
            <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">valueType</pc> return value can also be of a more specific type in your implementation.</source>
            <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">valueType</pc> return value can also be of a more specific type in your implementation.</target>
          </segment>
        </unit>
        <unit id="137">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="137">
            <source xml:space="preserve">The basic <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc> type is acceptable, but often you'll want your attached property to enforce type safety.</source>
            <target xml:space="preserve">The basic <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc> type is acceptable, but often you'll want your attached property to enforce type safety.</target>
          </segment>
        </unit>
        <unit id="138">
          <segment state="initial" id="138">
            <source xml:space="preserve">The use of typing in the getter and setter signatures is a recommended type-safety technique.</source>
            <target xml:space="preserve">The use of typing in the getter and setter signatures is a recommended type-safety technique.</target>
          </segment>
        </unit>
        <unit id="139">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="139">
            <source xml:space="preserve">The signature for the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Set*</pc>PropertyName* accessor must be this.</source>
            <target xml:space="preserve">The signature for the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Set*</pc>PropertyName* accessor must be this.</target>
          </segment>
        </unit>
        <unit id="140">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;code&gt;</data>
            <data id="id6">&lt;/code&gt;</data>
            <data id="id7">&lt;em&gt;</data>
            <data id="id8">&lt;/em&gt;</data>
            <data id="id9">&lt;code&gt;</data>
            <data id="id10">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="140">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">  public static void Set</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">PropertyName</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3"> (DependencyObject target , </pc>
							<pc dataRefEnd="id8" dataRefStart="id7" id="4">valueType</pc>
							<pc dataRefEnd="id10" dataRefStart="id9" id="5"> value)</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">  public static void Set</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">PropertyName</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3"> (DependencyObject target , </pc>
							<pc dataRefEnd="id8" dataRefStart="id7" id="4">valueType</pc>
							<pc dataRefEnd="id10" dataRefStart="id9" id="5"> value)</pc>
						</target>
          </segment>
        </unit>
        <unit id="141">
          <segment state="initial" id="141">
            <source xml:space="preserve">For Visual Basic, it is this.</source>
            <target xml:space="preserve">For Visual Basic, it is this.</target>
          </segment>
        </unit>
        <unit id="142">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;code&gt;</data>
            <data id="id6">&lt;/code&gt;</data>
            <data id="id7">&lt;em&gt;</data>
            <data id="id8">&lt;/em&gt;</data>
            <data id="id9">&lt;code&gt;</data>
            <data id="id10">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="142">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Public Shared Sub Set</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">PropertyName</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3"> (ByVal target As DependencyObject, ByVal value As </pc>
							<pc dataRefEnd="id8" dataRefStart="id7" id="4">valueType</pc>
							<pc dataRefEnd="id10" dataRefStart="id9" id="5">)</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Public Shared Sub Set</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">PropertyName</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3"> (ByVal target As DependencyObject, ByVal value As </pc>
							<pc dataRefEnd="id8" dataRefStart="id7" id="4">valueType</pc>
							<pc dataRefEnd="id10" dataRefStart="id9" id="5">)</pc>
						</target>
          </segment>
        </unit>
        <unit id="143">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="143">
            <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">target</pc> object can be of a more specific type in your implementation, but must derive from <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**DependencyObject**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">target</pc> object can be of a more specific type in your implementation, but must derive from <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**DependencyObject**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="144">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="144">
            <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">value</pc> object and its <pc dataRefEnd="id4" dataRefStart="id3" id="4">valueType</pc> can be of a more specific type in your implementation.</source>
            <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">value</pc> object and its <pc dataRefEnd="id4" dataRefStart="id3" id="4">valueType</pc> can be of a more specific type in your implementation.</target>
          </segment>
        </unit>
        <unit id="145">
          <segment state="initial" id="145">
            <source xml:space="preserve">Remember that the value for this method is the input that comes from the XAML processor when it encounters your attached property in markup.</source>
            <target xml:space="preserve">Remember that the value for this method is the input that comes from the XAML processor when it encounters your attached property in markup.</target>
          </segment>
        </unit>
        <unit id="146">
          <segment state="initial" id="146">
            <source xml:space="preserve">There must be type conversion or existing markup extension support for the type you use, so that the appropriate type can be created from an attribute value (which is ultimately just a string).</source>
            <target xml:space="preserve">There must be type conversion or existing markup extension support for the type you use, so that the appropriate type can be created from an attribute value (which is ultimately just a string).</target>
          </segment>
        </unit>
        <unit id="147">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="147">
            <source xml:space="preserve">The basic <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc> type is acceptable, but often you'll want further type safety.</source>
            <target xml:space="preserve">The basic <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc> type is acceptable, but often you'll want further type safety.</target>
          </segment>
        </unit>
        <unit id="148">
          <segment state="initial" id="148">
            <source xml:space="preserve">To accomplish that, put type enforcement in the accessors.</source>
            <target xml:space="preserve">To accomplish that, put type enforcement in the accessors.</target>
          </segment>
        </unit>
        <unit id="149">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="149">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  It's also possible to define an attached property where the intended usage is through property element syntax.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  It's also possible to define an attached property where the intended usage is through property element syntax.</target>
          </segment>
        </unit>
        <unit id="150">
          <segment state="initial" id="150">
            <source xml:space="preserve">In that case you don't need type conversion for the values, but you do need to assure that the values you intend can be constructed in XAML.</source>
            <target xml:space="preserve">In that case you don't need type conversion for the values, but you do need to assure that the values you intend can be constructed in XAML.</target>
          </segment>
        </unit>
        <unit id="151">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="151">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">**VisualStateManager.VisualStateGroups**</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc> is an example of an existing attached property that only supports property element usage.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">**VisualStateManager.VisualStateGroups**</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc> is an example of an existing attached property that only supports property element usage.</target>
          </segment>
        </unit>
        <unit id="152">
          <segment state="initial" id="152">
            <source xml:space="preserve">Code example</source>
            <target xml:space="preserve">Code example</target>
          </segment>
        </unit>
        <unit id="153">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;strong&gt;</data>
            <data id="id8">&lt;/strong&gt;</data>
            <data id="id9">&lt;strong&gt;</data>
            <data id="id10">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="153">
            <source xml:space="preserve">This example shows the dependency property registration (using the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**RegisterAttached**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method), as well as the <pc dataRefEnd="id8" dataRefStart="id7" id="4">Get</pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="6">Set</pc> accessors, for a custom attached property.</source>
            <target xml:space="preserve">This example shows the dependency property registration (using the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**RegisterAttached**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method), as well as the <pc dataRefEnd="id8" dataRefStart="id7" id="4">Get</pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="6">Set</pc> accessors, for a custom attached property.</target>
          </segment>
        </unit>
        <unit id="154">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="154">
            <source xml:space="preserve">In the example, the attached property name is <pc dataRefEnd="id2" dataRefStart="id1" id="2">IsMovable</pc>.</source>
            <target xml:space="preserve">In the example, the attached property name is <pc dataRefEnd="id2" dataRefStart="id1" id="2">IsMovable</pc>.</target>
          </segment>
        </unit>
        <unit id="155">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;code&gt;</data>
            <data id="id4">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="155">
            <source xml:space="preserve">Therefore, the accessors must be named <pc dataRefEnd="id2" dataRefStart="id1" id="2">GetIsMovable</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="4">SetIsMovable</pc>.</source>
            <target xml:space="preserve">Therefore, the accessors must be named <pc dataRefEnd="id2" dataRefStart="id1" id="2">GetIsMovable</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="4">SetIsMovable</pc>.</target>
          </segment>
        </unit>
        <unit id="156">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="156">
            <source xml:space="preserve">The owner of the attached property is a service class named <pc dataRefEnd="id2" dataRefStart="id1" id="2">GameService</pc> that doesn't have a UI of its own; its purpose is only to provide the attached property services when the <pc dataRefEnd="id4" dataRefStart="id3" id="4">GameService.IsMovable</pc> attached property is used.</source>
            <target xml:space="preserve">The owner of the attached property is a service class named <pc dataRefEnd="id2" dataRefStart="id1" id="2">GameService</pc> that doesn't have a UI of its own; its purpose is only to provide the attached property services when the <pc dataRefEnd="id4" dataRefStart="id3" id="4">GameService.IsMovable</pc> attached property is used.</target>
          </segment>
        </unit>
        <unit id="157">
          <segment state="initial" id="157">
            <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
            <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
          </segment>
        </unit>
        <unit id="158">
          <segment state="initial" id="158">
            <source xml:space="preserve">Defining the attached property in C++ is a bit more complex.</source>
            <target xml:space="preserve">Defining the attached property in C++ is a bit more complex.</target>
          </segment>
        </unit>
        <unit id="159">
          <segment state="initial" id="159">
            <source xml:space="preserve">You have to decide how to factor between the header and code file.</source>
            <target xml:space="preserve">You have to decide how to factor between the header and code file.</target>
          </segment>
        </unit>
        <unit id="160">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="160">
            <source xml:space="preserve">Also, you should expose the identifier as a property with only a <pc dataRefEnd="id2" dataRefStart="id1" id="2">get</pc> accessor, for reasons discussed in <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">Custom dependency properties</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Also, you should expose the identifier as a property with only a <pc dataRefEnd="id2" dataRefStart="id1" id="2">get</pc> accessor, for reasons discussed in <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">Custom dependency properties</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="161">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="161">
            <source xml:space="preserve">In C++ you must define this property-field relationship explicitly rather than relying on .NET <pc dataRefEnd="id2" dataRefStart="id1" id="2">readonly</pc> keywording and implicit backing of simple properties.</source>
            <target xml:space="preserve">In C++ you must define this property-field relationship explicitly rather than relying on .NET <pc dataRefEnd="id2" dataRefStart="id1" id="2">readonly</pc> keywording and implicit backing of simple properties.</target>
          </segment>
        </unit>
        <unit id="162">
          <segment state="initial" id="162">
            <source xml:space="preserve">You also need to perform the registration of the attached property within a helper function that only gets run once, when the app first starts but before any XAML pages that need the attached property are loaded.</source>
            <target xml:space="preserve">You also need to perform the registration of the attached property within a helper function that only gets run once, when the app first starts but before any XAML pages that need the attached property are loaded.</target>
          </segment>
        </unit>
        <unit id="163">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="163">
            <source xml:space="preserve">The typical place to call your property registration helper functions for any and all dependency or attached properties is from within the <pc dataRefEnd="id2" dataRefStart="id1" id="2">App</pc> / <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Application**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> constructor in the code for your app.xaml file.</source>
            <target xml:space="preserve">The typical place to call your property registration helper functions for any and all dependency or attached properties is from within the <pc dataRefEnd="id2" dataRefStart="id1" id="2">App</pc> / <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Application**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> constructor in the code for your app.xaml file.</target>
          </segment>
        </unit>
        <unit id="164">
          <segment state="initial" id="164">
            <source xml:space="preserve">Using your custom attached property in XAML</source>
            <target xml:space="preserve">Using your custom attached property in XAML</target>
          </segment>
        </unit>
        <unit id="165">
          <segment state="initial" id="165">
            <source xml:space="preserve">After you have defined your attached property and included its support members as part of a custom type, you must then make the definitions available for XAML usage.</source>
            <target xml:space="preserve">After you have defined your attached property and included its support members as part of a custom type, you must then make the definitions available for XAML usage.</target>
          </segment>
        </unit>
        <unit id="166">
          <segment state="initial" id="166">
            <source xml:space="preserve">To do this, you must map a XAML namespace that will reference the code namespace that contains the relevant class.</source>
            <target xml:space="preserve">To do this, you must map a XAML namespace that will reference the code namespace that contains the relevant class.</target>
          </segment>
        </unit>
        <unit id="167">
          <segment state="initial" id="167">
            <source xml:space="preserve">In cases where you have defined the attached property as part of a library, you must include that library as part of the app package for the app.</source>
            <target xml:space="preserve">In cases where you have defined the attached property as part of a library, you must include that library as part of the app package for the app.</target>
          </segment>
        </unit>
        <unit id="168">
          <segment state="initial" id="168">
            <source xml:space="preserve">An XML namespace mapping for XAML is typically placed in the root element of a XAML page.</source>
            <target xml:space="preserve">An XML namespace mapping for XAML is typically placed in the root element of a XAML page.</target>
          </segment>
        </unit>
        <unit id="169">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;code&gt;</data>
            <data id="id4">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="169">
            <source xml:space="preserve">For example, for the class named <pc dataRefEnd="id2" dataRefStart="id1" id="2">GameService</pc> in the namespace <pc dataRefEnd="id4" dataRefStart="id3" id="4">UserAndCustomControls</pc> that contains the attached property definitions shown in preceding snippets, the mapping might look like this.</source>
            <target xml:space="preserve">For example, for the class named <pc dataRefEnd="id2" dataRefStart="id1" id="2">GameService</pc> in the namespace <pc dataRefEnd="id4" dataRefStart="id3" id="4">UserAndCustomControls</pc> that contains the attached property definitions shown in preceding snippets, the mapping might look like this.</target>
          </segment>
        </unit>
        <unit id="170">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="170">
            <source xml:space="preserve">Using the mapping, you can set your <pc dataRefEnd="id2" dataRefStart="id1" id="2">GameService.IsMovable</pc> attached property on any element that matches your target definition, including an existing type that Windows Runtime defines.</source>
            <target xml:space="preserve">Using the mapping, you can set your <pc dataRefEnd="id2" dataRefStart="id1" id="2">GameService.IsMovable</pc> attached property on any element that matches your target definition, including an existing type that Windows Runtime defines.</target>
          </segment>
        </unit>
        <unit id="171">
          <segment state="initial" id="171">
            <source xml:space="preserve">If you are setting the property on an element that is also within the same mapped XML namespace, you still must include the prefix on the attached property name.</source>
            <target xml:space="preserve">If you are setting the property on an element that is also within the same mapped XML namespace, you still must include the prefix on the attached property name.</target>
          </segment>
        </unit>
        <unit id="172">
          <segment state="initial" id="172">
            <source xml:space="preserve">This is because the prefix qualifies the owner type.</source>
            <target xml:space="preserve">This is because the prefix qualifies the owner type.</target>
          </segment>
        </unit>
        <unit id="173">
          <segment state="initial" id="173">
            <source xml:space="preserve">The attached property's attribute cannot be assumed to be within the same XML namespace as the element where the attribute is included, even though, by normal XML rules, attributes can inherit namespace from elements.</source>
            <target xml:space="preserve">The attached property's attribute cannot be assumed to be within the same XML namespace as the element where the attribute is included, even though, by normal XML rules, attributes can inherit namespace from elements.</target>
          </segment>
        </unit>
        <unit id="174">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;code&gt;</data>
            <data id="id4">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="174">
            <source xml:space="preserve">For example, if you are setting <pc dataRefEnd="id2" dataRefStart="id1" id="2">GameService.IsMovable</pc> on a custom type of <pc dataRefEnd="id4" dataRefStart="id3" id="4">ImageWithLabelControl</pc> (definition not shown), and even if both were defined in the same code namespace mapped to same prefix, the XAML would still be this.</source>
            <target xml:space="preserve">For example, if you are setting <pc dataRefEnd="id2" dataRefStart="id1" id="2">GameService.IsMovable</pc> on a custom type of <pc dataRefEnd="id4" dataRefStart="id3" id="4">ImageWithLabelControl</pc> (definition not shown), and even if both were defined in the same code namespace mapped to same prefix, the XAML would still be this.</target>
          </segment>
        </unit>
        <unit id="175">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="175">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  If you are writing a XAML UI with C++, you must include the header for the custom type that defines the attached property, any time that a XAML page uses that type.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  If you are writing a XAML UI with C++, you must include the header for the custom type that defines the attached property, any time that a XAML page uses that type.</target>
          </segment>
        </unit>
        <unit id="176">
          <segment state="initial" id="176">
            <source xml:space="preserve">Each XAML page has an associated .xaml.h code-behind header.</source>
            <target xml:space="preserve">Each XAML page has an associated .xaml.h code-behind header.</target>
          </segment>
        </unit>
        <unit id="177">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="177">
            <source xml:space="preserve">This is where you should include (using <pc dataRefEnd="id2" dataRefStart="id1" id="2">\#include</pc>) the header for the definition of the attached property's owner type.</source>
            <target xml:space="preserve">This is where you should include (using <pc dataRefEnd="id2" dataRefStart="id1" id="2">\#include</pc>) the header for the definition of the attached property's owner type.</target>
          </segment>
        </unit>
        <unit id="178">
          <segment state="initial" id="178">
            <source xml:space="preserve">Value type of a custom attached property</source>
            <target xml:space="preserve">Value type of a custom attached property</target>
          </segment>
        </unit>
        <unit id="179">
          <segment state="initial" id="179">
            <source xml:space="preserve">The type that is used as the value type of a custom attached property affects the usage, the definition, or both the usage and definition.</source>
            <target xml:space="preserve">The type that is used as the value type of a custom attached property affects the usage, the definition, or both the usage and definition.</target>
          </segment>
        </unit>
        <unit id="180">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
            <data id="id5">&lt;em&gt;</data>
            <data id="id6">&lt;/em&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="180">
            <source xml:space="preserve">The attached property's value type is declared in several places: in the signatures of both the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="4">Set</pc> accessor methods, and also as the <pc dataRefEnd="id6" dataRefStart="id5" id="6">propertyType</pc> parameter of the <pc dataRefEnd="id8" dataRefStart="id7" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**RegisterAttached**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc> call.</source>
            <target xml:space="preserve">The attached property's value type is declared in several places: in the signatures of both the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Get</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="4">Set</pc> accessor methods, and also as the <pc dataRefEnd="id6" dataRefStart="id5" id="6">propertyType</pc> parameter of the <pc dataRefEnd="id8" dataRefStart="id7" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**RegisterAttached**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc> call.</target>
          </segment>
        </unit>
        <unit id="181">
          <segment state="initial" id="181">
            <source xml:space="preserve">The most common value type for attached properties (custom or otherwise) is a simple string.</source>
            <target xml:space="preserve">The most common value type for attached properties (custom or otherwise) is a simple string.</target>
          </segment>
        </unit>
        <unit id="182">
          <segment state="initial" id="182">
            <source xml:space="preserve">This is because attached properties are generally intended for XAML attribute usage, and using a string as the value type keeps the properties lightweight.</source>
            <target xml:space="preserve">This is because attached properties are generally intended for XAML attribute usage, and using a string as the value type keeps the properties lightweight.</target>
          </segment>
        </unit>
        <unit id="183">
          <segment state="initial" id="183">
            <source xml:space="preserve">Other primitives that have native conversion to string methods, such as integer, double, or an enumeration value, are also common as value types for attached properties.</source>
            <target xml:space="preserve">Other primitives that have native conversion to string methods, such as integer, double, or an enumeration value, are also common as value types for attached properties.</target>
          </segment>
        </unit>
        <unit id="184">
          <segment state="initial" id="184">
            <source xml:space="preserve">You can use other value types—ones that don't support native string conversion—as the attached property value.</source>
            <target xml:space="preserve">You can use other value types—ones that don't support native string conversion—as the attached property value.</target>
          </segment>
        </unit>
        <unit id="185">
          <segment state="initial" id="185">
            <source xml:space="preserve">However, this entails making a choice about either the usage or the implementation:</source>
            <target xml:space="preserve">However, this entails making a choice about either the usage or the implementation:</target>
          </segment>
        </unit>
        <unit id="186">
          <segment state="initial" id="186">
            <source xml:space="preserve">You can leave the attached property as it is, but the attached property can support usage only where the attached property is a property element, and the value is declared as an object element.</source>
            <target xml:space="preserve">You can leave the attached property as it is, but the attached property can support usage only where the attached property is a property element, and the value is declared as an object element.</target>
          </segment>
        </unit>
        <unit id="187">
          <segment state="initial" id="187">
            <source xml:space="preserve">In this case, the property type does have to support XAML usage as an object element.</source>
            <target xml:space="preserve">In this case, the property type does have to support XAML usage as an object element.</target>
          </segment>
        </unit>
        <unit id="188">
          <segment state="initial" id="188">
            <source xml:space="preserve">For existing Windows Runtime reference classes, check the XAML syntax to make sure that the type supports XAML object element usage.</source>
            <target xml:space="preserve">For existing Windows Runtime reference classes, check the XAML syntax to make sure that the type supports XAML object element usage.</target>
          </segment>
        </unit>
        <unit id="189">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="189">
            <source xml:space="preserve">You can leave the attached property as it is, but use it only in an attribute usage through a XAML reference technique such as a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Binding</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="4">StaticResource</pc> that can be expressed as a string.</source>
            <target xml:space="preserve">You can leave the attached property as it is, but use it only in an attribute usage through a XAML reference technique such as a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Binding</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="4">StaticResource</pc> that can be expressed as a string.</target>
          </segment>
        </unit>
        <unit id="190">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="190">
            <source xml:space="preserve">More about the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas.Left</pc> example</source>
            <target xml:space="preserve">More about the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas.Left</pc> example</target>
          </segment>
        </unit>
        <unit id="191">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="191">
            <source xml:space="preserve">In earlier examples of attached property usages we showed different ways to set the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas.Left**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> attached property.</source>
            <target xml:space="preserve">In earlier examples of attached property usages we showed different ways to set the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas.Left**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> attached property.</target>
          </segment>
        </unit>
        <unit id="192">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="192">
            <source xml:space="preserve">But what does that change about how a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> interacts with your object, and when does that happen?</source>
            <target xml:space="preserve">But what does that change about how a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> interacts with your object, and when does that happen?</target>
          </segment>
        </unit>
        <unit id="193">
          <segment state="initial" id="193">
            <source xml:space="preserve">We'll examine this particular example further, because if you implement an attached property, it's interesting to see what else a typical attached property owner class intends to do with its attached property values if it finds them on other objects.</source>
            <target xml:space="preserve">We'll examine this particular example further, because if you implement an attached property, it's interesting to see what else a typical attached property owner class intends to do with its attached property values if it finds them on other objects.</target>
          </segment>
        </unit>
        <unit id="194">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="194">
            <source xml:space="preserve">The main function of a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> is to be an absolute-positioned layout container in UI.</source>
            <target xml:space="preserve">The main function of a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> is to be an absolute-positioned layout container in UI.</target>
          </segment>
        </unit>
        <unit id="195">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="195">
            <source xml:space="preserve">The children of a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> are stored in a base-class defined property <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Children**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">The children of a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> are stored in a base-class defined property <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Children**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="196">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="196">
            <source xml:space="preserve">Of all the panels <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> is the only one that uses absolute positioning.</source>
            <target xml:space="preserve">Of all the panels <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> is the only one that uses absolute positioning.</target>
          </segment>
        </unit>
        <unit id="197">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;strong&gt;</data>
            <data id="id8">&lt;/strong&gt;</data>
            <data id="id9">&lt;strong&gt;</data>
            <data id="id10">&lt;/strong&gt;</data>
            <data id="id11">&lt;strong&gt;</data>
            <data id="id12">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="197">
            <source xml:space="preserve">It would've bloated the object model of the common <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**UIElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> type to add properties that might only be of concern to <pc dataRefEnd="id8" dataRefStart="id7" id="4">Canvas</pc> and those particular <pc dataRefEnd="id10" dataRefStart="id9" id="6">UIElement</pc> cases where they are child elements of a <pc dataRefEnd="id12" dataRefStart="id11" id="8">UIElement</pc>.</source>
            <target xml:space="preserve">It would've bloated the object model of the common <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**UIElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> type to add properties that might only be of concern to <pc dataRefEnd="id8" dataRefStart="id7" id="4">Canvas</pc> and those particular <pc dataRefEnd="id10" dataRefStart="id9" id="6">UIElement</pc> cases where they are child elements of a <pc dataRefEnd="id12" dataRefStart="id11" id="8">UIElement</pc>.</target>
          </segment>
        </unit>
        <unit id="198">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="198">
            <source xml:space="preserve">Defining the layout control properties of a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> to be attached properties that any <pc dataRefEnd="id4" dataRefStart="id3" id="4">UIElement</pc> can use keeps the object model cleaner.</source>
            <target xml:space="preserve">Defining the layout control properties of a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> to be attached properties that any <pc dataRefEnd="id4" dataRefStart="id3" id="4">UIElement</pc> can use keeps the object model cleaner.</target>
          </segment>
        </unit>
        <unit id="199">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="199">
            <source xml:space="preserve">In order to be a practical panel, <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> has behavior that overrides the framework-level <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Measure**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Arrange**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> methods.</source>
            <target xml:space="preserve">In order to be a practical panel, <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> has behavior that overrides the framework-level <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Measure**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Arrange**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> methods.</target>
          </segment>
        </unit>
        <unit id="200">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="200">
            <source xml:space="preserve">This is where <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> actually checks for attached property values on its children.</source>
            <target xml:space="preserve">This is where <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> actually checks for attached property values on its children.</target>
          </segment>
        </unit>
        <unit id="201">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
            <data id="id5">&lt;link&gt;</data>
            <data id="id6">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="201">
            <source xml:space="preserve">Part of both the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Measure</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="4">Arrange</pc> patterns is a loop that iterates over any content, and a panel has the <pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Children**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> property that makes it explicit what's supposed to be considered the child of a panel.</source>
            <target xml:space="preserve">Part of both the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Measure</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="4">Arrange</pc> patterns is a loop that iterates over any content, and a panel has the <pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Children**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> property that makes it explicit what's supposed to be considered the child of a panel.</target>
          </segment>
        </unit>
        <unit id="202">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id9">&lt;link&gt;</data>
            <data id="id10">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="202">
            <source xml:space="preserve">So the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> layout behavior iterates through these children, and makes static <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Canvas.GetLeft**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Canvas.GetTop**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> calls on each child to see whether those attached properties contain a non-default value (default is 0).</source>
            <target xml:space="preserve">So the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> layout behavior iterates through these children, and makes static <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Canvas.GetLeft**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Canvas.GetTop**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> calls on each child to see whether those attached properties contain a non-default value (default is 0).</target>
          </segment>
        </unit>
        <unit id="203">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="203">
            <source xml:space="preserve">These values are then used to absolutely position each child in the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> available layout space according to the specific values provided by each child, and committed using <pc dataRefEnd="id4" dataRefStart="id3" id="4">Arrange</pc>.</source>
            <target xml:space="preserve">These values are then used to absolutely position each child in the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> available layout space according to the specific values provided by each child, and committed using <pc dataRefEnd="id4" dataRefStart="id3" id="4">Arrange</pc>.</target>
          </segment>
        </unit>
        <unit id="204">
          <segment state="initial" id="204">
            <source xml:space="preserve">The code looks something like this pseudocode:</source>
            <target xml:space="preserve">The code looks something like this pseudocode:</target>
          </segment>
        </unit>
        <unit id="205">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="205">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  For more info on how panels work, see <pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId2">XAML custom panels overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="3CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  For more info on how panels work, see <pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId2">XAML custom panels overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="3CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="206">
          <segment state="initial" id="206">
            <source xml:space="preserve">Related topics</source>
            <target xml:space="preserve">Related topics</target>
          </segment>
        </unit>
        <unit id="207">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="207">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">**RegisterAttached**</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">**RegisterAttached**</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
        <unit id="208">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="208">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">Attached properties overview</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">Attached properties overview</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
        <unit id="209">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="209">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">Custom dependency properties</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">Custom dependency properties</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
        <unit id="210">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="210">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">XAML overview</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">XAML overview</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
      </group>
    </group>
  </file>
</xliff>