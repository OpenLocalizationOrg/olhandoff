{
  "nodes": [
    {
      "pos": [
        26,
        80
      ],
      "content": "Using API Management service to generate HTTP requests"
    },
    {
      "pos": [
        98,
        198
      ],
      "content": "Learn to use request and response policies in API Management to call external services from your API"
    },
    {
      "pos": [
        488,
        549
      ],
      "content": "Using external services from the Azure API Management service"
    },
    {
      "pos": [
        551,
        855
      ],
      "content": "The policies available in Azure API Management service can do a wide range of useful work based purely on the incoming request, the outgoing response and basic configuration information. However, being able to interact with external services from API Management policies opens up many more opportunities.",
      "nodes": [
        {
          "content": "The policies available in Azure API Management service can do a wide range of useful work based purely on the incoming request, the outgoing response and basic configuration information.",
          "pos": [
            0,
            186
          ]
        },
        {
          "content": "However, being able to interact with external services from API Management policies opens up many more opportunities.",
          "pos": [
            187,
            304
          ]
        }
      ]
    },
    {
      "pos": [
        857,
        1291
      ],
      "content": "We have previously seen how we can interact with the <bpt id=\"p1\">[</bpt>Azure Event Hub service for logging, monitoring and analytics<ept id=\"p1\">](api-management-log-to-eventhub-sample.md)</ept>. In this article we will demonstrate policies that allow you to interact with any external HTTP based service. These policies can be used for triggering remote events or for retrieving information that will be used to manipulate the original request and response in some way.",
      "nodes": [
        {
          "content": "We have previously seen how we can interact with the <bpt id=\"p1\">[</bpt>Azure Event Hub service for logging, monitoring and analytics<ept id=\"p1\">](api-management-log-to-eventhub-sample.md)</ept>.",
          "pos": [
            0,
            197
          ]
        },
        {
          "content": "In this article we will demonstrate policies that allow you to interact with any external HTTP based service.",
          "pos": [
            198,
            307
          ]
        },
        {
          "content": "These policies can be used for triggering remote events or for retrieving information that will be used to manipulate the original request and response in some way.",
          "pos": [
            308,
            472
          ]
        }
      ]
    },
    {
      "pos": [
        1296,
        1316
      ],
      "content": "Send-One-Way-Request"
    },
    {
      "pos": [
        1317,
        2025
      ],
      "content": "Possibly the simplest external interaction is the fire-and-forget style of request that allows an external service to be notified of some kind of important event. We can use the control flow policy <ph id=\"ph2\">`choose`</ph><ph id=\"ph3\"/> to detect any kind of condition that we are interested in and then, if the condition is satisfied, we can make an external HTTP request using the <bpt id=\"p2\">[</bpt>send-one-way-request<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendOneWayRequest)</ept><ph id=\"ph4\"/> policy. This could be a request to a messaging system like Hipchat or Slack, or a mail API like SendGrid or MailChimp, or for critical support incidents something like PagerDuty. All of these messaging systems have simple HTTP APIs that we can easily invoke.",
      "nodes": [
        {
          "content": "Possibly the simplest external interaction is the fire-and-forget style of request that allows an external service to be notified of some kind of important event.",
          "pos": [
            0,
            162
          ]
        },
        {
          "content": "We can use the control flow policy <ph id=\"ph2\">`choose`</ph><ph id=\"ph3\"/> to detect any kind of condition that we are interested in and then, if the condition is satisfied, we can make an external HTTP request using the <bpt id=\"p2\">[</bpt>send-one-way-request<ept id=\"p2\">](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendOneWayRequest)</ept><ph id=\"ph4\"/> policy.",
          "pos": [
            163,
            541
          ]
        },
        {
          "content": "This could be a request to a messaging system like Hipchat or Slack, or a mail API like SendGrid or MailChimp, or for critical support incidents something like PagerDuty.",
          "pos": [
            542,
            712
          ]
        },
        {
          "content": "All of these messaging systems have simple HTTP APIs that we can easily invoke.",
          "pos": [
            713,
            792
          ]
        }
      ]
    },
    {
      "pos": [
        2031,
        2050
      ],
      "content": "Alerting with Slack"
    },
    {
      "pos": [
        2051,
        2366
      ],
      "content": "The following example demonstrates how to send a message to a Slack chat room if the HTTP response status code is greater than or equal to 500. A 500 range error indicates a problem with our backend API that the client of our API cannot resolve themselves. It usually requires some kind of intervention on our part.",
      "nodes": [
        {
          "content": "The following example demonstrates how to send a message to a Slack chat room if the HTTP response status code is greater than or equal to 500.",
          "pos": [
            0,
            143
          ]
        },
        {
          "content": "A 500 range error indicates a problem with our backend API that the client of our API cannot resolve themselves.",
          "pos": [
            144,
            256
          ]
        },
        {
          "content": "It usually requires some kind of intervention on our part.",
          "pos": [
            257,
            315
          ]
        }
      ]
    },
    {
      "pos": [
        3643,
        3912
      ],
      "content": "Slack has the notion of inbound web hooks. When configuring an inbound web hook, Slack generates a special URL which allows you to do a simple POST request and to pass a message into the Slack channel. The JSON body that we create is based on a format defined by Slack.",
      "nodes": [
        {
          "content": "Slack has the notion of inbound web hooks.",
          "pos": [
            0,
            42
          ]
        },
        {
          "content": "When configuring an inbound web hook, Slack generates a special URL which allows you to do a simple POST request and to pass a message into the Slack channel.",
          "pos": [
            43,
            201
          ]
        },
        {
          "content": "The JSON body that we create is based on a format defined by Slack.",
          "pos": [
            202,
            269
          ]
        }
      ]
    },
    {
      "pos": [
        3914,
        4008
      ],
      "content": "<ph id=\"ph5\">![</ph>Slack Web Hook<ph id=\"ph6\">](./media/api-management-sample-send-request/api-management-slack-webhook.png)</ph>"
    },
    {
      "pos": [
        4014,
        4045
      ],
      "content": "Is fire and forget good enough?"
    },
    {
      "pos": [
        4046,
        4550
      ],
      "content": "There are certain tradeoffs when using a fire-and-forget style of request. If for some reason, the request fails, then the failure will not be reported. In this particular situation, the complexity of having a secondary failure reporting system and the additional performance cost of waiting for the response is not warranted. For scenarios where it is essential to check the response, then the <bpt id=\"p3\">[</bpt>send-request<ept id=\"p3\">](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendRequest)</ept><ph id=\"ph7\"/> policy is a better option.",
      "nodes": [
        {
          "content": "There are certain tradeoffs when using a fire-and-forget style of request.",
          "pos": [
            0,
            74
          ]
        },
        {
          "content": "If for some reason, the request fails, then the failure will not be reported.",
          "pos": [
            75,
            152
          ]
        },
        {
          "content": "In this particular situation, the complexity of having a secondary failure reporting system and the additional performance cost of waiting for the response is not warranted.",
          "pos": [
            153,
            326
          ]
        },
        {
          "content": "For scenarios where it is essential to check the response, then the <bpt id=\"p3\">[</bpt>send-request<ept id=\"p3\">](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendRequest)</ept><ph id=\"ph7\"/> policy is a better option.",
          "pos": [
            327,
            556
          ]
        }
      ]
    },
    {
      "pos": [
        4555,
        4567
      ],
      "content": "Send-Request"
    },
    {
      "pos": [
        4568,
        4761
      ],
      "content": "The <ph id=\"ph8\">`send-request`</ph><ph id=\"ph9\"/> policy enables using an external service to perform complex processing functions and return data to the API management service that can be used for further policy processing."
    },
    {
      "pos": [
        4767,
        4795
      ],
      "content": "Authorizing reference tokens"
    },
    {
      "pos": [
        4796,
        5371
      ],
      "content": "A major function of API Management is protecting backend resources. If the authorization server used by your API creates <bpt id=\"p4\">[</bpt>JWT tokens<ept id=\"p4\">](http://jwt.io/)</ept><ph id=\"ph10\"/> as part of its OAuth2 flow, as <bpt id=\"p5\">[</bpt>Azure Active Directory<ept id=\"p5\">](../active-directory/active-directory-aadconnect.md)</ept><ph id=\"ph11\"/> does, then you can use the <ph id=\"ph12\">`validate-jwt`</ph><ph id=\"ph13\"/> policy to verify the validity of the token. However, some authorization servers create what are called <bpt id=\"p6\">[</bpt>reference tokens<ept id=\"p6\">](http://leastprivilege.com/2015/11/25/reference-tokens-and-introspection/)</ept><ph id=\"ph14\"/> that cannot be verified without making a call back to the authorization server.",
      "nodes": [
        {
          "content": "A major function of API Management is protecting backend resources.",
          "pos": [
            0,
            67
          ]
        },
        {
          "content": "If the authorization server used by your API creates <bpt id=\"p4\">[</bpt>JWT tokens<ept id=\"p4\">](http://jwt.io/)</ept><ph id=\"ph10\"/> as part of its OAuth2 flow, as <bpt id=\"p5\">[</bpt>Azure Active Directory<ept id=\"p5\">](../active-directory/active-directory-aadconnect.md)</ept><ph id=\"ph11\"/> does, then you can use the <ph id=\"ph12\">`validate-jwt`</ph><ph id=\"ph13\"/> policy to verify the validity of the token.",
          "pos": [
            68,
            483
          ]
        },
        {
          "content": "However, some authorization servers create what are called <bpt id=\"p6\">[</bpt>reference tokens<ept id=\"p6\">](http://leastprivilege.com/2015/11/25/reference-tokens-and-introspection/)</ept><ph id=\"ph14\"/> that cannot be verified without making a call back to the authorization server.",
          "pos": [
            484,
            768
          ]
        }
      ]
    },
    {
      "pos": [
        5377,
        5403
      ],
      "content": "Standardized introspection"
    },
    {
      "pos": [
        5404,
        5693
      ],
      "content": "In the past there has been no standardized way of verifying a reference token with an authorization server. However a recently proposed standard <bpt id=\"p7\">[</bpt>RFC 7662<ept id=\"p7\">](https://tools.ietf.org/html/rfc7662)</ept><ph id=\"ph15\"/> was published by the IETF that defines how a resource server can verify the validity of a token.",
      "nodes": [
        {
          "content": "In the past there has been no standardized way of verifying a reference token with an authorization server.",
          "pos": [
            0,
            107
          ]
        },
        {
          "content": "However a recently proposed standard <bpt id=\"p7\">[</bpt>RFC 7662<ept id=\"p7\">](https://tools.ietf.org/html/rfc7662)</ept><ph id=\"ph15\"/> was published by the IETF that defines how a resource server can verify the validity of a token.",
          "pos": [
            108,
            342
          ]
        }
      ]
    },
    {
      "pos": [
        5699,
        5719
      ],
      "content": "Extracting the token"
    },
    {
      "pos": [
        5720,
        6258
      ],
      "content": "The first step is to extract the token from the Authorization header. The header value should be formatted with the <ph id=\"ph16\">`Bearer`</ph><ph id=\"ph17\"/> authorization scheme, a single space and then the authorization token as per <bpt id=\"p8\">[</bpt>RFC 6750<ept id=\"p8\">](http://tools.ietf.org/html/rfc6750#section-2.1)</ept>. Unfortunately there are cases where the authorization scheme is omitted. To account for this when parsing, we split the header value on a space and select the last string from the returned array of strings. This provides a workaround for badly formatted authorization headers.",
      "nodes": [
        {
          "content": "The first step is to extract the token from the Authorization header.",
          "pos": [
            0,
            69
          ]
        },
        {
          "content": "The header value should be formatted with the <ph id=\"ph16\">`Bearer`</ph><ph id=\"ph17\"/> authorization scheme, a single space and then the authorization token as per <bpt id=\"p8\">[</bpt>RFC 6750<ept id=\"p8\">](http://tools.ietf.org/html/rfc6750#section-2.1)</ept>.",
          "pos": [
            70,
            333
          ]
        },
        {
          "content": "Unfortunately there are cases where the authorization scheme is omitted.",
          "pos": [
            334,
            406
          ]
        },
        {
          "content": "To account for this when parsing, we split the header value on a space and select the last string from the returned array of strings.",
          "pos": [
            407,
            540
          ]
        },
        {
          "content": "This provides a workaround for badly formatted authorization headers.",
          "pos": [
            541,
            610
          ]
        }
      ]
    },
    {
      "pos": [
        6402,
        6431
      ],
      "content": "Making the validation request"
    },
    {
      "pos": [
        6432,
        6843
      ],
      "content": "Once we have the authorization token, we can make the request to validate the token. RFC 7662 calls this process introspection and requires that you <ph id=\"ph18\">`POST`</ph><ph id=\"ph19\"/> a HTML form to the introspection resource. The HTML form must at least contain a key/value pair with the key <ph id=\"ph20\">`token`</ph>. This request to the authorization server must also be authenticated to ensure that malicious clients cannot go trawling for valid tokens.",
      "nodes": [
        {
          "content": "Once we have the authorization token, we can make the request to validate the token.",
          "pos": [
            0,
            84
          ]
        },
        {
          "content": "RFC 7662 calls this process introspection and requires that you <ph id=\"ph18\">`POST`</ph><ph id=\"ph19\"/> a HTML form to the introspection resource.",
          "pos": [
            85,
            232
          ]
        },
        {
          "content": "The HTML form must at least contain a key/value pair with the key <ph id=\"ph20\">`token`</ph>.",
          "pos": [
            233,
            326
          ]
        },
        {
          "content": "This request to the authorization server must also be authenticated to ensure that malicious clients cannot go trawling for valid tokens.",
          "pos": [
            327,
            464
          ]
        }
      ]
    },
    {
      "pos": [
        7475,
        7496
      ],
      "content": "Checking the response"
    },
    {
      "pos": [
        7497,
        7710
      ],
      "content": "The <ph id=\"ph21\">`response-variable-name`</ph><ph id=\"ph22\"/> attribute is used to give access the returned response. The name defined in this property can be used as a key into the <ph id=\"ph23\">`context.Variables`</ph><ph id=\"ph24\"/> dictionary to access the <ph id=\"ph25\">`IResponse`</ph><ph id=\"ph26\"/> object.",
      "nodes": [
        {
          "content": "The <ph id=\"ph21\">`response-variable-name`</ph><ph id=\"ph22\"/> attribute is used to give access the returned response.",
          "pos": [
            0,
            118
          ]
        },
        {
          "content": "The name defined in this property can be used as a key into the <ph id=\"ph23\">`context.Variables`</ph><ph id=\"ph24\"/> dictionary to access the <ph id=\"ph25\">`IResponse`</ph><ph id=\"ph26\"/> object.",
          "pos": [
            119,
            315
          ]
        }
      ]
    },
    {
      "pos": [
        7712,
        7959
      ],
      "content": "From the response object we can retrieve the body and RFC 7622 tells us that the response must be a JSON object and must contain at least a property called <ph id=\"ph27\">`active`</ph><ph id=\"ph28\"/> that is a boolean value. When <ph id=\"ph29\">`active`</ph><ph id=\"ph30\"/> is true then the token is considered valid.",
      "nodes": [
        {
          "content": "From the response object we can retrieve the body and RFC 7622 tells us that the response must be a JSON object and must contain at least a property called <ph id=\"ph27\">`active`</ph><ph id=\"ph28\"/> that is a boolean value.",
          "pos": [
            0,
            223
          ]
        },
        {
          "content": "When <ph id=\"ph29\">`active`</ph><ph id=\"ph30\"/> is true then the token is considered valid.",
          "pos": [
            224,
            315
          ]
        }
      ]
    },
    {
      "pos": [
        7965,
        7982
      ],
      "content": "Reporting failure"
    },
    {
      "pos": [
        7983,
        8077
      ],
      "content": "We use a <ph id=\"ph31\">`&lt;choose&gt;`</ph><ph id=\"ph32\"/> policy to detect if the token is invalid and if so, return a 401 response."
    },
    {
      "pos": [
        8553,
        9155
      ],
      "content": "As per <bpt id=\"p9\">[</bpt>RFC 6750<ept id=\"p9\">](https://tools.ietf.org/html/rfc6750#section-3)</ept><ph id=\"ph33\"/> which describes how <ph id=\"ph34\">`bearer`</ph><ph id=\"ph35\"/> tokens should be used, we also return a <ph id=\"ph36\">`WWW-Authenticate`</ph><ph id=\"ph37\"/> header with the 401 response. The WWW-Authenticate is intended to instruct a client on how to construct a properly authorized request. Due to the wide variety of approaches possible with the OAuth2 framework, it is difficult to communicate all the needed information. Fortunately there are efforts underway to help <bpt id=\"p10\">[</bpt>clients discover how to properly authorize requests to a resource server<ept id=\"p10\">](http://tools.ietf.org/html/draft-jones-oauth-discovery-00)</ept>.",
      "nodes": [
        {
          "content": "As per <bpt id=\"p9\">[</bpt>RFC 6750<ept id=\"p9\">](https://tools.ietf.org/html/rfc6750#section-3)</ept><ph id=\"ph33\"/> which describes how <ph id=\"ph34\">`bearer`</ph><ph id=\"ph35\"/> tokens should be used, we also return a <ph id=\"ph36\">`WWW-Authenticate`</ph><ph id=\"ph37\"/> header with the 401 response.",
          "pos": [
            0,
            303
          ]
        },
        {
          "content": "The WWW-Authenticate is intended to instruct a client on how to construct a properly authorized request.",
          "pos": [
            304,
            408
          ]
        },
        {
          "content": "Due to the wide variety of approaches possible with the OAuth2 framework, it is difficult to communicate all the needed information.",
          "pos": [
            409,
            541
          ]
        },
        {
          "content": "Fortunately there are efforts underway to help <bpt id=\"p10\">[</bpt>clients discover how to properly authorize requests to a resource server<ept id=\"p10\">](http://tools.ietf.org/html/draft-jones-oauth-discovery-00)</ept>.",
          "pos": [
            542,
            763
          ]
        }
      ]
    },
    {
      "pos": [
        9161,
        9175
      ],
      "content": "Final solution"
    },
    {
      "pos": [
        9176,
        9237
      ],
      "content": "Putting all the pieces together, we get the following policy:"
    },
    {
      "pos": [
        10893,
        11096
      ],
      "content": "This is only one of many examples of how the <ph id=\"ph38\">`send-request`</ph><ph id=\"ph39\"/> policy can be used to integrate useful external services into the process of requests and responses flowing through the API Management service."
    },
    {
      "pos": [
        11101,
        11121
      ],
      "content": "Response Composition"
    },
    {
      "pos": [
        11122,
        11427
      ],
      "content": "The <ph id=\"ph40\">`send-request`</ph><ph id=\"ph41\"/> policy can be used for enhancing a primary request to a backend system, as we saw in the previous example, or it can be used as a complete replace for of the backend call. Using this technique we can easily create composite resources that are aggregated from multiple different systems.",
      "nodes": [
        {
          "content": "The <ph id=\"ph40\">`send-request`</ph><ph id=\"ph41\"/> policy can be used for enhancing a primary request to a backend system, as we saw in the previous example, or it can be used as a complete replace for of the backend call.",
          "pos": [
            0,
            224
          ]
        },
        {
          "content": "Using this technique we can easily create composite resources that are aggregated from multiple different systems.",
          "pos": [
            225,
            339
          ]
        }
      ]
    },
    {
      "pos": [
        11433,
        11453
      ],
      "content": "Building a dashboard"
    },
    {
      "pos": [
        11457,
        12078
      ],
      "content": "Sometimes you want to be able to expose information that exists in multiple backend systems, for example, to drive a dashboard. The KPIs come from all different back-ends, but you would prefer not to provide direct access to them and it would be nice if all the information could be retrieved in a single request. Perhaps some of the backend information needs some slicing and dicing and a little sanitizing first! Being able to cache that composite resource would be a useful to reduce the backend load as you know users have a habit of hammering the F5 key in order to see if their underperforming metrics might change.",
      "nodes": [
        {
          "content": "Sometimes you want to be able to expose information that exists in multiple backend systems, for example, to drive a dashboard.",
          "pos": [
            0,
            127
          ]
        },
        {
          "content": "The KPIs come from all different back-ends, but you would prefer not to provide direct access to them and it would be nice if all the information could be retrieved in a single request.",
          "pos": [
            128,
            313
          ]
        },
        {
          "content": "Perhaps some of the backend information needs some slicing and dicing and a little sanitizing first!",
          "pos": [
            314,
            414
          ]
        },
        {
          "content": "Being able to cache that composite resource would be a useful to reduce the backend load as you know users have a habit of hammering the F5 key in order to see if their underperforming metrics might change.",
          "pos": [
            415,
            621
          ]
        }
      ]
    },
    {
      "pos": [
        12088,
        12107
      ],
      "content": "Faking the resource"
    },
    {
      "pos": [
        12108,
        12338
      ],
      "content": "The first step to building our dashboard resource is to configure a new operation in the API Management publisher portal. This will be a placeholder operation used to configure our composition policy to build our dynamic resource.",
      "nodes": [
        {
          "content": "The first step to building our dashboard resource is to configure a new operation in the API Management publisher portal.",
          "pos": [
            0,
            121
          ]
        },
        {
          "content": "This will be a placeholder operation used to configure our composition policy to build our dynamic resource.",
          "pos": [
            122,
            230
          ]
        }
      ]
    },
    {
      "pos": [
        12340,
        12445
      ],
      "content": "<ph id=\"ph42\">![</ph>Dashboard operation<ph id=\"ph43\">](./media/api-management-sample-send-request/api-management-dashboard-operation.png)</ph>"
    },
    {
      "pos": [
        12451,
        12470
      ],
      "content": "Making the requests"
    },
    {
      "pos": [
        12471,
        12577
      ],
      "content": "Once the <ph id=\"ph44\">`dashboard`</ph><ph id=\"ph45\"/> operation has been created we can configure a policy specifically for that operation."
    },
    {
      "pos": [
        12580,
        12682
      ],
      "content": "<ph id=\"ph46\">![</ph>Dashboard operation<ph id=\"ph47\">](./media/api-management-sample-send-request/api-management-dashboard-policy.png)</ph>"
    },
    {
      "pos": [
        12684,
        13024
      ],
      "content": "The first step  is to extract any query parameters from the incoming request, so that we can forward them to our backend. In this example our dashboard is showing information based on a period of time an therefore has a <ph id=\"ph48\">`fromDate`</ph><ph id=\"ph49\"/> and <ph id=\"ph50\">`toDate`</ph><ph id=\"ph51\"/> parameter. We can use the <ph id=\"ph52\">`set-variable`</ph><ph id=\"ph53\"/> policy to extract the information from the request URL.",
      "nodes": [
        {
          "content": "The first step  is to extract any query parameters from the incoming request, so that we can forward them to our backend.",
          "pos": [
            0,
            121
          ]
        },
        {
          "content": "In this example our dashboard is showing information based on a period of time an therefore has a <ph id=\"ph48\">`fromDate`</ph><ph id=\"ph49\"/> and <ph id=\"ph50\">`toDate`</ph><ph id=\"ph51\"/> parameter.",
          "pos": [
            122,
            322
          ]
        },
        {
          "content": "We can use the <ph id=\"ph52\">`set-variable`</ph><ph id=\"ph53\"/> policy to extract the information from the request URL.",
          "pos": [
            323,
            442
          ]
        }
      ]
    },
    {
      "pos": [
        13205,
        13427
      ],
      "content": "Once we have this information we can make requests to all the backend systems. Each request constructs a new URL with the parameter information and calls its respective server and stores the response in a context variable.",
      "nodes": [
        {
          "content": "Once we have this information we can make requests to all the backend systems.",
          "pos": [
            0,
            78
          ]
        },
        {
          "content": "Each request constructs a new URL with the parameter information and calls its respective server and stores the response in a context variable.",
          "pos": [
            79,
            222
          ]
        }
      ]
    },
    {
      "pos": [
        14692,
        14888
      ],
      "content": "These requests will execute in sequence, which is not ideal. In an upcoming release we will be introducing a new policy called <ph id=\"ph54\">`wait`</ph><ph id=\"ph55\"/> that will enable all of these requests to execute in parallel.",
      "nodes": [
        {
          "content": "These requests will execute in sequence, which is not ideal.",
          "pos": [
            0,
            60
          ]
        },
        {
          "content": "In an upcoming release we will be introducing a new policy called <ph id=\"ph54\">`wait`</ph><ph id=\"ph55\"/> that will enable all of these requests to execute in parallel.",
          "pos": [
            61,
            230
          ]
        }
      ]
    },
    {
      "pos": [
        14894,
        14904
      ],
      "content": "Responding"
    },
    {
      "pos": [
        14906,
        15190
      ],
      "content": "To construct the composite response we can use the <bpt id=\"p11\">[</bpt>return-response<ept id=\"p11\">](https://msdn.microsoft.com/library/azure/dn894085.aspx#ReturnResponse)</ept><ph id=\"ph56\"/> policy. The <ph id=\"ph57\">`set-body`</ph><ph id=\"ph58\"/> element can use an expression to construct a new <ph id=\"ph59\">`JObject`</ph><ph id=\"ph60\"/> with all the component representations embedded as properties.",
      "nodes": [
        {
          "content": "To construct the composite response we can use the <bpt id=\"p11\">[</bpt>return-response<ept id=\"p11\">](https://msdn.microsoft.com/library/azure/dn894085.aspx#ReturnResponse)</ept><ph id=\"ph56\"/> policy.",
          "pos": [
            0,
            202
          ]
        },
        {
          "content": "The <ph id=\"ph57\">`set-body`</ph><ph id=\"ph58\"/> element can use an expression to construct a new <ph id=\"ph59\">`JObject`</ph><ph id=\"ph60\"/> with all the component representations embedded as properties.",
          "pos": [
            203,
            407
          ]
        }
      ]
    },
    {
      "pos": [
        16006,
        16043
      ],
      "content": "The complete policy looks as follows:"
    },
    {
      "pos": [
        18608,
        18907
      ],
      "content": "In the configuration of the placeholder operation we can configure the dashboard resource to be cached for at least an hour because we understand the nature of the data means that even if it is an hour out of date, it will still be sufficiently effective to convey valuable information to the users."
    },
    {
      "pos": [
        18912,
        18919
      ],
      "content": "Summary"
    },
    {
      "pos": [
        18920,
        19317
      ],
      "content": "Azure API Management service provides flexible policies that can be selectively applied to HTTP traffic and enables composition of backend services. Whether you want to enhance your API gateway with alerting functions, verification, validation capabilities or create new composite resources based on multiple backend services, the <ph id=\"ph61\">`send-request`</ph><ph id=\"ph62\"/> and related policies open a world of possibilities.",
      "nodes": [
        {
          "content": "Azure API Management service provides flexible policies that can be selectively applied to HTTP traffic and enables composition of backend services.",
          "pos": [
            0,
            148
          ]
        },
        {
          "content": "Whether you want to enhance your API gateway with alerting functions, verification, validation capabilities or create new composite resources based on multiple backend services, the <ph id=\"ph61\">`send-request`</ph><ph id=\"ph62\"/> and related policies open a world of possibilities.",
          "pos": [
            149,
            431
          ]
        }
      ]
    },
    {
      "pos": [
        19322,
        19362
      ],
      "content": "Watch a video overview of these policies"
    },
    {
      "pos": [
        19363,
        19733
      ],
      "content": "For more information on the <bpt id=\"p12\">[</bpt>send-one-way-request<ept id=\"p12\">](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendOneWayRequest)</ept>, <bpt id=\"p13\">[</bpt>send-request<ept id=\"p13\">](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendRequest)</ept>, and <bpt id=\"p14\">[</bpt>return-response<ept id=\"p14\">](https://msdn.microsoft.com/library/azure/dn894085.aspx#ReturnResponse)</ept><ph id=\"ph63\"/> policies covered in this article, please watch the following video."
    }
  ],
  "content": "<properties\n   pageTitle=\"Using API Management service to generate HTTP requests\"\n   description=\"Learn to use request and response policies in API Management to call external services from your API\"\n   services=\"api-management\"\n   documentationCenter=\"\"\n   authors=\"darrelmiller\"\n   manager=\"\"\n   editor=\"\"/>\n\n<tags\n   ms.service=\"api-management\"\n   ms.devlang=\"dotnet\"\n   ms.topic=\"article\"\n   ms.tgt_pltfrm=\"na\"\n   ms.workload=\"na\"\n   ms.date=\"02/01/2016\"\n   ms.author=\"v-darmi\"/>\n\n\n# Using external services from the Azure API Management service\n\nThe policies available in Azure API Management service can do a wide range of useful work based purely on the incoming request, the outgoing response and basic configuration information. However, being able to interact with external services from API Management policies opens up many more opportunities.\n\nWe have previously seen how we can interact with the [Azure Event Hub service for logging, monitoring and analytics](api-management-log-to-eventhub-sample.md). In this article we will demonstrate policies that allow you to interact with any external HTTP based service. These policies can be used for triggering remote events or for retrieving information that will be used to manipulate the original request and response in some way.\n\n## Send-One-Way-Request\nPossibly the simplest external interaction is the fire-and-forget style of request that allows an external service to be notified of some kind of important event. We can use the control flow policy `choose` to detect any kind of condition that we are interested in and then, if the condition is satisfied, we can make an external HTTP request using the [send-one-way-request](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendOneWayRequest) policy. This could be a request to a messaging system like Hipchat or Slack, or a mail API like SendGrid or MailChimp, or for critical support incidents something like PagerDuty. All of these messaging systems have simple HTTP APIs that we can easily invoke.\n\n### Alerting with Slack\nThe following example demonstrates how to send a message to a Slack chat room if the HTTP response status code is greater than or equal to 500. A 500 range error indicates a problem with our backend API that the client of our API cannot resolve themselves. It usually requires some kind of intervention on our part.  \n\n    <choose>\n        <when condition=\"@(context.Response.StatusCode >= 500)\">\n          <send-one-way-request mode=\"new\">\n            <set-url>https://hooks.slack.com/services/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</set-url>\n            <set-method>POST</set-method>\n            <set-body>@{\n                    return new JObject(\n                            new JProperty(\"username\",\"APIM Alert\"),\n                            new JProperty(\"icon_emoji\", \":ghost:\"),\n                            new JProperty(\"text\", String.Format(\"{0} {1}\\nHost: {2}\\n{3} {4}\\n User: {5}\",\n                                                    context.Request.Method,\n                                                    context.Request.Url.Path + context.Request.Url.QueryString,\n                                                    context.Request.Url.Host,\n                                                    context.Response.StatusCode,\n                                                    context.Response.StatusReason,\n                                                    context.User.Email\n                                                    ))\n                            ).ToString();\n                }</set-body>\n          </send-one-way-request>\n        </when>\n    </choose>\n\nSlack has the notion of inbound web hooks. When configuring an inbound web hook, Slack generates a special URL which allows you to do a simple POST request and to pass a message into the Slack channel. The JSON body that we create is based on a format defined by Slack.\n\n![Slack Web Hook](./media/api-management-sample-send-request/api-management-slack-webhook.png)\n\n### Is fire and forget good enough?\nThere are certain tradeoffs when using a fire-and-forget style of request. If for some reason, the request fails, then the failure will not be reported. In this particular situation, the complexity of having a secondary failure reporting system and the additional performance cost of waiting for the response is not warranted. For scenarios where it is essential to check the response, then the [send-request](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendRequest) policy is a better option.\n\n## Send-Request\nThe `send-request` policy enables using an external service to perform complex processing functions and return data to the API management service that can be used for further policy processing.\n\n### Authorizing reference tokens\nA major function of API Management is protecting backend resources. If the authorization server used by your API creates [JWT tokens](http://jwt.io/) as part of its OAuth2 flow, as [Azure Active Directory](../active-directory/active-directory-aadconnect.md) does, then you can use the `validate-jwt` policy to verify the validity of the token. However, some authorization servers create what are called [reference tokens](http://leastprivilege.com/2015/11/25/reference-tokens-and-introspection/) that cannot be verified without making a call back to the authorization server.\n\n### Standardized introspection\nIn the past there has been no standardized way of verifying a reference token with an authorization server. However a recently proposed standard [RFC 7662](https://tools.ietf.org/html/rfc7662) was published by the IETF that defines how a resource server can verify the validity of a token.\n\n### Extracting the token\nThe first step is to extract the token from the Authorization header. The header value should be formatted with the `Bearer` authorization scheme, a single space and then the authorization token as per [RFC 6750](http://tools.ietf.org/html/rfc6750#section-2.1). Unfortunately there are cases where the authorization scheme is omitted. To account for this when parsing, we split the header value on a space and select the last string from the returned array of strings. This provides a workaround for badly formatted authorization headers.\n\n    <set-variable name=\"token\" value=\"@(context.Request.Headers.GetValueOrDefault(\"Authorization\",\"scheme param\").Split(' ').Last())\" />\n\n### Making the validation request\nOnce we have the authorization token, we can make the request to validate the token. RFC 7662 calls this process introspection and requires that you `POST` a HTML form to the introspection resource. The HTML form must at least contain a key/value pair with the key `token`. This request to the authorization server must also be authenticated to ensure that malicious clients cannot go trawling for valid tokens.\n\n    <send-request mode=\"new\" response-variable-name=\"tokenstate\" timeout=\"20\" ignore-error=\"true\">\n      <set-url>https://microsoft-apiappec990ad4c76641c6aea22f566efc5a4e.azurewebsites.net/introspection</set-url>\n      <set-method>POST</set-method>\n      <set-header name=\"Authorization\" exists-action=\"override\">\n        <value>basic dXNlcm5hbWU6cGFzc3dvcmQ=</value>\n      </set-header>\n      <set-header name=\"Content-Type\" exists-action=\"override\">\n        <value>application/x-www-form-urlencoded</value>\n      </set-header>\n      <set-body>@($\"token={(string)context.Variables[\"token\"]}\")</set-body>\n    </send-request>\n\n### Checking the response\nThe `response-variable-name` attribute is used to give access the returned response. The name defined in this property can be used as a key into the `context.Variables` dictionary to access the `IResponse` object.\n\nFrom the response object we can retrieve the body and RFC 7622 tells us that the response must be a JSON object and must contain at least a property called `active` that is a boolean value. When `active` is true then the token is considered valid.\n\n### Reporting failure\nWe use a `<choose>` policy to detect if the token is invalid and if so, return a 401 response.\n\n    <choose>\n      <when condition=\"@((bool)((IResponse)context.Variables[\"tokenstate\"]).Body.As<JObject>()[\"active\"] == false)\">\n        <return-response response-variable-name=\"existing response variable\">\n          <set-status code=\"401\" reason=\"Unauthorized\" />\n          <set-header name=\"WWW-Authenticate\" exists-action=\"override\">\n            <value>Bearer error=\"invalid_token\"</value>\n          </set-header>\n        </return-response>\n      </when>\n    </choose>\n\nAs per [RFC 6750](https://tools.ietf.org/html/rfc6750#section-3) which describes how `bearer` tokens should be used, we also return a `WWW-Authenticate` header with the 401 response. The WWW-Authenticate is intended to instruct a client on how to construct a properly authorized request. Due to the wide variety of approaches possible with the OAuth2 framework, it is difficult to communicate all the needed information. Fortunately there are efforts underway to help [clients discover how to properly authorize requests to a resource server](http://tools.ietf.org/html/draft-jones-oauth-discovery-00).\n\n### Final solution\nPutting all the pieces together, we get the following policy:\n\n    <inbound>\n      <!-- Extract Token from Authorization header parameter -->\n      <set-variable name=\"token\" value=\"@(context.Request.Headers.GetValueOrDefault(\"Authorization\",\"scheme param\").Split(' ').Last())\" />\n\n      <!-- Send request to Token Server to validate token (see RFC 7662) -->\n      <send-request mode=\"new\" response-variable-name=\"tokenstate\" timeout=\"20\" ignore-error=\"true\">\n        <set-url>https://microsoft-apiappec990ad4c76641c6aea22f566efc5a4e.azurewebsites.net/introspection</set-url>\n        <set-method>POST</set-method>\n        <set-header name=\"Authorization\" exists-action=\"override\">\n          <value>basic dXNlcm5hbWU6cGFzc3dvcmQ=</value>\n        </set-header>\n        <set-header name=\"Content-Type\" exists-action=\"override\">\n          <value>application/x-www-form-urlencoded</value>\n        </set-header>\n        <set-body>@($\"token={(string)context.Variables[\"token\"]}\")</set-body>\n      </send-request>\n\n      <choose>\n            <!-- Check active property in response -->\n            <when condition=\"@((bool)((IResponse)context.Variables[\"tokenstate\"]).Body.As<JObject>()[\"active\"] == false)\">\n                <!-- Return 401 Unauthorized with http-problem payload -->\n                <return-response response-variable-name=\"existing response variable\">\n                    <set-status code=\"401\" reason=\"Unauthorized\" />\n                    <set-header name=\"WWW-Authenticate\" exists-action=\"override\">\n                        <value>Bearer error=\"invalid_token\"</value>\n                    </set-header>\n                </return-response>\n            </when>\n        </choose>\n      <base />\n    </inbound>\n\nThis is only one of many examples of how the `send-request` policy can be used to integrate useful external services into the process of requests and responses flowing through the API Management service.\n\n## Response Composition\nThe `send-request` policy can be used for enhancing a primary request to a backend system, as we saw in the previous example, or it can be used as a complete replace for of the backend call. Using this technique we can easily create composite resources that are aggregated from multiple different systems.\n\n### Building a dashboard   \nSometimes you want to be able to expose information that exists in multiple backend systems, for example, to drive a dashboard. The KPIs come from all different back-ends, but you would prefer not to provide direct access to them and it would be nice if all the information could be retrieved in a single request. Perhaps some of the backend information needs some slicing and dicing and a little sanitizing first! Being able to cache that composite resource would be a useful to reduce the backend load as you know users have a habit of hammering the F5 key in order to see if their underperforming metrics might change.    \n\n### Faking the resource\nThe first step to building our dashboard resource is to configure a new operation in the API Management publisher portal. This will be a placeholder operation used to configure our composition policy to build our dynamic resource.\n\n![Dashboard operation](./media/api-management-sample-send-request/api-management-dashboard-operation.png)\n\n### Making the requests\nOnce the `dashboard` operation has been created we can configure a policy specifically for that operation. \n\n![Dashboard operation](./media/api-management-sample-send-request/api-management-dashboard-policy.png)\n\nThe first step  is to extract any query parameters from the incoming request, so that we can forward them to our backend. In this example our dashboard is showing information based on a period of time an therefore has a `fromDate` and `toDate` parameter. We can use the `set-variable` policy to extract the information from the request URL.\n\n    <set-variable name=\"fromDate\" value=\"@(context.Request.Url.Query[\"fromDate\"].Last())\">\n    <set-variable name=\"toDate\" value=\"@(context.Request.Url.Query[\"toDate\"].Last())\">\n\nOnce we have this information we can make requests to all the backend systems. Each request constructs a new URL with the parameter information and calls its respective server and stores the response in a context variable.\n\n    <send-request mode=\"new\" response-variable-name=\"revenuedata\" timeout=\"20\" ignore-error=\"true\">\n      <set-url>@($\"https://accounting.acme.com/salesdata?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\n      <set-method>GET</set-method>\n    </send-request>\n\n    <send-request mode=\"new\" response-variable-name=\"materialdata\" timeout=\"20\" ignore-error=\"true\">\n      <set-url>@($\"https://inventory.acme.com/materiallevels?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\n      <set-method>GET</set-method>\n    </send-request>\n\n    <send-request mode=\"new\" response-variable-name=\"throughputdata\" timeout=\"20\" ignore-error=\"true\">\n    <set-url>@($\"https://production.acme.com/throughput?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\n      <set-method>GET</set-method>\n    </send-request>\n\n    <send-request mode=\"new\" response-variable-name=\"accidentdata\" timeout=\"20\" ignore-error=\"true\">\n    <set-url>@($\"https://production.acme.com/throughput?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\n      <set-method>GET</set-method>\n    </send-request>\n\nThese requests will execute in sequence, which is not ideal. In an upcoming release we will be introducing a new policy called `wait` that will enable all of these requests to execute in parallel.\n\n### Responding\n\nTo construct the composite response we can use the [return-response](https://msdn.microsoft.com/library/azure/dn894085.aspx#ReturnResponse) policy. The `set-body` element can use an expression to construct a new `JObject` with all the component representations embedded as properties.\n\n    <return-response response-variable-name=\"existing response variable\">\n      <set-status code=\"200\" reason=\"OK\" />\n      <set-header name=\"Content-Type\" exists-action=\"override\">\n        <value>application/json</value>\n      </set-header>\n      <set-body>\n        @(new JObject(new JProperty(\"revenuedata\",((IResponse)context.Variables[\"revenuedata\"]).Body.As<JObject>()),\n                      new JProperty(\"materialdata\",((IResponse)context.Variables[\"materialdata\"]).Body.As<JObject>()),\n                      new JProperty(\"throughputdata\",((IResponse)context.Variables[\"throughputdata\"]).Body.As<JObject>()),\n                      new JProperty(\"accidentdata\",((IResponse)context.Variables[\"accidentdata\"]).Body.As<JObject>())\n                      ).ToString())\n      </set-body>\n    </return-response>\n\nThe complete policy looks as follows:\n\n    <policies>\n        <inbound>\n\n      <set-variable name=\"fromDate\" value=\"@(context.Request.Url.Query[\"fromDate\"].Last())\">\n      <set-variable name=\"toDate\" value=\"@(context.Request.Url.Query[\"toDate\"].Last())\">\n\n        <send-request mode=\"new\" response-variable-name=\"revenuedata\" timeout=\"20\" ignore-error=\"true\">\n          <set-url>@($\"https://accounting.acme.com/salesdata?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\n          <set-method>GET</set-method>\n        </send-request>\n\n        <send-request mode=\"new\" response-variable-name=\"materialdata\" timeout=\"20\" ignore-error=\"true\">\n          <set-url>@($\"https://inventory.acme.com/materiallevels?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\n          <set-method>GET</set-method>\n        </send-request>\n\n        <send-request mode=\"new\" response-variable-name=\"throughputdata\" timeout=\"20\" ignore-error=\"true\">\n        <set-url>@($\"https://production.acme.com/throughput?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\n          <set-method>GET</set-method>\n        </send-request>\n\n        <send-request mode=\"new\" response-variable-name=\"accidentdata\" timeout=\"20\" ignore-error=\"true\">\n        <set-url>@($\"https://production.acme.com/throughput?from={(string)context.Variables[\"fromDate\"]}&to={(string)context.Variables[\"fromDate\"]}\")\"</set-url>\n          <set-method>GET</set-method>\n        </send-request>\n\n        <return-response response-variable-name=\"existing response variable\">\n          <set-status code=\"200\" reason=\"OK\" />\n          <set-header name=\"Content-Type\" exists-action=\"override\">\n            <value>application/json</value>\n          </set-header>\n          <set-body>\n            @(new JObject(new JProperty(\"revenuedata\",((IResponse)context.Variables[\"revenuedata\"]).Body.As<JObject>()),\n                          new JProperty(\"materialdata\",((IResponse)context.Variables[\"materialdata\"]).Body.As<JObject>()),\n                          new JProperty(\"throughputdata\",((IResponse)context.Variables[\"throughputdata\"]).Body.As<JObject>()),\n                          new JProperty(\"accidentdata\",((IResponse)context.Variables[\"accidentdata\"]).Body.As<JObject>())\n                          ).ToString())\n          </set-body>\n        </return-response>\n        </inbound>\n        <backend>\n            <base />\n        </backend>\n        <outbound>\n            <base />\n        </outbound>\n    </policies>\n\nIn the configuration of the placeholder operation we can configure the dashboard resource to be cached for at least an hour because we understand the nature of the data means that even if it is an hour out of date, it will still be sufficiently effective to convey valuable information to the users.\n\n## Summary\nAzure API Management service provides flexible policies that can be selectively applied to HTTP traffic and enables composition of backend services. Whether you want to enhance your API gateway with alerting functions, verification, validation capabilities or create new composite resources based on multiple backend services, the `send-request` and related policies open a world of possibilities.\n\n## Watch a video overview of these policies\nFor more information on the [send-one-way-request](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendOneWayRequest), [send-request](https://msdn.microsoft.com/library/azure/dn894085.aspx#SendRequest), and [return-response](https://msdn.microsoft.com/library/azure/dn894085.aspx#ReturnResponse) policies covered in this article, please watch the following video.\n\n> [AZURE.VIDEO send-request-and-return-response-policies]\n"
}