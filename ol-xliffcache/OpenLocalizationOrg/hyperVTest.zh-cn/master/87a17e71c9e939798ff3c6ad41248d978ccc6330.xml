{
  "nodes": [
    {
      "pos": [
        27,
        129
      ],
      "content": "Build a service using an existing SQL database with the Mobile Services .NET backend | Microsoft Azure"
    },
    {
      "pos": [
        148,
        246
      ],
      "content": "Learn how to use an existing cloud or on-premises SQL database with your .NET based mobile service"
    },
    {
      "pos": [
        567,
        651
      ],
      "content": "Build a service using an existing SQL database with the Mobile Services .NET backend"
    },
    {
      "pos": [
        756,
        762
      ],
      "content": "&amp;nbsp;"
    },
    {
      "pos": [
        765,
        1224
      ],
      "content": "The Mobile Services .NET backend makes it easy to take advantage of existing assets in building a mobile service. One particularly interesting scenario is using an existing SQL database (either on-premises or in the cloud), that may already be used by other applications, to make existing data available to mobile clients. In this case it's a requirement that database model (or <bpt id=\"p1\">*</bpt>schema<ept id=\"p1\">*</ept>) remain unchanged, in order for existing solutions to continue working.",
      "nodes": [
        {
          "content": "The Mobile Services .NET backend makes it easy to take advantage of existing assets in building a mobile service.",
          "pos": [
            0,
            113
          ]
        },
        {
          "content": "One particularly interesting scenario is using an existing SQL database (either on-premises or in the cloud), that may already be used by other applications, to make existing data available to mobile clients.",
          "pos": [
            114,
            322
          ]
        },
        {
          "content": "In this case it's a requirement that database model (or <bpt id=\"p1\">*</bpt>schema<ept id=\"p1\">*</ept>) remain unchanged, in order for existing solutions to continue working.",
          "pos": [
            323,
            497
          ]
        }
      ]
    },
    {
      "pos": [
        1258,
        1295
      ],
      "content": "Exploring the existing database model"
    },
    {
      "pos": [
        1297,
        1796
      ],
      "content": "For this tutorial we will use the database that was created with your mobile service, but we will not use the default model that is created. Instead, we will manually create an arbitrary model that will represent an existing application that you may have. For full details about how to connect to an on-premises database instead, check out <bpt id=\"p2\">[</bpt>Connect to an on-premises SQL Server from an Azure mobile service using Hybrid Connections<ept id=\"p2\">](mobile-services-dotnet-backend-hybrid-connections-get-started.md)</ept>.",
      "nodes": [
        {
          "content": "For this tutorial we will use the database that was created with your mobile service, but we will not use the default model that is created.",
          "pos": [
            0,
            140
          ]
        },
        {
          "content": "Instead, we will manually create an arbitrary model that will represent an existing application that you may have.",
          "pos": [
            141,
            255
          ]
        },
        {
          "content": "For full details about how to connect to an on-premises database instead, check out <bpt id=\"p2\">[</bpt>Connect to an on-premises SQL Server from an Azure mobile service using Hybrid Connections<ept id=\"p2\">](mobile-services-dotnet-backend-hybrid-connections-get-started.md)</ept>.",
          "pos": [
            256,
            537
          ]
        }
      ]
    },
    {
      "pos": [
        1801,
        2149
      ],
      "content": "Start by creating a Mobile Services server project in <bpt id=\"p3\">**</bpt>Visual Studio 2013 Update 2<ept id=\"p3\">**</ept><ph id=\"ph5\"/> or by using the quickstart project that you can download on the Mobile Services tab for your service in the <bpt id=\"p4\">[</bpt>Azure classic portal<ept id=\"p4\">](http://manage.windowsazure.com)</ept>. For the purposes of this tutorial, we will assume your server project name is <bpt id=\"p5\">**</bpt>ShoppingService<ept id=\"p5\">**</ept>.",
      "nodes": [
        {
          "content": "Start by creating a Mobile Services server project in <bpt id=\"p3\">**</bpt>Visual Studio 2013 Update 2<ept id=\"p3\">**</ept><ph id=\"ph5\"/> or by using the quickstart project that you can download on the Mobile Services tab for your service in the <bpt id=\"p4\">[</bpt>Azure classic portal<ept id=\"p4\">](http://manage.windowsazure.com)</ept>.",
          "pos": [
            0,
            339
          ]
        },
        {
          "content": "For the purposes of this tutorial, we will assume your server project name is <bpt id=\"p5\">**</bpt>ShoppingService<ept id=\"p5\">**</ept>.",
          "pos": [
            340,
            476
          ]
        }
      ]
    },
    {
      "pos": [
        2154,
        2355
      ],
      "content": "Create a <bpt id=\"p6\">**</bpt>Customer.cs<ept id=\"p6\">**</ept><ph id=\"ph6\"/> file inside the <bpt id=\"p7\">**</bpt>Models<ept id=\"p7\">**</ept><ph id=\"ph7\"/> folder and use the following implementation. You will need to add an assembly reference to <bpt id=\"p8\">**</bpt>System.ComponentModel.DataAnnotations<ept id=\"p8\">**</ept><ph id=\"ph8\"/> to your project.",
      "nodes": [
        {
          "content": "Create a <bpt id=\"p6\">**</bpt>Customer.cs<ept id=\"p6\">**</ept><ph id=\"ph6\"/> file inside the <bpt id=\"p7\">**</bpt>Models<ept id=\"p7\">**</ept><ph id=\"ph7\"/> folder and use the following implementation.",
          "pos": [
            0,
            200
          ]
        },
        {
          "content": "You will need to add an assembly reference to <bpt id=\"p8\">**</bpt>System.ComponentModel.DataAnnotations<ept id=\"p8\">**</ept><ph id=\"ph8\"/> to your project.",
          "pos": [
            201,
            357
          ]
        }
      ]
    },
    {
      "pos": [
        2777,
        2871
      ],
      "content": "Create an <bpt id=\"p9\">**</bpt>Order.cs<ept id=\"p9\">**</ept><ph id=\"ph9\"/> file inside the <bpt id=\"p10\">**</bpt>Models<ept id=\"p10\">**</ept><ph id=\"ph10\"/> folder and use the following implementation:"
    },
    {
      "pos": [
        3395,
        3630
      ],
      "content": "You will note that these two classes have a <bpt id=\"p11\">*</bpt>relationship<ept id=\"p11\">*</ept>: every <bpt id=\"p12\">**</bpt>Order<ept id=\"p12\">**</ept><ph id=\"ph11\"/> is associated with a single <bpt id=\"p13\">**</bpt>Customer<ept id=\"p13\">**</ept><ph id=\"ph12\"/> and a <bpt id=\"p14\">**</bpt>Customer<ept id=\"p14\">**</ept><ph id=\"ph13\"/> can be associated with multiple <bpt id=\"p15\">**</bpt>Orders<ept id=\"p15\">**</ept>. Having relationships is common in existing data models.",
      "nodes": [
        {
          "content": "You will note that these two classes have a <bpt id=\"p11\">*</bpt>relationship<ept id=\"p11\">*</ept>: every <bpt id=\"p12\">**</bpt>Order<ept id=\"p12\">**</ept><ph id=\"ph11\"/> is associated with a single <bpt id=\"p13\">**</bpt>Customer<ept id=\"p13\">**</ept><ph id=\"ph12\"/> and a <bpt id=\"p14\">**</bpt>Customer<ept id=\"p14\">**</ept><ph id=\"ph13\"/> can be associated with multiple <bpt id=\"p15\">**</bpt>Orders<ept id=\"p15\">**</ept>.",
          "pos": [
            0,
            424
          ]
        },
        {
          "content": "Having relationships is common in existing data models.",
          "pos": [
            425,
            480
          ]
        }
      ]
    },
    {
      "pos": [
        3635,
        3725
      ],
      "content": "Create an <bpt id=\"p16\">**</bpt>ExistingContext.cs<ept id=\"p16\">**</ept><ph id=\"ph14\"/> file inside the <bpt id=\"p17\">**</bpt>Models<ept id=\"p17\">**</ept><ph id=\"ph15\"/> folder and implement it as so:"
    },
    {
      "pos": [
        4165,
        4376
      ],
      "content": "The structure above approximates an existing Entity Framework model that you may already be using for an existing application. Please note that the model is not aware of Mobile Services in any way at this stage.",
      "nodes": [
        {
          "content": "The structure above approximates an existing Entity Framework model that you may already be using for an existing application.",
          "pos": [
            0,
            126
          ]
        },
        {
          "content": "Please note that the model is not aware of Mobile Services in any way at this stage.",
          "pos": [
            127,
            211
          ]
        }
      ]
    },
    {
      "pos": [
        4401,
        4462
      ],
      "content": "Creating data transfer objects (DTOs) for your mobile service"
    },
    {
      "pos": [
        4464,
        5097
      ],
      "content": "The data model you would like to use with your mobile service may be arbitrarily complex; it could contain hundreds of entities with a variety of relationships between them. When building a mobile app, it is usually desirable to simplify the data model and eliminate relationships (or handle them manually) in order to minimize the payload being sent back and forth between the app and the service. In this section, we will create a set of simplified objects (known as \"data transfer objects\" or \"DTOs\"), that are mapped to the data you have in your database, yet contain only the minimal set of properties needed by your mobile app.",
      "nodes": [
        {
          "content": "The data model you would like to use with your mobile service may be arbitrarily complex; it could contain hundreds of entities with a variety of relationships between them.",
          "pos": [
            0,
            173
          ]
        },
        {
          "content": "When building a mobile app, it is usually desirable to simplify the data model and eliminate relationships (or handle them manually) in order to minimize the payload being sent back and forth between the app and the service.",
          "pos": [
            174,
            398
          ]
        },
        {
          "content": "In this section, we will create a set of simplified objects (known as \"data transfer objects\" or \"DTOs\"), that are mapped to the data you have in your database, yet contain only the minimal set of properties needed by your mobile app.",
          "pos": [
            399,
            633
          ]
        }
      ]
    },
    {
      "pos": [
        5102,
        5231
      ],
      "content": "Create the <bpt id=\"p18\">**</bpt>MobileCustomer.cs<ept id=\"p18\">**</ept><ph id=\"ph18\"/> file in the <bpt id=\"p19\">**</bpt>DataObjects<ept id=\"p19\">**</ept><ph id=\"ph19\"/> folder of your service project and use the following implementation:"
    },
    {
      "pos": [
        5488,
        6123
      ],
      "content": "Note that this class is similar to the <bpt id=\"p20\">**</bpt>Customer<ept id=\"p20\">**</ept><ph id=\"ph20\"/> class in the model, except the relationship property to <bpt id=\"p21\">**</bpt>Order<ept id=\"p21\">**</ept><ph id=\"ph21\"/> is removed. For an object to work correctly with Mobile Services offline sync, it needs a set of <bpt id=\"p22\">*</bpt>system properties<ept id=\"p22\">*</ept><ph id=\"ph22\"/> for optimistic concurrency, so you will notice that the DTO inherits from <bpt id=\"p23\">[</bpt><bpt id=\"p24\">**</bpt>EntityData<ept id=\"p24\">**</ept><ept id=\"p23\">](http://msdn.microsoft.com/library/microsoft.windowsazure.mobile.service.entitydata.aspx)</ept>, which contains those properties. The int-based <bpt id=\"p25\">**</bpt>CustomerId<ept id=\"p25\">**</ept><ph id=\"ph23\"/> property from the original model is replaced by the string-based <bpt id=\"p26\">**</bpt>Id<ept id=\"p26\">**</ept><ph id=\"ph24\"/> property from <bpt id=\"p27\">**</bpt>EntityData<ept id=\"p27\">**</ept>, which will be the <bpt id=\"p28\">**</bpt>Id<ept id=\"p28\">**</ept><ph id=\"ph25\"/> that Mobile Services will use.",
      "nodes": [
        {
          "content": "Note that this class is similar to the <bpt id=\"p20\">**</bpt>Customer<ept id=\"p20\">**</ept><ph id=\"ph20\"/> class in the model, except the relationship property to <bpt id=\"p21\">**</bpt>Order<ept id=\"p21\">**</ept><ph id=\"ph21\"/> is removed.",
          "pos": [
            0,
            239
          ]
        },
        {
          "content": "For an object to work correctly with Mobile Services offline sync, it needs a set of <bpt id=\"p22\">*</bpt>system properties<ept id=\"p22\">*</ept><ph id=\"ph22\"/> for optimistic concurrency, so you will notice that the DTO inherits from <bpt id=\"p23\">[</bpt><bpt id=\"p24\">**</bpt>EntityData<ept id=\"p24\">**</ept><ept id=\"p23\">](http://msdn.microsoft.com/library/microsoft.windowsazure.mobile.service.entitydata.aspx)</ept>, which contains those properties.",
          "pos": [
            240,
            693
          ]
        },
        {
          "content": "The int-based <bpt id=\"p25\">**</bpt>CustomerId<ept id=\"p25\">**</ept><ph id=\"ph23\"/> property from the original model is replaced by the string-based <bpt id=\"p26\">**</bpt>Id<ept id=\"p26\">**</ept><ph id=\"ph24\"/> property from <bpt id=\"p27\">**</bpt>EntityData<ept id=\"p27\">**</ept>, which will be the <bpt id=\"p28\">**</bpt>Id<ept id=\"p28\">**</ept><ph id=\"ph25\"/> that Mobile Services will use.",
          "pos": [
            694,
            1085
          ]
        }
      ]
    },
    {
      "pos": [
        6128,
        6217
      ],
      "content": "Create the <bpt id=\"p29\">**</bpt>MobileOrder.cs<ept id=\"p29\">**</ept><ph id=\"ph26\"/> file in the <bpt id=\"p30\">**</bpt>DataObjects<ept id=\"p30\">**</ept><ph id=\"ph27\"/> folder of your service project."
    },
    {
      "pos": [
        6953,
        7217
      ],
      "content": "The <bpt id=\"p31\">**</bpt>Customer<ept id=\"p31\">**</ept><ph id=\"ph28\"/> relationship property has been replaced with the <bpt id=\"p32\">**</bpt>Customer<ept id=\"p32\">**</ept><ph id=\"ph29\"/> name and a <bpt id=\"p33\">**</bpt>MobileCustomerId<ept id=\"p33\">**</ept><ph id=\"ph30\"/> property that can be used to manually model the relationship on the client. For now you can ignore the <bpt id=\"p34\">**</bpt>CustomerId<ept id=\"p34\">**</ept><ph id=\"ph31\"/> property, it is only used later on.",
      "nodes": [
        {
          "content": "The <bpt id=\"p31\">**</bpt>Customer<ept id=\"p31\">**</ept><ph id=\"ph28\"/> relationship property has been replaced with the <bpt id=\"p32\">**</bpt>Customer<ept id=\"p32\">**</ept><ph id=\"ph29\"/> name and a <bpt id=\"p33\">**</bpt>MobileCustomerId<ept id=\"p33\">**</ept><ph id=\"ph30\"/> property that can be used to manually model the relationship on the client.",
          "pos": [
            0,
            351
          ]
        },
        {
          "content": "For now you can ignore the <bpt id=\"p34\">**</bpt>CustomerId<ept id=\"p34\">**</ept><ph id=\"ph31\"/> property, it is only used later on.",
          "pos": [
            352,
            484
          ]
        }
      ]
    },
    {
      "pos": [
        7222,
        7728
      ],
      "content": "You might notice that with the addition of the system properties on the <bpt id=\"p35\">**</bpt>EntityData<ept id=\"p35\">**</ept><ph id=\"ph32\"/> base class, our DTOs now have more properties than the model types. Clearly we need a place to store these properties, so we will add a few extra columns to the original database. While this does change the database, it will not break existing applications since the changes are purely additive (adding new columns to the schema). To do that, add the following statements to the top of <bpt id=\"p36\">**</bpt>Customer.cs<ept id=\"p36\">**</ept><ph id=\"ph33\"/> and <bpt id=\"p37\">**</bpt>Order.cs<ept id=\"p37\">**</ept>:",
      "nodes": [
        {
          "content": "You might notice that with the addition of the system properties on the <bpt id=\"p35\">**</bpt>EntityData<ept id=\"p35\">**</ept><ph id=\"ph32\"/> base class, our DTOs now have more properties than the model types.",
          "pos": [
            0,
            209
          ]
        },
        {
          "content": "Clearly we need a place to store these properties, so we will add a few extra columns to the original database.",
          "pos": [
            210,
            321
          ]
        },
        {
          "content": "While this does change the database, it will not break existing applications since the changes are purely additive (adding new columns to the schema).",
          "pos": [
            322,
            472
          ]
        },
        {
          "content": "To do that, add the following statements to the top of <bpt id=\"p36\">**</bpt>Customer.cs<ept id=\"p36\">**</ept><ph id=\"ph33\"/> and <bpt id=\"p37\">**</bpt>Order.cs<ept id=\"p37\">**</ept>:",
          "pos": [
            473,
            656
          ]
        }
      ]
    },
    {
      "pos": [
        7876,
        7932
      ],
      "content": "Next, add these extra properties to each of the classes:"
    },
    {
      "pos": [
        8611,
        8899
      ],
      "content": "The system properties just added have some built-in behaviors (for example automatic update of created/updated at) that happen transparently with database operations. To enable these behaviors, we need to make a change to <bpt id=\"p38\">**</bpt>ExistingContext.cs<ept id=\"p38\">**</ept>. At the top of the file, add the following:",
      "nodes": [
        {
          "content": "The system properties just added have some built-in behaviors (for example automatic update of created/updated at) that happen transparently with database operations.",
          "pos": [
            0,
            166
          ]
        },
        {
          "content": "To enable these behaviors, we need to make a change to <bpt id=\"p38\">**</bpt>ExistingContext.cs<ept id=\"p38\">**</ept>.",
          "pos": [
            167,
            285
          ]
        },
        {
          "content": "At the top of the file, add the following:",
          "pos": [
            286,
            328
          ]
        }
      ]
    },
    {
      "pos": [
        9057,
        9209
      ],
      "content": "In the body of <bpt id=\"p39\">**</bpt>ExistingContext<ept id=\"p39\">**</ept>, override <bpt id=\"p40\">[</bpt><bpt id=\"p41\">**</bpt>OnModelCreating<ept id=\"p41\">**</ept><ept id=\"p40\">](http://msdn.microsoft.com/library/system.data.entity.dbcontext.onmodelcreating.aspx)</ept>:"
    },
    {
      "pos": [
        9605,
        9840
      ],
      "content": "Let's populate the database with some example data. Open the file <bpt id=\"p42\">**</bpt>WebApiConfig.cs<ept id=\"p42\">**</ept>. Create a new <bpt id=\"p43\">[</bpt><bpt id=\"p44\">**</bpt>IDatabaseInitializer<ept id=\"p44\">**</ept><ept id=\"p43\">](http://msdn.microsoft.com/library/gg696323.aspx)</ept><ph id=\"ph34\"/> and configure it in the <bpt id=\"p45\">**</bpt>Register<ept id=\"p45\">**</ept><ph id=\"ph35\"/> method as shown below.",
      "nodes": [
        {
          "content": "Let's populate the database with some example data.",
          "pos": [
            0,
            51
          ]
        },
        {
          "content": "Open the file <bpt id=\"p42\">**</bpt>WebApiConfig.cs<ept id=\"p42\">**</ept>.",
          "pos": [
            52,
            126
          ]
        },
        {
          "content": "Create a new <bpt id=\"p43\">[</bpt><bpt id=\"p44\">**</bpt>IDatabaseInitializer<ept id=\"p44\">**</ept><ept id=\"p43\">](http://msdn.microsoft.com/library/gg696323.aspx)</ept><ph id=\"ph34\"/> and configure it in the <bpt id=\"p45\">**</bpt>Register<ept id=\"p45\">**</ept><ph id=\"ph35\"/> method as shown below.",
          "pos": [
            127,
            425
          ]
        }
      ]
    },
    {
      "pos": [
        12100,
        12145
      ],
      "content": "Establishing a mapping between DTOs and model"
    },
    {
      "pos": [
        12147,
        12481
      ],
      "content": "We now have the model types <bpt id=\"p46\">**</bpt>Customer<ept id=\"p46\">**</ept><ph id=\"ph38\"/> and <bpt id=\"p47\">**</bpt>Order<ept id=\"p47\">**</ept><ph id=\"ph39\"/> and the DTOs <bpt id=\"p48\">**</bpt>MobileCustomer<ept id=\"p48\">**</ept><ph id=\"ph40\"/> and <bpt id=\"p49\">**</bpt>MobileOrder<ept id=\"p49\">**</ept>, but we  need to instruct the backend to automatically transform between the two. Here Mobile Services relies on <bpt id=\"p50\">[</bpt><bpt id=\"p51\">**</bpt>AutoMapper<ept id=\"p51\">**</ept><ept id=\"p50\">](http://automapper.org/)</ept>, an object relational mapper, which is already referenced in the project.",
      "nodes": [
        {
          "content": "We now have the model types <bpt id=\"p46\">**</bpt>Customer<ept id=\"p46\">**</ept><ph id=\"ph38\"/> and <bpt id=\"p47\">**</bpt>Order<ept id=\"p47\">**</ept><ph id=\"ph39\"/> and the DTOs <bpt id=\"p48\">**</bpt>MobileCustomer<ept id=\"p48\">**</ept><ph id=\"ph40\"/> and <bpt id=\"p49\">**</bpt>MobileOrder<ept id=\"p49\">**</ept>, but we  need to instruct the backend to automatically transform between the two.",
          "pos": [
            0,
            393
          ]
        },
        {
          "content": "Here Mobile Services relies on <bpt id=\"p50\">[</bpt><bpt id=\"p51\">**</bpt>AutoMapper<ept id=\"p51\">**</ept><ept id=\"p50\">](http://automapper.org/)</ept>, an object relational mapper, which is already referenced in the project.",
          "pos": [
            394,
            619
          ]
        }
      ]
    },
    {
      "pos": [
        12486,
        12538
      ],
      "content": "Add the following to the top of <bpt id=\"p52\">**</bpt>WebApiConfig.cs<ept id=\"p52\">**</ept>:"
    },
    {
      "pos": [
        12613,
        12711
      ],
      "content": "To define the mapping, add the following to the <bpt id=\"p53\">**</bpt>Register<ept id=\"p53\">**</ept><ph id=\"ph41\"/> method of the <bpt id=\"p54\">**</bpt>WebApiConfig<ept id=\"p54\">**</ept><ph id=\"ph42\"/> class."
    },
    {
      "pos": [
        13174,
        13543
      ],
      "content": "AutoMapper will now map the objects to one another. All properties with corresponding names will be matched, for example <bpt id=\"p55\">**</bpt>MobileOrder.CustomerId<ept id=\"p55\">**</ept><ph id=\"ph43\"/> will get automatically mapped to <bpt id=\"p56\">**</bpt>Order.CustomerId<ept id=\"p56\">**</ept>. Custom mappings can be configured as shown above, where we map the <bpt id=\"p57\">**</bpt>MobileCustomerName<ept id=\"p57\">**</ept><ph id=\"ph44\"/> property to the <bpt id=\"p58\">**</bpt>Name<ept id=\"p58\">**</ept><ph id=\"ph45\"/> property of the <bpt id=\"p59\">**</bpt>Customer<ept id=\"p59\">**</ept><ph id=\"ph46\"/> relationship property.",
      "nodes": [
        {
          "content": "AutoMapper will now map the objects to one another.",
          "pos": [
            0,
            51
          ]
        },
        {
          "content": "All properties with corresponding names will be matched, for example <bpt id=\"p55\">**</bpt>MobileOrder.CustomerId<ept id=\"p55\">**</ept><ph id=\"ph43\"/> will get automatically mapped to <bpt id=\"p56\">**</bpt>Order.CustomerId<ept id=\"p56\">**</ept>.",
          "pos": [
            52,
            297
          ]
        },
        {
          "content": "Custom mappings can be configured as shown above, where we map the <bpt id=\"p57\">**</bpt>MobileCustomerName<ept id=\"p57\">**</ept><ph id=\"ph44\"/> property to the <bpt id=\"p58\">**</bpt>Name<ept id=\"p58\">**</ept><ph id=\"ph45\"/> property of the <bpt id=\"p59\">**</bpt>Customer<ept id=\"p59\">**</ept><ph id=\"ph46\"/> relationship property.",
          "pos": [
            298,
            629
          ]
        }
      ]
    },
    {
      "pos": [
        13577,
        13611
      ],
      "content": "Implementing domain-specific logic"
    },
    {
      "pos": [
        13613,
        14126
      ],
      "content": "The next step is to implement a <bpt id=\"p60\">[</bpt><bpt id=\"p61\">**</bpt>MappedEntityDomainManager<ept id=\"p61\">**</ept><ept id=\"p60\">](http://msdn.microsoft.com/library/dn643300.aspx)</ept>, which serves as an abstraction layer between our mapped data store and the controller which will serve HTTP traffic from our clients. We will be able to write our controller in the next section purely in terms of the DTOs and the <bpt id=\"p62\">**</bpt>MappedEntityDomainManager<ept id=\"p62\">**</ept><ph id=\"ph49\"/> we add here will handle the communication with the original data store, while also giving us a place to implement any logic specific to it.",
      "nodes": [
        {
          "content": "The next step is to implement a <bpt id=\"p60\">[</bpt><bpt id=\"p61\">**</bpt>MappedEntityDomainManager<ept id=\"p61\">**</ept><ept id=\"p60\">](http://msdn.microsoft.com/library/dn643300.aspx)</ept>, which serves as an abstraction layer between our mapped data store and the controller which will serve HTTP traffic from our clients.",
          "pos": [
            0,
            327
          ]
        },
        {
          "content": "We will be able to write our controller in the next section purely in terms of the DTOs and the <bpt id=\"p62\">**</bpt>MappedEntityDomainManager<ept id=\"p62\">**</ept><ph id=\"ph49\"/> we add here will handle the communication with the original data store, while also giving us a place to implement any logic specific to it.",
          "pos": [
            328,
            648
          ]
        }
      ]
    },
    {
      "pos": [
        14131,
        14252
      ],
      "content": "Add a <bpt id=\"p63\">**</bpt>MobileCustomerDomainManager.cs<ept id=\"p63\">**</ept><ph id=\"ph50\"/> to the <bpt id=\"p64\">**</bpt>Models<ept id=\"p64\">**</ept><ph id=\"ph51\"/> folder of your project. Paste in the following implementation:",
      "nodes": [
        {
          "content": "Add a <bpt id=\"p63\">**</bpt>MobileCustomerDomainManager.cs<ept id=\"p63\">**</ept><ph id=\"ph50\"/> to the <bpt id=\"p64\">**</bpt>Models<ept id=\"p64\">**</ept><ph id=\"ph51\"/> folder of your project.",
          "pos": [
            0,
            192
          ]
        },
        {
          "content": "Paste in the following implementation:",
          "pos": [
            193,
            231
          ]
        }
      ]
    },
    {
      "pos": [
        17900,
        18046
      ],
      "content": "An important part of this class is the <bpt id=\"p65\">**</bpt>GetKey<ept id=\"p65\">**</ept><ph id=\"ph52\"/> method where we indicate how to locate the ID property of the object in the original data model."
    },
    {
      "pos": [
        18051,
        18130
      ],
      "content": "Add a <bpt id=\"p66\">**</bpt>MobileOrderDomainManager.cs<ept id=\"p66\">**</ept><ph id=\"ph53\"/> to the <bpt id=\"p67\">**</bpt>Models<ept id=\"p67\">**</ept><ph id=\"ph54\"/> folder of your project:"
    },
    {
      "pos": [
        22581,
        23365
      ],
      "content": "In this case the <bpt id=\"p68\">**</bpt>InsertAsync<ept id=\"p68\">**</ept><ph id=\"ph55\"/> and <bpt id=\"p69\">**</bpt>UpdateAsync<ept id=\"p69\">**</ept><ph id=\"ph56\"/> methods are interesting; that's where we enforce the relationship that each <bpt id=\"p70\">**</bpt>Order<ept id=\"p70\">**</ept><ph id=\"ph57\"/> must have a valid associated <bpt id=\"p71\">**</bpt>Customer<ept id=\"p71\">**</ept>. In <bpt id=\"p72\">**</bpt>InsertAsync<ept id=\"p72\">**</ept><ph id=\"ph58\"/> you'll notice that we populate the <bpt id=\"p73\">**</bpt>MobileOrder.CustomerId<ept id=\"p73\">**</ept><ph id=\"ph59\"/> property, which maps to the <bpt id=\"p74\">**</bpt>Order.CustomerId<ept id=\"p74\">**</ept><ph id=\"ph60\"/> property. We get that value based by looking up the <bpt id=\"p75\">**</bpt>Customer<ept id=\"p75\">**</ept><ph id=\"ph61\"/> with the matching <bpt id=\"p76\">**</bpt>MobileOrder.MobileCustomerId<ept id=\"p76\">**</ept>. This is because by default the client is only aware of the Mobile Services ID (<bpt id=\"p77\">**</bpt>MobileOrder.MobileCustomerId<ept id=\"p77\">**</ept>) of the <bpt id=\"p78\">**</bpt>Customer<ept id=\"p78\">**</ept>, which is different than its actual primary key needed to set the foreign key (<bpt id=\"p79\">**</bpt>MobileOrder.CustomerId<ept id=\"p79\">**</ept>) from <bpt id=\"p80\">**</bpt>Order<ept id=\"p80\">**</ept><ph id=\"ph62\"/> to <bpt id=\"p81\">**</bpt>Customer<ept id=\"p81\">**</ept>. This is only used internally within the service to facilitate the insert operation.",
      "nodes": [
        {
          "content": "In this case the <bpt id=\"p68\">**</bpt>InsertAsync<ept id=\"p68\">**</ept><ph id=\"ph55\"/> and <bpt id=\"p69\">**</bpt>UpdateAsync<ept id=\"p69\">**</ept><ph id=\"ph56\"/> methods are interesting; that's where we enforce the relationship that each <bpt id=\"p70\">**</bpt>Order<ept id=\"p70\">**</ept><ph id=\"ph57\"/> must have a valid associated <bpt id=\"p71\">**</bpt>Customer<ept id=\"p71\">**</ept>.",
          "pos": [
            0,
            386
          ]
        },
        {
          "content": "In <bpt id=\"p72\">**</bpt>InsertAsync<ept id=\"p72\">**</ept><ph id=\"ph58\"/> you'll notice that we populate the <bpt id=\"p73\">**</bpt>MobileOrder.CustomerId<ept id=\"p73\">**</ept><ph id=\"ph59\"/> property, which maps to the <bpt id=\"p74\">**</bpt>Order.CustomerId<ept id=\"p74\">**</ept><ph id=\"ph60\"/> property.",
          "pos": [
            387,
            691
          ]
        },
        {
          "content": "We get that value based by looking up the <bpt id=\"p75\">**</bpt>Customer<ept id=\"p75\">**</ept><ph id=\"ph61\"/> with the matching <bpt id=\"p76\">**</bpt>MobileOrder.MobileCustomerId<ept id=\"p76\">**</ept>.",
          "pos": [
            692,
            893
          ]
        },
        {
          "content": "This is because by default the client is only aware of the Mobile Services ID (<bpt id=\"p77\">**</bpt>MobileOrder.MobileCustomerId<ept id=\"p77\">**</ept>) of the <bpt id=\"p78\">**</bpt>Customer<ept id=\"p78\">**</ept>, which is different than its actual primary key needed to set the foreign key (<bpt id=\"p79\">**</bpt>MobileOrder.CustomerId<ept id=\"p79\">**</ept>) from <bpt id=\"p80\">**</bpt>Order<ept id=\"p80\">**</ept><ph id=\"ph62\"/> to <bpt id=\"p81\">**</bpt>Customer<ept id=\"p81\">**</ept>.",
          "pos": [
            894,
            1380
          ]
        },
        {
          "content": "This is only used internally within the service to facilitate the insert operation.",
          "pos": [
            1381,
            1464
          ]
        }
      ]
    },
    {
      "pos": [
        23367,
        23440
      ],
      "content": "We are now ready to create controllers to expose our DTOs to our clients."
    },
    {
      "pos": [
        23471,
        23512
      ],
      "content": "Implementing a TableController using DTOs"
    },
    {
      "pos": [
        23517,
        23593
      ],
      "content": "In the <bpt id=\"p82\">**</bpt>Controllers<ept id=\"p82\">**</ept><ph id=\"ph65\"/> folder, add the file <bpt id=\"p83\">**</bpt>MobileCustomerController.cs<ept id=\"p83\">**</ept>:"
    },
    {
      "pos": [
        25494,
        25798
      ],
      "content": "You will note the use of the AuthorizeLevel attribute to restrict public access to the Insert/Update/Delete operations on the controller. For the purposes of this scenario, the list of Customers will be read-only, but we will allow the creation of new Orders and associating them with existing customers.",
      "nodes": [
        {
          "content": "You will note the use of the AuthorizeLevel attribute to restrict public access to the Insert/Update/Delete operations on the controller.",
          "pos": [
            0,
            137
          ]
        },
        {
          "content": "For the purposes of this scenario, the list of Customers will be read-only, but we will allow the creation of new Orders and associating them with existing customers.",
          "pos": [
            138,
            304
          ]
        }
      ]
    },
    {
      "pos": [
        25803,
        25876
      ],
      "content": "In the <bpt id=\"p84\">**</bpt>Controllers<ept id=\"p84\">**</ept><ph id=\"ph66\"/> folder, add the file <bpt id=\"p85\">**</bpt>MobileOrderController.cs<ept id=\"p85\">**</ept>:"
    },
    {
      "pos": [
        27698,
        27818
      ],
      "content": "You are now ready to run your service. Press <bpt id=\"p86\">**</bpt>F5<ept id=\"p86\">**</ept><ph id=\"ph67\"/> and use the test client built into the help page to modify the data.",
      "nodes": [
        {
          "content": "You are now ready to run your service.",
          "pos": [
            0,
            38
          ]
        },
        {
          "content": "Press <bpt id=\"p86\">**</bpt>F5<ept id=\"p86\">**</ept><ph id=\"ph67\"/> and use the test client built into the help page to modify the data.",
          "pos": [
            39,
            175
          ]
        }
      ]
    },
    {
      "pos": [
        27820,
        28270
      ],
      "content": "Please note that both controller implementations make exclusive use of the DTOs <bpt id=\"p87\">**</bpt>MobileCustomer<ept id=\"p87\">**</ept><ph id=\"ph68\"/> and <bpt id=\"p88\">**</bpt>MobileOrder<ept id=\"p88\">**</ept><ph id=\"ph69\"/> and are agnostic of the underlying model. These DTOs are readily serialized to JSON and can be used to exchange data with the  Mobile Services client SDK on all platforms. For example, building a Windows Store app, the corresponding client-side type would look as shown below. The type would be analogous on other client platforms.",
      "nodes": [
        {
          "content": "Please note that both controller implementations make exclusive use of the DTOs <bpt id=\"p87\">**</bpt>MobileCustomer<ept id=\"p87\">**</ept><ph id=\"ph68\"/> and <bpt id=\"p88\">**</bpt>MobileOrder<ept id=\"p88\">**</ept><ph id=\"ph69\"/> and are agnostic of the underlying model.",
          "pos": [
            0,
            270
          ]
        },
        {
          "content": "These DTOs are readily serialized to JSON and can be used to exchange data with the  Mobile Services client SDK on all platforms.",
          "pos": [
            271,
            400
          ]
        },
        {
          "content": "For example, building a Windows Store app, the corresponding client-side type would look as shown below.",
          "pos": [
            401,
            505
          ]
        },
        {
          "content": "The type would be analogous on other client platforms.",
          "pos": [
            506,
            560
          ]
        }
      ]
    },
    {
      "pos": [
        28815,
        28890
      ],
      "content": "As a next step, you can now build out the client app to access the service."
    }
  ],
  "content": "<properties\n    pageTitle=\"Build a service using an existing SQL database with the Mobile Services .NET backend | Microsoft Azure\"\n    description=\"Learn how to use an existing cloud or on-premises SQL database with your .NET based mobile service\"\n    services=\"mobile-services\"\n    documentationCenter=\"\"\n    authors=\"ggailey777\"\n    manager=\"dwrede\"\n    editor=\"mollybos\"/>\n\n<tags\n    ms.service=\"mobile-services\"\n    ms.workload=\"mobile\"\n    ms.tgt_pltfrm=\"na\"\n    ms.devlang=\"multiple\"\n    ms.topic=\"article\"\n    ms.date=\"11/09/2015\"\n    ms.author=\"glenga\"/>\n\n\n# Build a service using an existing SQL database with the Mobile Services .NET backend\n\n[AZURE.INCLUDE [mobile-service-note-mobile-apps](../../includes/mobile-services-note-mobile-apps.md)]\n\n&nbsp;\n\n\nThe Mobile Services .NET backend makes it easy to take advantage of existing assets in building a mobile service. One particularly interesting scenario is using an existing SQL database (either on-premises or in the cloud), that may already be used by other applications, to make existing data available to mobile clients. In this case it's a requirement that database model (or *schema*) remain unchanged, in order for existing solutions to continue working.\n\n<a name=\"ExistingModel\"></a>\n## Exploring the existing database model\n\nFor this tutorial we will use the database that was created with your mobile service, but we will not use the default model that is created. Instead, we will manually create an arbitrary model that will represent an existing application that you may have. For full details about how to connect to an on-premises database instead, check out [Connect to an on-premises SQL Server from an Azure mobile service using Hybrid Connections](mobile-services-dotnet-backend-hybrid-connections-get-started.md).\n\n1. Start by creating a Mobile Services server project in **Visual Studio 2013 Update 2** or by using the quickstart project that you can download on the Mobile Services tab for your service in the [Azure classic portal](http://manage.windowsazure.com). For the purposes of this tutorial, we will assume your server project name is **ShoppingService**.\n\n2. Create a **Customer.cs** file inside the **Models** folder and use the following implementation. You will need to add an assembly reference to **System.ComponentModel.DataAnnotations** to your project.\n\n        using System.Collections.Generic;\n        using System.ComponentModel.DataAnnotations;\n\n        namespace ShoppingService.Models\n        {\n            public class Customer\n            {\n                [Key]\n                public int CustomerId { get; set; }\n\n                public string Name { get; set; }\n\n                public virtual ICollection<Order> Orders { get; set; }\n\n            }\n        }\n\n3. Create an **Order.cs** file inside the **Models** folder and use the following implementation:\n\n        using System.ComponentModel.DataAnnotations;\n\n        namespace ShoppingService.Models\n        {\n            public class Order\n            {\n                [Key]\n                public int OrderId { get; set; }\n\n                public string Item { get; set; }\n\n                public int Quantity { get; set; }\n\n                public bool Completed { get; set; }\n\n                public int CustomerId { get; set; }\n\n                public virtual Customer Customer { get; set; }\n\n            }\n        }\n\n    You will note that these two classes have a *relationship*: every **Order** is associated with a single **Customer** and a **Customer** can be associated with multiple **Orders**. Having relationships is common in existing data models.\n\n4. Create an **ExistingContext.cs** file inside the **Models** folder and implement it as so:\n\n        using System.Data.Entity;\n\n        namespace ShoppingService.Models\n        {\n            public class ExistingContext : DbContext\n            {\n                public ExistingContext()\n                    : base(\"Name=MS_TableConnectionString\")\n                {\n                }\n\n                public DbSet<Customer> Customers { get; set; }\n\n                public DbSet<Order> Orders { get; set; }\n\n            }\n        }\n\nThe structure above approximates an existing Entity Framework model that you may already be using for an existing application. Please note that the model is not aware of Mobile Services in any way at this stage.\n\n<a name=\"DTOs\"></a>\n## Creating data transfer objects (DTOs) for your mobile service\n\nThe data model you would like to use with your mobile service may be arbitrarily complex; it could contain hundreds of entities with a variety of relationships between them. When building a mobile app, it is usually desirable to simplify the data model and eliminate relationships (or handle them manually) in order to minimize the payload being sent back and forth between the app and the service. In this section, we will create a set of simplified objects (known as \"data transfer objects\" or \"DTOs\"), that are mapped to the data you have in your database, yet contain only the minimal set of properties needed by your mobile app.\n\n1. Create the **MobileCustomer.cs** file in the **DataObjects** folder of your service project and use the following implementation:\n\n        using Microsoft.WindowsAzure.Mobile.Service;\n\n        namespace ShoppingService.DataObjects\n        {\n            public class MobileCustomer : EntityData\n            {\n                public string Name { get; set; }\n            }\n        }\n\n    Note that this class is similar to the **Customer** class in the model, except the relationship property to **Order** is removed. For an object to work correctly with Mobile Services offline sync, it needs a set of *system properties* for optimistic concurrency, so you will notice that the DTO inherits from [**EntityData**](http://msdn.microsoft.com/library/microsoft.windowsazure.mobile.service.entitydata.aspx), which contains those properties. The int-based **CustomerId** property from the original model is replaced by the string-based **Id** property from **EntityData**, which will be the **Id** that Mobile Services will use.\n\n2. Create the **MobileOrder.cs** file in the **DataObjects** folder of your service project.\n\n        using Microsoft.WindowsAzure.Mobile.Service;\n        using Newtonsoft.Json;\n        using System.ComponentModel.DataAnnotations;\n        using System.ComponentModel.DataAnnotations.Schema;\n\n        namespace ShoppingService.DataObjects\n        {\n            public class MobileOrder : EntityData\n            {\n                public string Item { get; set; }\n\n                public int Quantity { get; set; }\n\n                public bool Completed { get; set; }\n\n                [NotMapped]\n                public int CustomerId { get; set; }\n\n                [Required]\n                public string MobileCustomerId { get; set; }\n\n                public string MobileCustomerName { get; set; }\n            }\n        }\n\n    The **Customer** relationship property has been replaced with the **Customer** name and a **MobileCustomerId** property that can be used to manually model the relationship on the client. For now you can ignore the **CustomerId** property, it is only used later on.\n\n3. You might notice that with the addition of the system properties on the **EntityData** base class, our DTOs now have more properties than the model types. Clearly we need a place to store these properties, so we will add a few extra columns to the original database. While this does change the database, it will not break existing applications since the changes are purely additive (adding new columns to the schema). To do that, add the following statements to the top of **Customer.cs** and **Order.cs**:\n\n        using System.ComponentModel.DataAnnotations.Schema;\n        using Microsoft.WindowsAzure.Mobile.Service.Tables;\n        using System;\n\n4. Next, add these extra properties to each of the classes:\n\n        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]\n        [Index]\n        [TableColumn(TableColumnType.CreatedAt)]\n        public DateTimeOffset? CreatedAt { get; set; }\n\n        [TableColumn(TableColumnType.Deleted)]\n        public bool Deleted { get; set; }\n\n        [Index]\n        [TableColumn(TableColumnType.Id)]\n        [MaxLength(36)]\n        public string Id { get; set; }\n\n        [DatabaseGenerated(DatabaseGeneratedOption.Computed)]\n        [TableColumn(TableColumnType.UpdatedAt)]\n        public DateTimeOffset? UpdatedAt { get; set; }\n\n        [TableColumn(TableColumnType.Version)]\n        [Timestamp]\n        public byte[] Version { get; set; }\n\n4. The system properties just added have some built-in behaviors (for example automatic update of created/updated at) that happen transparently with database operations. To enable these behaviors, we need to make a change to **ExistingContext.cs**. At the top of the file, add the following:\n\n        using System.Data.Entity.ModelConfiguration.Conventions;\n        using Microsoft.WindowsAzure.Mobile.Service.Tables;\n        using System.Linq;\n\n5. In the body of **ExistingContext**, override [**OnModelCreating**](http://msdn.microsoft.com/library/system.data.entity.dbcontext.onmodelcreating.aspx):\n\n        protected override void OnModelCreating(DbModelBuilder modelBuilder)\n        {\n            modelBuilder.Conventions.Add(\n                new AttributeToColumnAnnotationConvention<TableColumnAttribute, string>(\n                    \"ServiceTableColumn\", (property, attributes) => attributes.Single().ColumnType.ToString()));\n\n            base.OnModelCreating(modelBuilder);\n        }\n\n5. Let's populate the database with some example data. Open the file **WebApiConfig.cs**. Create a new [**IDatabaseInitializer**](http://msdn.microsoft.com/library/gg696323.aspx) and configure it in the **Register** method as shown below.\n\n        using Microsoft.WindowsAzure.Mobile.Service;\n        using ShoppingService.Models;\n        using System;\n        using System.Collections.Generic;\n        using System.Collections.ObjectModel;\n        using System.Data.Entity;\n        using System.Web.Http;\n\n        namespace ShoppingService\n        {\n            public static class WebApiConfig\n            {\n                public static void Register()\n                {\n                    ConfigOptions options = new ConfigOptions();\n\n                    HttpConfiguration config = ServiceConfig.Initialize(new ConfigBuilder(options));\n\n                    Database.SetInitializer(new ExistingInitializer());\n                }\n            }\n\n            public class ExistingInitializer : ClearDatabaseSchemaIfModelChanges<ExistingContext>\n            {\n                protected override void Seed(ExistingContext context)\n                {\n                    List<Order> orders = new List<Order>\n                    {\n                        new Order { OrderId = 10, Item = \"Guitars\", Quantity = 2, Id = Guid.NewGuid().ToString()},\n                        new Order { OrderId = 20, Item = \"Drums\", Quantity = 10, Id = Guid.NewGuid().ToString()},\n                        new Order { OrderId = 30, Item = \"Tambourines\", Quantity = 20, Id = Guid.NewGuid().ToString() }\n                    };\n\n                    List<Customer> customers = new List<Customer>\n                    {\n                        new Customer { CustomerId = 1, Name = \"John\", Orders = new Collection<Order> {\n                            orders[0]}, Id = Guid.NewGuid().ToString()},\n                        new Customer { CustomerId = 2, Name = \"Paul\", Orders = new Collection<Order> {\n                            orders[1]}, Id = Guid.NewGuid().ToString()},\n                        new Customer { CustomerId = 3, Name = \"Ringo\", Orders = new Collection<Order> {\n                            orders[2]}, Id = Guid.NewGuid().ToString()},\n                    };\n\n                    foreach (Customer c in customers)\n                    {\n                        context.Customers.Add(c);\n                    }\n\n                    base.Seed(context);\n                }\n            }\n        }\n\n<a name=\"Mapping\"></a>\n## Establishing a mapping between DTOs and model\n\nWe now have the model types **Customer** and **Order** and the DTOs **MobileCustomer** and **MobileOrder**, but we  need to instruct the backend to automatically transform between the two. Here Mobile Services relies on [**AutoMapper**](http://automapper.org/), an object relational mapper, which is already referenced in the project.\n\n1. Add the following to the top of **WebApiConfig.cs**:\n\n        using AutoMapper;\n        using ShoppingService.DataObjects;\n\n2. To define the mapping, add the following to the **Register** method of the **WebApiConfig** class.\n\n        Mapper.Initialize(cfg =>\n        {\n            cfg.CreateMap<MobileOrder, Order>();\n            cfg.CreateMap<MobileCustomer, Customer>();\n            cfg.CreateMap<Order, MobileOrder>()\n                .ForMember(dst => dst.MobileCustomerId, map => map.MapFrom(x => x.Customer.Id))\n                .ForMember(dst => dst.MobileCustomerName, map => map.MapFrom(x => x.Customer.Name));\n            cfg.CreateMap<Customer, MobileCustomer>();\n\n        });\n\nAutoMapper will now map the objects to one another. All properties with corresponding names will be matched, for example **MobileOrder.CustomerId** will get automatically mapped to **Order.CustomerId**. Custom mappings can be configured as shown above, where we map the **MobileCustomerName** property to the **Name** property of the **Customer** relationship property.\n\n<a name=\"DomainManager\"></a>\n## Implementing domain-specific logic\n\nThe next step is to implement a [**MappedEntityDomainManager**](http://msdn.microsoft.com/library/dn643300.aspx), which serves as an abstraction layer between our mapped data store and the controller which will serve HTTP traffic from our clients. We will be able to write our controller in the next section purely in terms of the DTOs and the **MappedEntityDomainManager** we add here will handle the communication with the original data store, while also giving us a place to implement any logic specific to it.\n\n1. Add a **MobileCustomerDomainManager.cs** to the **Models** folder of your project. Paste in the following implementation:\n\n        using AutoMapper;\n        using Microsoft.WindowsAzure.Mobile.Service;\n        using ShoppingService.DataObjects;\n        using System.Data.Entity;\n        using System.Linq;\n        using System.Net.Http;\n        using System.Threading.Tasks;\n        using System.Web.Http;\n        using System.Web.Http.OData;\n\n        namespace ShoppingService.Models\n        {\n            public class MobileCustomerDomainManager : MappedEntityDomainManager<MobileCustomer, Customer>\n            {\n                private ExistingContext context;\n\n                public MobileCustomerDomainManager(ExistingContext context, HttpRequestMessage request, ApiServices services)\n                    : base(context, request, services)\n                {\n                    Request = request;\n                    this.context = context;\n                }\n\n                public static int GetKey(string mobileCustomerId, DbSet<Customer> customers, HttpRequestMessage request)\n                {\n                    int customerId = customers\n                       .Where(c => c.Id == mobileCustomerId)\n                       .Select(c => c.CustomerId)\n                       .FirstOrDefault();\n\n                    if (customerId == 0)\n                    {\n                        throw new HttpResponseException(request.CreateNotFoundResponse());\n                    }\n                    return customerId;\n                }\n\n                protected override T GetKey<T>(string mobileCustomerId)\n                {\n                    return (T)(object)GetKey(mobileCustomerId, this.context.Customers, this.Request);\n                }\n\n                public override SingleResult<MobileCustomer> Lookup(string mobileCustomerId)\n                {\n                    int customerId = GetKey<int>(mobileCustomerId);\n                    return LookupEntity(c => c.CustomerId == customerId);\n                }\n\n                public override async Task<MobileCustomer> InsertAsync(MobileCustomer mobileCustomer)\n                {\n                    return await base.InsertAsync(mobileCustomer);\n                }\n\n                public override async Task<MobileCustomer> UpdateAsync(string mobileCustomerId, Delta<MobileCustomer> patch)\n                {\n                    int customerId = GetKey<int>(mobileCustomerId);\n\n                    Customer existingCustomer = await this.Context.Set<Customer>().FindAsync(customerId);\n                    if (existingCustomer == null)\n                    {\n                        throw new HttpResponseException(this.Request.CreateNotFoundResponse());\n                    }\n\n                    MobileCustomer existingCustomerDTO = Mapper.Map<Customer, MobileCustomer>(existingCustomer);\n                    patch.Patch(existingCustomerDTO);\n                    Mapper.Map<MobileCustomer, Customer>(existingCustomerDTO, existingCustomer);\n\n                    await this.SubmitChangesAsync();\n\n                    MobileCustomer updatedCustomerDTO = Mapper.Map<Customer, MobileCustomer>(existingCustomer);\n\n                    return updatedCustomerDTO;\n                }\n\n                public override async Task<MobileCustomer> ReplaceAsync(string mobileCustomerId, MobileCustomer mobileCustomer)\n                {\n                    return await base.ReplaceAsync(mobileCustomerId, mobileCustomer);\n                }\n\n                public override async Task<bool> DeleteAsync(string mobileCustomerId)\n                {\n                    int customerId = GetKey<int>(mobileCustomerId);\n                    return await DeleteItemAsync(customerId);\n                }\n            }\n        }\n\n    An important part of this class is the **GetKey** method where we indicate how to locate the ID property of the object in the original data model.\n\n2. Add a **MobileOrderDomainManager.cs** to the **Models** folder of your project:\n\n        using AutoMapper;\n        using Microsoft.WindowsAzure.Mobile.Service;\n        using ShoppingService.DataObjects;\n        using System.Linq;\n        using System.Net.Http;\n        using System.Threading.Tasks;\n        using System.Web.Http;\n        using System.Web.Http.OData;\n\n        namespace ShoppingService.Models\n        {\n            public class MobileOrderDomainManager : MappedEntityDomainManager<MobileOrder, Order>\n            {\n                private ExistingContext context;\n\n                public MobileOrderDomainManager(ExistingContext context, HttpRequestMessage request, ApiServices services)\n                    : base(context, request, services)\n                {\n                    Request = request;\n                    this.context = context;\n                }\n\n                protected override T GetKey<T>(string mobileOrderId)\n                {\n                    int orderId = this.context.Orders\n                        .Where(o => o.Id == mobileOrderId)\n                        .Select(o => o.OrderId)\n                        .FirstOrDefault();\n\n                    if (orderId == 0)\n                    {\n                        throw new HttpResponseException(this.Request.CreateNotFoundResponse());\n                    }\n                    return (T)(object)orderId;\n                }\n\n                public override SingleResult<MobileOrder> Lookup(string mobileOrderId)\n                {\n                    int orderId = GetKey<int>(mobileOrderId);\n                    return LookupEntity(o => o.OrderId == orderId);\n                }\n\n                private async Task<Customer> VerifyMobileCustomer(string mobileCustomerId, string mobileCustomerName)\n                {\n                    int customerId = MobileCustomerDomainManager.GetKey(mobileCustomerId, this.context.Customers, this.Request);\n                    Customer customer = await this.context.Customers.FindAsync(customerId);\n                    if (customer == null)\n                    {\n                        throw new HttpResponseException(Request.CreateBadRequestResponse(\"Customer with name '{0}' was not found\", mobileCustomerName));\n                    }\n                    return customer;\n                }\n\n                public override async Task<MobileOrder> InsertAsync(MobileOrder mobileOrder)\n                {\n                    Customer customer = await VerifyMobileCustomer(mobileOrder.MobileCustomerId, mobileOrder.MobileCustomerName);\n                    mobileOrder.CustomerId = customer.CustomerId;\n                    return await base.InsertAsync(mobileOrder);\n                }\n\n                public override async Task<MobileOrder> UpdateAsync(string mobileOrderId, Delta<MobileOrder> patch)\n                {\n                    Customer customer = await VerifyMobileCustomer(patch.GetEntity().MobileCustomerId, patch.GetEntity().MobileCustomerName);\n\n                    int orderId = GetKey<int>(mobileOrderId);\n\n                    Order existingOrder = await this.Context.Set<Order>().FindAsync(orderId);\n                    if (existingOrder == null)\n                    {\n                        throw new HttpResponseException(this.Request.CreateNotFoundResponse());\n                    }\n\n                    MobileOrder existingOrderDTO = Mapper.Map<Order, MobileOrder>(existingOrder);\n                    patch.Patch(existingOrderDTO);\n                    Mapper.Map<MobileOrder, Order>(existingOrderDTO, existingOrder);\n\n                    // This is required to map the right Id for the customer\n                    existingOrder.CustomerId = customer.CustomerId;\n\n                    await this.SubmitChangesAsync();\n\n                    MobileOrder updatedOrderDTO = Mapper.Map<Order, MobileOrder>(existingOrder);\n\n                    return updatedOrderDTO;\n                }\n\n                public override async Task<MobileOrder> ReplaceAsync(string mobileOrderId, MobileOrder mobileOrder)\n                {\n                    await VerifyMobileCustomer(mobileOrder.MobileCustomerId, mobileOrder.MobileCustomerName);\n\n                    return await base.ReplaceAsync(mobileOrderId, mobileOrder);\n                }\n\n                public override Task<bool> DeleteAsync(string mobileOrderId)\n                {\n                    int orderId = GetKey<int>(mobileOrderId);\n                    return DeleteItemAsync(orderId);\n                }\n            }\n        }\n\n    In this case the **InsertAsync** and **UpdateAsync** methods are interesting; that's where we enforce the relationship that each **Order** must have a valid associated **Customer**. In **InsertAsync** you'll notice that we populate the **MobileOrder.CustomerId** property, which maps to the **Order.CustomerId** property. We get that value based by looking up the **Customer** with the matching **MobileOrder.MobileCustomerId**. This is because by default the client is only aware of the Mobile Services ID (**MobileOrder.MobileCustomerId**) of the **Customer**, which is different than its actual primary key needed to set the foreign key (**MobileOrder.CustomerId**) from **Order** to **Customer**. This is only used internally within the service to facilitate the insert operation.\n\nWe are now ready to create controllers to expose our DTOs to our clients.\n\n<a name=\"Controller\"></a>\n## Implementing a TableController using DTOs\n\n1. In the **Controllers** folder, add the file **MobileCustomerController.cs**:\n\n        using Microsoft.WindowsAzure.Mobile.Service;\n        using Microsoft.WindowsAzure.Mobile.Service.Security;\n        using ShoppingService.DataObjects;\n        using ShoppingService.Models;\n        using System.Linq;\n        using System.Threading.Tasks;\n        using System.Web.Http;\n        using System.Web.Http.Controllers;\n        using System.Web.Http.OData;\n\n        namespace ShoppingService.Controllers\n        {\n            public class MobileCustomerController : TableController<MobileCustomer>\n            {\n                protected override void Initialize(HttpControllerContext controllerContext)\n                {\n                    base.Initialize(controllerContext);\n                    var context = new ExistingContext();\n                    DomainManager = new MobileCustomerDomainManager(context, Request, Services);\n                }\n\n                public IQueryable<MobileCustomer> GetAllMobileCustomers()\n                {\n                    return Query();\n                }\n\n                public SingleResult<MobileCustomer> GetMobileCustomer(string id)\n                {\n                    return Lookup(id);\n                }\n\n                [AuthorizeLevel(AuthorizationLevel.Admin)]\n                protected override Task<MobileCustomer> PatchAsync(string id, Delta<MobileCustomer> patch)\n                {\n                    return base.UpdateAsync(id, patch);\n                }\n\n                [AuthorizeLevel(AuthorizationLevel.Admin)]\n                protected override Task<MobileCustomer> PostAsync(MobileCustomer item)\n                {\n                    return base.InsertAsync(item);\n                }\n\n                [AuthorizeLevel(AuthorizationLevel.Admin)]\n                protected override Task DeleteAsync(string id)\n                {\n                    return base.DeleteAsync(id);\n                }\n            }\n        }\n\n    You will note the use of the AuthorizeLevel attribute to restrict public access to the Insert/Update/Delete operations on the controller. For the purposes of this scenario, the list of Customers will be read-only, but we will allow the creation of new Orders and associating them with existing customers.\n\n2. In the **Controllers** folder, add the file **MobileOrderController.cs**:\n\n        using Microsoft.WindowsAzure.Mobile.Service;\n        using ShoppingService.DataObjects;\n        using ShoppingService.Models;\n        using System.Linq;\n        using System.Threading.Tasks;\n        using System.Web.Http;\n        using System.Web.Http.Controllers;\n        using System.Web.Http.Description;\n        using System.Web.Http.OData;\n\n        namespace ShoppingService.Controllers\n        {\n            public class MobileOrderController : TableController<MobileOrder>\n            {\n                protected override void Initialize(HttpControllerContext controllerContext)\n                {\n                    base.Initialize(controllerContext);\n                    ExistingContext context = new ExistingContext();\n                    DomainManager = new MobileOrderDomainManager(context, Request, Services);\n                }\n\n                public IQueryable<MobileOrder> GetAllMobileOrders()\n                {\n                    return Query();\n                }\n\n                public SingleResult<MobileOrder> GetMobileOrder(string id)\n                {\n                    return Lookup(id);\n                }\n\n                public Task<MobileOrder> PatchMobileOrder(string id, Delta<MobileOrder> patch)\n                {\n                    return UpdateAsync(id, patch);\n                }\n\n                [ResponseType(typeof(MobileOrder))]\n                public async Task<IHttpActionResult> PostMobileOrder(MobileOrder item)\n                {\n                    MobileOrder current = await InsertAsync(item);\n                    return CreatedAtRoute(\"Tables\", new { id = current.Id }, current);\n                }\n\n                public Task DeleteMobileOrder(string id)\n                {\n                    return DeleteAsync(id);\n                }\n            }\n        }\n\n3. You are now ready to run your service. Press **F5** and use the test client built into the help page to modify the data.\n\nPlease note that both controller implementations make exclusive use of the DTOs **MobileCustomer** and **MobileOrder** and are agnostic of the underlying model. These DTOs are readily serialized to JSON and can be used to exchange data with the  Mobile Services client SDK on all platforms. For example, building a Windows Store app, the corresponding client-side type would look as shown below. The type would be analogous on other client platforms.\n\n    using Microsoft.WindowsAzure.MobileServices;\n    using System;\n\n    namespace ShoppingClient\n    {\n        public class MobileCustomer\n        {\n            public string Id { get; set; }\n\n            public string Name { get; set; }\n\n            [CreatedAt]\n            public DateTimeOffset? CreatedAt { get; set; }\n\n            [UpdatedAt]\n            public DateTimeOffset? UpdatedAt { get; set; }\n\n            public bool Deleted { get; set; }\n\n            [Version]\n            public string Version { get; set; }\n\n        }\n\n    }\n\nAs a next step, you can now build out the client app to access the service.\n"
}