<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="it-it" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">b4923b2cae33b625fb88fc0c3659b70071406365</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: 26DF15E8-2C05-4174-A714-7DF2E8273D32</source>
          <target xml:space="preserve">ms.assetid: 26DF15E8-2C05-4174-A714-7DF2E8273D32</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">title: ListView and GridView UI optimization</source>
          <target xml:space="preserve">title: ListView and GridView UI optimization</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">description: Improve ListView and GridView performance and startup time through UI virtualization, element reduction, and progressive updating of items.</source>
          <target xml:space="preserve">description: Improve ListView and GridView performance and startup time through UI virtualization, element reduction, and progressive updating of items.</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">ListView and GridView UI optimization</source>
          <target xml:space="preserve">ListView and GridView UI optimization</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="106">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="107">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>
					</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>
					</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://channel9.msdn.com/events/build/2013/3-158)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more details, see the //build/ session <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView</pc>.</source>
          <target xml:space="preserve">For more details, see the //build/ session <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView</pc>.</target>
        </segment>
      </unit>
      <unit id="109">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Improve <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> performance and startup time through UI virtualization, element reduction, and progressive updating of items.</source>
          <target xml:space="preserve">Improve <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> performance and startup time through UI virtualization, element reduction, and progressive updating of items.</target>
        </segment>
      </unit>
      <unit id="110">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](listview-and-gridview-data-optimization.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For data virtualization techniques, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView and GridView data virtualization</pc>.</source>
          <target xml:space="preserve">For data virtualization techniques, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView and GridView data virtualization</pc>.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">Two key factors in collection performance</source>
          <target xml:space="preserve">Two key factors in collection performance</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">Manipulating collections is a common scenario.</source>
          <target xml:space="preserve">Manipulating collections is a common scenario.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">A photo viewer has collections of photos, a reader has collections of articles/books/stories, and a shopping app has collections of products.</source>
          <target xml:space="preserve">A photo viewer has collections of photos, a reader has collections of articles/books/stories, and a shopping app has collections of products.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">This topic shows what you can do to make your app efficient at manipulating collections.</source>
          <target xml:space="preserve">This topic shows what you can do to make your app efficient at manipulating collections.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source xml:space="preserve">There are two key factors in performance when it comes to collections: one is the time spent by the UI thread creating items; the other is the memory used by both the raw data set and the UI elements used to render that data.</source>
          <target xml:space="preserve">There are two key factors in performance when it comes to collections: one is the time spent by the UI thread creating items; the other is the memory used by both the raw data set and the UI elements used to render that data.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">For smooth panning/scrolling, it's vital that the UI thread do an efficient and smart job of instantiating, data-binding, and laying out items.</source>
          <target xml:space="preserve">For smooth panning/scrolling, it's vital that the UI thread do an efficient and smart job of instantiating, data-binding, and laying out items.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">UI virtualization</source>
          <target xml:space="preserve">UI virtualization</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">UI virtualization is the most important improvement you can make.</source>
          <target xml:space="preserve">UI virtualization is the most important improvement you can make.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">This means that UI elements representing the items are created on demand.</source>
          <target xml:space="preserve">This means that UI elements representing the items are created on demand.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">For an items control bound to a 1000-item collection, it would be a waste of resources to create the UI for all the items at the same time, because they can't all be displayed at the same time.</source>
          <target xml:space="preserve">For an items control bound to a 1000-item collection, it would be a waste of resources to create the UI for all the items at the same time, because they can't all be displayed at the same time.</target>
        </segment>
      </unit>
      <unit id="121">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242803)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc>
						</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> (and other standard <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ItemsControl</pc></pc>-derived controls) perform UI virtualization for you.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc>
						</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> (and other standard <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ItemsControl</pc></pc>-derived controls) perform UI virtualization for you.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">When items are close to being scrolled into view (a few pages away), the framework generates the UI for the items and caches them.</source>
          <target xml:space="preserve">When items are close to being scrolled into view (a few pages away), the framework generates the UI for the items and caches them.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">When it's unlikely that the items will be shown again, the framework re-claims the memory.</source>
          <target xml:space="preserve">When it's unlikely that the items will be shown again, the framework re-claims the memory.</target>
        </segment>
      </unit>
      <unit id="124">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemspanel)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/Dn298849)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/Dn298795)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you provide a custom items panel template (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsPanel</pc></pc>) then make sure you use a virtualizing panel such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ItemsWrapGrid</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ItemsStackPanel</pc></pc>.</source>
          <target xml:space="preserve">If you provide a custom items panel template (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsPanel</pc></pc>) then make sure you use a virtualizing panel such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ItemsWrapGrid</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ItemsStackPanel</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="125">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227651)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR227717)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209635)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VariableSizedWrapGrid</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">WrapGrid</pc></pc>, or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">StackPanel</pc></pc>, then you will not get virtualization.</source>
          <target xml:space="preserve">If you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VariableSizedWrapGrid</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">WrapGrid</pc></pc>, or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">StackPanel</pc></pc>, then you will not get virtualization.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source xml:space="preserve">The concept of a viewport is critical to UI virtualization because the framework must create the elements that are likely to be shown.</source>
          <target xml:space="preserve">The concept of a viewport is critical to UI virtualization because the framework must create the elements that are likely to be shown.</target>
        </segment>
      </unit>
      <unit id="127">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In general, the viewport of an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> is the extent of the logical control.</source>
          <target xml:space="preserve">In general, the viewport of an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> is the extent of the logical control.</target>
        </segment>
      </unit>
      <unit id="128">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, the viewport of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> is the width and height of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ListView</pc> element.</source>
          <target xml:space="preserve">For example, the viewport of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> is the width and height of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ListView</pc> element.</target>
        </segment>
      </unit>
      <unit id="129">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209527)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242704)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Some panels allow child elements unlimited space, examples being <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollViewer</pc></pc> and a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Grid</pc></pc>, with auto-sized rows or columns.</source>
          <target xml:space="preserve">Some panels allow child elements unlimited space, examples being <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollViewer</pc></pc> and a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Grid</pc></pc>, with auto-sized rows or columns.</target>
        </segment>
      </unit>
      <unit id="130">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When a virtualized <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemsControl</pc> is placed in a panel like that, it takes enough room to display all of its items, which defeats virtualization.</source>
          <target xml:space="preserve">When a virtualized <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemsControl</pc> is placed in a panel like that, it takes enough room to display all of its items, which defeats virtualization.</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Restore virtualization by setting a width and height on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemsControl</pc>.</source>
          <target xml:space="preserve">Restore virtualization by setting a width and height on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ItemsControl</pc>.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source xml:space="preserve">Element reduction per item</source>
          <target xml:space="preserve">Element reduction per item</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">Keep the number of UI elements used to render your items to a reasonable minimum.</source>
          <target xml:space="preserve">Keep the number of UI elements used to render your items to a reasonable minimum.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">When an items control is first shown, all the elements needed to render a viewport full of items are created.</source>
          <target xml:space="preserve">When an items control is first shown, all the elements needed to render a viewport full of items are created.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">Also, as items approach the viewport, the framework updates the UI elements in cached item templates with the bound data objects.</source>
          <target xml:space="preserve">Also, as items approach the viewport, the framework updates the UI elements in cached item templates with the bound data objects.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source xml:space="preserve">Minimizing the complexity of the markup inside templates pays off in memory and in time spent on the UI thread, improving responsiveness especially while panning/scrolling.</source>
          <target xml:space="preserve">Minimizing the complexity of the markup inside templates pays off in memory and in time spent on the UI thread, improving responsiveness especially while panning/scrolling.</target>
        </segment>
      </unit>
      <unit id="137">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemtemplate)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">[</data>
          <data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemcontainerstyle)</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The templates in question are the item template (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemTemplate</pc></pc>) and the control template of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ListViewItem</pc></pc> or a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">GridViewItem</pc></pc> (the item control template, or <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">ItemContainerStyle</pc></pc>).</source>
          <target xml:space="preserve">The templates in question are the item template (see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemTemplate</pc></pc>) and the control template of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ListViewItem</pc></pc> or a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">GridViewItem</pc></pc> (the item control template, or <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">ItemContainerStyle</pc></pc>).</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source xml:space="preserve">The benefit of even a small reduction in element count is multiplied by the number of items displayed.</source>
          <target xml:space="preserve">The benefit of even a small reduction in element count is multiplied by the number of items displayed.</target>
        </segment>
      </unit>
      <unit id="139">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](optimize-xaml-loading.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For examples of element reduction, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimize your XAML markup</pc>.</source>
          <target xml:space="preserve">For examples of element reduction, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimize your XAML markup</pc>.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/Dn298500)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">[</data>
          <data id="id14">](https://msdn.microsoft.com/library/windows/apps/Dn279298)</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The default control templates for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewItem</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridViewItem</pc></pc> contain a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ListViewItemPresenter</pc></pc> and a <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">GridViewItemPresenter</pc></pc> element, respectively.</source>
          <target xml:space="preserve">The default control templates for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewItem</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridViewItem</pc></pc> contain a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ListViewItemPresenter</pc></pc> and a <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">GridViewItemPresenter</pc></pc> element, respectively.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">Each of these presenters is a single optimized element that displays complex visuals for focus, selection, and other visual states.</source>
          <target xml:space="preserve">Each of these presenters is a single optimized element that displays complex visuals for focus, selection, and other visual states.</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803-itemcontainerstyle)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you already have custom item control templates (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemContainerStyle</pc></pc>), or if in future you edit a copy of an item control template, then we recommend you use a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ListViewItemPresenter</pc> or a <pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridViewItemPresenter</pc> because those elements will give you optimum balance between performance and customizability in the majority of cases.</source>
          <target xml:space="preserve">If you already have custom item control templates (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemContainerStyle</pc></pc>), or if in future you edit a copy of an item control template, then we recommend you use a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ListViewItemPresenter</pc> or a <pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridViewItemPresenter</pc> because those elements will give you optimum balance between performance and customizability in the majority of cases.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">You customize these presenters by setting properties on them.</source>
          <target xml:space="preserve">You customize these presenters by setting properties on them.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">For example, here's markup that removes the check mark that appears by default when an item is selected, and changes the background color of the selected item to orange.</source>
          <target xml:space="preserve">For example, here's markup that removes the check mark that appears by default when an item is selected, and changes the background color of the selected item to orange.</target>
        </segment>
      </unit>
      <unit id="145">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn298500-selectioncheckmarkvisualenabled)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/Dn298500-selectedbackground)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">There are about 25 properties with self-describing names similar to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SelectionCheckMarkVisualEnabled</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SelectedBackground</pc></pc>.</source>
          <target xml:space="preserve">There are about 25 properties with self-describing names similar to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SelectionCheckMarkVisualEnabled</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SelectedBackground</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">`ListViewItemExpanded`</data>
          <data id="id2">`GridViewItemExpanded`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Should the presenter types prove not to be customizable enough for your use case, you can edit a copy of the <ph dataRef="id1" id="ph1" /> or <ph dataRef="id2" id="ph2" /> control template instead.</source>
          <target xml:space="preserve">Should the presenter types prove not to be customizable enough for your use case, you can edit a copy of the <ph dataRef="id1" id="ph1" /> or <ph dataRef="id2" id="ph2" /> control template instead.</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">`\Program Files (x86)\Windows Kits\10\DesignTime\CommonConfiguration\Neutral\UAP\&lt;version&gt;\Generic\generic.xaml`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">These can be found in <ph dataRef="id1" id="ph1" />.</source>
          <target xml:space="preserve">These can be found in <ph dataRef="id1" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source xml:space="preserve">Be aware that using these templates means trading some performance for the increase in customization.</source>
          <target xml:space="preserve">Be aware that using these templates means trading some performance for the increase in customization.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source xml:space="preserve">Update ListView and GridView items progressively</source>
          <target xml:space="preserve">Update ListView and GridView items progressively</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you're using data virtualization then you can keep <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> responsiveness high by configuring the control to render temporary UI elements for the items still being (down)loaded.</source>
          <target xml:space="preserve">If you're using data virtualization then you can keep <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> responsiveness high by configuring the control to render temporary UI elements for the items still being (down)loaded.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source xml:space="preserve">The temporary elements are then progressively replaced with actual UI as data loads.</source>
          <target xml:space="preserve">The temporary elements are then progressively replaced with actual UI as data loads.</target>
        </segment>
      </unit>
      <unit id="152">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Also—no matter where you're loading data from (local disk, network, or cloud)—a user can pan/scroll a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> so rapidly that it's not possible to render each item with full fidelity while preserving smooth panning/scrolling.</source>
          <target xml:space="preserve">Also—no matter where you're loading data from (local disk, network, or cloud)—a user can pan/scroll a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> so rapidly that it's not possible to render each item with full fidelity while preserving smooth panning/scrolling.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source xml:space="preserve">To preserve smooth panning/scrolling you can choose to render an item in multiple phases in addition to using placeholders.</source>
          <target xml:space="preserve">To preserve smooth panning/scrolling you can choose to render an item in multiple phases in addition to using placeholders.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">An example of these techniques is often seen in photo-viewing apps: even though not all of the images have been loaded and displayed, the user can still pan/scroll and interact with the collection.</source>
          <target xml:space="preserve">An example of these techniques is often seen in photo-viewing apps: even though not all of the images have been loaded and displayed, the user can still pan/scroll and interact with the collection.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">Or, for a "movie" item, you could show the title in the first phase, the rating in the second phase, and an image of the poster in the third phase.</source>
          <target xml:space="preserve">Or, for a "movie" item, you could show the title in the first phase, the rating in the second phase, and an image of the poster in the third phase.</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source xml:space="preserve">The user sees the most important data about each item as early as possible, and that means they're able to take action at once.</source>
          <target xml:space="preserve">The user sees the most important data about each item as early as possible, and that means they're able to take action at once.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source xml:space="preserve">Then the less important info is filled-in as time allows.</source>
          <target xml:space="preserve">Then the less important info is filled-in as time allows.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">Here are the platform features you can use to implement these techniques.</source>
          <target xml:space="preserve">Here are the platform features you can use to implement these techniques.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source xml:space="preserve">Placeholders</source>
          <target xml:space="preserve">Placeholders</target>
        </segment>
      </unit>
      <unit id="160">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The temporary placeholder visuals feature is on by default, and it's controlled with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ShowsScrollingPlaceholders</pc></pc> property.</source>
          <target xml:space="preserve">The temporary placeholder visuals feature is on by default, and it's controlled with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ShowsScrollingPlaceholders</pc></pc> property.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source xml:space="preserve">During fast panning/scrolling, this feature gives the user a visual hint that there are more items yet to fully display while also preserving smoothness.</source>
          <target xml:space="preserve">During fast panning/scrolling, this feature gives the user a visual hint that there are more items yet to fully display while also preserving smoothness.</target>
        </segment>
      </unit>
      <unit id="162">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you use one of the techniques below then you can set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ShowsScrollingPlaceholders</pc> to false if you prefer not to have the system render placeholders.</source>
          <target xml:space="preserve">If you use one of the techniques below then you can set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ShowsScrollingPlaceholders</pc> to false if you prefer not to have the system render placeholders.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source xml:space="preserve">Progressive data template updates using x:Phase</source>
          <target xml:space="preserve">Progressive data template updates using x:Phase</target>
        </segment>
      </unit>
      <unit id="164">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204790)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Here's how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase attribute</pc> with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc> bindings to implement progressive data template updates.</source>
          <target xml:space="preserve">Here's how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase attribute</pc> with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc> bindings to implement progressive data template updates.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">Here's what the binding source looks like (this is the data source that we'll bind to).</source>
          <target xml:space="preserve">Here's what the binding source looks like (this is the data source that we'll bind to).</target>
        </segment>
      </unit>
      <unit id="166">
        <originalData>
          <data id="id1">`DeferMainPage.xaml`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Here's the markup that <ph dataRef="id1" id="ph1" /> contains.</source>
          <target xml:space="preserve">Here's the markup that <ph dataRef="id1" id="ph1" /> contains.</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The grid view contains an item template with elements bound to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Title</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Subtitle</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Description</pc> properties of the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">MyItem</pc> class.</source>
          <target xml:space="preserve">The grid view contains an item template with elements bound to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Title</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Subtitle</pc>, and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Description</pc> properties of the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">MyItem</pc> class.</target>
        </segment>
      </unit>
      <unit id="168">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Note that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc> defaults to 0.</source>
          <target xml:space="preserve">Note that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc> defaults to 0.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source xml:space="preserve">Here, items will be initially rendered with just the title visible.</source>
          <target xml:space="preserve">Here, items will be initially rendered with just the title visible.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source xml:space="preserve">Then the subtitle element will be data bound and made visible for all the items and so on until all the phases have been processed.</source>
          <target xml:space="preserve">Then the subtitle element will be data bound and made visible for all the items and so on until all the phases have been processed.</target>
        </segment>
      </unit>
      <unit id="171">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you run the app now and pan/scroll quickly through the grid view then you'll notice that as each new item appears on the screen, at first it is rendered as a dark gray rectangle (thanks to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ShowsScrollingPlaceholders</pc></pc> property defaulting to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc>), then the title appears, followed by subtitle, followed by description.</source>
          <target xml:space="preserve">If you run the app now and pan/scroll quickly through the grid view then you'll notice that as each new item appears on the screen, at first it is rendered as a dark gray rectangle (thanks to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ShowsScrollingPlaceholders</pc></pc> property defaulting to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc>), then the title appears, followed by subtitle, followed by description.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">Progressive data template updates using ContainerContentChanging</source>
          <target xml:space="preserve">Progressive data template updates using ContainerContentChanging</target>
        </segment>
      </unit>
      <unit id="173">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The general strategy for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event is to use <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Opacity</pc> to hide elements that don’t need to be immediately visible.</source>
          <target xml:space="preserve">The general strategy for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event is to use <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Opacity</pc> to hide elements that don’t need to be immediately visible.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source xml:space="preserve">When elements are recycled, they will retain their old values so we want to hide those elements until we've updated those values from the new data item.</source>
          <target xml:space="preserve">When elements are recycled, they will retain their old values so we want to hide those elements until we've updated those values from the new data item.</target>
        </segment>
      </unit>
      <unit id="175">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">We use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Phase</pc> property on the event arguments to determine which elements to update and show.</source>
          <target xml:space="preserve">We use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Phase</pc> property on the event arguments to determine which elements to update and show.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source xml:space="preserve">If additional phases are needed, we register a callback.</source>
          <target xml:space="preserve">If additional phases are needed, we register a callback.</target>
        </segment>
      </unit>
      <unit id="177">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">We'll use the same binding source as for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc>.</source>
          <target xml:space="preserve">We'll use the same binding source as for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc>.</target>
        </segment>
      </unit>
      <unit id="178">
        <originalData>
          <data id="id1">`MainPage.xaml`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Here's the markup that <ph dataRef="id1" id="ph1" /> contains.</source>
          <target xml:space="preserve">Here's the markup that <ph dataRef="id1" id="ph1" /> contains.</target>
        </segment>
      </unit>
      <unit id="179">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The grid view declares a handler to its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event, and it contains an item template with elements used to display the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Title</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Subtitle</pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Description</pc> properties of the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">MyItem</pc> class.</source>
          <target xml:space="preserve">The grid view declares a handler to its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event, and it contains an item template with elements used to display the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Title</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Subtitle</pc>, and <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Description</pc> properties of the <pc dataRefEnd="id12" dataRefStart="id11" id="p6">MyItem</pc> class.</target>
        </segment>
      </unit>
      <unit id="180">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To get the maximum performance benefits of using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ContainerContentChanging</pc>, we don't use bindings in the markup but we instead assign values programmatically.</source>
          <target xml:space="preserve">To get the maximum performance benefits of using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ContainerContentChanging</pc>, we don't use bindings in the markup but we instead assign values programmatically.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">The exception here is the element displaying the title, which we consider to be in phase 0.</source>
          <target xml:space="preserve">The exception here is the element displaying the title, which we consider to be in phase 0.</target>
        </segment>
      </unit>
      <unit id="182">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-containercontentchanging)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Lastly, here's the implementation of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event handler.</source>
          <target xml:space="preserve">Lastly, here's the implementation of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContainerContentChanging</pc></pc> event handler.</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This code also shows how we add a property of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecordingViewModel</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MainPage</pc> to expose the binding source class from the class that represents our page of markup.</source>
          <target xml:space="preserve">This code also shows how we add a property of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1">RecordingViewModel</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">MainPage</pc> to expose the binding source class from the class that represents our page of markup.</target>
        </segment>
      </unit>
      <unit id="184">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">As long as you don't have any <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc> bindings in your data template, then mark the event arguments object as handled in the first phase of the handler to hint to the item that it needn't set a data context.</source>
          <target xml:space="preserve">As long as you don't have any <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc> bindings in your data template, then mark the event arguments object as handled in the first phase of the handler to hint to the item that it needn't set a data context.</target>
        </segment>
      </unit>
      <unit id="185">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you run the app now and pan/scroll quickly through the grid view then you'll see the same behavior as for as for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc>.</source>
          <target xml:space="preserve">If you run the app now and pan/scroll quickly through the grid view then you'll see the same behavior as for as for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Phase</pc>.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">Container-recycling with heterogeneous collections</source>
          <target xml:space="preserve">Container-recycling with heterogeneous collections</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source xml:space="preserve">In some applications, you need to have different UI for different types of item within a collection.</source>
          <target xml:space="preserve">In some applications, you need to have different UI for different types of item within a collection.</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source xml:space="preserve">This can create a situation where it is impossible for virtualizing panels to reuse/recycle the visual elements used to display the items.</source>
          <target xml:space="preserve">This can create a situation where it is impossible for virtualizing panels to reuse/recycle the visual elements used to display the items.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source xml:space="preserve">Recreating the visual elements for an item during panning undoes many of the performance wins provided by virtualization.</source>
          <target xml:space="preserve">Recreating the visual elements for an item during panning undoes many of the performance wins provided by virtualization.</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source xml:space="preserve">However, a little planning can allow virtualizing panels to reuse the elements.</source>
          <target xml:space="preserve">However, a little planning can allow virtualizing panels to reuse the elements.</target>
        </segment>
      </unit>
      <unit id="191">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Developers have a couple of options depending on their scenario: the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc></pc> event, or an item template selector.</source>
          <target xml:space="preserve">Developers have a couple of options depending on their scenario: the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc></pc> event, or an item template selector.</target>
        </segment>
      </unit>
      <unit id="192">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc> event is the most performant approach.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc> event is the most performant approach.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source xml:space="preserve">The ChoosingItemContainer event</source>
          <target xml:space="preserve">The ChoosingItemContainer event</target>
        </segment>
      </unit>
      <unit id="194">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">[</data>
          <data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
          <data id="id17">[</data>
          <data id="id18">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
          <data id="id19">**</data>
          <data id="id20">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc>
						</pc> is an event that allows you to provide an item (<pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ListViewItem</pc></pc>/<pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">GridViewItem</pc></pc>) to the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">ListView</pc></pc>/<pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">GridView</pc></pc> whenever a new item is needed during start-up or recycling.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc>
						</pc> is an event that allows you to provide an item (<pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ListViewItem</pc></pc>/<pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">GridViewItem</pc></pc>) to the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">ListView</pc></pc>/<pc dataRefEnd="id18" dataRefStart="id17" id="p9"><pc dataRefEnd="id20" dataRefStart="id19" id="p10">GridView</pc></pc> whenever a new item is needed during start-up or recycling.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source xml:space="preserve">You can create a container based on the type of data item the container will display (shown in the example below).</source>
          <target xml:space="preserve">You can create a container based on the type of data item the container will display (shown in the example below).</target>
        </segment>
      </unit>
      <unit id="196">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc> is the most performant way to use different data templates for different items.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc> is the most performant way to use different data templates for different items.</target>
        </segment>
      </unit>
      <unit id="197">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Container caching is something that can be achieved using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc>.</source>
          <target xml:space="preserve">Container caching is something that can be achieved using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChoosingItemContainer</pc>.</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source xml:space="preserve">For example, if you have five different template, with one template occurring an order of magnitude more often than the others, then ChoosingItemContainer allows you not only to create items at the ratios needed but also to keep an appropriate number of elements cached and available for recycling.</source>
          <target xml:space="preserve">For example, if you have five different template, with one template occurring an order of magnitude more often than the others, then ChoosingItemContainer allows you not only to create items at the ratios needed but also to keep an appropriate number of elements cached and available for recycling.</target>
        </segment>
      </unit>
      <unit id="199">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosinggroupheadercontainer)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingGroupHeaderContainer</pc>
						</pc> provides the same functionality for group headers.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingGroupHeaderContainer</pc>
						</pc> provides the same functionality for group headers.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source xml:space="preserve">Item template selector</source>
          <target xml:space="preserve">Item template selector</target>
        </segment>
      </unit>
      <unit id="201">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209469)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">An item template selector (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataTemplateSelector</pc></pc>) allows an app to return a different item template at runtime based on the type of the data item that will be displayed.</source>
          <target xml:space="preserve">An item template selector (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataTemplateSelector</pc></pc>) allows an app to return a different item template at runtime based on the type of the data item that will be displayed.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source xml:space="preserve">This makes development more productive, but it makes UI virtualization more difficult because not every item template can be reused for every data item.</source>
          <target xml:space="preserve">This makes development more productive, but it makes UI virtualization more difficult because not every item template can be reused for every data item.</target>
        </segment>
      </unit>
      <unit id="203">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878item)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705item)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When recycling an item (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewItem</pc></pc>/<pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridViewItem</pc></pc>), the framework must decide whether the items that are available for use in the recycle queue (the recycle queue is a cache of items that are not currently being used to display data) have an item template that will match the one desired by the current data item.</source>
          <target xml:space="preserve">When recycling an item (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewItem</pc></pc>/<pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridViewItem</pc></pc>), the framework must decide whether the items that are available for use in the recycle queue (the recycle queue is a cache of items that are not currently being used to display data) have an item template that will match the one desired by the current data item.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source xml:space="preserve">If there are no items in the recycle queue with the appropriate item template then a new item is created, and the appropriate item template is instantiated for it.</source>
          <target xml:space="preserve">If there are no items in the recycle queue with the appropriate item template then a new item is created, and the appropriate item template is instantiated for it.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source xml:space="preserve">If, on other hand, the recycle queue contains an item with the appropriate item template then that item is removed from the recycle queue and is used for the current data item.</source>
          <target xml:space="preserve">If, on other hand, the recycle queue contains an item with the appropriate item template then that item is removed from the recycle queue and is used for the current data item.</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source xml:space="preserve">An item template selector works in situations where only a small number of item templates are used and there is a flat distribution throughout the collection of items that use different item templates.</source>
          <target xml:space="preserve">An item template selector works in situations where only a small number of item templates are used and there is a flat distribution throughout the collection of items that use different item templates.</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source xml:space="preserve">When there is an uneven distribution of items that use different item templates then new item templates will likely need to be created during panning, and this negates many of the gains provided by virtualization.</source>
          <target xml:space="preserve">When there is an uneven distribution of items that use different item templates then new item templates will likely need to be created during panning, and this negates many of the gains provided by virtualization.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source xml:space="preserve">Additionally, an item template selector only considers five possible candidates when evaluating whether a particular container can be reused for the current data item.</source>
          <target xml:space="preserve">Additionally, an item template selector only considers five possible candidates when evaluating whether a particular container can be reused for the current data item.</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source xml:space="preserve">So you should carefully consider whether your data is appropriate for use with an item template selector before using one in your app.</source>
          <target xml:space="preserve">So you should carefully consider whether your data is appropriate for use with an item template selector before using one in your app.</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source xml:space="preserve">If your collection is mostly homogeneous then the selector is returning the same type most (possibly all) of the time.</source>
          <target xml:space="preserve">If your collection is mostly homogeneous then the selector is returning the same type most (possibly all) of the time.</target>
        </segment>
      </unit>
      <unit id="211">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-choosingitemcontainer)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Just be aware of the price you're paying for the rare exceptions to that homegeneity, and consider whether using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc></pc> (or two items controls) is preferable.</source>
          <target xml:space="preserve">Just be aware of the price you're paying for the rare exceptions to that homegeneity, and consider whether using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChoosingItemContainer</pc></pc> (or two items controls) is preferable.</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>