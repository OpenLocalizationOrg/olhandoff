<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="it-it" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">bcc64cfc51aa038349c2de9d8fc6a91ca2560c66</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">description: We describe the programming concept of events in a Windows Runtime app, when using C#, Visual Basic or Visual C++ component extensions (C++/CX) as your programming language, and XAML for your UI definition.</source>
          <target xml:space="preserve">description: We describe the programming concept of events in a Windows Runtime app, when using C#, Visual Basic or Visual C++ component extensions (C++/CX) as your programming language, and XAML for your UI definition.</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">title: Events and routed events overview</source>
          <target xml:space="preserve">title: Events and routed events overview</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: 34C219E8-3EFB-45BC-8BBD-6FD937698832</source>
          <target xml:space="preserve">ms.assetid: 34C219E8-3EFB-45BC-8BBD-6FD937698832</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">Events and routed events overview</source>
          <target xml:space="preserve">Events and routed events overview</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="106">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">Important APIs</source>
          <target xml:space="preserve">Important APIs</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source xml:space="preserve">UIElement</source>
          <target xml:space="preserve">UIElement</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">RoutedEventArgs</source>
          <target xml:space="preserve">RoutedEventArgs</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">We describe the programming concept of events in a Windows Runtime app, when using C#, Visual Basic or Visual C++ component extensions (C++/CX) as your programming language, and XAML for your UI definition.</source>
          <target xml:space="preserve">We describe the programming concept of events in a Windows Runtime app, when using C#, Visual Basic or Visual C++ component extensions (C++/CX) as your programming language, and XAML for your UI definition.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">You can assign handlers for events as part of the declarations for UI elements in XAML, or you can add the handlers in code.</source>
          <target xml:space="preserve">You can assign handlers for events as part of the declarations for UI elements in XAML, or you can add the handlers in code.</target>
        </segment>
      </unit>
      <unit id="112">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Windows Runtime supports <pc dataRefEnd="id2" dataRefStart="id1" id="p1">routed events</pc>: certain input events and data events can be handled by objects beyond the object that fired the event.</source>
          <target xml:space="preserve">Windows Runtime supports <pc dataRefEnd="id2" dataRefStart="id1" id="p1">routed events</pc>: certain input events and data events can be handled by objects beyond the object that fired the event.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">Routed events are useful when you define control templates, or use pages or layout containers.</source>
          <target xml:space="preserve">Routed events are useful when you define control templates, or use pages or layout containers.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">Events as a programming concept</source>
          <target xml:space="preserve">Events as a programming concept</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source xml:space="preserve">Generally speaking, event concepts when programming a Windows Runtime app are similar to the event model in most popular programming languages.</source>
          <target xml:space="preserve">Generally speaking, event concepts when programming a Windows Runtime app are similar to the event model in most popular programming languages.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">If you know how to work with Microsoft .NET or C++ events already, you have a head start.</source>
          <target xml:space="preserve">If you know how to work with Microsoft .NET or C++ events already, you have a head start.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">But you don't need to know that much about event model concepts to perform some basic tasks, such as attaching handlers.</source>
          <target xml:space="preserve">But you don't need to know that much about event model concepts to perform some basic tasks, such as attaching handlers.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">When you use C#, Visual Basic or C++/CX as your programming language, the UI is defined in markup (XAML).</source>
          <target xml:space="preserve">When you use C#, Visual Basic or C++/CX as your programming language, the UI is defined in markup (XAML).</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">In XAML markup syntax, some of the principles of connecting events between markup elements and runtime code entities are similar to other Web technologies, such as ASP.NET, or HTML5.</source>
          <target xml:space="preserve">In XAML markup syntax, some of the principles of connecting events between markup elements and runtime code entities are similar to other Web technologies, such as ASP.NET, or HTML5.</target>
        </segment>
      </unit>
      <unit id="120">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The code that provides the runtime logic for a XAML-defined UI is often referred to as <pc dataRefEnd="id4" dataRefStart="id3" id="p2">code-behind</pc> or the code-behind file.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The code that provides the runtime logic for a XAML-defined UI is often referred to as <pc dataRefEnd="id4" dataRefStart="id3" id="p2">code-behind</pc> or the code-behind file.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">In the Microsoft Visual Studio solution views, this relationship is shown graphically, with the code-behind file being a dependent and nested file versus the XAML page it refers to.</source>
          <target xml:space="preserve">In the Microsoft Visual Studio solution views, this relationship is shown graphically, with the code-behind file being a dependent and nested file versus the XAML page it refers to.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">Button.Click: an introduction to events and XAML</source>
          <target xml:space="preserve">Button.Click: an introduction to events and XAML</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">One of the most common programming tasks for a Windows Runtime app is to capture user input to the UI.</source>
          <target xml:space="preserve">One of the most common programming tasks for a Windows Runtime app is to capture user input to the UI.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">For example, your UI might have a button that the user must click to submit info or to change state.</source>
          <target xml:space="preserve">For example, your UI might have a button that the user must click to submit info or to change state.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">You define the UI for your Windows Runtime app by generating XAML.</source>
          <target xml:space="preserve">You define the UI for your Windows Runtime app by generating XAML.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source xml:space="preserve">This XAML is usually the output from a design surface in Visual Studio.</source>
          <target xml:space="preserve">This XAML is usually the output from a design surface in Visual Studio.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source xml:space="preserve">You can also write the XAML in a plain-text editor or a third-party XAML editor.</source>
          <target xml:space="preserve">You can also write the XAML in a plain-text editor or a third-party XAML editor.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">While generating that XAML, you can wire event handlers for individual UI elements at the same time that you define all the other XAML attributes that establish property values of that UI element.</source>
          <target xml:space="preserve">While generating that XAML, you can wire event handlers for individual UI elements at the same time that you define all the other XAML attributes that establish property values of that UI element.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source xml:space="preserve">To wire the events in XAML, you specify the string-form name of the handler method that you've already defined or will define later in your code-behind.</source>
          <target xml:space="preserve">To wire the events in XAML, you specify the string-form name of the handler method that you've already defined or will define later in your code-behind.</target>
        </segment>
      </unit>
      <unit id="130">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](x-name-attribute.md)</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br209366)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">[</data>
          <data id="id12">](https://msdn.microsoft.com/library/windows/apps/br227737)</data>
          <data id="id13">**</data>
          <data id="id14">**</data>
          <data id="id15">`showUpdatesButton_Click`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, this XAML defines a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> object with other properties (<pc dataRefEnd="id6" dataRefStart="id5" id="p3">x:Name attribute</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Content</pc></pc>) assigned as attributes, and wires a handler for the button's <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Click</pc></pc> event by referencing a method named <ph dataRef="id15" id="ph1" />:</source>
          <target xml:space="preserve">For example, this XAML defines a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> object with other properties (<pc dataRefEnd="id6" dataRefStart="id5" id="p3">x:Name attribute</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Content</pc></pc>) assigned as attributes, and wires a handler for the button's <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Click</pc></pc> event by referencing a method named <ph dataRef="id15" id="ph1" />:</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Event wiring</pc> is a programming term.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Event wiring</pc> is a programming term.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source xml:space="preserve">It refers to the process or code whereby you indicate that occurrences of an event should invoke a named handler method.</source>
          <target xml:space="preserve">It refers to the process or code whereby you indicate that occurrences of an event should invoke a named handler method.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">In most procedural code models, event wiring is implicit or explicit "AddHandler" code that names both the event and method, and usually involves a target object instance.</source>
          <target xml:space="preserve">In most procedural code models, event wiring is implicit or explicit "AddHandler" code that names both the event and method, and usually involves a target object instance.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">In XAML, the "AddHandler" is implicit, and event wiring consists entirely of naming the event as the attribute name of an object element, and naming the handler as that attribute's value.</source>
          <target xml:space="preserve">In XAML, the "AddHandler" is implicit, and event wiring consists entirely of naming the event as the attribute name of an object element, and naming the handler as that attribute's value.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">You write the actual handler in the programming language that you're using for all your app's code and code-behind.</source>
          <target xml:space="preserve">You write the actual handler in the programming language that you're using for all your app's code and code-behind.</target>
        </segment>
      </unit>
      <unit id="136">
        <originalData>
          <data id="id1">`Click="showUpdatesButton_Click"`</data>
          <data id="id2">`showUpdatesButton_Click`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">With the attribute <ph dataRef="id1" id="ph1" />, you have created a contract that when the XAML is markup-compiled and parsed, both the XAML markup compile step in your IDE's build action and the eventual XAML parse when the app loads can find a method named <ph dataRef="id2" id="ph2" /> as part of the app's code.</source>
          <target xml:space="preserve">With the attribute <ph dataRef="id1" id="ph1" />, you have created a contract that when the XAML is markup-compiled and parsed, both the XAML markup compile step in your IDE's build action and the eventual XAML parse when the app loads can find a method named <ph dataRef="id2" id="ph2" /> as part of the app's code.</target>
        </segment>
      </unit>
      <unit id="137">
        <originalData>
          <data id="id1">`showUpdatesButton_Click`</data>
          <data id="id2">[</data>
          <data id="id3">](https://msdn.microsoft.com/library/windows/apps/br227737)</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<ph dataRef="id1" id="ph1" /> must be a method that implements a compatible method signature (based on a delegate) for any handler of the <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">Click</pc></pc> event.</source>
          <target xml:space="preserve">
						<ph dataRef="id1" id="ph1" /> must be a method that implements a compatible method signature (based on a delegate) for any handler of the <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">Click</pc></pc> event.</target>
        </segment>
      </unit>
      <unit id="138">
        <originalData>
          <data id="id1">`showUpdatesButton_Click`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, this code defines the <ph dataRef="id1" id="ph1" /> handler.</source>
          <target xml:space="preserve">For example, this code defines the <ph dataRef="id1" id="ph1" /> handler.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
          <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">`showUpdatesButton_Click`</data>
          <data id="id2">[</data>
          <data id="id3">](https://msdn.microsoft.com/library/windows/apps/br208812)</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In this example, the <ph dataRef="id1" id="ph1" /> method is based on the <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">RoutedEventHandler</pc></pc> delegate.</source>
          <target xml:space="preserve">In this example, the <ph dataRef="id1" id="ph1" /> method is based on the <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">RoutedEventHandler</pc></pc> delegate.</target>
        </segment>
      </unit>
      <unit id="141">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227737)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You'd know that this is the delegate to use because you'll see that delegate named in the syntax for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc></pc> method on the MSDN reference page.</source>
          <target xml:space="preserve">You'd know that this is the delegate to use because you'll see that delegate named in the syntax for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc></pc> method on the MSDN reference page.</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  Visual Studio provides a convenient way to name the event handler and define the handler method while you're editing XAML.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  Visual Studio provides a convenient way to name the event handler and define the handler method while you're editing XAML.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">When you provide the attribute name of the event in the XAML text editor, wait a moment until a Microsoft IntelliSense list displays.</source>
          <target xml:space="preserve">When you provide the attribute name of the event in the XAML text editor, wait a moment until a Microsoft IntelliSense list displays.</target>
        </segment>
      </unit>
      <unit id="144">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you click <pc dataRefEnd="id2" dataRefStart="id1" id="p1">&amp;lt;New Event Handler&amp;gt;</pc> from the list, Microsoft Visual Studio will suggest a method name based on the element's <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Name</pc> (or type name), the event name, and a numeric suffix.</source>
          <target xml:space="preserve">If you click <pc dataRefEnd="id2" dataRefStart="id1" id="p1">&amp;lt;New Event Handler&amp;gt;</pc> from the list, Microsoft Visual Studio will suggest a method name based on the element's <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Name</pc> (or type name), the event name, and a numeric suffix.</target>
        </segment>
      </unit>
      <unit id="145">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can then right-click the selected event handler name and click <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Navigate to Event Handler</pc>.</source>
          <target xml:space="preserve">You can then right-click the selected event handler name and click <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Navigate to Event Handler</pc>.</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source xml:space="preserve">This will navigate directly to the newly inserted event handler definition, as seen in the code editor view of your code-behind file for the XAML page.</source>
          <target xml:space="preserve">This will navigate directly to the newly inserted event handler definition, as seen in the code editor view of your code-behind file for the XAML page.</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The event handler already has the correct signature, including the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> parameter and the event data class that the event uses.</source>
          <target xml:space="preserve">The event handler already has the correct signature, including the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> parameter and the event data class that the event uses.</target>
        </segment>
      </unit>
      <unit id="148">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Also, if a handler method with the correct signature already exists in your code-behind, that method's name appears in the auto-complete drop-down along with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">&amp;lt;New Event Handler&amp;gt;</pc> option.</source>
          <target xml:space="preserve">Also, if a handler method with the correct signature already exists in your code-behind, that method's name appears in the auto-complete drop-down along with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">&amp;lt;New Event Handler&amp;gt;</pc> option.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source xml:space="preserve">You can also press the Tab key as a shortcut instead of clicking the IntelliSense list items.</source>
          <target xml:space="preserve">You can also press the Tab key as a shortcut instead of clicking the IntelliSense list items.</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source xml:space="preserve">Defining an event handler</source>
          <target xml:space="preserve">Defining an event handler</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source xml:space="preserve">For objects that are UI elements and declared in XAML, event handler code is defined in the partial class that serves as the code-behind for a XAML page.</source>
          <target xml:space="preserve">For objects that are UI elements and declared in XAML, event handler code is defined in the partial class that serves as the code-behind for a XAML page.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source xml:space="preserve">Event handlers are methods that you write as part of the partial class that is associated with your XAML.</source>
          <target xml:space="preserve">Event handlers are methods that you write as part of the partial class that is associated with your XAML.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source xml:space="preserve">These event handlers are based on the delegates that a particular event uses.</source>
          <target xml:space="preserve">These event handlers are based on the delegates that a particular event uses.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">Your event handler methods can be public or private.</source>
          <target xml:space="preserve">Your event handler methods can be public or private.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">Private access works because the handler and instance created by the XAML are ultimately joined by code generation.</source>
          <target xml:space="preserve">Private access works because the handler and instance created by the XAML are ultimately joined by code generation.</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source xml:space="preserve">In general, we recommend that you make your event handler methods private in the class.</source>
          <target xml:space="preserve">In general, we recommend that you make your event handler methods private in the class.</target>
        </segment>
      </unit>
      <unit id="157">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Event handlers for C++ don't get defined in partial classes, they are declared in the header as a private class member.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Event handlers for C++ don't get defined in partial classes, they are declared in the header as a private class member.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">The build actions for a C++ project take care of generating code that supports the XAML type system and code-behind model for C++.</source>
          <target xml:space="preserve">The build actions for a C++ project take care of generating code that supports the XAML type system and code-behind model for C++.</target>
        </segment>
      </unit>
      <unit id="159">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> parameter and event data</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> parameter and event data</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source xml:space="preserve">The handler you write for the event can access two values that are available as input for each case where your handler is invoked.</source>
          <target xml:space="preserve">The handler you write for the event can access two values that are available as input for each case where your handler is invoked.</target>
        </segment>
      </unit>
      <unit id="161">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The first such value is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc>, which is a reference to the object where the handler is attached.</source>
          <target xml:space="preserve">The first such value is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc>, which is a reference to the object where the handler is attached.</target>
        </segment>
      </unit>
      <unit id="162">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> parameter is typed as the base <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Object</pc> type.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> parameter is typed as the base <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Object</pc> type.</target>
        </segment>
      </unit>
      <unit id="163">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A common technique is to cast <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> to a more precise type.</source>
          <target xml:space="preserve">A common technique is to cast <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> to a more precise type.</target>
        </segment>
      </unit>
      <unit id="164">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This technique is useful if you expect to check or change state on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> object itself.</source>
          <target xml:space="preserve">This technique is useful if you expect to check or change state on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> object itself.</target>
        </segment>
      </unit>
      <unit id="165">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Based on your own app design, you usually know a type that is safe to cast <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> to, based on where the handler is attached or other design specifics.</source>
          <target xml:space="preserve">Based on your own app design, you usually know a type that is safe to cast <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> to, based on where the handler is attached or other design specifics.</target>
        </segment>
      </unit>
      <unit id="166">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The second value is event data, which generally appears in syntax definitions as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">e</pc> parameter.</source>
          <target xml:space="preserve">The second value is event data, which generally appears in syntax definitions as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">e</pc> parameter.</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can discover which properties for event data are available by looking at the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">e</pc> parameter of the delegate that is assigned for the specific event you are handling, and then using IntelliSense or Object Browser in Visual Studio.</source>
          <target xml:space="preserve">You can discover which properties for event data are available by looking at the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">e</pc> parameter of the delegate that is assigned for the specific event you are handling, and then using IntelliSense or Object Browser in Visual Studio.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source xml:space="preserve">Or you can use the Windows Runtime reference documentation.</source>
          <target xml:space="preserve">Or you can use the Windows Runtime reference documentation.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source xml:space="preserve">For some events, the event data's specific property values are as important as knowing that the event occurred.</source>
          <target xml:space="preserve">For some events, the event data's specific property values are as important as knowing that the event occurred.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source xml:space="preserve">This is especially true of the input events.</source>
          <target xml:space="preserve">This is especially true of the input events.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source xml:space="preserve">For pointer events, the position of the pointer when the event occurred might be important.</source>
          <target xml:space="preserve">For pointer events, the position of the pointer when the event occurred might be important.</target>
        </segment>
      </unit>
      <unit id="172">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208941)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208942)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For keyboard events, all possible key presses fire a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc> event.</source>
          <target xml:space="preserve">For keyboard events, all possible key presses fire a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc> event.</target>
        </segment>
      </unit>
      <unit id="173">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh943072)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To determine which key a user pressed, you must access the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyRoutedEventArgs</pc></pc> that is available to the event handler.</source>
          <target xml:space="preserve">To determine which key a user pressed, you must access the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyRoutedEventArgs</pc></pc> that is available to the event handler.</target>
        </segment>
      </unit>
      <unit id="174">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt185607)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/mt404610)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info about handling input events, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keyboard interactions</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Handle pointer input</pc>.</source>
          <target xml:space="preserve">For more info about handling input events, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keyboard interactions</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Handle pointer input</pc>.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">Input events and input scenarios often have additional considerations that are not covered in this topic, such as pointer capture for pointer events, and modifier keys and platform key codes for keyboard events.</source>
          <target xml:space="preserve">Input events and input scenarios often have additional considerations that are not covered in this topic, such as pointer capture for pointer events, and modifier keys and platform key codes for keyboard events.</target>
        </segment>
      </unit>
      <unit id="176">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Event handlers that use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> pattern</source>
          <target xml:space="preserve">Event handlers that use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> pattern</target>
        </segment>
      </unit>
      <unit id="177">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In some cases you'll want to use APIs that use an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> pattern within an event handler.</source>
          <target xml:space="preserve">In some cases you'll want to use APIs that use an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> pattern within an event handler.</target>
        </segment>
      </unit>
      <unit id="178">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh701927)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, you might use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> in an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AppBar</pc></pc> to display a file picker and interact with it.</source>
          <target xml:space="preserve">For example, you might use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> in an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AppBar</pc></pc> to display a file picker and interact with it.</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source xml:space="preserve">However, many of the file picker APIs are asynchronous.</source>
          <target xml:space="preserve">However, many of the file picker APIs are asynchronous.</target>
        </segment>
      </unit>
      <unit id="180">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">They have to be called within an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc>/awaitable scope, and the compiler will enforce this.</source>
          <target xml:space="preserve">They have to be called within an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc>/awaitable scope, and the compiler will enforce this.</target>
        </segment>
      </unit>
      <unit id="181">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">So what you can do is add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> keyword to your event handler such that the handler is now <pc dataRefEnd="id4" dataRefStart="id3" id="p2">async</pc> <pc dataRefEnd="id6" dataRefStart="id5" id="p3">void</pc>.</source>
          <target xml:space="preserve">So what you can do is add the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> keyword to your event handler such that the handler is now <pc dataRefEnd="id4" dataRefStart="id3" id="p2">async</pc> <pc dataRefEnd="id6" dataRefStart="id5" id="p3">void</pc>.</target>
        </segment>
      </unit>
      <unit id="182">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Now your event handler is permitted to make <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc>/awaitable calls.</source>
          <target xml:space="preserve">Now your event handler is permitted to make <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc>/awaitable calls.</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/jj655411)</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh974581)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For an example of user-interaction event handling using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> pattern, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">File access and pickers</pc> (part of the<pc dataRefEnd="id6" dataRefStart="id5" id="p3">Create your first Windows Runtime app using C# or Visual Basic</pc> series).</source>
          <target xml:space="preserve">For an example of user-interaction event handling using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> pattern, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">File access and pickers</pc> (part of the<pc dataRefEnd="id6" dataRefStart="id5" id="p3">Create your first Windows Runtime app using C# or Visual Basic</pc> series).</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source xml:space="preserve">See also [Call asynchronous APIs in C).</source>
          <target xml:space="preserve">See also [Call asynchronous APIs in C).</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source xml:space="preserve">Adding event handlers in code</source>
          <target xml:space="preserve">Adding event handlers in code</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">XAML is not the only way to assign an event handler to an object.</source>
          <target xml:space="preserve">XAML is not the only way to assign an event handler to an object.</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source xml:space="preserve">To add event handlers to any given object in code, including to objects that are not usable in XAML, you can use the language-specific syntax for adding event handlers.</source>
          <target xml:space="preserve">To add event handlers to any given object in code, including to objects that are not usable in XAML, you can use the language-specific syntax for adding event handlers.</target>
        </segment>
      </unit>
      <unit id="188">
        <originalData>
          <data id="id1">`+=`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In C#, the syntax is to use the <ph dataRef="id1" id="ph1" /> operator.</source>
          <target xml:space="preserve">In C#, the syntax is to use the <ph dataRef="id1" id="ph1" /> operator.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source xml:space="preserve">You register the handler by referencing the event handler method name on the right side of the operator.</source>
          <target xml:space="preserve">You register the handler by referencing the event handler method name on the right side of the operator.</target>
        </segment>
      </unit>
      <unit id="190">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208723)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208737)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you use code to add event handlers to objects that appear in the run-time UI, a common practice is to add such handlers in response to an object lifetime event or callback, such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Loaded</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnApplyTemplate</pc></pc>, so that the event handlers on the relevant object are ready for user-initiated events at run time.</source>
          <target xml:space="preserve">If you use code to add event handlers to objects that appear in the run-time UI, a common practice is to add such handlers in response to an object lifetime event or callback, such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Loaded</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnApplyTemplate</pc></pc>, so that the event handlers on the relevant object are ready for user-initiated events at run time.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source xml:space="preserve">This example shows a XAML outline of the page structure and then provides the C# language syntax for adding an event handler to an object.</source>
          <target xml:space="preserve">This example shows a XAML outline of the page structure and then provides the C# language syntax for adding an event handler to an object.</target>
        </segment>
      </unit>
      <unit id="192">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  A more verbose syntax exists.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  A more verbose syntax exists.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source xml:space="preserve">In 2005, C# added a feature called delegate inference, which enables a compiler to infer the new delegate instance and enables the previous, simpler syntax.</source>
          <target xml:space="preserve">In 2005, C# added a feature called delegate inference, which enables a compiler to infer the new delegate instance and enables the previous, simpler syntax.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source xml:space="preserve">The verbose syntax is functionally identical to the previous example, but explicitly creates a new delegate instance before registering it, thus not taking advantage of delegate inference.</source>
          <target xml:space="preserve">The verbose syntax is functionally identical to the previous example, but explicitly creates a new delegate instance before registering it, thus not taking advantage of delegate inference.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source xml:space="preserve">This explicit syntax is less common, but you might still see it in some code examples.</source>
          <target xml:space="preserve">This explicit syntax is less common, but you might still see it in some code examples.</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source xml:space="preserve">There are two possibilities for Visual Basic syntax.</source>
          <target xml:space="preserve">There are two possibilities for Visual Basic syntax.</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source xml:space="preserve">One is to parallel the C# syntax and attach handlers directly to instances.</source>
          <target xml:space="preserve">One is to parallel the C# syntax and attach handlers directly to instances.</target>
        </segment>
      </unit>
      <unit id="198">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This requires the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AddHandler</pc> keyword and also the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">AddressOf</pc> operator that dereferences the handler method name.</source>
          <target xml:space="preserve">This requires the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AddHandler</pc> keyword and also the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">AddressOf</pc> operator that dereferences the handler method name.</target>
        </segment>
      </unit>
      <unit id="199">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The other option for Visual Basic syntax is to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handles</pc> keyword on event handlers.</source>
          <target xml:space="preserve">The other option for Visual Basic syntax is to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handles</pc> keyword on event handlers.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source xml:space="preserve">This technique is appropriate for cases where handlers are expected to exist on objects at load time and persist throughout the object lifetime.</source>
          <target xml:space="preserve">This technique is appropriate for cases where handlers are expected to exist on objects at load time and persist throughout the object lifetime.</target>
        </segment>
      </unit>
      <unit id="201">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handles</pc> on an object that is defined in XAML requires that you provide a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc> / <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x:Name</pc>.</source>
          <target xml:space="preserve">Using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handles</pc> on an object that is defined in XAML requires that you provide a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc> / <pc dataRefEnd="id6" dataRefStart="id5" id="p3">x:Name</pc>.</target>
        </segment>
      </unit>
      <unit id="202">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This name becomes the instance qualifier that is needed for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Instance.Event</pc> part of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Handles</pc> syntax.</source>
          <target xml:space="preserve">This name becomes the instance qualifier that is needed for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Instance.Event</pc> part of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Handles</pc> syntax.</target>
        </segment>
      </unit>
      <unit id="203">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In this case you don't need an object lifetime-based event handler to initiate attaching the other event handlers; the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handles</pc> connections are created when you compile your XAML page.</source>
          <target xml:space="preserve">In this case you don't need an object lifetime-based event handler to initiate attaching the other event handlers; the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handles</pc> connections are created when you compile your XAML page.</target>
        </segment>
      </unit>
      <unit id="204">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Visual Studio and its XAML design surface generally promote the instance-handling technique instead of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Handles</pc> keyword.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Visual Studio and its XAML design surface generally promote the instance-handling technique instead of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Handles</pc> keyword.</target>
        </segment>
      </unit>
      <unit id="205">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This is because establishing the event handler wiring in XAML is part of typical designer-developer workflow, and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handles</pc> keyword technique is incompatible with wiring the event handlers in XAML.</source>
          <target xml:space="preserve">This is because establishing the event handler wiring in XAML is part of typical designer-developer workflow, and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handles</pc> keyword technique is incompatible with wiring the event handlers in XAML.</target>
        </segment>
      </unit>
      <unit id="206">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In C++, you also use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">+=</pc> syntax, but there are differences from the basic C# form:</source>
          <target xml:space="preserve">In C++, you also use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">+=</pc> syntax, but there are differences from the basic C# form:</target>
        </segment>
      </unit>
      <unit id="207">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">No delegate inference exists, so you must use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ref new</pc> for the delegate instance.</source>
          <target xml:space="preserve">No delegate inference exists, so you must use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ref new</pc> for the delegate instance.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source xml:space="preserve">The delegate constructor has two parameters, and requires the target object as the first parameter.</source>
          <target xml:space="preserve">The delegate constructor has two parameters, and requires the target object as the first parameter.</target>
        </segment>
      </unit>
      <unit id="209">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Typically you specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">this</pc>.</source>
          <target xml:space="preserve">Typically you specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">this</pc>.</target>
        </segment>
      </unit>
      <unit id="210">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The delegate constructor requires the method address as the second parameter, so the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">&amp;</pc> reference operator precedes the method name.</source>
          <target xml:space="preserve">The delegate constructor requires the method address as the second parameter, so the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">&amp;</pc> reference operator precedes the method name.</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source xml:space="preserve">Removing event handlers in code</source>
          <target xml:space="preserve">Removing event handlers in code</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source xml:space="preserve">It's not usually necessary to remove event handlers in code, even if you added them in code.</source>
          <target xml:space="preserve">It's not usually necessary to remove event handlers in code, even if you added them in code.</target>
        </segment>
      </unit>
      <unit id="213">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209041)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The object lifetime behavior for most Windows Runtime objects such as pages and controls will destroy the objects when they are disconnected from the main <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Window</pc></pc> and its visual tree, and any delegate references are destroyed too.</source>
          <target xml:space="preserve">The object lifetime behavior for most Windows Runtime objects such as pages and controls will destroy the objects when they are disconnected from the main <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Window</pc></pc> and its visual tree, and any delegate references are destroyed too.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source xml:space="preserve">.NET does this through garbage collection and Windows Runtime with C++/CX uses weak references by default.</source>
          <target xml:space="preserve">.NET does this through garbage collection and Windows Runtime with C++/CX uses weak references by default.</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source xml:space="preserve">There are some rare cases where you do want to remove event handlers explicitly.</source>
          <target xml:space="preserve">There are some rare cases where you do want to remove event handlers explicitly.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source xml:space="preserve">These include:</source>
          <target xml:space="preserve">These include:</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source xml:space="preserve">Handlers you added for static events, which can't get garbage-collected in a conventional way.</source>
          <target xml:space="preserve">Handlers you added for static events, which can't get garbage-collected in a conventional way.</target>
        </segment>
      </unit>
      <unit id="218">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228126)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br205867)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Examples of static events in the Windows Runtime API are the events of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionTarget</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Clipboard</pc></pc> classes.</source>
          <target xml:space="preserve">Examples of static events in the Windows Runtime API are the events of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionTarget</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Clipboard</pc></pc> classes.</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source xml:space="preserve">Test code where you want the timing of handler removal to be immediate, or code where you what to swap old/new event handlers for an event at run time.</source>
          <target xml:space="preserve">Test code where you want the timing of handler removal to be immediate, or code where you what to swap old/new event handlers for an event at run time.</target>
        </segment>
      </unit>
      <unit id="220">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The implementation of a custom <pc dataRefEnd="id2" dataRefStart="id1" id="p1">remove</pc> accessor.</source>
          <target xml:space="preserve">The implementation of a custom <pc dataRefEnd="id2" dataRefStart="id1" id="p1">remove</pc> accessor.</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source xml:space="preserve">Custom static events.</source>
          <target xml:space="preserve">Custom static events.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source xml:space="preserve">Handlers for page navigations.</source>
          <target xml:space="preserve">Handlers for page navigations.</target>
        </segment>
      </unit>
      <unit id="223">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208748)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227507)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Unloaded</pc>
						</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Page.NavigatedFrom</pc></pc> are possible event triggers that have appropriate positions in state management and object lifetime such that you can use them for removing handlers for other events.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Unloaded</pc>
						</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Page.NavigatedFrom</pc></pc> are possible event triggers that have appropriate positions in state management and object lifetime such that you can use them for removing handlers for other events.</target>
        </segment>
      </unit>
      <unit id="224">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, you can remove an event handler named <pc dataRefEnd="id2" dataRefStart="id1" id="p1">textBlock1\_PointerEntered</pc> from the target object <pc dataRefEnd="id4" dataRefStart="id3" id="p2">textBlock1</pc> using this code.</source>
          <target xml:space="preserve">For example, you can remove an event handler named <pc dataRefEnd="id2" dataRefStart="id1" id="p1">textBlock1\_PointerEntered</pc> from the target object <pc dataRefEnd="id4" dataRefStart="id3" id="p2">textBlock1</pc> using this code.</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
          <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source xml:space="preserve">You can also remove handlers for cases where the event was added through a XAML attribute, which means that the handler was added in generated code.</source>
          <target xml:space="preserve">You can also remove handlers for cases where the event was added through a XAML attribute, which means that the handler was added in generated code.</target>
        </segment>
      </unit>
      <unit id="227">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This is easier to do if you provided a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> value for the element where the handler was attached, because that provides an object reference for code later; however, you could also walk the object tree in order to find the necessary object reference in cases where the object has no <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc>.</source>
          <target xml:space="preserve">This is easier to do if you provided a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> value for the element where the handler was attached, because that provides an object reference for code later; however, you could also walk the object tree in order to find the necessary object reference in cases where the object has no <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc>.</target>
        </segment>
      </unit>
      <unit id="228">
        <originalData>
          <data id="id1">`+=`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you need to remove an event handler in C++/CX, you'll need a registration token, which you should've received from the return value of the <ph dataRef="id1" id="ph1" /> event handler registration.</source>
          <target xml:space="preserve">If you need to remove an event handler in C++/CX, you'll need a registration token, which you should've received from the return value of the <ph dataRef="id1" id="ph1" /> event handler registration.</target>
        </segment>
      </unit>
      <unit id="229">
        <originalData>
          <data id="id1">`-=`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">That's because the value you use for the right side of the <ph dataRef="id1" id="ph1" /> deregistration in the C++/CX syntax is the token, not the method name.</source>
          <target xml:space="preserve">That's because the value you use for the right side of the <ph dataRef="id1" id="ph1" /> deregistration in the C++/CX syntax is the token, not the method name.</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source xml:space="preserve">For C++/CX, you can't remove handlers that were added as a XAML attribute because the C++/CX generated code doesn't save a token.</source>
          <target xml:space="preserve">For C++/CX, you can't remove handlers that were added as a XAML attribute because the C++/CX generated code doesn't save a token.</target>
        </segment>
      </unit>
      <unit id="231">
        <segment state="initial">
          <source xml:space="preserve">Routed events</source>
          <target xml:space="preserve">Routed events</target>
        </segment>
      </unit>
      <unit id="232">
        <segment state="initial">
          <source xml:space="preserve">The Windows Runtime with C#, Microsoft Visual Basic or C++/CX supports the concept of a routed event for a set of events that are present on most UI elements.</source>
          <target xml:space="preserve">The Windows Runtime with C#, Microsoft Visual Basic or C++/CX supports the concept of a routed event for a set of events that are present on most UI elements.</target>
        </segment>
      </unit>
      <unit id="233">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208911)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">These events are for input and user interaction scenarios, and they are implemented on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> base class.</source>
          <target xml:space="preserve">These events are for input and user interaction scenarios, and they are implemented on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> base class.</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source xml:space="preserve">Here's a list of input events that are routed events:</source>
          <target xml:space="preserve">Here's a list of input events that are routed events:</target>
        </segment>
      </unit>
      <unit id="235">
        <segment state="initial">
          <source xml:space="preserve">DoubleTapped</source>
          <target xml:space="preserve">DoubleTapped</target>
        </segment>
      </unit>
      <unit id="236">
        <segment state="initial">
          <source xml:space="preserve">DragEnter</source>
          <target xml:space="preserve">DragEnter</target>
        </segment>
      </unit>
      <unit id="237">
        <segment state="initial">
          <source xml:space="preserve">DragLeave</source>
          <target xml:space="preserve">DragLeave</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source xml:space="preserve">DragOver</source>
          <target xml:space="preserve">DragOver</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source xml:space="preserve">Drop</source>
          <target xml:space="preserve">Drop</target>
        </segment>
      </unit>
      <unit id="240">
        <segment state="initial">
          <source xml:space="preserve">Holding</source>
          <target xml:space="preserve">Holding</target>
        </segment>
      </unit>
      <unit id="241">
        <segment state="initial">
          <source xml:space="preserve">KeyDown</source>
          <target xml:space="preserve">KeyDown</target>
        </segment>
      </unit>
      <unit id="242">
        <segment state="initial">
          <source xml:space="preserve">KeyUp</source>
          <target xml:space="preserve">KeyUp</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source xml:space="preserve">ManipulationCompleted</source>
          <target xml:space="preserve">ManipulationCompleted</target>
        </segment>
      </unit>
      <unit id="244">
        <segment state="initial">
          <source xml:space="preserve">ManipulationDelta</source>
          <target xml:space="preserve">ManipulationDelta</target>
        </segment>
      </unit>
      <unit id="245">
        <segment state="initial">
          <source xml:space="preserve">ManipulationInertiaStarting</source>
          <target xml:space="preserve">ManipulationInertiaStarting</target>
        </segment>
      </unit>
      <unit id="246">
        <segment state="initial">
          <source xml:space="preserve">ManipulationStarted</source>
          <target xml:space="preserve">ManipulationStarted</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source xml:space="preserve">ManipulationStarting</source>
          <target xml:space="preserve">ManipulationStarting</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source xml:space="preserve">PointerCanceled</source>
          <target xml:space="preserve">PointerCanceled</target>
        </segment>
      </unit>
      <unit id="249">
        <segment state="initial">
          <source xml:space="preserve">PointerCaptureLost</source>
          <target xml:space="preserve">PointerCaptureLost</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source xml:space="preserve">PointerEntered</source>
          <target xml:space="preserve">PointerEntered</target>
        </segment>
      </unit>
      <unit id="251">
        <segment state="initial">
          <source xml:space="preserve">PointerExited</source>
          <target xml:space="preserve">PointerExited</target>
        </segment>
      </unit>
      <unit id="252">
        <segment state="initial">
          <source xml:space="preserve">PointerMoved</source>
          <target xml:space="preserve">PointerMoved</target>
        </segment>
      </unit>
      <unit id="253">
        <segment state="initial">
          <source xml:space="preserve">PointerPressed</source>
          <target xml:space="preserve">PointerPressed</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source xml:space="preserve">PointerReleased</source>
          <target xml:space="preserve">PointerReleased</target>
        </segment>
      </unit>
      <unit id="255">
        <segment state="initial">
          <source xml:space="preserve">PointerWheelChanged</source>
          <target xml:space="preserve">PointerWheelChanged</target>
        </segment>
      </unit>
      <unit id="256">
        <segment state="initial">
          <source xml:space="preserve">RightTapped</source>
          <target xml:space="preserve">RightTapped</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source xml:space="preserve">Tapped</source>
          <target xml:space="preserve">Tapped</target>
        </segment>
      </unit>
      <unit id="258">
        <segment state="initial">
          <source xml:space="preserve">GotFocus</source>
          <target xml:space="preserve">GotFocus</target>
        </segment>
      </unit>
      <unit id="259">
        <segment state="initial">
          <source xml:space="preserve">LostFocus</source>
          <target xml:space="preserve">LostFocus</target>
        </segment>
      </unit>
      <unit id="260">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A routed event is an event that is potentially passed on (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">routed</pc>) from a child object to each of its successive parent objects in an object tree.</source>
          <target xml:space="preserve">A routed event is an event that is potentially passed on (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">routed</pc>) from a child object to each of its successive parent objects in an object tree.</target>
        </segment>
      </unit>
      <unit id="261">
        <segment state="initial">
          <source xml:space="preserve">The XAML structure of your UI approximates this tree, with the root of that tree being the root element in XAML.</source>
          <target xml:space="preserve">The XAML structure of your UI approximates this tree, with the root of that tree being the root element in XAML.</target>
        </segment>
      </unit>
      <unit id="262">
        <segment state="initial">
          <source xml:space="preserve">The true object tree might vary somewhat from the XAML element nesting, because the object tree doesn't include XAML language features such as property element tags.</source>
          <target xml:space="preserve">The true object tree might vary somewhat from the XAML element nesting, because the object tree doesn't include XAML language features such as property element tags.</target>
        </segment>
      </unit>
      <unit id="263">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can conceive of the routed event as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">bubbling</pc> from any XAML object element child element that fires the event, toward the parent object element that contains it.</source>
          <target xml:space="preserve">You can conceive of the routed event as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">bubbling</pc> from any XAML object element child element that fires the event, toward the parent object element that contains it.</target>
        </segment>
      </unit>
      <unit id="264">
        <segment state="initial">
          <source xml:space="preserve">The event and its event data can be handled on multiple objects along the event route.</source>
          <target xml:space="preserve">The event and its event data can be handled on multiple objects along the event route.</target>
        </segment>
      </unit>
      <unit id="265">
        <segment state="initial">
          <source xml:space="preserve">If no element has handlers, the route potentially keeps going until the root element is reached.</source>
          <target xml:space="preserve">If no element has handlers, the route potentially keeps going until the root element is reached.</target>
        </segment>
      </unit>
      <unit id="266">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you know Web technologies such as Dynamic HTML (DHTML) or HTML5, you might already be familiar with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">bubbling</pc> event concept.</source>
          <target xml:space="preserve">If you know Web technologies such as Dynamic HTML (DHTML) or HTML5, you might already be familiar with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">bubbling</pc> event concept.</target>
        </segment>
      </unit>
      <unit id="267">
        <segment state="initial">
          <source xml:space="preserve">When a routed event bubbles through its event route, any attached event handlers all access a shared instance of event data.</source>
          <target xml:space="preserve">When a routed event bubbles through its event route, any attached event handlers all access a shared instance of event data.</target>
        </segment>
      </unit>
      <unit id="268">
        <segment state="initial">
          <source xml:space="preserve">Therefore, if any of the event data is writeable by a handler, any changes made to event data will be passed on to the next handler, and may no longer represent the original event data from the event.</source>
          <target xml:space="preserve">Therefore, if any of the event data is writeable by a handler, any changes made to event data will be passed on to the next handler, and may no longer represent the original event data from the event.</target>
        </segment>
      </unit>
      <unit id="269">
        <segment state="initial">
          <source xml:space="preserve">When an event has a routed event behavior, the reference documentation will include remarks or other notations about the routed behavior.</source>
          <target xml:space="preserve">When an event has a routed event behavior, the reference documentation will include remarks or other notations about the routed behavior.</target>
        </segment>
      </unit>
      <unit id="270">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OriginalSource</pc> property of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">RoutedEventArgs</pc></source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OriginalSource</pc> property of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">RoutedEventArgs</pc></target>
        </segment>
      </unit>
      <unit id="271">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When an event bubbles up an event route, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> is no longer the same object as the event-raising object.</source>
          <target xml:space="preserve">When an event bubbles up an event route, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> is no longer the same object as the event-raising object.</target>
        </segment>
      </unit>
      <unit id="272">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Instead, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> is the object where the handler that is being invoked is attached.</source>
          <target xml:space="preserve">Instead, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> is the object where the handler that is being invoked is attached.</target>
        </segment>
      </unit>
      <unit id="273">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In some cases, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> is not interesting, and you are instead interested in info such as which of the possible child objects the pointer is over when a pointer event fired, or which object in a larger UI held focus when a user pressed a keyboard key.</source>
          <target xml:space="preserve">In some cases, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sender</pc> is not interesting, and you are instead interested in info such as which of the possible child objects the pointer is over when a pointer event fired, or which object in a larger UI held focus when a user pressed a keyboard key.</target>
        </segment>
      </unit>
      <unit id="274">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208810)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For these cases, you can use the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OriginalSource</pc></pc> property.</source>
          <target xml:space="preserve">For these cases, you can use the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OriginalSource</pc></pc> property.</target>
        </segment>
      </unit>
      <unit id="275">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">At all points on the route, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OriginalSource</pc> reports the original object that fired the event, instead of the object where the handler is attached.</source>
          <target xml:space="preserve">At all points on the route, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OriginalSource</pc> reports the original object that fired the event, instead of the object where the handler is attached.</target>
        </segment>
      </unit>
      <unit id="276">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208911)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">However, for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> input events, that original object is often an object that is not immediately visible in the page-level UI definition XAML.</source>
          <target xml:space="preserve">However, for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> input events, that original object is often an object that is not immediately visible in the page-level UI definition XAML.</target>
        </segment>
      </unit>
      <unit id="277">
        <segment state="initial">
          <source xml:space="preserve">Instead, that original source object might be a templated part of a control.</source>
          <target xml:space="preserve">Instead, that original source object might be a templated part of a control.</target>
        </segment>
      </unit>
      <unit id="278">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br209250)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">[</data>
          <data id="id12">](https://msdn.microsoft.com/library/windows/apps/br209465)</data>
          <data id="id13">**</data>
          <data id="id14">**</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, if the user hovers the pointer over the very edge of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc>, for most pointer events the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">OriginalSource</pc> is a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Border</pc></pc> template part in the <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Template</pc></pc>, not the <pc dataRefEnd="id16" dataRefStart="id15" id="p8">Button</pc> itself.</source>
          <target xml:space="preserve">For example, if the user hovers the pointer over the very edge of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc>, for most pointer events the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">OriginalSource</pc> is a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Border</pc></pc> template part in the <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Template</pc></pc>, not the <pc dataRefEnd="id16" dataRefStart="id15" id="p8">Button</pc> itself.</target>
        </segment>
      </unit>
      <unit id="279">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  Input event bubbling is especially useful if you are creating a templated control.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>  Input event bubbling is especially useful if you are creating a templated control.</target>
        </segment>
      </unit>
      <unit id="280">
        <segment state="initial">
          <source xml:space="preserve">Any control that has a template can have a new template applied by its consumer.</source>
          <target xml:space="preserve">Any control that has a template can have a new template applied by its consumer.</target>
        </segment>
      </unit>
      <unit id="281">
        <segment state="initial">
          <source xml:space="preserve">The consumer that's trying to recreate a working template might unintentionally eliminate some event handling declared in the default template.</source>
          <target xml:space="preserve">The consumer that's trying to recreate a working template might unintentionally eliminate some event handling declared in the default template.</target>
        </segment>
      </unit>
      <unit id="282">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208737)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can still provide control-level event handling by attaching handlers as part of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnApplyTemplate</pc></pc> override in the class definition.</source>
          <target xml:space="preserve">You can still provide control-level event handling by attaching handlers as part of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnApplyTemplate</pc></pc> override in the class definition.</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source xml:space="preserve">Then you can catch the input events that bubble up to the control's root on instantiation.</source>
          <target xml:space="preserve">Then you can catch the input events that bubble up to the control's root on instantiation.</target>
        </segment>
      </unit>
      <unit id="284">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> property</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> property</target>
        </segment>
      </unit>
      <unit id="285">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Several event data classes for specific routed events contain a property named <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc>.</source>
          <target xml:space="preserve">Several event data classes for specific routed events contain a property named <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc>.</target>
        </segment>
      </unit>
      <unit id="286">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh943079)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh943073)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/br242375)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For examples, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerRoutedEventArgs.Handled</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyRoutedEventArgs.Handled</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">DragEventArgs.Handled</pc></pc>.</source>
          <target xml:space="preserve">For examples, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerRoutedEventArgs.Handled</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyRoutedEventArgs.Handled</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">DragEventArgs.Handled</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="287">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In all cases <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> is a settable Boolean property.</source>
          <target xml:space="preserve">In all cases <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> is a settable Boolean property.</target>
        </segment>
      </unit>
      <unit id="288">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> property to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">true</pc> influences the event system behavior.</source>
          <target xml:space="preserve">Setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> property to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">true</pc> influences the event system behavior.</target>
        </segment>
      </unit>
      <unit id="289">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">true</pc>, the routing stops for most event handlers; the event doesn't continue along the route to notify other attached handlers of that particular event case.</source>
          <target xml:space="preserve">When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">true</pc>, the routing stops for most event handlers; the event doesn't continue along the route to notify other attached handlers of that particular event case.</target>
        </segment>
      </unit>
      <unit id="290">
        <segment state="initial">
          <source xml:space="preserve">What "handled" means in the context of the event and how your app responds to it is up to you.</source>
          <target xml:space="preserve">What "handled" means in the context of the event and how your app responds to it is up to you.</target>
        </segment>
      </unit>
      <unit id="291">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Basically, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> is a simple protocol that enables app code to state that an occurrence of an event doesn't need to bubble to any containers, your app logic has taken care of what needs done.</source>
          <target xml:space="preserve">Basically, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> is a simple protocol that enables app code to state that an occurrence of an event doesn't need to bubble to any containers, your app logic has taken care of what needs done.</target>
        </segment>
      </unit>
      <unit id="292">
        <segment state="initial">
          <source xml:space="preserve">Conversely though, you do have to be careful that you aren't handling events that probably should bubble so that built-in system or control behaviors can act.</source>
          <target xml:space="preserve">Conversely though, you do have to be careful that you aren't handling events that probably should bubble so that built-in system or control behaviors can act.</target>
        </segment>
      </unit>
      <unit id="293">
        <segment state="initial">
          <source xml:space="preserve">For example, handling low-level events within the parts or items of a selection control can be detrimental.</source>
          <target xml:space="preserve">For example, handling low-level events within the parts or items of a selection control can be detrimental.</target>
        </segment>
      </unit>
      <unit id="294">
        <segment state="initial">
          <source xml:space="preserve">The selection control might be looking for input events to know that the selection should change.</source>
          <target xml:space="preserve">The selection control might be looking for input events to know that the selection should change.</target>
        </segment>
      </unit>
      <unit id="295">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Not all of the routed events can cancel a route in this way, and you can tell that because they won't have a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> property.</source>
          <target xml:space="preserve">Not all of the routed events can cancel a route in this way, and you can tell that because they won't have a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> property.</target>
        </segment>
      </unit>
      <unit id="296">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208927)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208943)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GotFocus</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">LostFocus</pc></pc> do bubble, but they always bubble all the way to the root, and their event data classes don't have a <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Handled</pc> property that can influence that behavior.</source>
          <target xml:space="preserve">For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GotFocus</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">LostFocus</pc></pc> do bubble, but they always bubble all the way to the root, and their event data classes don't have a <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Handled</pc> property that can influence that behavior.</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source xml:space="preserve">Input event handlers in controls</source>
          <target xml:space="preserve">Input event handlers in controls</target>
        </segment>
      </unit>
      <unit id="298">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Specific Windows Runtime controls sometimes use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> concept for input events internally.</source>
          <target xml:space="preserve">Specific Windows Runtime controls sometimes use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> concept for input events internally.</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source xml:space="preserve">This can make it seem like an input event never occurs, because your user code can't handle it.</source>
          <target xml:space="preserve">This can make it seem like an input event never occurs, because your user code can't handle it.</target>
        </segment>
      </unit>
      <unit id="300">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208971)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> class includes logic that deliberately handles the general input event <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PointerPressed</pc></pc>.</source>
          <target xml:space="preserve">For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> class includes logic that deliberately handles the general input event <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PointerPressed</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="301">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227737)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">It does so because buttons fire a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc></pc> event that is initiated by pointer-pressed input, as well as by other input modes such as handling keys like the Enter key that can invoke the button when it's focused.</source>
          <target xml:space="preserve">It does so because buttons fire a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc></pc> event that is initiated by pointer-pressed input, as well as by other input modes such as handling keys like the Enter key that can invoke the button when it's focused.</target>
        </segment>
      </unit>
      <unit id="302">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For purposes of the class design of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Button</pc>, the raw input event is conceptually handled, and class consumers such as your user code can instead interact with the control-relevant <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc> event.</source>
          <target xml:space="preserve">For purposes of the class design of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Button</pc>, the raw input event is conceptually handled, and class consumers such as your user code can instead interact with the control-relevant <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc> event.</target>
        </segment>
      </unit>
      <unit id="303">
        <segment state="initial">
          <source xml:space="preserve">Topics for specific control classes in the Windows Runtime API reference often note the event handling behavior that the class implements.</source>
          <target xml:space="preserve">Topics for specific control classes in the Windows Runtime API reference often note the event handling behavior that the class implements.</target>
        </segment>
      </unit>
      <unit id="304">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In some cases, you can change the behavior by overriding <pc dataRefEnd="id2" dataRefStart="id1" id="p1">On</pc><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Event</pc> methods.</source>
          <target xml:space="preserve">In some cases, you can change the behavior by overriding <pc dataRefEnd="id2" dataRefStart="id1" id="p1">On</pc><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Event</pc> methods.</target>
        </segment>
      </unit>
      <unit id="305">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209683)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh967982)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, you can change how your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBox</pc></pc> derived class reacts to key input by overriding <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Control.OnKeyDown</pc></pc>.</source>
          <target xml:space="preserve">For example, you can change how your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBox</pc></pc> derived class reacts to key input by overriding <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Control.OnKeyDown</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="306">
        <segment state="initial">
          <source xml:space="preserve">Registering handlers for already-handled routed events</source>
          <target xml:space="preserve">Registering handlers for already-handled routed events</target>
        </segment>
      </unit>
      <unit id="307">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Earlier we said that setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">true</pc> prevents most handlers from being called.</source>
          <target xml:space="preserve">Earlier we said that setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">true</pc> prevents most handlers from being called.</target>
        </segment>
      </unit>
      <unit id="308">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702399)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AddHandler</pc></pc> method provides a technique where you can attach a handler that is always invoked for the route, even if some other handler earlier in the route has set <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Handled</pc> to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">true</pc> in the shared event data.</source>
          <target xml:space="preserve">But the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AddHandler</pc></pc> method provides a technique where you can attach a handler that is always invoked for the route, even if some other handler earlier in the route has set <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Handled</pc> to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">true</pc> in the shared event data.</target>
        </segment>
      </unit>
      <unit id="309">
        <segment state="initial">
          <source xml:space="preserve">This technique is useful if a control you are using has handled the event in its internal compositing or for control-specific logic.</source>
          <target xml:space="preserve">This technique is useful if a control you are using has handled the event in its internal compositing or for control-specific logic.</target>
        </segment>
      </unit>
      <unit id="310">
        <segment state="initial">
          <source xml:space="preserve">but you still want to respond to it from a control instance, or your app UI.</source>
          <target xml:space="preserve">but you still want to respond to it from a control instance, or your app UI.</target>
        </segment>
      </unit>
      <unit id="311">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But use this technique with caution, because it can contradict the purpose of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> and possibly break a control's intended interactions.</source>
          <target xml:space="preserve">But use this technique with caution, because it can contradict the purpose of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Handled</pc> and possibly break a control's intended interactions.</target>
        </segment>
      </unit>
      <unit id="312">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702399)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Only the routed events that have a corresponding routed event identifier can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AddHandler</pc></pc> event handling technique, because the identifier is a required input of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">AddHandler</pc> method.</source>
          <target xml:space="preserve">Only the routed events that have a corresponding routed event identifier can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AddHandler</pc></pc> event handling technique, because the identifier is a required input of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">AddHandler</pc> method.</target>
        </segment>
      </unit>
      <unit id="313">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702399)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">See the reference documentation for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AddHandler</pc></pc> for a list of events that have routed event identifiers available.</source>
          <target xml:space="preserve">See the reference documentation for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AddHandler</pc></pc> for a list of events that have routed event identifiers available.</target>
        </segment>
      </unit>
      <unit id="314">
        <segment state="initial">
          <source xml:space="preserve">For the most part this is the same list of routed events we showed you earlier.</source>
          <target xml:space="preserve">For the most part this is the same list of routed events we showed you earlier.</target>
        </segment>
      </unit>
      <unit id="315">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208927)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208943)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The exception is that the last two in the list: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GotFocus</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">LostFocus</pc></pc> don't have a routed event identifier, so you can't use <pc dataRefEnd="id10" dataRefStart="id9" id="p5">AddHandler</pc> for those.</source>
          <target xml:space="preserve">The exception is that the last two in the list: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GotFocus</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">LostFocus</pc></pc> don't have a routed event identifier, so you can't use <pc dataRefEnd="id10" dataRefStart="id9" id="p5">AddHandler</pc> for those.</target>
        </segment>
      </unit>
      <unit id="316">
        <segment state="initial">
          <source xml:space="preserve">Routed events outside the visual tree</source>
          <target xml:space="preserve">Routed events outside the visual tree</target>
        </segment>
      </unit>
      <unit id="317">
        <segment state="initial">
          <source xml:space="preserve">Certain objects participate in a relationship with the primary visual tree that is conceptually like having an overlay over the main visuals.</source>
          <target xml:space="preserve">Certain objects participate in a relationship with the primary visual tree that is conceptually like having an overlay over the main visuals.</target>
        </segment>
      </unit>
      <unit id="318">
        <segment state="initial">
          <source xml:space="preserve">These objects are not part of the usual parent-child relationships that connect all tree elements to the visual root.</source>
          <target xml:space="preserve">These objects are not part of the usual parent-child relationships that connect all tree elements to the visual root.</target>
        </segment>
      </unit>
      <unit id="319">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227842)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227608)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This is the case for any displayed <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Popup</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ToolTip</pc></pc>.</source>
          <target xml:space="preserve">This is the case for any displayed <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Popup</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ToolTip</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="320">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you want to handle routed events from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Popup</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ToolTip</pc>, place the handlers on specific UI elements that are within the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Popup</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">ToolTip</pc> and not the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Popup</pc> or <pc dataRefEnd="id12" dataRefStart="id11" id="p6">ToolTip</pc> elements themselves.</source>
          <target xml:space="preserve">If you want to handle routed events from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Popup</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ToolTip</pc>, place the handlers on specific UI elements that are within the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Popup</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">ToolTip</pc> and not the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Popup</pc> or <pc dataRefEnd="id12" dataRefStart="id11" id="p6">ToolTip</pc> elements themselves.</target>
        </segment>
      </unit>
      <unit id="321">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Don't rely on routing inside any compositing that is performed for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Popup</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ToolTip</pc> content.</source>
          <target xml:space="preserve">Don't rely on routing inside any compositing that is performed for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Popup</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ToolTip</pc> content.</target>
        </segment>
      </unit>
      <unit id="322">
        <segment state="initial">
          <source xml:space="preserve">This is because event routing for routed events works only along the main visual tree.</source>
          <target xml:space="preserve">This is because event routing for routed events works only along the main visual tree.</target>
        </segment>
      </unit>
      <unit id="323">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Popup</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ToolTip</pc> is not considered a parent of subsidiary UI elements and never receives the routed event, even if it is trying to use something like the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Popup</pc> default background as the capture area for input events.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Popup</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ToolTip</pc> is not considered a parent of subsidiary UI elements and never receives the routed event, even if it is trying to use something like the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Popup</pc> default background as the capture area for input events.</target>
        </segment>
      </unit>
      <unit id="324">
        <segment state="initial">
          <source xml:space="preserve">Hit testing and input events</source>
          <target xml:space="preserve">Hit testing and input events</target>
        </segment>
      </unit>
      <unit id="325">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Determining whether and where in UI an element is visible to mouse, touch, and stylus input is called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">hit testing</pc>.</source>
          <target xml:space="preserve">Determining whether and where in UI an element is visible to mouse, touch, and stylus input is called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">hit testing</pc>.</target>
        </segment>
      </unit>
      <unit id="326">
        <segment state="initial">
          <source xml:space="preserve">For touch actions and also for interaction-specific or manipulation events that are consequences of a touch action, an element must be hit-test visible in order to be the event source and fire the event that is associated with the action.</source>
          <target xml:space="preserve">For touch actions and also for interaction-specific or manipulation events that are consequences of a touch action, an element must be hit-test visible in order to be the event source and fire the event that is associated with the action.</target>
        </segment>
      </unit>
      <unit id="327">
        <segment state="initial">
          <source xml:space="preserve">Otherwise, the action passes through the element to any underlying elements or parent elements in the visual tree that could interact with that input.</source>
          <target xml:space="preserve">Otherwise, the action passes through the element to any underlying elements or parent elements in the visual tree that could interact with that input.</target>
        </segment>
      </unit>
      <unit id="328">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208933)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">There are several factors that affect hit testing, but you can determine whether a given element can fire input events by checking its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsHitTestVisible</pc></pc> property.</source>
          <target xml:space="preserve">There are several factors that affect hit testing, but you can determine whether a given element can fire input events by checking its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsHitTestVisible</pc></pc> property.</target>
        </segment>
      </unit>
      <unit id="329">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This property returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc> only if the element meets these criteria:</source>
          <target xml:space="preserve">This property returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc> only if the element meets these criteria:</target>
        </segment>
      </unit>
      <unit id="330">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208992)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209006)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The element's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visibility</pc></pc> property value is <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visible</pc></pc>.</source>
          <target xml:space="preserve">The element's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visibility</pc></pc> property value is <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visible</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="331">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The element's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Background</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Fill</pc> property value is not <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.</source>
          <target xml:space="preserve">The element's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Background</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Fill</pc> property value is not <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.</target>
        </segment>
      </unit>
      <unit id="332">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br228076)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Brush</pc></pc> value results in transparency and hit test invisibility.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Brush</pc></pc> value results in transparency and hit test invisibility.</target>
        </segment>
      </unit>
      <unit id="333">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh748061)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">(To make an element transparent but also hit testable, use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Transparent</pc></pc> brush instead of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.)</source>
          <target xml:space="preserve">(To make an element transparent but also hit testable, use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Transparent</pc></pc> brush instead of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.)</target>
        </segment>
      </unit>
      <unit id="334">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br208911)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">[</data>
          <data id="id12">](https://msdn.microsoft.com/library/windows/apps/br209390)</data>
          <data id="id13">**</data>
          <data id="id14">**</data>
          <data id="id15">[</data>
          <data id="id16">](https://msdn.microsoft.com/library/windows/apps/br243377)</data>
          <data id="id17">**</data>
          <data id="id18">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Background</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Fill</pc> aren't defined by <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">UIElement</pc></pc>, and are instead defined by different derived classes such as <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Control</pc></pc> and <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">Shape</pc></pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Background</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Fill</pc> aren't defined by <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">UIElement</pc></pc>, and are instead defined by different derived classes such as <pc dataRefEnd="id12" dataRefStart="id11" id="p6"><pc dataRefEnd="id14" dataRefStart="id13" id="p7">Control</pc></pc> and <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">Shape</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="335">
        <segment state="initial">
          <source xml:space="preserve">But the implications of brushes you use for foreground and background properties are the same for hit testing and input events, no matter which subclass implements the properties.</source>
          <target xml:space="preserve">But the implications of brushes you use for foreground and background properties are the same for hit testing and input events, no matter which subclass implements the properties.</target>
        </segment>
      </unit>
      <unit id="336">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209419)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If the element is a control, its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsEnabled</pc></pc> property value must be <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc>.</source>
          <target xml:space="preserve">If the element is a control, its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsEnabled</pc></pc> property value must be <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc>.</target>
        </segment>
      </unit>
      <unit id="337">
        <segment state="initial">
          <source xml:space="preserve">The element must have actual dimensions in layout.</source>
          <target xml:space="preserve">The element must have actual dimensions in layout.</target>
        </segment>
      </unit>
      <unit id="338">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208707)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208709)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">An element where either <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ActualHeight</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ActualWidth</pc></pc> are 0 won't fire input events.</source>
          <target xml:space="preserve">An element where either <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ActualHeight</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ActualWidth</pc></pc> are 0 won't fire input events.</target>
        </segment>
      </unit>
      <unit id="339">
        <segment state="initial">
          <source xml:space="preserve">Some controls have special rules for hit testing.</source>
          <target xml:space="preserve">Some controls have special rules for hit testing.</target>
        </segment>
      </unit>
      <unit id="340">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209652)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBlock</pc></pc> has no <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Background</pc> property, but is still hit testable within the entire region of its dimensions.</source>
          <target xml:space="preserve">For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextBlock</pc></pc> has no <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Background</pc> property, but is still hit testable within the entire region of its dimensions.</target>
        </segment>
      </unit>
      <unit id="341">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242752)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242926)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image</pc>
						</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MediaElement</pc></pc> controls are hit testable over their defined rectangle dimensions, regardless of transparent content such as alpha channel in the media source file being displayed.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image</pc>
						</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MediaElement</pc></pc> controls are hit testable over their defined rectangle dimensions, regardless of transparent content such as alpha channel in the media source file being displayed.</target>
        </segment>
      </unit>
      <unit id="342">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227702)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">WebView</pc>
						</pc> controls have special hit testing behavior because the input can be handled by the hosted HTML and fire script events.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">WebView</pc>
						</pc> controls have special hit testing behavior because the input can be handled by the hosted HTML and fire script events.</target>
        </segment>
      </unit>
      <unit id="343">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227511)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209250)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Most <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Panel</pc></pc> classes and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc></pc> are not hit-testable in their own background, but can still handle the user input events that are routed from the elements that they contain.</source>
          <target xml:space="preserve">Most <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Panel</pc></pc> classes and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc></pc> are not hit-testable in their own background, but can still handle the user input events that are routed from the elements that they contain.</target>
        </segment>
      </unit>
      <unit id="344">
        <segment state="initial">
          <source xml:space="preserve">You can determine which elements are located at the same position as a user input event, regardless of whether the elements are hit-testable.</source>
          <target xml:space="preserve">You can determine which elements are located at the same position as a user input event, regardless of whether the elements are hit-testable.</target>
        </segment>
      </unit>
      <unit id="345">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br243039)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To do this, call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindElementsInHostCoordinates</pc></pc> method.</source>
          <target xml:space="preserve">To do this, call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindElementsInHostCoordinates</pc></pc> method.</target>
        </segment>
      </unit>
      <unit id="346">
        <segment state="initial">
          <source xml:space="preserve">As the name implies, this method finds the elements at a location relative to a specified host element.</source>
          <target xml:space="preserve">As the name implies, this method finds the elements at a location relative to a specified host element.</target>
        </segment>
      </unit>
      <unit id="347">
        <segment state="initial">
          <source xml:space="preserve">However, applied transforms and layout changes can adjust the relative coordinate system of an element, and therefore affect which elements are found at a given location.</source>
          <target xml:space="preserve">However, applied transforms and layout changes can adjust the relative coordinate system of an element, and therefore affect which elements are found at a given location.</target>
        </segment>
      </unit>
      <unit id="348">
        <segment state="initial">
          <source xml:space="preserve">Commanding</source>
          <target xml:space="preserve">Commanding</target>
        </segment>
      </unit>
      <unit id="349">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A small number of UI elements support <pc dataRefEnd="id2" dataRefStart="id1" id="p1">commanding</pc>.</source>
          <target xml:space="preserve">A small number of UI elements support <pc dataRefEnd="id2" dataRefStart="id1" id="p1">commanding</pc>.</target>
        </segment>
      </unit>
      <unit id="350">
        <segment state="initial">
          <source xml:space="preserve">Commanding uses input-related routed events in its underlying implementation and enables processing of related UI input (a certain pointer action, a specific accelerator key) by invoking a single command handler.</source>
          <target xml:space="preserve">Commanding uses input-related routed events in its underlying implementation and enables processing of related UI input (a certain pointer action, a specific accelerator key) by invoking a single command handler.</target>
        </segment>
      </unit>
      <unit id="351">
        <segment state="initial">
          <source xml:space="preserve">If commanding is available for a UI element, consider using its commanding APIs instead of any discrete input events.</source>
          <target xml:space="preserve">If commanding is available for a UI element, consider using its commanding APIs instead of any discrete input events.</target>
        </segment>
      </unit>
      <unit id="352">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You typically use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Binding</pc> reference into properties of a class that defines the view model for data.</source>
          <target xml:space="preserve">You typically use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Binding</pc> reference into properties of a class that defines the view model for data.</target>
        </segment>
      </unit>
      <unit id="353">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The properties hold named commands that implement the language-specific <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ICommand</pc> commanding pattern.</source>
          <target xml:space="preserve">The properties hold named commands that implement the language-specific <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ICommand</pc> commanding pattern.</target>
        </segment>
      </unit>
      <unit id="354">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227740)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ButtonBase.Command</pc></pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ButtonBase.Command</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="355">
        <segment state="initial">
          <source xml:space="preserve">Custom events in the Windows Runtime</source>
          <target xml:space="preserve">Custom events in the Windows Runtime</target>
        </segment>
      </unit>
      <unit id="356">
        <segment state="initial">
          <source xml:space="preserve">For purposes of defining custom events, how you add the event and what that means for your class design is highly dependent on which programming language you are using.</source>
          <target xml:space="preserve">For purposes of defining custom events, how you add the event and what that means for your class design is highly dependent on which programming language you are using.</target>
        </segment>
      </unit>
      <unit id="357">
        <segment state="initial">
          <source xml:space="preserve">For C# and Visual Basic, you are defining a CLR event.</source>
          <target xml:space="preserve">For C# and Visual Basic, you are defining a CLR event.</target>
        </segment>
      </unit>
      <unit id="358">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can use the standard .NET event pattern, so long as you aren't using custom accessors (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">add</pc>/<pc dataRefEnd="id4" dataRefStart="id3" id="p2">remove</pc>).</source>
          <target xml:space="preserve">You can use the standard .NET event pattern, so long as you aren't using custom accessors (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">add</pc>/<pc dataRefEnd="id4" dataRefStart="id3" id="p2">remove</pc>).</target>
        </segment>
      </unit>
      <unit id="359">
        <segment state="initial">
          <source xml:space="preserve">Additional tips:</source>
          <target xml:space="preserve">Additional tips:</target>
        </segment>
      </unit>
      <unit id="360">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/db0etb8x.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">&lt;TEventArgs&gt;</data>
          <data id="id6">[</data>
          <data id="id7">](https://msdn.microsoft.com/library/windows/apps/br206577)</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">&lt;T&gt;</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For the event handler it's a good idea to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.EventHandler<ph dataRef="id5" id="ph1" /></pc></pc> because it has built-in translation to the Windows Runtime generic event delegate <pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">EventHandler<ph dataRef="id10" id="ph2" /></pc></pc>.</source>
          <target xml:space="preserve">For the event handler it's a good idea to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.EventHandler<ph dataRef="id5" id="ph1" /></pc></pc> because it has built-in translation to the Windows Runtime generic event delegate <pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">EventHandler<ph dataRef="id10" id="ph2" /></pc></pc>.</target>
        </segment>
      </unit>
      <unit id="361">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/system.eventargs.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Don't base your event data class on <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.EventArgs</pc></pc> because it doesn't translate to the Windows Runtime.</source>
          <target xml:space="preserve">Don't base your event data class on <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.EventArgs</pc></pc> because it doesn't translate to the Windows Runtime.</target>
        </segment>
      </unit>
      <unit id="362">
        <segment state="initial">
          <source xml:space="preserve">Use an existing event data class or no base class at all.</source>
          <target xml:space="preserve">Use an existing event data class or no base class at all.</target>
        </segment>
      </unit>
      <unit id="363">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh972883.aspx)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you are using custom accessors, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom events and event accessors in Windows Runtime Components</pc>.</source>
          <target xml:space="preserve">If you are using custom accessors, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom events and event accessors in Windows Runtime Components</pc>.</target>
        </segment>
      </unit>
      <unit id="364">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://msdn.microsoft.com/library/dd833067.aspx)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you're not clear on what the standard .NET event pattern is, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining Events for Custom Silverlight Classes</pc>.</source>
          <target xml:space="preserve">If you're not clear on what the standard .NET event pattern is, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Defining Events for Custom Silverlight Classes</pc>.</target>
        </segment>
      </unit>
      <unit id="365">
        <segment state="initial">
          <source xml:space="preserve">This is written for Microsoft Silverlight but it's still a good summation of the code and concepts for the standard .NET event pattern.</source>
          <target xml:space="preserve">This is written for Microsoft Silverlight but it's still a good summation of the code and concepts for the standard .NET event pattern.</target>
        </segment>
      </unit>
      <unit id="366">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755799.aspx)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For C++/CX, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Events (C++/CX)</pc>.</source>
          <target xml:space="preserve">For C++/CX, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Events (C++/CX)</pc>.</target>
        </segment>
      </unit>
      <unit id="367">
        <segment state="initial">
          <source xml:space="preserve">Use named references even for your own usages of custom events.</source>
          <target xml:space="preserve">Use named references even for your own usages of custom events.</target>
        </segment>
      </unit>
      <unit id="368">
        <segment state="initial">
          <source xml:space="preserve">Don't use lambda for custom events, it can create a circular reference.</source>
          <target xml:space="preserve">Don't use lambda for custom events, it can create a circular reference.</target>
        </segment>
      </unit>
      <unit id="369">
        <segment state="initial">
          <source xml:space="preserve">You can't declare a custom routed event for Windows Runtime; routed events are limited to the set that comes from the Windows Runtime.</source>
          <target xml:space="preserve">You can't declare a custom routed event for Windows Runtime; routed events are limited to the set that comes from the Windows Runtime.</target>
        </segment>
      </unit>
      <unit id="370">
        <segment state="initial">
          <source xml:space="preserve">Defining a custom event is usually done as part of the exercise of defining a custom control.</source>
          <target xml:space="preserve">Defining a custom event is usually done as part of the exercise of defining a custom control.</target>
        </segment>
      </unit>
      <unit id="371">
        <segment state="initial">
          <source xml:space="preserve">It's a common pattern to have a dependency property that has a property-changed callback, and to also define a custom event that's fired by the dependency property callback in some or all cases.</source>
          <target xml:space="preserve">It's a common pattern to have a dependency property that has a property-changed callback, and to also define a custom event that's fired by the dependency property callback in some or all cases.</target>
        </segment>
      </unit>
      <unit id="372">
        <segment state="initial">
          <source xml:space="preserve">Consumers of your control don't have access to the property-changed callback you defined, but having a notification event available is the next best thing.</source>
          <target xml:space="preserve">Consumers of your control don't have access to the property-changed callback you defined, but having a notification event available is the next best thing.</target>
        </segment>
      </unit>
      <unit id="373">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](custom-dependency-properties.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom dependency properties</pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom dependency properties</pc>.</target>
        </segment>
      </unit>
      <unit id="374">
        <segment state="initial">
          <source xml:space="preserve">Related topics</source>
          <target xml:space="preserve">Related topics</target>
        </segment>
      </unit>
      <unit id="375">
        <segment state="initial">
          <source xml:space="preserve">XAML overview</source>
          <target xml:space="preserve">XAML overview</target>
        </segment>
      </unit>
      <unit id="376">
        <segment state="initial">
          <source xml:space="preserve">Quickstart: Touch input</source>
          <target xml:space="preserve">Quickstart: Touch input</target>
        </segment>
      </unit>
      <unit id="377">
        <segment state="initial">
          <source xml:space="preserve">Keyboard interactions</source>
          <target xml:space="preserve">Keyboard interactions</target>
        </segment>
      </unit>
      <unit id="378">
        <segment state="initial">
          <source xml:space="preserve">.NET events and delegates</source>
          <target xml:space="preserve">.NET events and delegates</target>
        </segment>
      </unit>
      <unit id="379">
        <segment state="initial">
          <source xml:space="preserve">Creating Windows Runtime components</source>
          <target xml:space="preserve">Creating Windows Runtime components</target>
        </segment>
      </unit>
      <unit id="380">
        <segment state="initial">
          <source xml:space="preserve">AddHandler</source>
          <target xml:space="preserve">AddHandler</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>