<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="it-it" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">590d41f5e2dba044b0355aa5cf2291f6f2e17a0b</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: DE5B084C-DAC1-430B-A15B-5B3D5FB698F7</source>
          <target xml:space="preserve">ms.assetid: DE5B084C-DAC1-430B-A15B-5B3D5FB698F7</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">title: Optimize animations, media, and images</source>
          <target xml:space="preserve">title: Optimize animations, media, and images</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">description: Create Universal Windows Platform (UWP) apps with smooth animations, high frame rate, and high-performance media capture and playback.</source>
          <target xml:space="preserve">description: Create Universal Windows Platform (UWP) apps with smooth animations, high frame rate, and high-performance media capture and playback.</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">Optimize animations, media, and images</source>
          <target xml:space="preserve">Optimize animations, media, and images</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="106">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">Create Universal Windows Platform (UWP) apps with smooth animations, high frame rate, and high-performance media capture and playback.</source>
          <target xml:space="preserve">Create Universal Windows Platform (UWP) apps with smooth animations, high frame rate, and high-performance media capture and playback.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source xml:space="preserve">Make animations smooth</source>
          <target xml:space="preserve">Make animations smooth</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">A key aspect of UWP apps is smooth interactions.</source>
          <target xml:space="preserve">A key aspect of UWP apps is smooth interactions.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">This includes touch manipulations that "stick to your finger," smooth transitions and animations, and small motions that provide input feedback.</source>
          <target xml:space="preserve">This includes touch manipulations that "stick to your finger," smooth transitions and animations, and small motions that provide input feedback.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">In the XAML framework there is a thread called the composition thread that is dedicated to the composition and animation of an app’s visual elements.</source>
          <target xml:space="preserve">In the XAML framework there is a thread called the composition thread that is dedicated to the composition and animation of an app’s visual elements.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">Because the composition thread is separate from UI thread (the thread that runs framework and developer code), apps can achieve a consistent frame rate and smooth animations regardless of complicated layout passes or extended calculations.</source>
          <target xml:space="preserve">Because the composition thread is separate from UI thread (the thread that runs framework and developer code), apps can achieve a consistent frame rate and smooth animations regardless of complicated layout passes or extended calculations.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">This section shows how to use the composition thread to keep an app’s animations buttery smooth.</source>
          <target xml:space="preserve">This section shows how to use the composition thread to keep an app’s animations buttery smooth.</target>
        </segment>
      </unit>
      <unit id="114">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt187350)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info about animations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animations overview</pc>.</source>
          <target xml:space="preserve">For more info about animations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animations overview</pc>.</target>
        </segment>
      </unit>
      <unit id="115">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](keep-the-ui-thread-responsive.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To learn about increasing an app’s responsiveness while performing intensive computations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keep the UI thread responsive</pc>.</source>
          <target xml:space="preserve">To learn about increasing an app’s responsiveness while performing intensive computations, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keep the UI thread responsive</pc>.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">Use independent instead of dependent animations</source>
          <target xml:space="preserve">Use independent instead of dependent animations</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">Independent animations can be calculated from beginning to end at the time of creation because changes to the property being animated don't affect rest of the objects in a scene.</source>
          <target xml:space="preserve">Independent animations can be calculated from beginning to end at the time of creation because changes to the property being animated don't affect rest of the objects in a scene.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">Independent animations can therefore run on the composition thread instead of the UI thread.</source>
          <target xml:space="preserve">Independent animations can therefore run on the composition thread instead of the UI thread.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">This guarantees that they remain smooth because the composition thread is updated at a consistent cadence.</source>
          <target xml:space="preserve">This guarantees that they remain smooth because the composition thread is updated at a consistent cadence.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">All of these types of animations are guaranteed to be independent:</source>
          <target xml:space="preserve">All of these types of animations are guaranteed to be independent:</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">Object animations using key frames</source>
          <target xml:space="preserve">Object animations using key frames</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">Zero-duration animations</source>
          <target xml:space="preserve">Zero-duration animations</target>
        </segment>
      </unit>
      <unit id="123">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh759771)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/Hh759772)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Animations to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Canvas.Left</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Canvas.Top</pc></pc> properties</source>
          <target xml:space="preserve">Animations to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Canvas.Left</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Canvas.Top</pc></pc> properties</target>
        </segment>
      </unit>
      <unit id="124">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208962)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Animations to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.Opacity</pc></pc> property</source>
          <target xml:space="preserve">Animations to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.Opacity</pc></pc> property</target>
        </segment>
      </unit>
      <unit id="125">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228076)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242963)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Animations to properties of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Brush</pc></pc> when targeting the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SolidColorBrush.Color</pc></pc> subproperty</source>
          <target xml:space="preserve">Animations to properties of type <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Brush</pc></pc> when targeting the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SolidColorBrush.Color</pc></pc> subproperty</target>
        </segment>
      </unit>
      <unit id="126">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Animations to the following <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> properties when targeting subproperties of these return value types:</source>
          <target xml:space="preserve">Animations to the following <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> properties when targeting subproperties of these return value types:</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source xml:space="preserve">RenderTransform</source>
          <target xml:space="preserve">RenderTransform</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">Projection</source>
          <target xml:space="preserve">Projection</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source xml:space="preserve">Clip</source>
          <target xml:space="preserve">Clip</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source xml:space="preserve">Dependent animations affect layout, which therefore cannot be calculated without extra input from the UI thread.</source>
          <target xml:space="preserve">Dependent animations affect layout, which therefore cannot be calculated without extra input from the UI thread.</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208751)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208718)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Dependent animations include modifications to properties like <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Width</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Height</pc></pc>.</source>
          <target xml:space="preserve">Dependent animations include modifications to properties like <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Width</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Height</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source xml:space="preserve">By default, dependent animations are not run and require an opt-in from the app developer.</source>
          <target xml:space="preserve">By default, dependent animations are not run and require an opt-in from the app developer.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">When enabled, they run smoothly if the UI thread remains unblocked, but they begin to stutter if the framework or app is doing a lot of other work on the UI thread.</source>
          <target xml:space="preserve">When enabled, they run smoothly if the UI thread remains unblocked, but they begin to stutter if the framework or app is doing a lot of other work on the UI thread.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">Almost all animations in the XAML framework are independent by default, but there are some actions that you can take to disable this optimization.</source>
          <target xml:space="preserve">Almost all animations in the XAML framework are independent by default, but there are some actions that you can take to disable this optimization.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">Beware of these scenarios particularly:</source>
          <target xml:space="preserve">Beware of these scenarios particularly:</target>
        </segment>
      </unit>
      <unit id="136">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR210356)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">EnableDependentAnimation</pc></pc> property to allow a dependent animation to run on the UI thread.</source>
          <target xml:space="preserve">Setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">EnableDependentAnimation</pc></pc> property to allow a dependent animation to run on the UI thread.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">Convert these animations into an independent version.</source>
          <target xml:space="preserve">Convert these animations into an independent version.</target>
        </segment>
      </unit>
      <unit id="138">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242946)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242948)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR208751)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">[</data>
          <data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR208718)</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example animate <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScaleTransform.ScaleX</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ScaleTransform.ScaleY</pc></pc> instead of the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Width</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Height</pc></pc> of an object.</source>
          <target xml:space="preserve">For example animate <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScaleTransform.ScaleX</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ScaleTransform.ScaleY</pc></pc> instead of the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Width</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Height</pc></pc> of an object.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">Don’t be afraid to scale objects like images and text.</source>
          <target xml:space="preserve">Don’t be afraid to scale objects like images and text.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242940)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The framework applies bilinear scaling only while the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScaleTransform</pc></pc> is being animated.</source>
          <target xml:space="preserve">The framework applies bilinear scaling only while the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScaleTransform</pc></pc> is being animated.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">The image/text will be rerasterized at the final size to ensure it’s always clear.</source>
          <target xml:space="preserve">The image/text will be rerasterized at the final size to ensure it’s always clear.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source xml:space="preserve">Making per frame updates, which are effectively dependent animations.</source>
          <target xml:space="preserve">Making per frame updates, which are effectively dependent animations.</target>
        </segment>
      </unit>
      <unit id="143">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228127)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">An example of this is applying transformations in the handler of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositonTarget.Rendering</pc></pc> event.</source>
          <target xml:space="preserve">An example of this is applying transformations in the handler of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositonTarget.Rendering</pc></pc> event.</target>
        </segment>
      </unit>
      <unit id="144">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911-cachemode)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Running any animation considered independent in an element with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CacheMode</pc></pc> property set to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">BitmapCache</pc>.</source>
          <target xml:space="preserve">Running any animation considered independent in an element with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CacheMode</pc></pc> property set to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">BitmapCache</pc>.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source xml:space="preserve">This is considered dependent because the cache must be re-rasterized for each frame.</source>
          <target xml:space="preserve">This is considered dependent because the cache must be re-rasterized for each frame.</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source xml:space="preserve">Don't animate a WebView or MediaElement</source>
          <target xml:space="preserve">Don't animate a WebView or MediaElement</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227702)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Web content within a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">WebView</pc></pc> control is not directly rendered by the XAML framework and it requires extra work to be composed with the rest of the scene.</source>
          <target xml:space="preserve">Web content within a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">WebView</pc></pc> control is not directly rendered by the XAML framework and it requires extra work to be composed with the rest of the scene.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source xml:space="preserve">This extra work adds up when animating the control around the screen and can potentially introduce synchronization issues (for example, the HTML content might not move in sync with the rest of the XAML content on the page).</source>
          <target xml:space="preserve">This extra work adds up when animating the control around the screen and can potentially introduce synchronization issues (for example, the HTML content might not move in sync with the rest of the XAML content on the page).</target>
        </segment>
      </unit>
      <unit id="149">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR227702brush)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When you need to animate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WebView</pc> control, swap it with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">WebViewBrush</pc></pc> for the duration of the animation.</source>
          <target xml:space="preserve">When you need to animate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">WebView</pc> control, swap it with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">WebViewBrush</pc></pc> for the duration of the animation.</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Animating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is a similarly bad idea.</source>
          <target xml:space="preserve">Animating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is a similarly bad idea.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source xml:space="preserve">Beyond the performance detriment, it can cause tearing or other artifacts in the video content being played.</source>
          <target xml:space="preserve">Beyond the performance detriment, it can cause tearing or other artifacts in the video content being played.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source xml:space="preserve">Use infinite animations sparingly</source>
          <target xml:space="preserve">Use infinite animations sparingly</target>
        </segment>
      </unit>
      <unit id="153">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243207)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Most animations execute for a specified amount of time, but setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Timeline.Duration</pc></pc> property to Forever allows an animation to run indefinitely.</source>
          <target xml:space="preserve">Most animations execute for a specified amount of time, but setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Timeline.Duration</pc></pc> property to Forever allows an animation to run indefinitely.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">We recommend minimizing the use of infinite animations because they continually consume CPU resources and can prevent the CPU from going into a low power or idle state, causing it to run out of power more quickly.</source>
          <target xml:space="preserve">We recommend minimizing the use of infinite animations because they continually consume CPU resources and can prevent the CPU from going into a low power or idle state, causing it to run out of power more quickly.</target>
        </segment>
      </unit>
      <unit id="155">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR228127)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Adding a handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionTarget.Rendering</pc></pc> is similar to running an infinite animation.</source>
          <target xml:space="preserve">Adding a handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositionTarget.Rendering</pc></pc> is similar to running an infinite animation.</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source xml:space="preserve">Normally the UI thread is active only when there is work to do, but adding handler for this event forces it to run every frame.</source>
          <target xml:space="preserve">Normally the UI thread is active only when there is work to do, but adding handler for this event forces it to run every frame.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source xml:space="preserve">Remove the handler when there is no work to be done and reregister it when it’s needed again.</source>
          <target xml:space="preserve">Remove the handler when there is no work to be done and reregister it when it’s needed again.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">Use the animation library</source>
          <target xml:space="preserve">Use the animation library</target>
        </segment>
      </unit>
      <unit id="159">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243232)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Media.Animation</pc></pc> namespace includes a library of high-performance, smooth animations that have a look and feel consistent with other Windows animations.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Media.Animation</pc></pc> namespace includes a library of high-performance, smooth animations that have a look and feel consistent with other Windows animations.</target>
        </segment>
      </unit>
      <unit id="160">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt187350)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The relevant classes have "Theme" in their name, and are described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animations overview</pc>.</source>
          <target xml:space="preserve">The relevant classes have "Theme" in their name, and are described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Animations overview</pc>.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source xml:space="preserve">This library supports many common animation scenarios, such as animating the first view of the app and creating state and content transitions.</source>
          <target xml:space="preserve">This library supports many common animation scenarios, such as animating the first view of the app and creating state and content transitions.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">We recommend using this animation library whenever possible to increase performance and consistency for UWP UI.</source>
          <target xml:space="preserve">We recommend using this animation library whenever possible to increase performance and consistency for UWP UI.</target>
        </segment>
      </unit>
      <unit id="163">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The animation library can't animate all possible properties.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>   The animation library can't animate all possible properties.</target>
        </segment>
      </unit>
      <unit id="164">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt187354)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For XAML scenarios where the animation library doesn't apply, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</source>
          <target xml:space="preserve">For XAML scenarios where the animation library doesn't apply, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc>.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">Animate CompositeTransform3D properties independently</source>
          <target xml:space="preserve">Animate CompositeTransform3D properties independently</target>
        </segment>
      </unit>
      <unit id="166">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn914714)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can animate each property of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositeTransform3D</pc></pc> independently, so apply only the animations you need.</source>
          <target xml:space="preserve">You can animate each property of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CompositeTransform3D</pc></pc> independently, so apply only the animations you need.</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911-transform3d)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For examples and more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.Transform3D</pc></pc>.</source>
          <target xml:space="preserve">For examples and more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement.Transform3D</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="168">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt187354)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt187352)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info about animating transforms, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Key-frame and easing function animations</pc>.</source>
          <target xml:space="preserve">For more info about animating transforms, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Storyboarded animations</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Key-frame and easing function animations</pc>.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source xml:space="preserve">Optimize media resources</source>
          <target xml:space="preserve">Optimize media resources</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source xml:space="preserve">Audio, video, and images are compelling forms of content that the majority of apps use.</source>
          <target xml:space="preserve">Audio, video, and images are compelling forms of content that the majority of apps use.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source xml:space="preserve">As media capture rates increase and content moves from standard definition to high definition the amount of resources need to store, decode, and play back this content increases.</source>
          <target xml:space="preserve">As media capture rates increase and content moves from standard definition to high definition the amount of resources need to store, decode, and play back this content increases.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">The XAML framework builds on the latest features added to the UWP media engines so apps get these improvements for free.</source>
          <target xml:space="preserve">The XAML framework builds on the latest features added to the UWP media engines so apps get these improvements for free.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source xml:space="preserve">Here we explain some additional tricks that allow you to get the most out media in your UWP app.</source>
          <target xml:space="preserve">Here we explain some additional tricks that allow you to get the most out media in your UWP app.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source xml:space="preserve">Release media streams</source>
          <target xml:space="preserve">Release media streams</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">Media files are some of the most common and expensive resources apps typically use.</source>
          <target xml:space="preserve">Media files are some of the most common and expensive resources apps typically use.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source xml:space="preserve">Because media file resources can greatly increase the size of your app's memory footprint, you must remember to release the handle to media as soon as the app is finished using it.</source>
          <target xml:space="preserve">Because media file resources can greatly increase the size of your app's memory footprint, you must remember to release the handle to media as soon as the app is finished using it.</target>
        </segment>
      </unit>
      <unit id="177">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR241747)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR241718)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, if your app working with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RandomAccessStream</pc></pc> or an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IInputStream</pc></pc> object, be sure to call the close method on the object when your app has finished using it, to release the underlying object.</source>
          <target xml:space="preserve">For example, if your app working with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RandomAccessStream</pc></pc> or an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IInputStream</pc></pc> object, be sure to call the close method on the object when your app has finished using it, to release the underlying object.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source xml:space="preserve">Display full screen video playback when possible</source>
          <target xml:space="preserve">Display full screen video playback when possible</target>
        </segment>
      </unit>
      <unit id="179">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926-isfullwindow)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In UWP apps, always use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsFullWindow</pc></pc> property on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MediaElement</pc></pc> to enable and disable full window rendering.</source>
          <target xml:space="preserve">In UWP apps, always use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsFullWindow</pc></pc> property on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MediaElement</pc></pc> to enable and disable full window rendering.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source xml:space="preserve">This insures system level optimizations are used during media playback.</source>
          <target xml:space="preserve">This insures system level optimizations are used during media playback.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">The XAML framework can optimize the display of video content when it is the only thing being rendered, resulting in an experience that uses less power and yields higher frame rates.</source>
          <target xml:space="preserve">The XAML framework can optimize the display of video content when it is the only thing being rendered, resulting in an experience that uses less power and yields higher frame rates.</target>
        </segment>
      </unit>
      <unit id="182">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For most efficient media playback set the size of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> to be the width and height of the screen and don’t display other XAML elements</source>
          <target xml:space="preserve">For most efficient media playback set the size of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> to be the width and height of the screen and don’t display other XAML elements</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">There are legitimate reasons to overlay XAML elements on a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> that takes up the full width and height of the screen, for example closed captions or momentary transport controls.</source>
          <target xml:space="preserve">There are legitimate reasons to overlay XAML elements on a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> that takes up the full width and height of the screen, for example closed captions or momentary transport controls.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source xml:space="preserve">Making sure to hide these elements (eg.</source>
          <target xml:space="preserve">Making sure to hide these elements (eg.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source xml:space="preserve">setting Visibility=”Collapsed”) when they are not needed pops media playback back into its most efficient state.</source>
          <target xml:space="preserve">setting Visibility=”Collapsed”) when they are not needed pops media playback back into its most efficient state.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">Display deactivation and conserving power</source>
          <target xml:space="preserve">Display deactivation and conserving power</target>
        </segment>
      </unit>
      <unit id="187">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR241818)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To prevent the display from be deactivating when user action is no longer detected, such as when an app is playing video, you can call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayRequest.RequestActive</pc></pc>.</source>
          <target xml:space="preserve">To prevent the display from be deactivating when user action is no longer detected, such as when an app is playing video, you can call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayRequest.RequestActive</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="188">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR241819)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To conserve power and battery life, you should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayRequest.RequestRelease</pc></pc> to release the display request as soon as it is no longer required.</source>
          <target xml:space="preserve">To conserve power and battery life, you should call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DisplayRequest.RequestRelease</pc></pc> to release the display request as soon as it is no longer required.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source xml:space="preserve">Here are some situations when you should release the display request:</source>
          <target xml:space="preserve">Here are some situations when you should release the display request:</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source xml:space="preserve">Video playback is paused, for example by user action, buffering, or adjustment due to limited bandwidth.</source>
          <target xml:space="preserve">Video playback is paused, for example by user action, buffering, or adjustment due to limited bandwidth.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source xml:space="preserve">Playback stops.</source>
          <target xml:space="preserve">Playback stops.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source xml:space="preserve">For example, the video is done playing or the presentation is over.</source>
          <target xml:space="preserve">For example, the video is done playing or the presentation is over.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source xml:space="preserve">A playback error has occurred.</source>
          <target xml:space="preserve">A playback error has occurred.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source xml:space="preserve">For example, network connectivity issues or a corrupted file.</source>
          <target xml:space="preserve">For example, network connectivity issues or a corrupted file.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source xml:space="preserve">Put other elements to the side of embedded video</source>
          <target xml:space="preserve">Put other elements to the side of embedded video</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source xml:space="preserve">Often apps offer an embedded view where video is played within a page.</source>
          <target xml:space="preserve">Often apps offer an embedded view where video is played within a page.</target>
        </segment>
      </unit>
      <unit id="197">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Now you obviously lost the full screen optimization because the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is not the size of the page and there are other XAML objects drawn.</source>
          <target xml:space="preserve">Now you obviously lost the full screen optimization because the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is not the size of the page and there are other XAML objects drawn.</target>
        </segment>
      </unit>
      <unit id="198">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Beware of unintentionally entering this mode by drawing a border around a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement</pc>.</source>
          <target xml:space="preserve">Beware of unintentionally entering this mode by drawing a border around a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement</pc>.</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source xml:space="preserve">Don’t draw XAML elements on top of video when it’s in embedded mode.</source>
          <target xml:space="preserve">Don’t draw XAML elements on top of video when it’s in embedded mode.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source xml:space="preserve">If you do, the framework is forced to do a little extra work to compose the scene.</source>
          <target xml:space="preserve">If you do, the framework is forced to do a little extra work to compose the scene.</target>
        </segment>
      </unit>
      <unit id="201">
        <segment state="initial">
          <source xml:space="preserve">Placing transport controls below an embedded media element instead of on top of the video is a good example of optimizing for this situation.</source>
          <target xml:space="preserve">Placing transport controls below an embedded media element instead of on top of the video is a good example of optimizing for this situation.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source xml:space="preserve">In this image, the red bar indicates a set of transport controls (play, pause, stop, etc.).</source>
          <target xml:space="preserve">In this image, the red bar indicates a set of transport controls (play, pause, stop, etc.).</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source xml:space="preserve">MediaElement with overlaying elements</source>
          <target xml:space="preserve">MediaElement with overlaying elements</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source xml:space="preserve">Don’t place these controls on top of media that is not full screen.</source>
          <target xml:space="preserve">Don’t place these controls on top of media that is not full screen.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source xml:space="preserve">Instead place the transport controls somewhere outside of the area where the media is being rendered.</source>
          <target xml:space="preserve">Instead place the transport controls somewhere outside of the area where the media is being rendered.</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source xml:space="preserve">In the next image, the controls are placed below the media.</source>
          <target xml:space="preserve">In the next image, the controls are placed below the media.</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source xml:space="preserve">MediaElement with neighboring elements</source>
          <target xml:space="preserve">MediaElement with neighboring elements</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source xml:space="preserve">Delay setting the source for a MediaElement</source>
          <target xml:space="preserve">Delay setting the source for a MediaElement</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source xml:space="preserve">Media engines are expensive objects and the XAML framework delays loading dlls and creating large objects as long as possible.</source>
          <target xml:space="preserve">Media engines are expensive objects and the XAML framework delays loading dlls and creating large objects as long as possible.</target>
        </segment>
      </unit>
      <unit id="210">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242926-source)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242926-setsource)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is forced to do this work after its source is set via the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Source</pc></pc> property or the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SetSource</pc></pc> method.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> is forced to do this work after its source is set via the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Source</pc></pc> property or the <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">SetSource</pc></pc> method.</target>
        </segment>
      </unit>
      <unit id="211">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Setting these when the user is really ready to play media delays the majority of the cost associated with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement</pc> as long as possible.</source>
          <target xml:space="preserve">Setting these when the user is really ready to play media delays the majority of the cost associated with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement</pc> as long as possible.</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source xml:space="preserve">Set MediaElement.PosterSource</source>
          <target xml:space="preserve">Set MediaElement.PosterSource</target>
        </segment>
      </unit>
      <unit id="213">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926-postersource)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement.PosterSource</pc></pc> enables XAML to release some GPU resources that would have otherwise been used.</source>
          <target xml:space="preserve">Setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement.PosterSource</pc></pc> enables XAML to release some GPU resources that would have otherwise been used.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source xml:space="preserve">This API allows an app to use as little memory as possible.</source>
          <target xml:space="preserve">This API allows an app to use as little memory as possible.</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source xml:space="preserve">Improve media scrubbing</source>
          <target xml:space="preserve">Improve media scrubbing</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source xml:space="preserve">Scrubbing is always a tough task for media platforms to make really responsive.</source>
          <target xml:space="preserve">Scrubbing is always a tough task for media platforms to make really responsive.</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source xml:space="preserve">Generally people accomplish this by changing the value of a Slider.</source>
          <target xml:space="preserve">Generally people accomplish this by changing the value of a Slider.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source xml:space="preserve">Here are a couple tips on how to make this as efficient as possible:</source>
          <target xml:space="preserve">Here are a couple tips on how to make this as efficient as possible:</target>
        </segment>
      </unit>
      <unit id="219">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209614)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242926-position)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Either bind the value of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Slider</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MediaElement.Position</pc></pc> or update it based on a timer.</source>
          <target xml:space="preserve">Either bind the value of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Slider</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">MediaElement.Position</pc></pc> or update it based on a timer.</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source xml:space="preserve">Don't do both.</source>
          <target xml:space="preserve">Don't do both.</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source xml:space="preserve">If you choose the latter, make sure to use a reasonable update frequency for your timer.</source>
          <target xml:space="preserve">If you choose the latter, make sure to use a reasonable update frequency for your timer.</target>
        </segment>
      </unit>
      <unit id="222">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The XAML framework only updates <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement.Position</pc> only every 250 milliseconds during playback.</source>
          <target xml:space="preserve">The XAML framework only updates <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaElement.Position</pc> only every 250 milliseconds during playback.</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source xml:space="preserve">The size of the step frequency on the Slider must scale with the length of the video.</source>
          <target xml:space="preserve">The size of the step frequency on the Slider must scale with the length of the video.</target>
        </segment>
      </unit>
      <unit id="224">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerpressed)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointermoved)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerreleased)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">[</data>
          <data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242926-playbackrate)</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Subscribe to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerPressed</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PointerMoved</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PointerReleased</pc></pc> events on the slider to set the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">MediaElement.PlaybackRate</pc></pc> property to 0 when the user drags the thumb of the slider.</source>
          <target xml:space="preserve">Subscribe to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerPressed</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PointerMoved</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PointerReleased</pc></pc> events on the slider to set the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">MediaElement.PlaybackRate</pc></pc> property to 0 when the user drags the thumb of the slider.</target>
        </segment>
      </unit>
      <unit id="225">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911-pointerreleased)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerReleased</pc></pc> event handler, manually set the media position to the slider position value to achieve optimal thumb snapping while scrubbing.</source>
          <target xml:space="preserve">In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PointerReleased</pc></pc> event handler, manually set the media position to the slider position value to achieve optimal thumb snapping while scrubbing.</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source xml:space="preserve">Match video resolution to device resolution</source>
          <target xml:space="preserve">Match video resolution to device resolution</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source xml:space="preserve">Decoding video takes a lot of memory and GPU cycles, so choose a video format close to the resolution it will be displayed at.</source>
          <target xml:space="preserve">Decoding video takes a lot of memory and GPU cycles, so choose a video format close to the resolution it will be displayed at.</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source xml:space="preserve">There is no point in using the resources to decode 1080 video if it’s going to get scaled down to a much smaller size.</source>
          <target xml:space="preserve">There is no point in using the resources to decode 1080 video if it’s going to get scaled down to a much smaller size.</target>
        </segment>
      </unit>
      <unit id="229">
        <segment state="initial">
          <source xml:space="preserve">Many apps don’t have the same video encoded at different resolutions; but if it is available, use an encoding that is close to the resolution at which it will be displayed.</source>
          <target xml:space="preserve">Many apps don’t have the same video encoded at different resolutions; but if it is available, use an encoding that is close to the resolution at which it will be displayed.</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source xml:space="preserve">Choose recommended formats</source>
          <target xml:space="preserve">Choose recommended formats</target>
        </segment>
      </unit>
      <unit id="231">
        <segment state="initial">
          <source xml:space="preserve">Media format selection can be a sensitive topic and is often driven by business decisions.</source>
          <target xml:space="preserve">Media format selection can be a sensitive topic and is often driven by business decisions.</target>
        </segment>
      </unit>
      <unit id="232">
        <segment state="initial">
          <source xml:space="preserve">From a UWP performance perspective, we recommend H.264 video as the primary video format and AAC and MP3 as the preferred audio formats.</source>
          <target xml:space="preserve">From a UWP performance perspective, we recommend H.264 video as the primary video format and AAC and MP3 as the preferred audio formats.</target>
        </segment>
      </unit>
      <unit id="233">
        <segment state="initial">
          <source xml:space="preserve">For local file playback, MP4 is the preferred file container for video content.</source>
          <target xml:space="preserve">For local file playback, MP4 is the preferred file container for video content.</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source xml:space="preserve">H.264 decoding is accelerated through most recent graphics hardware.</source>
          <target xml:space="preserve">H.264 decoding is accelerated through most recent graphics hardware.</target>
        </segment>
      </unit>
      <unit id="235">
        <segment state="initial">
          <source xml:space="preserve">Also, although hardware acceleration for VC-1 decoding is broadly available, for a large set of graphics hardware on the market, the acceleration is limited in many cases to a partial acceleration level (or IDCT level), rather than a full-steam level hardware offload (i.e. VLD mode).</source>
          <target xml:space="preserve">Also, although hardware acceleration for VC-1 decoding is broadly available, for a large set of graphics hardware on the market, the acceleration is limited in many cases to a partial acceleration level (or IDCT level), rather than a full-steam level hardware offload (i.e. VLD mode).</target>
        </segment>
      </unit>
      <unit id="236">
        <segment state="initial">
          <source xml:space="preserve">If you have full control of the video content generation process, you must figure out how to keep a good balance between compression efficiency and GOP structure.</source>
          <target xml:space="preserve">If you have full control of the video content generation process, you must figure out how to keep a good balance between compression efficiency and GOP structure.</target>
        </segment>
      </unit>
      <unit id="237">
        <segment state="initial">
          <source xml:space="preserve">Relatively smaller GOP size with B pictures can increase the performance in seeking or trick modes.</source>
          <target xml:space="preserve">Relatively smaller GOP size with B pictures can increase the performance in seeking or trick modes.</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source xml:space="preserve">When including short, low-latency audio effects, for example in games, use WAV files with uncompressed PCM data to reduce processing overhead that is typical for compressed audio formats.</source>
          <target xml:space="preserve">When including short, low-latency audio effects, for example in games, use WAV files with uncompressed PCM data to reduce processing overhead that is typical for compressed audio formats.</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source xml:space="preserve">Hardware audio offloading</source>
          <target xml:space="preserve">Hardware audio offloading</target>
        </segment>
      </unit>
      <unit id="240">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242926-audiocategory)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For hardware audio offload to be automatically applied, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement.AudioCategory</pc></pc> must be set to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ForegroundOnlyMedia</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">BackgroundCapableMedia</pc>.</source>
          <target xml:space="preserve">For hardware audio offload to be automatically applied, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement.AudioCategory</pc></pc> must be set to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ForegroundOnlyMedia</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">BackgroundCapableMedia</pc>.</target>
        </segment>
      </unit>
      <unit id="241">
        <segment state="initial">
          <source xml:space="preserve">Hardware audio offload optimizes audio rendering which can improve functionality and battery life.</source>
          <target xml:space="preserve">Hardware audio offload optimizes audio rendering which can improve functionality and battery life.</target>
        </segment>
      </unit>
      <unit id="242">
        <segment state="initial">
          <source xml:space="preserve">Optimize image resources</source>
          <target xml:space="preserve">Optimize image resources</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source xml:space="preserve">Scale images to the appropriate size</source>
          <target xml:space="preserve">Scale images to the appropriate size</target>
        </segment>
      </unit>
      <unit id="244">
        <segment state="initial">
          <source xml:space="preserve">Images are captured at very high resolutions, which can lead to apps using more CPU when decoding the image data and more memory after it’s loaded from disk.</source>
          <target xml:space="preserve">Images are captured at very high resolutions, which can lead to apps using more CPU when decoding the image data and more memory after it’s loaded from disk.</target>
        </segment>
      </unit>
      <unit id="245">
        <segment state="initial">
          <source xml:space="preserve">But there’s no sense decoding and saving a high-resolution image in memory only to display it smaller than its native size.</source>
          <target xml:space="preserve">But there’s no sense decoding and saving a high-resolution image in memory only to display it smaller than its native size.</target>
        </segment>
      </unit>
      <unit id="246">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243243)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243241)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Instead, create a version of the image at the exact size it will be drawn on-screen using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> properties.</source>
          <target xml:space="preserve">Instead, create a version of the image at the exact size it will be drawn on-screen using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> properties.</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source xml:space="preserve">Don't do this:</source>
          <target xml:space="preserve">Don't do this:</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source xml:space="preserve">Instead, do this:</source>
          <target xml:space="preserve">Instead, do this:</target>
        </segment>
      </unit>
      <unit id="249">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243243)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243241)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The units for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> are by default physical pixels.</source>
          <target xml:space="preserve">The units for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> are by default physical pixels.</target>
        </segment>
      </unit>
      <unit id="250">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn298545)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelType</pc></pc> property can be used to change this behavior: setting <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DecodePixelType</pc> to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Logical</pc> results in the decode size automatically accounting for the system’s current scale factor, similar to other XAML content.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelType</pc></pc> property can be used to change this behavior: setting <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DecodePixelType</pc> to <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Logical</pc> results in the decode size automatically accounting for the system’s current scale factor, similar to other XAML content.</target>
        </segment>
      </unit>
      <unit id="251">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">It would therefore be generally appropriate to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DecodePixelType</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Logical</pc> if, for instance, you want <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DecodePixelWidth</pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc> to match the Height and Width properties of the Image control the image will be displayed in.</source>
          <target xml:space="preserve">It would therefore be generally appropriate to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DecodePixelType</pc> to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Logical</pc> if, for instance, you want <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DecodePixelWidth</pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc> to match the Height and Width properties of the Image control the image will be displayed in.</target>
        </segment>
      </unit>
      <unit id="252">
        <segment state="initial">
          <source xml:space="preserve">With the default behavior of using physical pixels, you must account for the system’s current scale factor yourself; and you should listen for scale change notifications in case the user changes their display preferences.</source>
          <target xml:space="preserve">With the default behavior of using physical pixels, you must account for the system’s current scale factor yourself; and you should listen for scale change notifications in case the user changes their display preferences.</target>
        </segment>
      </unit>
      <unit id="253">
        <segment state="initial">
          <source xml:space="preserve">If DecodePixelWidth/Height are explicitly set larger than the image will be displayed on-screen then the app will unnecessarily use extra memory—up to 4 bytes per pixel—which quickly becomes expensive for large images.</source>
          <target xml:space="preserve">If DecodePixelWidth/Height are explicitly set larger than the image will be displayed on-screen then the app will unnecessarily use extra memory—up to 4 bytes per pixel—which quickly becomes expensive for large images.</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source xml:space="preserve">The image will also be scaled down using bilinear scaling which could cause it to appear blurry for large scale factors.</source>
          <target xml:space="preserve">The image will also be scaled down using bilinear scaling which could cause it to appear blurry for large scale factors.</target>
        </segment>
      </unit>
      <unit id="255">
        <segment state="initial">
          <source xml:space="preserve">If DecodePixelWidth/DecodePixelHeight are explicitly set smaller than the image will be displayed on screen then it will be scaled up and could appear pixelated.</source>
          <target xml:space="preserve">If DecodePixelWidth/DecodePixelHeight are explicitly set smaller than the image will be displayed on screen then it will be scaled up and could appear pixelated.</target>
        </segment>
      </unit>
      <unit id="256">
        <segment state="initial">
          <source xml:space="preserve">In some cases where an appropriate decode size cannot be determined ahead of time, you should defer to XAML’s automatic right-size-decoding which will make a best effort attempt to decode the image at the appropriate size if an explicit DecodePixelWidth/DecodePixelHeight is not specified.</source>
          <target xml:space="preserve">In some cases where an appropriate decode size cannot be determined ahead of time, you should defer to XAML’s automatic right-size-decoding which will make a best effort attempt to decode the image at the appropriate size if an explicit DecodePixelWidth/DecodePixelHeight is not specified.</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source xml:space="preserve">You should set an explicit decode size if you know the size of the image content ahead of time.</source>
          <target xml:space="preserve">You should set an explicit decode size if you know the size of the image content ahead of time.</target>
        </segment>
      </unit>
      <unit id="258">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn298545)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You should also in conjunction set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelType</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Logical</pc> if the supplied decode size is relative to other XAML element sizes.</source>
          <target xml:space="preserve">You should also in conjunction set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelType</pc></pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Logical</pc> if the supplied decode size is relative to other XAML element sizes.</target>
        </segment>
      </unit>
      <unit id="259">
        <segment state="initial">
          <source xml:space="preserve">For example, if you explicitly set the content size with Image.Width and Image.Height, you could set DecodePixelType to DecodePixelType.Logical to use the same logical pixel dimensions as an Image control and then explicitly use BitmapImage.DecodePixelWidth and/or BitmapImage.DecodePixelHeight to control the size of the image to achieve potentially large memory savings.</source>
          <target xml:space="preserve">For example, if you explicitly set the content size with Image.Width and Image.Height, you could set DecodePixelType to DecodePixelType.Logical to use the same logical pixel dimensions as an Image control and then explicitly use BitmapImage.DecodePixelWidth and/or BitmapImage.DecodePixelHeight to control the size of the image to achieve potentially large memory savings.</target>
        </segment>
      </unit>
      <unit id="260">
        <segment state="initial">
          <source xml:space="preserve">Note that Image.Stretch should be considered when determining the size of the decoded content.</source>
          <target xml:space="preserve">Note that Image.Stretch should be considered when determining the size of the decoded content.</target>
        </segment>
      </unit>
      <unit id="261">
        <segment state="initial">
          <source xml:space="preserve">Right-sized decoding</source>
          <target xml:space="preserve">Right-sized decoding</target>
        </segment>
      </unit>
      <unit id="262">
        <segment state="initial">
          <source xml:space="preserve">In the event that you don't set an explicit decode size, XAML will make a best effort attempt to save memory by decoding an image to the exact size it will appear on-screen according to the containing page’s initial layout.</source>
          <target xml:space="preserve">In the event that you don't set an explicit decode size, XAML will make a best effort attempt to save memory by decoding an image to the exact size it will appear on-screen according to the containing page’s initial layout.</target>
        </segment>
      </unit>
      <unit id="263">
        <segment state="initial">
          <source xml:space="preserve">You're advised to write your application in such a way as to make use of this feature when possible.</source>
          <target xml:space="preserve">You're advised to write your application in such a way as to make use of this feature when possible.</target>
        </segment>
      </unit>
      <unit id="264">
        <segment state="initial">
          <source xml:space="preserve">This feature will be disabled if any of the following conditions are met.</source>
          <target xml:space="preserve">This feature will be disabled if any of the following conditions are met.</target>
        </segment>
      </unit>
      <unit id="265">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243235)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/JJ191522)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BitmapImage</pc></pc> is connected to the live XAML tree after setting the content with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">UriSource</pc></pc>.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BitmapImage</pc></pc> is connected to the live XAML tree after setting the content with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">UriSource</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="266">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243255)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The image is decoded using synchronous decoding such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetSource</pc></pc>.</source>
          <target xml:space="preserve">The image is decoded using synchronous decoding such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetSource</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="267">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208962)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911-visibility)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The image is hidden via setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Opacity</pc></pc> to 0 or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visibility</pc></pc> to <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Collapsed</pc> on the host image element or brush or any parent element.</source>
          <target xml:space="preserve">The image is hidden via setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Opacity</pc></pc> to 0 or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visibility</pc></pc> to <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Collapsed</pc> on the host image element or brush or any parent element.</target>
        </segment>
      </unit>
      <unit id="268">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242968)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The image control or brush uses a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Stretch</pc></pc> of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">None</pc>.</source>
          <target xml:space="preserve">The image control or brush uses a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Stretch</pc></pc> of <pc dataRefEnd="id6" dataRefStart="id5" id="p3">None</pc>.</target>
        </segment>
      </unit>
      <unit id="269">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242756)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The image is used as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>.</source>
          <target xml:space="preserve">The image is used as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="270">
        <originalData>
          <data id="id1">`CacheMode="BitmapCache"`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<ph dataRef="id1" id="ph1" /> is set on the image element or on any parent element.</source>
          <target xml:space="preserve">
						<ph dataRef="id1" id="ph1" /> is set on the image element or on any parent element.</target>
        </segment>
      </unit>
      <unit id="271">
        <segment state="initial">
          <source xml:space="preserve">The image brush is non-rectangular (such as when applied to a shape or to text).</source>
          <target xml:space="preserve">The image brush is non-rectangular (such as when applied to a shape or to text).</target>
        </segment>
      </unit>
      <unit id="272">
        <segment state="initial">
          <source xml:space="preserve">In the above scenarios, setting an explicit decode size is the only way to achieve memory savings.</source>
          <target xml:space="preserve">In the above scenarios, setting an explicit decode size is the only way to achieve memory savings.</target>
        </segment>
      </unit>
      <unit id="273">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243235)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You should always attach a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BitmapImage</pc></pc> to the live tree before setting the source.</source>
          <target xml:space="preserve">You should always attach a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">BitmapImage</pc></pc> to the live tree before setting the source.</target>
        </segment>
      </unit>
      <unit id="274">
        <segment state="initial">
          <source xml:space="preserve">Any time an image element or brush is specified in markup, this will automatically be the case.</source>
          <target xml:space="preserve">Any time an image element or brush is specified in markup, this will automatically be the case.</target>
        </segment>
      </unit>
      <unit id="275">
        <segment state="initial">
          <source xml:space="preserve">Examples are provided below under the heading "Live tree examples".</source>
          <target xml:space="preserve">Examples are provided below under the heading "Live tree examples".</target>
        </segment>
      </unit>
      <unit id="276">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243255)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/JJ191522)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You should always avoid using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetSource</pc></pc> and instead use <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> when setting a stream source.</source>
          <target xml:space="preserve">You should always avoid using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetSource</pc></pc> and instead use <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> when setting a stream source.</target>
        </segment>
      </unit>
      <unit id="277">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243235-imageopened)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">And it's a good idea to avoid hiding image content (either with zero opacity or with collapsed visibility) while waiting for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ImageOpened</pc></pc> event to be raised.</source>
          <target xml:space="preserve">And it's a good idea to avoid hiding image content (either with zero opacity or with collapsed visibility) while waiting for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ImageOpened</pc></pc> event to be raised.</target>
        </segment>
      </unit>
      <unit id="278">
        <segment state="initial">
          <source xml:space="preserve">Doing this is a judgment call: you won't benefit from automatic right-sized decoding if it's done.</source>
          <target xml:space="preserve">Doing this is a judgment call: you won't benefit from automatic right-sized decoding if it's done.</target>
        </segment>
      </unit>
      <unit id="279">
        <segment state="initial">
          <source xml:space="preserve">If your app must hide image content initially then it should also set the decode size explicitly if possible.</source>
          <target xml:space="preserve">If your app must hide image content initially then it should also set the decode size explicitly if possible.</target>
        </segment>
      </unit>
      <unit id="280">
        <segment state="initial">
          <source xml:space="preserve">Live tree examples</source>
          <target xml:space="preserve">Live tree examples</target>
        </segment>
      </unit>
      <unit id="281">
        <segment state="initial">
          <source xml:space="preserve">Example 1 (good)—Uniform Resource Identifier (URI) specified in markup.</source>
          <target xml:space="preserve">Example 1 (good)—Uniform Resource Identifier (URI) specified in markup.</target>
        </segment>
      </unit>
      <unit id="282">
        <segment state="initial">
          <source xml:space="preserve">Example 2 markup—URI specified in code-behind.</source>
          <target xml:space="preserve">Example 2 markup—URI specified in code-behind.</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source xml:space="preserve">Example 2 code-behind (good)—connecting the BitmapImage to the tree before setting its UriSource.</source>
          <target xml:space="preserve">Example 2 code-behind (good)—connecting the BitmapImage to the tree before setting its UriSource.</target>
        </segment>
      </unit>
      <unit id="284">
        <segment state="initial">
          <source xml:space="preserve">Example 2 code-behind (bad)—setting the the BitmapImage's UriSource before connecting it to the tree.</source>
          <target xml:space="preserve">Example 2 code-behind (bad)—setting the the BitmapImage's UriSource before connecting it to the tree.</target>
        </segment>
      </unit>
      <unit id="285">
        <segment state="initial">
          <source xml:space="preserve">Caching optimizations</source>
          <target xml:space="preserve">Caching optimizations</target>
        </segment>
      </unit>
      <unit id="286">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Caching optimizations are in effect for images that use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UriSource</pc></pc> to load content from an app package or from the web.</source>
          <target xml:space="preserve">Caching optimizations are in effect for images that use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UriSource</pc></pc> to load content from an app package or from the web.</target>
        </segment>
      </unit>
      <unit id="287">
        <segment state="initial">
          <source xml:space="preserve">The URI is used to uniquely identify the underlying content, and internally the XAML framework will not download or decode the content multiple times.</source>
          <target xml:space="preserve">The URI is used to uniquely identify the underlying content, and internally the XAML framework will not download or decode the content multiple times.</target>
        </segment>
      </unit>
      <unit id="288">
        <segment state="initial">
          <source xml:space="preserve">Instead, it will use the cached software or hardware resources to display the content multiple times.</source>
          <target xml:space="preserve">Instead, it will use the cached software or hardware resources to display the content multiple times.</target>
        </segment>
      </unit>
      <unit id="289">
        <segment state="initial">
          <source xml:space="preserve">The exception to this optimization is if the image is displayed multiple times at different resolutions (which can be specified explicitly or through automatic right-sized decoding).</source>
          <target xml:space="preserve">The exception to this optimization is if the image is displayed multiple times at different resolutions (which can be specified explicitly or through automatic right-sized decoding).</target>
        </segment>
      </unit>
      <unit id="290">
        <segment state="initial">
          <source xml:space="preserve">Each cache entry also stores the resolution of the image, and if XAML cannot find an image with a source URI that matches the required resolution then it will decode a new version at that size.</source>
          <target xml:space="preserve">Each cache entry also stores the resolution of the image, and if XAML cannot find an image with a source URI that matches the required resolution then it will decode a new version at that size.</target>
        </segment>
      </unit>
      <unit id="291">
        <segment state="initial">
          <source xml:space="preserve">It will not, however, download the encoded image data again.</source>
          <target xml:space="preserve">It will not, however, download the encoded image data again.</target>
        </segment>
      </unit>
      <unit id="292">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243235-urisource)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/JJ191522)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Consequently, you should embrace using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UriSource</pc></pc> when loading images from an app package, and avoid using a file stream and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> when it's not required.</source>
          <target xml:space="preserve">Consequently, you should embrace using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UriSource</pc></pc> when loading images from an app package, and avoid using a file stream and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SetSourceAsync</pc></pc> when it's not required.</target>
        </segment>
      </unit>
      <unit id="293">
        <segment state="initial">
          <source xml:space="preserve">Images in virtualized panels (ListView, for instance)</source>
          <target xml:space="preserve">Images in virtualized panels (ListView, for instance)</target>
        </segment>
      </unit>
      <unit id="294">
        <segment state="initial">
          <source xml:space="preserve">If an image is removed from the tree—because the app explicitly removed it, or because it’s in a modern virtualized panel and was implicitly removed when scrolled out of view—then XAML will optimize memory usage by releasing the hardware resources for the image since they are no longer required.</source>
          <target xml:space="preserve">If an image is removed from the tree—because the app explicitly removed it, or because it’s in a modern virtualized panel and was implicitly removed when scrolled out of view—then XAML will optimize memory usage by releasing the hardware resources for the image since they are no longer required.</target>
        </segment>
      </unit>
      <unit id="295">
        <segment state="initial">
          <source xml:space="preserve">The memory is not released immediately, but rather is released during the frame update that occurs after one second of the image element no longer being in the tree.</source>
          <target xml:space="preserve">The memory is not released immediately, but rather is released during the frame update that occurs after one second of the image element no longer being in the tree.</target>
        </segment>
      </unit>
      <unit id="296">
        <segment state="initial">
          <source xml:space="preserve">Consequently, you should strive to use modern virtualized panels to host lists of image content.</source>
          <target xml:space="preserve">Consequently, you should strive to use modern virtualized panels to host lists of image content.</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source xml:space="preserve">Software-rasterized images</source>
          <target xml:space="preserve">Software-rasterized images</target>
        </segment>
      </unit>
      <unit id="298">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242756)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When an image is used for a non-rectangular brush or for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>, the image will use a software rasterization path, which will not scale images at all.</source>
          <target xml:space="preserve">When an image is used for a non-rectangular brush or for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>, the image will use a software rasterization path, which will not scale images at all.</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source xml:space="preserve">Additionally, it must store a copy of the image in both software and hardware memory.</source>
          <target xml:space="preserve">Additionally, it must store a copy of the image in both software and hardware memory.</target>
        </segment>
      </unit>
      <unit id="300">
        <segment state="initial">
          <source xml:space="preserve">For instance, if an image is used as a brush for an ellipse then the potentially large full image will be stored twice internally.</source>
          <target xml:space="preserve">For instance, if an image is used as a brush for an ellipse then the potentially large full image will be stored twice internally.</target>
        </segment>
      </unit>
      <unit id="301">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NineGrid</pc> or a non-rectangular brush, then, your app should pre-scale its images to approximately the size they will be rendered at.</source>
          <target xml:space="preserve">When using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">NineGrid</pc> or a non-rectangular brush, then, your app should pre-scale its images to approximately the size they will be rendered at.</target>
        </segment>
      </unit>
      <unit id="302">
        <segment state="initial">
          <source xml:space="preserve">Background thread image-loading</source>
          <target xml:space="preserve">Background thread image-loading</target>
        </segment>
      </unit>
      <unit id="303">
        <segment state="initial">
          <source xml:space="preserve">XAML has an internal optimization that allows it to decode the contents of an image asynchronously to a surface in hardware memory without requiring an intermediate surface in software memory.</source>
          <target xml:space="preserve">XAML has an internal optimization that allows it to decode the contents of an image asynchronously to a surface in hardware memory without requiring an intermediate surface in software memory.</target>
        </segment>
      </unit>
      <unit id="304">
        <segment state="initial">
          <source xml:space="preserve">This reduces peak memory usage and rendering latency.</source>
          <target xml:space="preserve">This reduces peak memory usage and rendering latency.</target>
        </segment>
      </unit>
      <unit id="305">
        <segment state="initial">
          <source xml:space="preserve">This feature will be disabled if any of the following conditions are met.</source>
          <target xml:space="preserve">This feature will be disabled if any of the following conditions are met.</target>
        </segment>
      </unit>
      <unit id="306">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242756)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The image is used as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>.</source>
          <target xml:space="preserve">The image is used as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">NineGrid</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="307">
        <originalData>
          <data id="id1">`CacheMode="BitmapCache"`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<ph dataRef="id1" id="ph1" /> is set on the image element or on any parent element.</source>
          <target xml:space="preserve">
						<ph dataRef="id1" id="ph1" /> is set on the image element or on any parent element.</target>
        </segment>
      </unit>
      <unit id="308">
        <segment state="initial">
          <source xml:space="preserve">The image brush is non-rectangular (such as when applied to a shape or to text).</source>
          <target xml:space="preserve">The image brush is non-rectangular (such as when applied to a shape or to text).</target>
        </segment>
      </unit>
      <unit id="309">
        <segment state="initial">
          <source xml:space="preserve">SoftwareBitmapSource</source>
          <target xml:space="preserve">SoftwareBitmapSource</target>
        </segment>
      </unit>
      <unit id="310">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn997854)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR226176)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmapSource</pc></pc> class exchanges interoperable uncompressed images between different WinRT namespaces such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">BitmapDecoder</pc></pc>, camera APIs, and XAML.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmapSource</pc></pc> class exchanges interoperable uncompressed images between different WinRT namespaces such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">BitmapDecoder</pc></pc>, camera APIs, and XAML.</target>
        </segment>
      </unit>
      <unit id="311">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243259)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This class obviates an extra copy that would typically be necessary with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">WriteableBitmap</pc></pc>, and that helps reduce peak memory and source-to-screen latency.</source>
          <target xml:space="preserve">This class obviates an extra copy that would typically be necessary with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">WriteableBitmap</pc></pc>, and that helps reduce peak memory and source-to-screen latency.</target>
        </segment>
      </unit>
      <unit id="312">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn887358)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/desktop/Ee719675)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmap</pc></pc> that supplies source information can also be configured to use a custom <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IWICBitmap</pc></pc> to provide a reloadable backing store that allows the app to re-map memory as it sees fit.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmap</pc></pc> that supplies source information can also be configured to use a custom <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IWICBitmap</pc></pc> to provide a reloadable backing store that allows the app to re-map memory as it sees fit.</target>
        </segment>
      </unit>
      <unit id="313">
        <segment state="initial">
          <source xml:space="preserve">This is an advanced C++ use case.</source>
          <target xml:space="preserve">This is an advanced C++ use case.</target>
        </segment>
      </unit>
      <unit id="314">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn887358)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/Dn997854)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Your app should use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmap</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SoftwareBitmapSource</pc></pc> to interoperate with other WinRT APIs that produce and consume images.</source>
          <target xml:space="preserve">Your app should use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SoftwareBitmap</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SoftwareBitmapSource</pc></pc> to interoperate with other WinRT APIs that produce and consume images.</target>
        </segment>
      </unit>
      <unit id="315">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR243259)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">And your app should use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SoftwareBitmapSource</pc> when loading uncompressed image data instead of using <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">WriteableBitmap</pc></pc>.</source>
          <target xml:space="preserve">And your app should use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SoftwareBitmapSource</pc> when loading uncompressed image data instead of using <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">WriteableBitmap</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="316">
        <originalData>
          <data id="id1">&lt;span id="use-getthumbnailasync-for-thumbnails"&gt;</data>
          <data id="id2">&lt;/span&gt;</data>
          <data id="id3">&lt;span id="USE-GETTHUMBNAILASYNC-FOR-THUMBNAILS"&gt;</data>
          <data id="id4">&lt;/span&gt;</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<ph dataRef="id1" id="ph1" />
						<ph dataRef="id2" id="ph2" />
						<ph dataRef="id3" id="ph3" />
						<ph dataRef="id4" id="ph4" />Use GetThumbnailAsync for thumbnails</source>
          <target xml:space="preserve">
						<ph dataRef="id1" id="ph1" />
						<ph dataRef="id2" id="ph2" />
						<ph dataRef="id3" id="ph3" />
						<ph dataRef="id4" id="ph4" />Use GetThumbnailAsync for thumbnails</target>
        </segment>
      </unit>
      <unit id="317">
        <segment state="initial">
          <source xml:space="preserve">One use case for scaling images is creating thumbnails.</source>
          <target xml:space="preserve">One use case for scaling images is creating thumbnails.</target>
        </segment>
      </unit>
      <unit id="318">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243243)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243241)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Although you could use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> to provide small versions of images, UWP provides even more efficient APIs for retrieving thumbnails.</source>
          <target xml:space="preserve">Although you could use <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DecodePixelWidth</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">DecodePixelHeight</pc></pc> to provide small versions of images, UWP provides even more efficient APIs for retrieving thumbnails.</target>
        </segment>
      </unit>
      <unit id="319">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227210)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetThumbnailAsync</pc>
						</pc> provides the thumbnails for images that have the file system already cached.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetThumbnailAsync</pc>
						</pc> provides the thumbnails for images that have the file system already cached.</target>
        </segment>
      </unit>
      <unit id="320">
        <segment state="initial">
          <source xml:space="preserve">This provides even better performance than the XAML APIs because the image doesn’t need to be opened or decoded.</source>
          <target xml:space="preserve">This provides even better performance than the XAML APIs because the image doesn’t need to be opened or decoded.</target>
        </segment>
      </unit>
      <unit id="321">
        <segment state="initial">
          <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
          <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
        </segment>
      </unit>
      <unit id="322">
        <segment state="initial">
          <source xml:space="preserve">Decode images once</source>
          <target xml:space="preserve">Decode images once</target>
        </segment>
      </unit>
      <unit id="323">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242760)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To prevent images from being decoded more than once, assign the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image.Source</pc></pc> property from an Uri rather than using memory streams.</source>
          <target xml:space="preserve">To prevent images from being decoded more than once, assign the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image.Source</pc></pc> property from an Uri rather than using memory streams.</target>
        </segment>
      </unit>
      <unit id="324">
        <segment state="initial">
          <source xml:space="preserve">The XAML framework can associate the same Uri in multiple places with one decoded image, but it cannot do the same for multiple memory streams that contain the same data and creates a different decoded image for each memory stream.</source>
          <target xml:space="preserve">The XAML framework can associate the same Uri in multiple places with one decoded image, but it cannot do the same for multiple memory streams that contain the same data and creates a different decoded image for each memory stream.</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>