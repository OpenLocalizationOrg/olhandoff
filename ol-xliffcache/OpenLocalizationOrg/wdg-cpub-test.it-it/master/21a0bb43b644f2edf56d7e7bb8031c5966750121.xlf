<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="it-it" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">21a0bb43b644f2edf56d7e7bb8031c5966750121</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">description: The {x:Bind} markup extension&amp;\#8212;new for Windows 10&amp;\#8212;is an alternative to {Binding}.</source>
          <target xml:space="preserve">description: The {x:Bind} markup extension&amp;\#8212;new for Windows 10&amp;\#8212;is an alternative to {Binding}.</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">{x:Bind} lacks some of the features of {Binding}, but it runs in less time and less memory than {Binding} and supports better debugging.</source>
          <target xml:space="preserve">{x:Bind} lacks some of the features of {Binding}, but it runs in less time and less memory than {Binding} and supports better debugging.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">title: {x:Bind} markup extension'</source>
          <target xml:space="preserve">title: {x:Bind} markup extension'</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: 529FBEB5-E589-486F-A204-B310ACDC5C06</source>
          <target xml:space="preserve">ms.assetid: 529FBEB5-E589-486F-A204-B310ACDC5C06</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">{x:Bind} markup extension</source>
          <target xml:space="preserve">{x:Bind} markup extension</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="107">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For general info about using data binding in your app with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc> (and for an all-up comparison between <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{x:Bind}</pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">{Binding}</pc>), see <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Data binding in depth</pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For general info about using data binding in your app with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc> (and for an all-up comparison between <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{x:Bind}</pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="p4">{Binding}</pc>), see <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Data binding in depth</pc>.</target>
        </segment>
      </unit>
      <unit id="109">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> markup extension—new for Windows 10—is an alternative to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc>.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> markup extension—new for Windows 10—is an alternative to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc>.</target>
        </segment>
      </unit>
      <unit id="110">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> lacks some of the features of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc>, but it runs in less time and less memory than <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{Binding}</pc> and supports better debugging.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> lacks some of the features of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc>, but it runs in less time and less memory than <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{Binding}</pc> and supports better debugging.</target>
        </segment>
      </unit>
      <unit id="111">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">At XAML load time, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> is converted into what you can think of as a binding object, and this object gets a value from a property on a data source.</source>
          <target xml:space="preserve">At XAML load time, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> is converted into what you can think of as a binding object, and this object gets a value from a property on a data source.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">The binding object can optionally be configured to observe changes in the value of the data source property and refresh itself based on those changes.</source>
          <target xml:space="preserve">The binding object can optionally be configured to observe changes in the value of the data source property and refresh itself based on those changes.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">It can also optionally be configured to push changes in its own value back to the source property.</source>
          <target xml:space="preserve">It can also optionally be configured to push changes in its own value back to the source property.</target>
        </segment>
      </unit>
      <unit id="114">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The binding objects created by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> are largely functionally equivalent.</source>
          <target xml:space="preserve">The binding objects created by <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> are largely functionally equivalent.</target>
        </segment>
      </unit>
      <unit id="115">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> executes special-purpose code, which it generates at compile-time, and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> uses general-purpose runtime object inspection.</source>
          <target xml:space="preserve">But <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> executes special-purpose code, which it generates at compile-time, and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> uses general-purpose runtime object inspection.</target>
        </segment>
      </unit>
      <unit id="116">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Consequently, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> bindings (often referred-to as compiled bindings) have great performance, provide compile-time validation of your binding expressions, and support debugging by enabling you to set breakpoints in the code files that are generated as the partial class for your page.</source>
          <target xml:space="preserve">Consequently, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> bindings (often referred-to as compiled bindings) have great performance, provide compile-time validation of your binding expressions, and support debugging by enabling you to set breakpoints in the code files that are generated as the partial class for your page.</target>
        </segment>
      </unit>
      <unit id="117">
        <originalData>
          <data id="id1">`obj`</data>
          <data id="id2">`&lt;view name&gt;.g.cs`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">These files can be found in your <ph dataRef="id1" id="ph1" /> folder, with names like (for C#) <ph dataRef="id2" id="ph2" />.</source>
          <target xml:space="preserve">These files can be found in your <ph dataRef="id1" id="ph1" /> folder, with names like (for C#) <ph dataRef="id2" id="ph2" />.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">Sample apps that demonstrate {x:Bind}</source>
          <target xml:space="preserve">Sample apps that demonstrate {x:Bind}</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">{x:Bind} sample</source>
          <target xml:space="preserve">{x:Bind} sample</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">QuizGame</source>
          <target xml:space="preserve">QuizGame</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">XAML UI Basics sample</source>
          <target xml:space="preserve">XAML UI Basics sample</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">XAML attribute usage</source>
          <target xml:space="preserve">XAML attribute usage</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">Term</source>
          <target xml:space="preserve">Term</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">Description</source>
          <target xml:space="preserve">Description</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">propertyPath</source>
          <target xml:space="preserve">propertyPath</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source xml:space="preserve">A string that specifies the property path for the binding.</source>
          <target xml:space="preserve">A string that specifies the property path for the binding.</target>
        </segment>
      </unit>
      <unit id="127">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#property-path)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">More info is in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Property path</pc> section below.</source>
          <target xml:space="preserve">More info is in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Property path</pc> section below.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">bindingProperties</source>
          <target xml:space="preserve">bindingProperties</target>
        </segment>
      </unit>
      <unit id="129">
        <originalData>
          <data id="id1">_</data>
          <data id="id2">_</data>
          <data id="id3">_</data>
          <data id="id4">_</data>
          <data id="id5">_</data>
          <data id="id6">_</data>
          <data id="id7">_</data>
          <data id="id8">_</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">propName</pc>=<pc dataRefEnd="id4" dataRefStart="id3" id="p2">value</pc>\[, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">propName</pc>=<pc dataRefEnd="id8" dataRefStart="id7" id="p4">value</pc>\]*</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">propName</pc>=<pc dataRefEnd="id4" dataRefStart="id3" id="p2">value</pc>\[, <pc dataRefEnd="id6" dataRefStart="id5" id="p3">propName</pc>=<pc dataRefEnd="id8" dataRefStart="id7" id="p4">value</pc>\]*</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source xml:space="preserve">One or more binding properties that are specified using a name/value pair syntax.</source>
          <target xml:space="preserve">One or more binding properties that are specified using a name/value pair syntax.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source xml:space="preserve">propName</source>
          <target xml:space="preserve">propName</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source xml:space="preserve">The string name of the property to set on the binding object.</source>
          <target xml:space="preserve">The string name of the property to set on the binding object.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">For example, "Converter".</source>
          <target xml:space="preserve">For example, "Converter".</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">value</source>
          <target xml:space="preserve">value</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">The value to set the property to.</source>
          <target xml:space="preserve">The value to set the property to.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source xml:space="preserve">The syntax of the argument depends on the property being set.</source>
          <target xml:space="preserve">The syntax of the argument depends on the property being set.</target>
        </segment>
      </unit>
      <unit id="137">
        <originalData>
          <data id="id1">_</data>
          <data id="id2">_</data>
          <data id="id3">_</data>
          <data id="id4">_</data>
          <data id="id5">`Converter={StaticResource myConverterClass}`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Here's an example of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">propName</pc>=<pc dataRefEnd="id4" dataRefStart="id3" id="p2">value</pc> usage where the value is itself a markup extension: <ph dataRef="id5" id="ph1" />.</source>
          <target xml:space="preserve">Here's an example of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">propName</pc>=<pc dataRefEnd="id4" dataRefStart="id3" id="p2">value</pc> usage where the value is itself a markup extension: <ph dataRef="id5" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="138">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#properties-you-can-set)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Properties that you can set with {x:Bind}</pc> section below.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Properties that you can set with {x:Bind}</pc> section below.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">Property path</source>
          <target xml:space="preserve">Property path</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">PropertyPath</pc> sets the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Path</pc> for an <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{x:Bind}</pc> expression.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">PropertyPath</pc> sets the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Path</pc> for an <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{x:Bind}</pc> expression.</target>
        </segment>
      </unit>
      <unit id="141">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Path</pc> is a property path specifying the value of the property, sub-property, field, or method that you're binding to (the source).</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Path</pc> is a property path specifying the value of the property, sub-property, field, or method that you're binding to (the source).</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">`{Binding Path=...}`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can mention the name of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Path</pc> property explicitly: <ph dataRef="id3" id="ph1" />.</source>
          <target xml:space="preserve">You can mention the name of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Path</pc> property explicitly: <ph dataRef="id3" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="143">
        <originalData>
          <data id="id1">`{Binding ...}`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Or you can omit it: <ph dataRef="id1" id="ph1" />.</source>
          <target xml:space="preserve">Or you can omit it: <ph dataRef="id1" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="144">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> does not use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> as a default source—instead, it uses the page or user control itself.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> does not use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> as a default source—instead, it uses the page or user control itself.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source xml:space="preserve">So it will look in the code-behind of your page or user control for properties, fields, and methods.</source>
          <target xml:space="preserve">So it will look in the code-behind of your page or user control for properties, fields, and methods.</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To expose your view model to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc>, you will typically want to add new fields or properties to the code behind for your page or user control.</source>
          <target xml:space="preserve">To expose your view model to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc>, you will typically want to add new fields or properties to the code behind for your page or user control.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source xml:space="preserve">Steps in a property path are delimited by dots (.), and you can include multiple delimiters to traverse successive sub-properties.</source>
          <target xml:space="preserve">Steps in a property path are delimited by dots (.), and you can include multiple delimiters to traverse successive sub-properties.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source xml:space="preserve">Use the dot delimiter regardless of the programming language used to implement the object being bound to.</source>
          <target xml:space="preserve">Use the dot delimiter regardless of the programming language used to implement the object being bound to.</target>
        </segment>
      </unit>
      <unit id="149">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example: in a page, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Text="{x:Bind Employee.FirstName}"</pc> will look for an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Employee</pc> member on the page and then a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">FirstName</pc> member on the object returned by <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Employee</pc>.</source>
          <target xml:space="preserve">For example: in a page, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Text="{x:Bind Employee.FirstName}"</pc> will look for an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Employee</pc> member on the page and then a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">FirstName</pc> member on the object returned by <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Employee</pc>.</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source xml:space="preserve">If you are binding an items control to a property that contains an employee's dependents, your property path might be "Employee.Dependents", and the item template of the items control would take care of displaying the items in "Dependents".</source>
          <target xml:space="preserve">If you are binding an items control to a property that contains an employee's dependents, your property path might be "Employee.Dependents", and the item template of the items control would take care of displaying the items in "Dependents".</target>
        </segment>
      </unit>
      <unit id="151">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For C++/CX, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> cannot bind to private fields and properties in the page or data model – you will need to have a public property for it to be bindable.</source>
          <target xml:space="preserve">For C++/CX, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> cannot bind to private fields and properties in the page or data model – you will need to have a public property for it to be bindable.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source xml:space="preserve">The surface area for binding needs to be exposed as CX classes/interfaces so that we can get the relevant metadata.</source>
          <target xml:space="preserve">The surface area for binding needs to be exposed as CX classes/interfaces so that we can get the relevant metadata.</target>
        </segment>
      </unit>
      <unit id="153">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">\[Bindable\]</pc> attribute should not be needed.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">\[Bindable\]</pc> attribute should not be needed.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">If the data source is a collection, then a property path can specify items in the collection by their position or index.</source>
          <target xml:space="preserve">If the data source is a collection, then a property path can specify items in the collection by their position or index.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">For example, "Teams\[0\].Players", where the literal "\[\]" encloses the "0" that requests the first item in a zero-indexed collection.</source>
          <target xml:space="preserve">For example, "Teams\[0\].Players", where the literal "\[\]" encloses the "0" that requests the first item in a zero-indexed collection.</target>
        </segment>
      </unit>
      <unit id="156">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To use an indexer, the model needs to implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IList&amp;lt;T&amp;gt;</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVector&amp;lt;T&amp;gt;</pc> on the type of the property that is going to be indexed.</source>
          <target xml:space="preserve">To use an indexer, the model needs to implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IList&amp;lt;T&amp;gt;</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IVector&amp;lt;T&amp;gt;</pc> on the type of the property that is going to be indexed.</target>
        </segment>
      </unit>
      <unit id="157">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If the type of the indexed property supports <pc dataRefEnd="id2" dataRefStart="id1" id="p1">INotifyCollectionChanged</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IObservableVector</pc> and the binding is OneWay or TwoWay, then it will register and listen for change notifications on those interfaces.</source>
          <target xml:space="preserve">If the type of the indexed property supports <pc dataRefEnd="id2" dataRefStart="id1" id="p1">INotifyCollectionChanged</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">IObservableVector</pc> and the binding is OneWay or TwoWay, then it will register and listen for change notifications on those interfaces.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">The change detection logic will update based on all collection changes, even if that doesn’t affect the specific indexed value.</source>
          <target xml:space="preserve">The change detection logic will update based on all collection changes, even if that doesn’t affect the specific indexed value.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source xml:space="preserve">This is because the listening logic is common across all instances of the collection.</source>
          <target xml:space="preserve">This is because the listening logic is common across all instances of the collection.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source xml:space="preserve">To bind to attached properties, you need to put the class and property name into parentheses after the dot.</source>
          <target xml:space="preserve">To bind to attached properties, you need to put the class and property name into parentheses after the dot.</target>
        </segment>
      </unit>
      <unit id="161">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Text="{x:Bind Button22.(Grid.Row)}"</pc>.</source>
          <target xml:space="preserve">For example <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Text="{x:Bind Button22.(Grid.Row)}"</pc>.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">If the property is not declared in a Xaml namespace, then you will need to prefix it with a xml namespace, which you should map to a code namespace at the head of the document.</source>
          <target xml:space="preserve">If the property is not declared in a Xaml namespace, then you will need to prefix it with a xml namespace, which you should map to a code namespace at the head of the document.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source xml:space="preserve">Compiled bindings are strongly typed, and will resolve the type of each step in a path.</source>
          <target xml:space="preserve">Compiled bindings are strongly typed, and will resolve the type of each step in a path.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source xml:space="preserve">If the type returned doesn’t have the member, it will fail at compile time.</source>
          <target xml:space="preserve">If the type returned doesn’t have the member, it will fail at compile time.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">You can specify a cast to tell binding the real type of the object.</source>
          <target xml:space="preserve">You can specify a cast to tell binding the real type of the object.</target>
        </segment>
      </unit>
      <unit id="166">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In the following case, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">obj</pc> is a property of type object, but contains a text box, so we can use <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Text="{x:Bind obj.(TextBox.Text)}"</pc>.</source>
          <target xml:space="preserve">In the following case, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">obj</pc> is a property of type object, but contains a text box, so we can use <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Text="{x:Bind obj.(TextBox.Text)}"</pc>.</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">groups3</pc> field in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Text="{x:Bind groups3\[0\].(data:SampleDataGroup.Title)}"</pc> is a dictionary of objects, so you must cast it to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">data:SampleDataGroup</pc>.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">groups3</pc> field in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Text="{x:Bind groups3\[0\].(data:SampleDataGroup.Title)}"</pc> is a dictionary of objects, so you must cast it to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">data:SampleDataGroup</pc>.</target>
        </segment>
      </unit>
      <unit id="168">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Note the use of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">data:</pc> namespace prefix for mapping the object type to a namespace that isn't part of the default XAML namespace.</source>
          <target xml:space="preserve">Note the use of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">data:</pc> namespace prefix for mapping the object type to a namespace that isn't part of the default XAML namespace.</target>
        </segment>
      </unit>
      <unit id="169">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">With <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Bind</pc>, you do not need to use <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ElementName=xxx</pc> as part of the binding expression.</source>
          <target xml:space="preserve">With <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Bind</pc>, you do not need to use <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ElementName=xxx</pc> as part of the binding expression.</target>
        </segment>
      </unit>
      <unit id="170">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">With <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Bind</pc>, you can use the name of the element as the first part of the path for the binding because named elements become fields within the page or user control that represents the root binding source.</source>
          <target xml:space="preserve">With <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Bind</pc>, you can use the name of the element as the first part of the path for the binding because named elements become fields within the page or user control that represents the root binding source.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source xml:space="preserve">Event binding is a new feature for compiled binding.</source>
          <target xml:space="preserve">Event binding is a new feature for compiled binding.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">It enables you to specify the handler for an event using a binding, rather than it having to be a method on the code behind.</source>
          <target xml:space="preserve">It enables you to specify the handler for an event using a binding, rather than it having to be a method on the code behind.</target>
        </segment>
      </unit>
      <unit id="173">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click="{x:Bind rootFrame.GoForward}"</pc>.</source>
          <target xml:space="preserve">For example: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click="{x:Bind rootFrame.GoForward}"</pc>.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source xml:space="preserve">For events, the target method must not be overloaded and must also:</source>
          <target xml:space="preserve">For events, the target method must not be overloaded and must also:</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">Match the signature of the event.</source>
          <target xml:space="preserve">Match the signature of the event.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source xml:space="preserve">OR have no parameters.</source>
          <target xml:space="preserve">OR have no parameters.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source xml:space="preserve">OR have the same number of parameters of types that are assignable from the types of the event parameters.</source>
          <target xml:space="preserve">OR have the same number of parameters of types that are assignable from the types of the event parameters.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source xml:space="preserve">In generated code-behind, compiled binding handles the event and routes it to the method on the model, evaluating the path of the binding expression when the event occurs.</source>
          <target xml:space="preserve">In generated code-behind, compiled binding handles the event and routes it to the method on the model, evaluating the path of the binding expression when the event occurs.</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source xml:space="preserve">This means that, unlike property bindings, it doesn’t track changes to the model.</source>
          <target xml:space="preserve">This means that, unlike property bindings, it doesn’t track changes to the model.</target>
        </segment>
      </unit>
      <unit id="180">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](property-path-syntax.md)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info about the string syntax for a property path, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Property-path syntax</pc>, keeping in mind the differences described here for <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc>.</source>
          <target xml:space="preserve">For more info about the string syntax for a property path, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Property-path syntax</pc>, keeping in mind the differences described here for <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc>.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">Properties that you can set with {x:Bind}</source>
          <target xml:space="preserve">Properties that you can set with {x:Bind}</target>
        </segment>
      </unit>
      <unit id="182">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> is illustrated with the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">bindingProperties</pc> placeholder syntax because there are multiple read/write properties that can be set in the markup extension.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> is illustrated with the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">bindingProperties</pc> placeholder syntax because there are multiple read/write properties that can be set in the markup extension.</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The properties can be set in any order with comma-separated <pc dataRefEnd="id2" dataRefStart="id1" id="p1">propName</pc>=<pc dataRefEnd="id4" dataRefStart="id3" id="p2">value</pc> pairs.</source>
          <target xml:space="preserve">The properties can be set in any order with comma-separated <pc dataRefEnd="id2" dataRefStart="id1" id="p1">propName</pc>=<pc dataRefEnd="id4" dataRefStart="id3" id="p2">value</pc> pairs.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source xml:space="preserve">Note that you cannot include line breaks in the binding expression.</source>
          <target xml:space="preserve">Note that you cannot include line breaks in the binding expression.</target>
        </segment>
      </unit>
      <unit id="185">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Some of the properties require types that don't have a type conversion, so these require markup extensions of their own nested within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc>.</source>
          <target xml:space="preserve">Some of the properties require types that don't have a type conversion, so these require markup extensions of their own nested within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc>.</target>
        </segment>
      </unit>
      <unit id="186">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209820)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">These properties work in much the same way as the properties of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Binding</pc></pc> class.</source>
          <target xml:space="preserve">These properties work in much the same way as the properties of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Binding</pc></pc> class.</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source xml:space="preserve">Property</source>
          <target xml:space="preserve">Property</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source xml:space="preserve">Description</source>
          <target xml:space="preserve">Description</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source xml:space="preserve">Path</source>
          <target xml:space="preserve">Path</target>
        </segment>
      </unit>
      <unit id="190">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#property-path)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">See the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Property path</pc> section above.</source>
          <target xml:space="preserve">See the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Property path</pc> section above.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source xml:space="preserve">Converter</source>
          <target xml:space="preserve">Converter</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source xml:space="preserve">Specifies the converter object that is called by the binding engine.</source>
          <target xml:space="preserve">Specifies the converter object that is called by the binding engine.</target>
        </segment>
      </unit>
      <unit id="193">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](staticresource-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The converter can be set in XAML, but only if you refer to an object instance that you've assigned in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{StaticResource} markup extension</pc> reference to that object in the resource dictionary.</source>
          <target xml:space="preserve">The converter can be set in XAML, but only if you refer to an object instance that you've assigned in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{StaticResource} markup extension</pc> reference to that object in the resource dictionary.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source xml:space="preserve">ConverterLanguage</source>
          <target xml:space="preserve">ConverterLanguage</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source xml:space="preserve">Specifies the culture to be used by the converter.</source>
          <target xml:space="preserve">Specifies the culture to be used by the converter.</target>
        </segment>
      </unit>
      <unit id="196">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">(If you're setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConverterLanguage</pc> you should also be setting <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Converter</pc>.) The culture is set as a standards-based identifier.</source>
          <target xml:space="preserve">(If you're setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConverterLanguage</pc> you should also be setting <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Converter</pc>.) The culture is set as a standards-based identifier.</target>
        </segment>
      </unit>
      <unit id="197">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701880)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConverterLanguage</pc></pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConverterLanguage</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source xml:space="preserve">ConverterParameter</source>
          <target xml:space="preserve">ConverterParameter</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source xml:space="preserve">Specifies the converter parameter that can be used in converter logic.</source>
          <target xml:space="preserve">Specifies the converter parameter that can be used in converter logic.</target>
        </segment>
      </unit>
      <unit id="200">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">(If you're setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConverterParameter</pc> you should also be setting <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Converter</pc>.) Most converters use simple logic that get all the info they need from the passed value to convert, and don't need a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ConverterParameter</pc> value.</source>
          <target xml:space="preserve">(If you're setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConverterParameter</pc> you should also be setting <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Converter</pc>.) Most converters use simple logic that get all the info they need from the passed value to convert, and don't need a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">ConverterParameter</pc> value.</target>
        </segment>
      </unit>
      <unit id="201">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConverterParameter</pc> parameter is for moderately advanced converter implementations that have more than one logic that keys off what's passed in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConverterParameter</pc>.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ConverterParameter</pc> parameter is for moderately advanced converter implementations that have more than one logic that keys off what's passed in <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConverterParameter</pc>.</target>
        </segment>
      </unit>
      <unit id="202">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209827)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can write a converter that uses values other than strings but this is uncommon, see Remarks in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConverterParameter</pc></pc> for more info.</source>
          <target xml:space="preserve">You can write a converter that uses values other than strings but this is uncommon, see Remarks in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ConverterParameter</pc></pc> for more info.</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source xml:space="preserve">FallbackValue</source>
          <target xml:space="preserve">FallbackValue</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source xml:space="preserve">Specifies a value to display when the source or path cannot be resolved.</source>
          <target xml:space="preserve">Specifies a value to display when the source or path cannot be resolved.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source xml:space="preserve">Mode</source>
          <target xml:space="preserve">Mode</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source xml:space="preserve">Specifies the binding mode, as one of these strings: "OneTime", "OneWay", or "TwoWay".</source>
          <target xml:space="preserve">Specifies the binding mode, as one of these strings: "OneTime", "OneWay", or "TwoWay".</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source xml:space="preserve">The default is "OneTime".</source>
          <target xml:space="preserve">The default is "OneTime".</target>
        </segment>
      </unit>
      <unit id="208">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Note that this differs from the default for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc>, which is "OneWay" in most cases.</source>
          <target xml:space="preserve">Note that this differs from the default for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc>, which is "OneWay" in most cases.</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source xml:space="preserve">TargetNullValue</source>
          <target xml:space="preserve">TargetNullValue</target>
        </segment>
      </unit>
      <unit id="210">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Specifies a value to display when the source value resolves but is explicitly <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc>.</source>
          <target xml:space="preserve">Specifies a value to display when the source value resolves but is explicitly <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc>.</target>
        </segment>
      </unit>
      <unit id="211">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you're converting markup from <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{x:Bind}</pc>, then be aware of the differences in default values for the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Mode</pc> property.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you're converting markup from <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{x:Bind}</pc>, then be aware of the differences in default values for the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Mode</pc> property.</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source xml:space="preserve">Remarks</source>
          <target xml:space="preserve">Remarks</target>
        </segment>
      </unit>
      <unit id="213">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Because <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> uses generated code to achieve its benefits, it requires type information at compile time.</source>
          <target xml:space="preserve">Because <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> uses generated code to achieve its benefits, it requires type information at compile time.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source xml:space="preserve">This means that you cannot bind to properties where you do not know the type ahead of time.</source>
          <target xml:space="preserve">This means that you cannot bind to properties where you do not know the type ahead of time.</target>
        </segment>
      </unit>
      <unit id="215">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Because of this, you cannot use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> with the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> property, which is of type <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Object</pc>, and is also subject to change at run time.</source>
          <target xml:space="preserve">Because of this, you cannot use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> with the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> property, which is of type <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Object</pc>, and is also subject to change at run time.</target>
        </segment>
      </unit>
      <unit id="216">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> with data templates, you must indicate the type being bound to by setting an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:DataType</pc> value, as shown in the example below.</source>
          <target xml:space="preserve">When using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> with data templates, you must indicate the type being bound to by setting an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:DataType</pc> value, as shown in the example below.</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source xml:space="preserve">You can also set the type to an interface or base class type, and then use casts if necessary to formulate a full expression.</source>
          <target xml:space="preserve">You can also set the type to an interface or base class type, and then use casts if necessary to formulate a full expression.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source xml:space="preserve">Compiled bindings depend on code generation.</source>
          <target xml:space="preserve">Compiled bindings depend on code generation.</target>
        </segment>
      </unit>
      <unit id="219">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">So if you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> in a resource dictionary then the resource dictionary needs to have a code-behind class.</source>
          <target xml:space="preserve">So if you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> in a resource dictionary then the resource dictionary needs to have a code-behind class.</target>
        </segment>
      </unit>
      <unit id="220">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](../data-binding/data-binding-in-depth.md#resource-dictionaries-with-x-bind)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Resource dictionaries with {x:Bind}</pc> for a code example.</source>
          <target xml:space="preserve">See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Resource dictionaries with {x:Bind}</pc> for a code example.</target>
        </segment>
      </unit>
      <unit id="221">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>   If you set a local value for a property that previously had a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc> markup extension to provide a local value, the binding is completely removed.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>   If you set a local value for a property that previously had a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{x:Bind}</pc> markup extension to provide a local value, the binding is completely removed.</target>
        </segment>
      </unit>
      <unit id="222">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br209830)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br209827)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">`\{`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>   If you need to specify a single curly brace for a value, such as in <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Path</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ConverterParameter</pc></pc>, precede it with a backslash: <ph dataRef="id11" id="ph1" />.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Tip</pc>   If you need to specify a single curly brace for a value, such as in <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">Path</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ConverterParameter</pc></pc>, precede it with a backslash: <ph dataRef="id11" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="223">
        <originalData>
          <data id="id1">`ConverterParameter='{Mix}'`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Alternatively, enclose the entire string that contains the braces that need escaping in a secondary quotation set, for example <ph dataRef="id1" id="ph1" />.</source>
          <target xml:space="preserve">Alternatively, enclose the entire string that contains the braces that need escaping in a secondary quotation set, for example <ph dataRef="id1" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="224">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209826)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/hh701880)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Converter</pc>
						</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ConverterLanguage</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5">ConverterLanguage</pc> are all related to the scenario of converting a value or type from the binding source into a type or value that is compatible with the binding target property.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Converter</pc>
						</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ConverterLanguage</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5">ConverterLanguage</pc> are all related to the scenario of converting a value or type from the binding source into a type or value that is compatible with the binding target property.</target>
        </segment>
      </unit>
      <unit id="225">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt210946)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info and examples, see the "Data conversions" section of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</source>
          <target xml:space="preserve">For more info and examples, see the "Data conversions" section of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data binding in depth</pc>.</target>
        </segment>
      </unit>
      <unit id="226">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> is a markup extension only, with no way to create or manipulate such bindings programmatically.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> is a markup extension only, with no way to create or manipulate such bindings programmatically.</target>
        </segment>
      </unit>
      <unit id="227">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](xaml-overview.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info about markup extensions, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML overview</pc>.</source>
          <target xml:space="preserve">For more info about markup extensions, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML overview</pc>.</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source xml:space="preserve">Examples</source>
          <target xml:space="preserve">Examples</target>
        </segment>
      </unit>
      <unit id="229">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This example XAML uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView.ItemTemplate</pc> property.</source>
          <target xml:space="preserve">This example XAML uses <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> with a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView.ItemTemplate</pc> property.</target>
        </segment>
      </unit>
      <unit id="230">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Note the declaration of an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:DataType</pc> value.</source>
          <target xml:space="preserve">Note the declaration of an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:DataType</pc> value.</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>