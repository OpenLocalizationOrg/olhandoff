<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="it-it" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">6d661cd0e37976c81cddea56d307ab47e322ef9d</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">ListView and GridView data virtualization</source>
          <target xml:space="preserve">ListView and GridView data virtualization</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="103">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="104">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://channel9.msdn.com/Events/Build/2013/3-158)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For more details, see the //build/ session <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView</pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For more details, see the //build/ session <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Dramatically Increase Performance when Users Interact with Large Amounts of Data in GridView and ListView</pc>.</target>
        </segment>
      </unit>
      <unit id="105">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242705)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Improve <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> performance and startup time through data virtualization.</source>
          <target xml:space="preserve">Improve <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc> performance and startup time through data virtualization.</target>
        </segment>
      </unit>
      <unit id="106">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](optimize-gridview-and-listview.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For UI virtualization, element reduction, and progressive updating of items, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView and GridView UI optimization</pc>.</source>
          <target xml:space="preserve">For UI virtualization, element reduction, and progressive updating of items, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView and GridView UI optimization</pc>.</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">A method of data virtualization is needed for a data set that is so large that it cannot or should not all be stored in memory at one time.</source>
          <target xml:space="preserve">A method of data virtualization is needed for a data set that is so large that it cannot or should not all be stored in memory at one time.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source xml:space="preserve">You load an initial portion into memory (from local disk, network, or cloud) and apply UI virtualization to this partial data set.</source>
          <target xml:space="preserve">You load an initial portion into memory (from local disk, network, or cloud) and apply UI virtualization to this partial data set.</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">You can later load data incrementally, or from arbitrary points in the master data set (random access), on demand.</source>
          <target xml:space="preserve">You can later load data incrementally, or from arbitrary points in the master data set (random access), on demand.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">Whether data virtualization is appropriate for you depends on many factors.</source>
          <target xml:space="preserve">Whether data virtualization is appropriate for you depends on many factors.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">The size of your data set</source>
          <target xml:space="preserve">The size of your data set</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">The size of each item</source>
          <target xml:space="preserve">The size of each item</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">The source of the data set (local disk, network, or cloud)</source>
          <target xml:space="preserve">The source of the data set (local disk, network, or cloud)</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">The overall memory consumption of your app</source>
          <target xml:space="preserve">The overall memory consumption of your app</target>
        </segment>
      </unit>
      <unit id="115">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Be aware that a feature is enabled by default for ListView and GridView that displays temporary placeholder visuals while the user is panning/scrolling quickly.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Be aware that a feature is enabled by default for ListView and GridView that displays temporary placeholder visuals while the user is panning/scrolling quickly.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">As data is loaded, these placeholder visuals are replaced with your item template.</source>
          <target xml:space="preserve">As data is loaded, these placeholder visuals are replaced with your item template.</target>
        </segment>
      </unit>
      <unit id="117">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878base-showsscrollingplaceholders)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can turn the feature off by setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewBase.ShowsScrollingPlaceholders</pc></pc> to false, but if you do so then we recommend that you use the x:Phase attribute to progressively render the elements in your item template.</source>
          <target xml:space="preserve">You can turn the feature off by setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListViewBase.ShowsScrollingPlaceholders</pc></pc> to false, but if you do so then we recommend that you use the x:Phase attribute to progressively render the elements in your item template.</target>
        </segment>
      </unit>
      <unit id="118">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](optimize-gridview-and-listview.md#update-items-incrementally)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Update ListView and GridView items progressively</pc>.</source>
          <target xml:space="preserve">See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Update ListView and GridView items progressively</pc>.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">Here are more details about the incremental and random-access data virtualization techniques.</source>
          <target xml:space="preserve">Here are more details about the incremental and random-access data virtualization techniques.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">Incremental data virtualization</source>
          <target xml:space="preserve">Incremental data virtualization</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">Incremental data virtualization loads data sequentially.</source>
          <target xml:space="preserve">Incremental data virtualization loads data sequentially.</target>
        </segment>
      </unit>
      <unit id="122">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> that uses incremental data virtualization may be used to view a collection of a million items, but only 50 items are loaded initially.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> that uses incremental data virtualization may be used to view a collection of a million items, but only 50 items are loaded initially.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">As the user pans/scrolls, the next 50 are loaded.</source>
          <target xml:space="preserve">As the user pans/scrolls, the next 50 are loaded.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">As items are loaded, the scroll bar's thumb decreases in size.</source>
          <target xml:space="preserve">As items are loaded, the scroll bar's thumb decreases in size.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">For this type of data virtualization you write a data source class that implements these interfaces.</source>
          <target xml:space="preserve">For this type of data virtualization you write a data source class that implements these interfaces.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source xml:space="preserve">IList</source>
          <target xml:space="preserve">IList</target>
        </segment>
      </unit>
      <unit id="127">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](T:System.Collections.Specialized.INotifyCollectionChanged)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR226052)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc>
						</pc> (C\#/VB) or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector&amp;lt;T&amp;gt;</pc></pc> (C++/CX)</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc>
						</pc> (C\#/VB) or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector&amp;lt;T&amp;gt;</pc></pc> (C++/CX)</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">ISupportIncrementalLoading</source>
          <target xml:space="preserve">ISupportIncrementalLoading</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source xml:space="preserve">A data source like this is an in-memory list that can be continually extended.</source>
          <target xml:space="preserve">A data source like this is an in-memory list that can be continually extended.</target>
        </segment>
      </unit>
      <unit id="130">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](T:System.Collections.IList)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The items control will ask for items using the standard <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IList</pc></pc> indexer and count properties.</source>
          <target xml:space="preserve">The items control will ask for items using the standard <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IList</pc></pc> indexer and count properties.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source xml:space="preserve">The count should represent the number of items locally, not the true size of the dataset.</source>
          <target xml:space="preserve">The count should represent the number of items locally, not the true size of the dataset.</target>
        </segment>
      </unit>
      <unit id="132">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh701916-hasmoreitems)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When the items control gets close to the end of the existing data, it will call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISupportIncrementalLoading.HasMoreItems</pc></pc>.</source>
          <target xml:space="preserve">When the items control gets close to the end of the existing data, it will call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISupportIncrementalLoading.HasMoreItems</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="133">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/Hh701916-loadmoreitemsasync)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc>, then it will call <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ISupportIncrementalLoading.LoadMoreItemsAsync</pc></pc> passing an advised number of items to load.</source>
          <target xml:space="preserve">If you return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc>, then it will call <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ISupportIncrementalLoading.LoadMoreItemsAsync</pc></pc> passing an advised number of items to load.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">Depending on where you're loading data from (local disk, network, or cloud), you may choose to load a different number of items than that advised.</source>
          <target xml:space="preserve">Depending on where you're loading data from (local disk, network, or cloud), you may choose to load a different number of items than that advised.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">For example, if your service supports batches of 50 items but the items control only asks for 10 then you can load 50.</source>
          <target xml:space="preserve">For example, if your service supports batches of 50 items but the items control only asks for 10 then you can load 50.</target>
        </segment>
      </unit>
      <unit id="136">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](T:System.Collections.Specialized.INotifyCollectionChanged)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR226052)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Load the data from your back end, add it to your list, and raise a change notification via <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector&amp;lt;T&amp;gt;</pc></pc> so that the items control knows about the new items.</source>
          <target xml:space="preserve">Load the data from your back end, add it to your list, and raise a change notification via <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector&amp;lt;T&amp;gt;</pc></pc> so that the items control knows about the new items.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">Also return a count of the items you actually loaded.</source>
          <target xml:space="preserve">Also return a count of the items you actually loaded.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source xml:space="preserve">If you load fewer items than advised, or the items control has been panned/scrolled even further in the interim, then your data source will be called again for more items and the cycle will continue.</source>
          <target xml:space="preserve">If you load fewer items than advised, or the items control has been panned/scrolled even further in the interim, then your data source will be called again for more items and the cycle will continue.</target>
        </segment>
      </unit>
      <unit id="139">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://code.msdn.microsoft.com/windowsapps/Data-Binding-7b1d67b5)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can learn more by downloading the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML data binding sample</pc> for Windows 8.1 and re-using its source code in your Windows 10 app.</source>
          <target xml:space="preserve">You can learn more by downloading the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML data binding sample</pc> for Windows 8.1 and re-using its source code in your Windows 10 app.</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source xml:space="preserve">Random access data virtualization</source>
          <target xml:space="preserve">Random access data virtualization</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">Random access data virtualization allows loading from an arbitrary point in the data set.</source>
          <target xml:space="preserve">Random access data virtualization allows loading from an arbitrary point in the data set.</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> that uses random access data virtualization, used to view a collection of a million items, can load the items 100,000 – 100,050.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> that uses random access data virtualization, used to view a collection of a million items, can load the items 100,000 – 100,050.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">If the user then moves to the beginning of the list, the control loads items 1 – 50.</source>
          <target xml:space="preserve">If the user then moves to the beginning of the list, the control loads items 1 – 50.</target>
        </segment>
      </unit>
      <unit id="144">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">At all times, the scroll bar's thumb indicates that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView</pc> contains a million items.</source>
          <target xml:space="preserve">At all times, the scroll bar's thumb indicates that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ListView</pc> contains a million items.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source xml:space="preserve">The position of the scroll bar's thumb is relative to where the visible items are located in the collection's entire data set.</source>
          <target xml:space="preserve">The position of the scroll bar's thumb is relative to where the visible items are located in the collection's entire data set.</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source xml:space="preserve">This type of data virtualization can significantly reduce the memory requirements and load times for the collection.</source>
          <target xml:space="preserve">This type of data virtualization can significantly reduce the memory requirements and load times for the collection.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source xml:space="preserve">To enable it you need to write a data source class that fetches data on demand and manages a local cache and implements these interfaces.</source>
          <target xml:space="preserve">To enable it you need to write a data source class that fetches data on demand and manages a local cache and implements these interfaces.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source xml:space="preserve">IList</source>
          <target xml:space="preserve">IList</target>
        </segment>
      </unit>
      <unit id="149">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](T:System.Collections.Specialized.INotifyCollectionChanged)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR226052)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc>
						</pc> (C\#/VB) or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector&amp;lt;T&amp;gt;</pc></pc> (C++/CX)</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc>
						</pc> (C\#/VB) or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector&amp;lt;T&amp;gt;</pc></pc> (C++/CX)</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877070)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">(Optionally) <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc></source>
          <target xml:space="preserve">(Optionally) <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc></target>
        </segment>
      </unit>
      <unit id="151">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877074)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">(Optionally) <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISelectionInfo</pc></pc></source>
          <target xml:space="preserve">(Optionally) <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ISelectionInfo</pc></pc></target>
        </segment>
      </unit>
      <unit id="152">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877070)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc>
						</pc> provides information on which items the control is actively using.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc>
						</pc> provides information on which items the control is actively using.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source xml:space="preserve">The items control will call this method whenever its view is changing, and will include these two sets of ranges.</source>
          <target xml:space="preserve">The items control will call this method whenever its view is changing, and will include these two sets of ranges.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">The set of items that are in the viewport.</source>
          <target xml:space="preserve">The set of items that are in the viewport.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">A set of non-virtualized items that the control is using that may not be in the viewport.</source>
          <target xml:space="preserve">A set of non-virtualized items that the control is using that may not be in the viewport.</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source xml:space="preserve">A buffer of items around the viewport that the items control keeps so that touch panning is smooth.</source>
          <target xml:space="preserve">A buffer of items around the viewport that the items control keeps so that touch panning is smooth.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source xml:space="preserve">The focused item.</source>
          <target xml:space="preserve">The focused item.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">The first item.</source>
          <target xml:space="preserve">The first item.</target>
        </segment>
      </unit>
      <unit id="159">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877070)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">By implementing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc> your data source knows what items need to be fetched and cached, and when to prune from the cache data that is no longer needed.</source>
          <target xml:space="preserve">By implementing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc> your data source knows what items need to be fetched and cached, and when to prune from the cache data that is no longer needed.</target>
        </segment>
      </unit>
      <unit id="160">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/Dn877081)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IItemsRangeInfo</pc> uses <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ItemIndexRange</pc></pc> objects to describe a set of items based on their index in the collection.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IItemsRangeInfo</pc> uses <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ItemIndexRange</pc></pc> objects to describe a set of items based on their index in the collection.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source xml:space="preserve">This is so that it doesn't use item pointers, which may not be correct or stable.</source>
          <target xml:space="preserve">This is so that it doesn't use item pointers, which may not be correct or stable.</target>
        </segment>
      </unit>
      <unit id="162">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IItemsRangeInfo</pc> is designed to be used by only a single instance of an items control because it relies on state information for that items control.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IItemsRangeInfo</pc> is designed to be used by only a single instance of an items control because it relies on state information for that items control.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source xml:space="preserve">If multiple items controls need access to the same data then you will need a separate instance of the data source for each.</source>
          <target xml:space="preserve">If multiple items controls need access to the same data then you will need a separate instance of the data source for each.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source xml:space="preserve">They can share a common cache, but the logic to purge from the cache will be more complicated.</source>
          <target xml:space="preserve">They can share a common cache, but the logic to purge from the cache will be more complicated.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">Here's the basic strategy for your random access data virtualization data source.</source>
          <target xml:space="preserve">Here's the basic strategy for your random access data virtualization data source.</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source xml:space="preserve">When asked for an item</source>
          <target xml:space="preserve">When asked for an item</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source xml:space="preserve">If you have it available in memory, then return it.</source>
          <target xml:space="preserve">If you have it available in memory, then return it.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source xml:space="preserve">If you don’t have it, then return either null or a placeholder item.</source>
          <target xml:space="preserve">If you don’t have it, then return either null or a placeholder item.</target>
        </segment>
      </unit>
      <unit id="169">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877070)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Use the request for an item (or the range information from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc>) to know which items are needed, and to fetch data for items from your back end asynchronously.</source>
          <target xml:space="preserve">Use the request for an item (or the range information from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc>) to know which items are needed, and to fetch data for items from your back end asynchronously.</target>
        </segment>
      </unit>
      <unit id="170">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](T:System.Collections.Specialized.INotifyCollectionChanged)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR226052)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">After retrieving the data, raise a change notification via <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector&amp;lt;T&amp;gt;</pc></pc> so that the items control knows about the new item.</source>
          <target xml:space="preserve">After retrieving the data, raise a change notification via <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">INotifyCollectionChanged</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IObservableVector&amp;lt;T&amp;gt;</pc></pc> so that the items control knows about the new item.</target>
        </segment>
      </unit>
      <unit id="171">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Dn877070)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">(Optionally) as the items control's viewport changes, identify what items are needed from your data source via your implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc>.</source>
          <target xml:space="preserve">(Optionally) as the items control's viewport changes, identify what items are needed from your data source via your implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IItemsRangeInfo</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">Beyond that, the strategy for when to load data items, how many to load, and which items to keep in memory is up to your application.</source>
          <target xml:space="preserve">Beyond that, the strategy for when to load data items, how many to load, and which items to keep in memory is up to your application.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source xml:space="preserve">Some general considerations to keep in mind:</source>
          <target xml:space="preserve">Some general considerations to keep in mind:</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source xml:space="preserve">Make asynchronous requests for data; don't block the UI thread.</source>
          <target xml:space="preserve">Make asynchronous requests for data; don't block the UI thread.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">Find the sweet spot in the size of the batches you fetch items in.</source>
          <target xml:space="preserve">Find the sweet spot in the size of the batches you fetch items in.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source xml:space="preserve">Prefer chunky to chatty.</source>
          <target xml:space="preserve">Prefer chunky to chatty.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source xml:space="preserve">Not so small that you make too many small requests; not too large that they take too long to retrieve.</source>
          <target xml:space="preserve">Not so small that you make too many small requests; not too large that they take too long to retrieve.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source xml:space="preserve">Consider how many requests you want to have pending at the same time.</source>
          <target xml:space="preserve">Consider how many requests you want to have pending at the same time.</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source xml:space="preserve">Performing one at a time is easier, but it may be too slow if turnaround time is high.</source>
          <target xml:space="preserve">Performing one at a time is easier, but it may be too slow if turnaround time is high.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source xml:space="preserve">Can you cancel requests for data?</source>
          <target xml:space="preserve">Can you cancel requests for data?</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">If using a hosted service, is there a cost per transaction?</source>
          <target xml:space="preserve">If using a hosted service, is there a cost per transaction?</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source xml:space="preserve">What kind of notifications are provided by the service when the results of a query are changed?</source>
          <target xml:space="preserve">What kind of notifications are provided by the service when the results of a query are changed?</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source xml:space="preserve">Will you know if an item is inserted at index 33?</source>
          <target xml:space="preserve">Will you know if an item is inserted at index 33?</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source xml:space="preserve">If your service supports queries based on a key-plus-offset, that may be better than just using an index.</source>
          <target xml:space="preserve">If your service supports queries based on a key-plus-offset, that may be better than just using an index.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source xml:space="preserve">How smart do you want to be in pre-fetching items?</source>
          <target xml:space="preserve">How smart do you want to be in pre-fetching items?</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">Are you going to try and track the direction and velocity of scrolling to predict which items are needed?</source>
          <target xml:space="preserve">Are you going to try and track the direction and velocity of scrolling to predict which items are needed?</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source xml:space="preserve">How aggressive do you want to be in purging the cache?</source>
          <target xml:space="preserve">How aggressive do you want to be in purging the cache?</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source xml:space="preserve">This is a tradeoff of memory versus experience.</source>
          <target xml:space="preserve">This is a tradeoff of memory versus experience.</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>