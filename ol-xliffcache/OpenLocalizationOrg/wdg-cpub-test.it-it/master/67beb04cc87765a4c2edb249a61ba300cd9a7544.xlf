<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="it-it" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">67beb04cc87765a4c2edb249a61ba300cd9a7544</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">description: A XAML namescope stores relationships between the XAML-defined names of objects and their instance equivalents.</source>
          <target xml:space="preserve">description: A XAML namescope stores relationships between the XAML-defined names of objects and their instance equivalents.</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">This concept is similar to the wider meaning of the term namescope in other programming languages and technologies.</source>
          <target xml:space="preserve">This concept is similar to the wider meaning of the term namescope in other programming languages and technologies.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">title: XAML namescopes</source>
          <target xml:space="preserve">title: XAML namescopes</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: EB060CBD-A589-475E-B83D-B24068B54C21</source>
          <target xml:space="preserve">ms.assetid: EB060CBD-A589-475E-B83D-B24068B54C21</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">XAML namescopes</source>
          <target xml:space="preserve">XAML namescopes</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="107">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namescope</pc> stores relationships between the XAML-defined names of objects and their instance equivalents.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namescope</pc> stores relationships between the XAML-defined names of objects and their instance equivalents.</target>
        </segment>
      </unit>
      <unit id="109">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This concept is similar to the wider meaning of the term <pc dataRefEnd="id2" dataRefStart="id1" id="p1">namescope</pc> in other programming languages and technologies.</source>
          <target xml:space="preserve">This concept is similar to the wider meaning of the term <pc dataRefEnd="id2" dataRefStart="id1" id="p1">namescope</pc> in other programming languages and technologies.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">How XAML namescopes are defined</source>
          <target xml:space="preserve">How XAML namescopes are defined</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">Names in XAML namescopes enable user code to reference the objects that were initially declared in XAML.</source>
          <target xml:space="preserve">Names in XAML namescopes enable user code to reference the objects that were initially declared in XAML.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations.</source>
          <target xml:space="preserve">The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.</source>
          <target xml:space="preserve">These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.</target>
        </segment>
      </unit>
      <unit id="114">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> method in the partial class templates.</source>
          <target xml:space="preserve">The most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> method in the partial class templates.</target>
        </segment>
      </unit>
      <unit id="115">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can also use the utility method <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> yourself at run time to return a reference to objects that were defined with a name in the XAML markup.</source>
          <target xml:space="preserve">You can also use the utility method <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> yourself at run time to return a reference to objects that were defined with a name in the XAML markup.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">More about build actions and XAML</source>
          <target xml:space="preserve">More about build actions and XAML</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">What happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together.</source>
          <target xml:space="preserve">What happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together.</target>
        </segment>
      </unit>
      <unit id="118">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](x-name-attribute.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Each object element with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Name attribute</pc> defined in the markup generates an internal field with a name that matches the XAML name.</source>
          <target xml:space="preserve">Each object element with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Name attribute</pc> defined in the markup generates an internal field with a name that matches the XAML name.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">This field is initially empty.</source>
          <target xml:space="preserve">This field is initially empty.</target>
        </segment>
      </unit>
      <unit id="120">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Then the class generates an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> method that is called only after all the XAML is loaded.</source>
          <target xml:space="preserve">Then the class generates an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> method that is called only after all the XAML is loaded.</target>
        </segment>
      </unit>
      <unit id="121">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> logic, each internal field is then populated with the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FindName</pc></pc> return value for the equivalent name string.</source>
          <target xml:space="preserve">Within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> logic, each internal field is then populated with the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FindName</pc></pc> return value for the equivalent name string.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">You can observe this infrastructure for yourself by looking at the ".g" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation.</source>
          <target xml:space="preserve">You can observe this infrastructure for yourself by looking at the ".g" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation.</target>
        </segment>
      </unit>
      <unit id="123">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can also see the fields and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.</source>
          <target xml:space="preserve">You can also see the fields and <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InitializeComponent</pc> method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.</target>
        </segment>
      </unit>
      <unit id="124">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Specifically for Visual C++ component extensions (C++/CX) apps, a backing field for an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Name</pc> reference is not created for the root element of a XAML file.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Specifically for Visual C++ component extensions (C++/CX) apps, a backing field for an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Name</pc> reference is not created for the root element of a XAML file.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal.</source>
          <target xml:space="preserve">If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal.</target>
        </segment>
      </unit>
      <unit id="126">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208739)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example you can call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> for a known named child element and then call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Parent</pc></pc>.</source>
          <target xml:space="preserve">For example you can call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> for a known named child element and then call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Parent</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source xml:space="preserve">Creating objects at run time with XamlReader.Load</source>
          <target xml:space="preserve">Creating objects at run time with XamlReader.Load</target>
        </segment>
      </unit>
      <unit id="128">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228048)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">XAML can be also be used as the string input for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlReader.Load</pc></pc> method, which acts analogously to the initial XAML source parse operation.</source>
          <target xml:space="preserve">XAML can be also be used as the string input for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlReader.Load</pc></pc> method, which acts analogously to the initial XAML source parse operation.</target>
        </segment>
      </unit>
      <unit id="129">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> creates a new disconnected tree of objects at run time.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> creates a new disconnected tree of objects at run time.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source xml:space="preserve">The disconnected tree can then be attached to some point on the main object tree.</source>
          <target xml:space="preserve">The disconnected tree can then be attached to some point on the main object tree.</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br210101)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br243378)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You must explicitly connect your created object tree, either by adding it to a content property collection such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Children</pc>, or by setting some other property that takes an object value (for example, loading a new <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ImageBrush</pc></pc> for a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Fill</pc></pc> property value).</source>
          <target xml:space="preserve">You must explicitly connect your created object tree, either by adding it to a content property collection such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Children</pc>, or by setting some other property that takes an object value (for example, loading a new <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ImageBrush</pc></pc> for a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Fill</pc></pc> property value).</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source xml:space="preserve">XAML namescope implications of XamlReader.Load</source>
          <target xml:space="preserve">XAML namescope implications of XamlReader.Load</target>
        </segment>
      </unit>
      <unit id="133">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228048)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The preliminary XAML namescope defined by the new object tree created by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlReader.Load</pc></pc> evaluates any defined names in the provided XAML for uniqueness.</source>
          <target xml:space="preserve">The preliminary XAML namescope defined by the new object tree created by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlReader.Load</pc></pc> evaluates any defined names in the provided XAML for uniqueness.</target>
        </segment>
      </unit>
      <unit id="134">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If names in the provided XAML are not internally unique at this point, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> throws an exception.</source>
          <target xml:space="preserve">If names in the provided XAML are not internally unique at this point, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> throws an exception.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree.</source>
          <target xml:space="preserve">The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source xml:space="preserve">After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it.</source>
          <target xml:space="preserve">After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it.</target>
        </segment>
      </unit>
      <unit id="137">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The divisions occur at the connection points between objects, where you set some property to be the value returned from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> call.</source>
          <target xml:space="preserve">The divisions occur at the connection points between objects, where you set some property to be the value returned from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlReader.Load</pc> call.</target>
        </segment>
      </unit>
      <unit id="138">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The complication of having discrete and disconnected XAML namescopes is that calls to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> method as well as direct managed object references no longer operate against a unified XAML namescope.</source>
          <target xml:space="preserve">The complication of having discrete and disconnected XAML namescopes is that calls to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> method as well as direct managed object references no longer operate against a unified XAML namescope.</target>
        </segment>
      </unit>
      <unit id="139">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Instead, the particular object that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FindName</pc> is called on implies the scope, with the scope being the XAML namescope that the calling object is within.</source>
          <target xml:space="preserve">Instead, the particular object that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FindName</pc> is called on implies the scope, with the scope being the XAML namescope that the calling object is within.</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source xml:space="preserve">In the direct managed object reference case, the scope is implied by the class where the code exists.</source>
          <target xml:space="preserve">In the direct managed object reference case, the scope is implied by the class where the code exists.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">Typically, the code-behind for run-time interaction of a "page" of app content exists in the partial class that backs the root "page", and therefore the XAML namescope is the root XAML namescope.</source>
          <target xml:space="preserve">Typically, the code-behind for run-time interaction of a "page" of app content exists in the partial class that backs the root "page", and therefore the XAML namescope is the root XAML namescope.</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br228048)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">XamlReader.Load</pc></pc>.</source>
          <target xml:space="preserve">If you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">XamlReader.Load</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="143">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Conversely, if you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FindName</pc> from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.</source>
          <target xml:space="preserve">Conversely, if you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FindName</pc> from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.</target>
        </segment>
      </unit>
      <unit id="144">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> call.</source>
          <target xml:space="preserve">This discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> call.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source xml:space="preserve">To get references to objects that are defined in a different XAML namescope, you can use several techniques:</source>
          <target xml:space="preserve">To get references to objects that are defined in a different XAML namescope, you can use several techniques:</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208739)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227514)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Walk the entire tree in discrete steps with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Parent</pc></pc> and/or collection properties that are known to exist in your object tree structure (such as the collection returned by <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Panel.Children</pc></pc>).</source>
          <target xml:space="preserve">Walk the entire tree in discrete steps with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Parent</pc></pc> and/or collection properties that are known to exist in your object tree structure (such as the collection returned by <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Panel.Children</pc></pc>).</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source xml:space="preserve">If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed.</source>
          <target xml:space="preserve">If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed.</target>
        </segment>
      </unit>
      <unit id="148">
        <originalData>
          <data id="id1">`Window.Current.Content`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call <ph dataRef="id1" id="ph1" />.</source>
          <target xml:space="preserve">You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call <ph dataRef="id1" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="149">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208706)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can then cast to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc> and call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FindName</pc></pc> from this scope.</source>
          <target xml:space="preserve">You can then cast to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement</pc></pc> and call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FindName</pc></pc> from this scope.</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br228048)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlReader.Load</pc></pc> and then added to the main object tree.</source>
          <target xml:space="preserve">If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlReader.Load</pc></pc> and then added to the main object tree.</target>
        </segment>
      </unit>
      <unit id="151">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This object is now a valid object for calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> within the discrete XAML namescope.</source>
          <target xml:space="preserve">This object is now a valid object for calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> within the discrete XAML namescope.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source xml:space="preserve">You could keep this object available as a global variable or otherwise pass it by using method parameters.</source>
          <target xml:space="preserve">You could keep this object available as a global variable or otherwise pass it by using method parameters.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source xml:space="preserve">You can avoid names and XAML namescope considerations entirely by examining the visual tree.</source>
          <target xml:space="preserve">You can avoid names and XAML namescope considerations entirely by examining the visual tree.</target>
        </segment>
      </unit>
      <unit id="154">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br243038)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualTreeHelper</pc></pc> API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualTreeHelper</pc></pc> API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">XAML namescopes in templates</source>
          <target xml:space="preserve">XAML namescopes in templates</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source xml:space="preserve">Templates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level.</source>
          <target xml:space="preserve">Templates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source xml:space="preserve">That same template might be used multiple times in a page.</source>
          <target xml:space="preserve">That same template might be used multiple times in a page.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied.</source>
          <target xml:space="preserve">For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source xml:space="preserve">Consider this example:</source>
          <target xml:space="preserve">Consider this example:</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source xml:space="preserve">Here, the same template is applied to two different controls.</source>
          <target xml:space="preserve">Here, the same template is applied to two different controls.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source xml:space="preserve">If templates did not have discrete XAML namescopes, the "MyTextBlock" name used in the template would cause a name collision.</source>
          <target xml:space="preserve">If templates did not have discrete XAML namescopes, the "MyTextBlock" name used in the template would cause a name collision.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</source>
          <target xml:space="preserve">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source xml:space="preserve">However, the root XAML namescope does not contain the name from either template.</source>
          <target xml:space="preserve">However, the root XAML namescope does not contain the name from either template.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source xml:space="preserve">Because of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique.</source>
          <target xml:space="preserve">Because of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique.</target>
        </segment>
      </unit>
      <unit id="165">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208715)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209416)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Rather than calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> on some object in the object tree, you first obtain the object that has the template applied, and then call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetTemplateChild</pc></pc>.</source>
          <target xml:space="preserve">Rather than calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FindName</pc></pc> on some object in the object tree, you first obtain the object that has the template applied, and then call <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetTemplateChild</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="166">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetTemplateChild</pc> method from your control implementation code.</source>
          <target xml:space="preserve">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetTemplateChild</pc> method from your control implementation code.</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetTemplateChild</pc> method is protected, so only the control author has access to it.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetTemplateChild</pc> method is protected, so only the control author has access to it.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source xml:space="preserve">Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class.</source>
          <target xml:space="preserve">Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source xml:space="preserve">This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.</source>
          <target xml:space="preserve">This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source xml:space="preserve">Related topics</source>
          <target xml:space="preserve">Related topics</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source xml:space="preserve">XAML overview</source>
          <target xml:space="preserve">XAML overview</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">x:Name attribute</source>
          <target xml:space="preserve">x:Name attribute</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source xml:space="preserve">Quickstart: Control templates</source>
          <target xml:space="preserve">Quickstart: Control templates</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source xml:space="preserve">XamlReader.Load</source>
          <target xml:space="preserve">XamlReader.Load</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">FindName</source>
          <target xml:space="preserve">FindName</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>