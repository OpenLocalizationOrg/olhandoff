ms입니다. ContentId: 4981828d-1a08-4d8c-a99d-874a926a153f
제목: PowerShell을 Docker 비교

#PowerShell을 Windows 서버 컨테이너를 관리 하기 위한 Docker 비교

테스트를 ver2 27-년 10 월에 콘텐츠를 업데이트 합니다.
다양 한 방법으로 Windows 서버 컨테이너 (이 미리 보기 PowerShell) 상자에 Windows 도구와 Docker와 같은 공개 소스 관리 도구를 사용 하 여 관리할 수 있습니다.
안내선을 여기 모두 개별적으로 사용할 수 있는 개요:
* [Docker와 Windows Server 컨테이너 관리](../quick_start/manage_docker.md)
* [PowerShell 사용한 Windows Server 컨테이너 관리](../quick_start/manage_powershell.md)

이 페이지는 Docker 도구 및 PowerShell 관리 도구 비교 깊이 참조에 더 합니다.

##Hyper-v Vm과 컨테이너에 대 한 PowerShell

만들 지정, 실행 및 PowerShell cmdlet을 사용 하 여 Windows Server 컨테이너와 상호작용 합니다.
적용 하기 위해 필요한 모든 것이 상자에서 사용할 수 있습니다.

Hyper-v PowerShell을 사용한 경우에 cmdlet의 디자인에 알아 있어야 합니다.
워크플로의 많은 Hyper-v 모듈을 사용 하 여 가상 컴퓨터를 관리할 것 어떻게 하는 것과 비슷합니다.
대신 `NEW-VM`, `Get VM`, `시작 VM`, `STOP-VM`, 해야 `새 컨테이너`, `Get 컨테이너`, `시작 컨테이너`, `중지 컨테이너`.
다음과 같이 몇가지 컨테이너 관련 cmdlet 및 매개 변수를 있지만 일반적인 수명 주기 및 Windows 컨테이너의 관리는 다음과 유사 하는 Hyper-v VM.

##Docker에 PowerShell 관리 비교 하는 방법

컨테이너 PowerShell cmdlet은 상당히와 다르므로 Docker; 하는 API를 노출 합니다. 일반적으로 cmdlet은 작업에서 더 세분화 됩니다.
일부 Docker 명령은 PowerShell에서 명료한 평행선을가지고 있습니다.

| Docker 명령| PowerShell Cmdlet|
|----|----|
| `docker ps-a`| `Get 컨테이너`|
| `docker 이미지`| `Get ContainerImage`|
| `docker rm`| `컨테이너 제거`|
| `docker rmi`| `ContainerImage 제거`|
| `docker 만들기`| `새 컨테이너`|
| `docker 커밋 < 컨테이너 ID >`| `새 ContainerImage-< 컨테이너 > 컨테이너`|
| `docker 부하 < tarball >`| `가져오기-ContainerImage < AppX 패키지 >`|
| `docker 저장`| `내보내기 ContainerImage`|
| `docker 시작`| `시작 컨테이너`|
| `docker 중지`| `중지 컨테이너`|
PowerShell cmdlet는 정확 하 게 완벽 한 패리티 없는 되며 공정 하 게 우리가 하지에 대 한 PowerShell 대체를 제공 하는 명령 수 * (특히 `docker 빌드` 및 `docker cp`).
에 대 한 단일 한 줄짜리 바뀌지 않고 있다는 것은 어떤 수 ø ī ° 하지만 `실행 docker`.

\ * 변경 될 수 있습니다.

###Docker 필요 하지만 실행! 무슨 일?

우리가 하 고 있는 몇 여기 자신의 둘러보면 PowerShell 이미 알고 있는 사용자에 대 한 약간 더 친숙 한 상호작용 모델을 제공할 수 있습니다.
물론, docker 작동 하는 방식에 사용 하는 경우 약간의 세밀 한 전환 됩니다.

1.  PowerShell 모델에서 컨테이너의 수명 주기는 약간 다릅니다.
   컨테이너 PowerShell 모듈을 보다 세부적으로 작업을 노출할 `새 컨테이너` (중지 된 새 컨테이너를 만드는) 및 `시작 컨테이너`.
   
   사이 만들고 컨테이너를 시작 하면 구성할 수도 있습니다 컨테이너의 설정입니다. TP3는 다른 구성만 노출 하도록 계획은 컨테이너에 대 한 네트워크 연결을 설정 하는 기능입니다.
   (추가/제거/연결/연결 끊기/Get/Set)를 사용 하 여-ContainerNetworkAdapter cmdlet.
   
2.  현재는 시작 시에 컨테이너 내에서 실행 될 명령을 전달할 수 없습니다. 그러나 대화형 PowerShell 세션을 사용 하 여 실행 중인 컨테이너를 여전히 가져올 수 `Enter-pssession-ContainerId <는 실행 중인 컨테이너의 ID >`, 명령을 사용 하 여 실행 중인 컨테이너 안에 실행할 수 `Invoke-command-ContainerId < 컨테이너 id >-ScriptBlock {컨테이너 내에서 실행 되도록 코드}` 또는 `Invoke-command-ContainerId < 컨테이너 id >-FilePath < 스크립트에 대 한 경로 >`.  
이러한 명령은 모두 허용 선택적 `-RunAsAdministrator` 높은 privilige 작업에 대 한 플래그입니다.


##주의 사항 및 알려진된 문제

1.  지금 하 고 컨테이너 cmdlet은 모든 컨테이너 또는 Docker를 통해 만든 이미지에 대 한 지식이 없는 Docker 하지 않는 모든 컨테이너 및 PowerShell을 통해 만든 이미지에 대 한 합니다.
   Docker에서 만든 경우 관리에 Docker; PowerShell을 통해 만든 경우 PowerShell을 통해 관리 합니다.
   
2.  아주 약간의 작업이 더 나은 오류 메시지, 더 나은 진행률 보고, 잘못 된 이벤트 문자열 등-최종 사용자 환경을 개선 하기 위해 수행 하고자 했습니다.
   에 부 딪 혔 자세한 받는지를 모두 시겠습니까 있다면 또는 향상 된 정보, 의견이 있으시면 포럼에 보냅니다.

##빠른 runthrough

일부 일반적인 작업 과정의 과정을 따라 하면서 다음과 같습니다.

이 "ServerDatacenterCore" 라는 OS 컨테이너 이미지를 설치 하 고 "가상 스위치" (New-vmswitch 사용) 라는 가상 스위치를 생성 한 가정 합니다.

``` PowerShell
### 1. Enumerating images
# At this point, you can enumerate the images on the system:
Get-ContainerImage

# Get-ContainerImage also accepts filters.
# For example, this will return all container images whose Name starts with S (case-insensitive):
Get-ContainerImage -Name S*

# You can save the results of this to a variable.
# (If you're not familiar with PowerShell, the "$" denotes a variable.)
$baseImage = Get-ContainerImage -Name ServerDatacenterCore
$baseImage

### 2. Creating and enumerating containers
# Now, we can create a new container using this image:
New-Container -Name "MyContainer" -ContainerImage $baseImage -SwitchName "Virtual Switch"

# Now we can enumerate all containers.
Get-Container

# Similarly, we can save this container to a variable:
$container1 = Get-Container -Name "MyContainer"

### 3. Starting containers, interacting with running containers, and stopping containers
# Now let's go ahead and start the container.
Start-Container -Name "MyContainer"

# (We could've also started this container using "Start-Container -Container $container1".)

# With the container now running, let's go ahead and enter an interactive PowerShell session:
Enter-PSSession -ContainerId $container1.Id

# This should eventually bring up a PowerShell prompt from inside the container.
# You can try all the things that you did in the interactive cmd prompt given by "docker run -it".
# For now, just to prove we've been here, we can create a new file:
cd \
mkdir Test
cd Test
echo "hello world" > hello.txt
exit

# Now we should be back in the outside world. Even though we've exited the PowerShell session,
# the container itself is still running, as you can see by printing out the container again:
$container1

# Before we can commit this container to a new image, we need to stop the container.
# Let's do that now.
Stop-Container -Container $container1

### 4. Creating a new container image
# And now let's commit it to a new image.
$image1 = New-ContainerImage -Container $container1 -Publisher Test -Name Image1 -Version 1.0

# Enumerate all the images again, for sanity's sake:
Get-ContainerImage

# Rinse and repeat! Make another container based on the new image.
$container2 = New-Container -Name "MySecondContainer" -ContainerImage $image1 -SwitchName "Virtual Switch"

# (If you like, you can start the second container and verify that the new file
# "\Test\hello.txt" is there as expected.)

### 5. Removing a container
# The first container we created is now stopped. Let's get rid of it:
Remove-Container -Container $container1

# And confirm that it's gone:
Get-Container

### 6. Exporting, removing, and importing images
# For images that aren't the base OS image, we can export them into an .appx package file.
Export-ContainerImage -Image $image1 -Path "C:\exports"
# This should create a .appx file in the C:\exports folder.
# If you've given your image the same publisher, name, and version we used earlier,
# you'd expect the resulting .appx to be named "CN=Test_Image1_1.0.0.0.appx".

# Before we can try importing the image again, we need to remove the image.
# (If you have any running containers that depend on this image, you'll want to stop them first.)
Remove-ContainerImage -Image $image1

# Now let's import the image again:
Import-ContainerImage -Path C:\exports\CN=Test_Image1_1.0.0.0.appx

# We'd previously created a container dependent on this image. You should be able to start it:
Start-Container -Container $container2 
```

###사용자 고유의 샘플 빌드

모든 컨테이너 사용 되는 cmdlet을 볼 수 있습니다 `Get-command-모듈 컨테이너`.
여러 다른 cmdlet, 여기에 설명 되지 않은 여러분 스스로 대 한 자세한에 남겨둘 수 있습니다.
**참고** 이 반환 되지 않습니다는 `Enter-pssession` 및 `Invoke-command` 핵심 PowerShell의 구성 요소인 cmdlet.

사용 하 여 모든 cmdlet에 대 한 도움을 받을 수도 있습니다 `Get-help [cmdlet 이름]`, 또는 동등 하 게 `[cmdlet 이름]-?`.
오늘날에 도움말 출력이 자동으로 생성 요약 하 고 방금 명령;에 대 한 구문 추가 될 예정임 추가로 설명서 cmdlet 설계를 완료 하는 중에 더 가까운 얻게으로 합니다.

더 멋진 구문을 검색 방법은 PowerShell ISE 수 하지는에서 살펴본 하기 전에 대단히 PowerShell을 사용 하지 않은 경우입니다.
허용 하는 SKU를 실행 하는 경우 명령 창을 열고 cmdlet 및 해당 매개 변수 집합을 그래픽으로 표시 됩니다 "컨테이너" 모듈을 선택 하는 ISE를 시작 하십시오.

PS: 방금를 증명 하기 위해 수행할 수 있습니다, 여기서는 PowerShell 함수는 ersatz에 이미 살펴봤습니다 cmdlet 중 일부를 작성 하는 `실행 docker`.
(명확 하 게,이 현재 개발 중인 하지의 개념 증명 합니다.)

``` PowerShell
function Run-Container ([string]$ContainerImageName, [string]$Name="fancy_name", [switch]$Remove, [switch]$Interactive, [scriptblock]$Command) {
    $image = Get-ContainerImage -Name $ContainerImageName
    $container = New-Container -Name $Name -ContainerImage $image
    Start-Container $container

    if ($Interactive) {
         Start-Process powershell ("-NoExit", "-c", "Enter-PSSession -ContainerId $($container.Id)") -Wait
    } else {
        Invoke-Command -ContainerId $container.Id -ScriptBlock $Command
    }

    Stop-Container $container

    if ($Remove) {
        Remove-Container $container -Force
    }
} 
```

##Docker

Windows Server 컨테이너 Docker 명령을 사용 하 여 관리할 수 있습니다.
컨테이너 해야 Linux 상응 하는 비교할 수 있고 동일한 관리 Windows Docker 통해을 발생 하는 동안 단순히 필요 하지 않은 Windows 컨테이너와 일부 Docker 명령이 있습니다.
다른 사람이 단순히 하지 않은 테스트를 거쳤습니다 (우리 보시기 있습니다).

Docker에서 제공 되는 API 설명서를 복제 하지 하기 위한 노력을 자신의 관리 Api에 대 한 링크 다음과 같습니다.
해당 연습 환상적인 됩니다.

우리는 진행 중인 작업에 문서에 Docker Api에서 작동 하지 않는 것 관리할 수 있습니다.




