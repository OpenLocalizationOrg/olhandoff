<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci1\xaml-platform\custom-attached-properties.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4433307ce4ea0a0e9f43328bfab0c594e4bbad0d</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Explains how to implement a XAML attached property as a dependency property and how to define the accessor convention that is necessary for your attached property to be usable in XAML.</source>
          <target state="new">Explains how to implement a XAML attached property as a dependency property and how to define the accessor convention that is necessary for your attached property to be usable in XAML.</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Custom attached properties</source>
          <target state="new">Custom attached properties</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Custom attached properties</source>
          <target state="new">Custom attached properties</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>An <bpt id="p1">*</bpt>attached property<ept id="p1">*</ept> is a XAML concept.</source>
          <target state="new">An <bpt id="p1">*</bpt>attached property<ept id="p1">*</ept> is a XAML concept.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Attached properties are typically defined as a specialized form of dependency property.</source>
          <target state="new">Attached properties are typically defined as a specialized form of dependency property.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This topic explains how to implement an attached property as a dependency property and how to define the accessor convention that is necessary for your attached property to be usable in XAML.</source>
          <target state="new">This topic explains how to implement an attached property as a dependency property and how to define the accessor convention that is necessary for your attached property to be usable in XAML.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="new">Prerequisites</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>We assume that you understand dependency properties from the perspective of a consumer of existing dependency properties, and that you have read the <bpt id="p1">[</bpt>Dependency properties overview<ept id="p1">](dependency-properties-overview.md)</ept>.</source>
          <target state="new">We assume that you understand dependency properties from the perspective of a consumer of existing dependency properties, and that you have read the <bpt id="p1">[</bpt>Dependency properties overview<ept id="p1">](dependency-properties-overview.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>You should also have read <bpt id="p1">[</bpt>Attached properties overview<ept id="p1">](attached-properties-overview.md)</ept>.</source>
          <target state="new">You should also have read <bpt id="p1">[</bpt>Attached properties overview<ept id="p1">](attached-properties-overview.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C#, or Visual Basic.</source>
          <target state="new">To follow the examples in this topic, you should also understand XAML and know how to write a basic Windows Runtime app using C++, C#, or Visual Basic.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Scenarios for attached properties</source>
          <target state="new">Scenarios for attached properties</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You might create an attached property when there is a reason to have a property-setting mechanism available for classes other than the defining class.</source>
          <target state="new">You might create an attached property when there is a reason to have a property-setting mechanism available for classes other than the defining class.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The most common scenarios for this are layout and services support.</source>
          <target state="new">The most common scenarios for this are layout and services support.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Examples of existing layout properties are <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas.ZIndex<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh759773)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Canvas.Top<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh759772)</ept>.</source>
          <target state="new">Examples of existing layout properties are <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas.ZIndex<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh759773)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Canvas.Top<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh759772)</ept>.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>In a layout scenario, elements that exist as child elements to layout-controlling elements can express layout requirements to their parent elements individually, each setting a property value that the parent defines as an attached property.</source>
          <target state="new">In a layout scenario, elements that exist as child elements to layout-controlling elements can express layout requirements to their parent elements individually, each setting a property value that the parent defines as an attached property.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>An example of the services-support scenario in the Windows Runtime API is set of the attached properties of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ScrollViewer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209527)</ept>, such as <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ScrollViewer.IsZoomChainingEnabled<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209561)</ept>.</source>
          <target state="new">An example of the services-support scenario in the Windows Runtime API is set of the attached properties of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ScrollViewer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209527)</ept>, such as <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ScrollViewer.IsZoomChainingEnabled<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209561)</ept>.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Caution<ept id="p1">**</ept>  An existing limitation of the Windows Runtime XAML implementation is that you cannot animate your custom attached property.</source>
          <target state="new"><bpt id="p1">**</bpt>Caution<ept id="p1">**</ept>  An existing limitation of the Windows Runtime XAML implementation is that you cannot animate your custom attached property.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Registering a custom attached property</source>
          <target state="new">Registering a custom attached property</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>If you are defining the attached property strictly for use on other types, the class where the property is registered does not have to derive from <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DependencyObject<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>.</source>
          <target state="new">If you are defining the attached property strictly for use on other types, the class where the property is registered does not have to derive from <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DependencyObject<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>But you do need to have the target parameter for accessors use <bpt id="p1">**</bpt>DependencyObject<ept id="p1">**</ept> if you follow the typical model of having your attached property also be a dependency property, so that you can use the backing property store.</source>
          <target state="new">But you do need to have the target parameter for accessors use <bpt id="p1">**</bpt>DependencyObject<ept id="p1">**</ept> if you follow the typical model of having your attached property also be a dependency property, so that you can use the backing property store.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Define your attached property as a dependency property by declaring a <bpt id="p1">**</bpt>public<ept id="p1">**</ept> <bpt id="p2">**</bpt>static<ept id="p2">**</ept> <bpt id="p3">**</bpt>readonly<ept id="p3">**</ept> property of type <bpt id="p4">[</bpt><bpt id="p5">**</bpt>DependencyProperty<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept>.</source>
          <target state="new">Define your attached property as a dependency property by declaring a <bpt id="p1">**</bpt>public<ept id="p1">**</ept> <bpt id="p2">**</bpt>static<ept id="p2">**</ept> <bpt id="p3">**</bpt>readonly<ept id="p3">**</ept> property of type <bpt id="p4">[</bpt><bpt id="p5">**</bpt>DependencyProperty<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br242362)</ept>.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>You define this property by using the return value of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>RegisterAttached<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh701833)</ept> method.</source>
          <target state="new">You define this property by using the return value of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>RegisterAttached<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh701833)</ept> method.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The property name must match the attached property name you specify as the <bpt id="p1">**</bpt>RegisterAttached<ept id="p1">**</ept> <bpt id="p2">*</bpt>name<ept id="p2">*</ept> parameter, with the string "Property" added to the end.</source>
          <target state="new">The property name must match the attached property name you specify as the <bpt id="p1">**</bpt>RegisterAttached<ept id="p1">**</ept> <bpt id="p2">*</bpt>name<ept id="p2">*</ept> parameter, with the string "Property" added to the end.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>This is the established convention for naming the identifiers of dependency properties in relation to the properties that they represent.</source>
          <target state="new">This is the established convention for naming the identifiers of dependency properties in relation to the properties that they represent.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>The main area where defining a custom attached property differs from a custom dependency property is in how you define the accessors or wrappers.</source>
          <target state="new">The main area where defining a custom attached property differs from a custom dependency property is in how you define the accessors or wrappers.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Instead of the using the wrapper technique described in <bpt id="p1">[</bpt>Custom dependency properties<ept id="p1">](custom-dependency-properties.md)</ept>, you must also provide static <bpt id="p2">**</bpt>Get<ept id="p2">**</ept><bpt id="p3">*</bpt>PropertyName<ept id="p3">*</ept> and <bpt id="p4">**</bpt>Set<ept id="p4">**</ept><bpt id="p5">*</bpt>PropertyName<ept id="p5">*</ept> methods as accessors for the attached property.</source>
          <target state="new">Instead of the using the wrapper technique described in <bpt id="p1">[</bpt>Custom dependency properties<ept id="p1">](custom-dependency-properties.md)</ept>, you must also provide static <bpt id="p2">**</bpt>Get<ept id="p2">**</ept><bpt id="p3">*</bpt>PropertyName<ept id="p3">*</ept> and <bpt id="p4">**</bpt>Set<ept id="p4">**</ept><bpt id="p5">*</bpt>PropertyName<ept id="p5">*</ept> methods as accessors for the attached property.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The accessors are used mostly by the XAML parser, although any other caller can also use them to set values in non-XAML scenarios.</source>
          <target state="new">The accessors are used mostly by the XAML parser, although any other caller can also use them to set values in non-XAML scenarios.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>  If you don't define the accessors correctly, the XAML processor can't access your attached property and anyone who tries to use it will probably get a XAML parser error.</source>
          <target state="new"><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>  If you don't define the accessors correctly, the XAML processor can't access your attached property and anyone who tries to use it will probably get a XAML parser error.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Also, design and coding tools often rely on the "<ph id="ph1">\*</ph>Property" conventions for naming identifiers when they encounter a custom dependency property in a referenced assembly.</source>
          <target state="new">Also, design and coding tools often rely on the "<ph id="ph1">\*</ph>Property" conventions for naming identifiers when they encounter a custom dependency property in a referenced assembly.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="new">Accessors</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The signature for the <bpt id="p1">**</bpt>Get<ept id="p1">**</ept><bpt id="p2">_</bpt>PropertyName<ept id="p2">_</ept> accessor must be this.</source>
          <target state="new">The signature for the <bpt id="p1">**</bpt>Get<ept id="p1">**</ept><bpt id="p2">_</bpt>PropertyName<ept id="p2">_</ept> accessor must be this.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>valueType<ept id="p1">_</ept> <bpt id="p2">**</bpt>Get<ept id="p2">**</ept><bpt id="p3">_</bpt>PropertyName<ept id="p3">_</ept></source>
          <target state="new"><bpt id="p1">_</bpt>valueType<ept id="p1">_</ept> <bpt id="p2">**</bpt>Get<ept id="p2">**</ept><bpt id="p3">_</bpt>PropertyName<ept id="p3">_</ept></target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>For Microsoft Visual Basic, it is this.</source>
          <target state="new">For Microsoft Visual Basic, it is this.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>PropertyName<ept id="p1">_</ept><ph id="ph1">`(ByVal target As DependencyObject) As `</ph><bpt id="p2">_</bpt>valueType<ept id="p2">_</ept></source>
          <target state="new"><bpt id="p1">_</bpt>PropertyName<ept id="p1">_</ept><ph id="ph1">`(ByVal target As DependencyObject) As `</ph><bpt id="p2">_</bpt>valueType<ept id="p2">_</ept></target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>target<ept id="p1">*</ept> object can be of a more specific type in your implementation, but must derive from <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DependencyObject<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>.</source>
          <target state="new">The <bpt id="p1">*</bpt>target<ept id="p1">*</ept> object can be of a more specific type in your implementation, but must derive from <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DependencyObject<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>valueType<ept id="p1">*</ept> return value can also be of a more specific type in your implementation.</source>
          <target state="new">The <bpt id="p1">*</bpt>valueType<ept id="p1">*</ept> return value can also be of a more specific type in your implementation.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The basic <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> type is acceptable, but often you'll want your attached property to enforce type safety.</source>
          <target state="new">The basic <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> type is acceptable, but often you'll want your attached property to enforce type safety.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The use of typing in the getter and setter signatures is a recommended type-safety technique.</source>
          <target state="new">The use of typing in the getter and setter signatures is a recommended type-safety technique.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>The signature for the <bpt id="p1">**</bpt>Set<ept id="p1">**</ept><bpt id="p2">*</bpt>PropertyName<ept id="p2">*</ept> accessor must be this.</source>
          <target state="new">The signature for the <bpt id="p1">**</bpt>Set<ept id="p1">**</ept><bpt id="p2">*</bpt>PropertyName<ept id="p2">*</ept> accessor must be this.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>PropertyName<ept id="p1">_</ept><ph id="ph1">` (DependencyObject target , `</ph><bpt id="p2">_</bpt>valueType<ept id="p2">_</ept></source>
          <target state="new"><bpt id="p1">_</bpt>PropertyName<ept id="p1">_</ept><ph id="ph1">` (DependencyObject target , `</ph><bpt id="p2">_</bpt>valueType<ept id="p2">_</ept></target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>For Visual Basic, it is this.</source>
          <target state="new">For Visual Basic, it is this.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source><bpt id="p1">_</bpt>PropertyName<ept id="p1">_</ept><ph id="ph1">` (ByVal target As DependencyObject, ByVal value As `</ph><bpt id="p2">_</bpt>valueType<ept id="p2">_</ept></source>
          <target state="new"><bpt id="p1">_</bpt>PropertyName<ept id="p1">_</ept><ph id="ph1">` (ByVal target As DependencyObject, ByVal value As `</ph><bpt id="p2">_</bpt>valueType<ept id="p2">_</ept></target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>target<ept id="p1">*</ept> object can be of a more specific type in your implementation, but must derive from <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DependencyObject<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>.</source>
          <target state="new">The <bpt id="p1">*</bpt>target<ept id="p1">*</ept> object can be of a more specific type in your implementation, but must derive from <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DependencyObject<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">*</bpt>value<ept id="p1">*</ept> object and its <bpt id="p2">*</bpt>valueType<ept id="p2">*</ept> can be of a more specific type in your implementation.</source>
          <target state="new">The <bpt id="p1">*</bpt>value<ept id="p1">*</ept> object and its <bpt id="p2">*</bpt>valueType<ept id="p2">*</ept> can be of a more specific type in your implementation.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Remember that the value for this method is the input that comes from the XAML processor when it encounters your attached property in markup.</source>
          <target state="new">Remember that the value for this method is the input that comes from the XAML processor when it encounters your attached property in markup.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>There must be type conversion or existing markup extension support for the type you use, so that the appropriate type can be created from an attribute value (which is ultimately just a string).</source>
          <target state="new">There must be type conversion or existing markup extension support for the type you use, so that the appropriate type can be created from an attribute value (which is ultimately just a string).</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The basic <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> type is acceptable, but often you'll want further type safety.</source>
          <target state="new">The basic <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> type is acceptable, but often you'll want further type safety.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>To accomplish that, put type enforcement in the accessors.</source>
          <target state="new">To accomplish that, put type enforcement in the accessors.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  It's also possible to define an attached property where the intended usage is through property element syntax.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  It's also possible to define an attached property where the intended usage is through property element syntax.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>In that case you don't need type conversion for the values, but you do need to assure that the values you intend can be constructed in XAML.</source>
          <target state="new">In that case you don't need type conversion for the values, but you do need to assure that the values you intend can be constructed in XAML.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt><bpt id="p2">**</bpt>VisualStateManager.VisualStateGroups<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh738505)</ept> is an example of an existing attached property that only supports property element usage.</source>
          <target state="new"><bpt id="p1">[</bpt><bpt id="p2">**</bpt>VisualStateManager.VisualStateGroups<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh738505)</ept> is an example of an existing attached property that only supports property element usage.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Code example</source>
          <target state="new">Code example</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This example shows the dependency property registration (using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>RegisterAttached<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh701833)</ept> method), as well as the <bpt id="p3">**</bpt>Get<ept id="p3">**</ept> and <bpt id="p4">**</bpt>Set<ept id="p4">**</ept> accessors, for a custom attached property.</source>
          <target state="new">This example shows the dependency property registration (using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>RegisterAttached<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh701833)</ept> method), as well as the <bpt id="p3">**</bpt>Get<ept id="p3">**</ept> and <bpt id="p4">**</bpt>Set<ept id="p4">**</ept> accessors, for a custom attached property.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>In the example, the attached property name is <ph id="ph1">`IsMovable`</ph>.</source>
          <target state="new">In the example, the attached property name is <ph id="ph1">`IsMovable`</ph>.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Therefore, the accessors must be named <ph id="ph1">`GetIsMovable`</ph> and <ph id="ph2">`SetIsMovable`</ph>.</source>
          <target state="new">Therefore, the accessors must be named <ph id="ph1">`GetIsMovable`</ph> and <ph id="ph2">`SetIsMovable`</ph>.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The owner of the attached property is a service class named <ph id="ph1">`GameService`</ph> that doesn't have a UI of its own; its purpose is only to provide the attached property services when the <bpt id="p1">**</bpt>GameService.IsMovable<ept id="p1">**</ept> attached property is used.</source>
          <target state="new">The owner of the attached property is a service class named <ph id="ph1">`GameService`</ph> that doesn't have a UI of its own; its purpose is only to provide the attached property services when the <bpt id="p1">**</bpt>GameService.IsMovable<ept id="p1">**</ept> attached property is used.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>[!div class="tabbedCodeSnippets"]</source>
          <target state="new">[!div class="tabbedCodeSnippets"]</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Defining the attached property in C++ is a bit more complex.</source>
          <target state="new">Defining the attached property in C++ is a bit more complex.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>You have to decide how to factor between the header and code file.</source>
          <target state="new">You have to decide how to factor between the header and code file.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Also, you should expose the identifier as a property with only a <bpt id="p1">**</bpt>get<ept id="p1">**</ept> accessor, for reasons discussed in <bpt id="p2">[</bpt>Custom dependency properties<ept id="p2">](custom-dependency-properties.md)</ept>.</source>
          <target state="new">Also, you should expose the identifier as a property with only a <bpt id="p1">**</bpt>get<ept id="p1">**</ept> accessor, for reasons discussed in <bpt id="p2">[</bpt>Custom dependency properties<ept id="p2">](custom-dependency-properties.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>In C++ you must define this property-field relationship explicitly rather than relying on .NET <bpt id="p1">**</bpt>readonly<ept id="p1">**</ept> keywording and implicit backing of simple properties.</source>
          <target state="new">In C++ you must define this property-field relationship explicitly rather than relying on .NET <bpt id="p1">**</bpt>readonly<ept id="p1">**</ept> keywording and implicit backing of simple properties.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You also need to perform the registration of the attached property within a helper function that only gets run once, when the app first starts but before any XAML pages that need the attached property are loaded.</source>
          <target state="new">You also need to perform the registration of the attached property within a helper function that only gets run once, when the app first starts but before any XAML pages that need the attached property are loaded.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The typical place to call your property registration helper functions for any and all dependency or attached properties is from within the <bpt id="p1">**</bpt>App<ept id="p1">**</ept><ph id="ph1"> / </ph><bpt id="p2">[</bpt><bpt id="p3">**</bpt>Application<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br242325)</ept> constructor in the code for your app.xaml file.</source>
          <target state="new">The typical place to call your property registration helper functions for any and all dependency or attached properties is from within the <bpt id="p1">**</bpt>App<ept id="p1">**</ept><ph id="ph1"> / </ph><bpt id="p2">[</bpt><bpt id="p3">**</bpt>Application<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br242325)</ept> constructor in the code for your app.xaml file.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Using your custom attached property in XAML</source>
          <target state="new">Using your custom attached property in XAML</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>After you have defined your attached property and included its support members as part of a custom type, you must then make the definitions available for XAML usage.</source>
          <target state="new">After you have defined your attached property and included its support members as part of a custom type, you must then make the definitions available for XAML usage.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>To do this, you must map a XAML namespace that will reference the code namespace that contains the relevant class.</source>
          <target state="new">To do this, you must map a XAML namespace that will reference the code namespace that contains the relevant class.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In cases where you have defined the attached property as part of a library, you must include that library as part of the app package for the app.</source>
          <target state="new">In cases where you have defined the attached property as part of a library, you must include that library as part of the app package for the app.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>An XML namespace mapping for XAML is typically placed in the root element of a XAML page.</source>
          <target state="new">An XML namespace mapping for XAML is typically placed in the root element of a XAML page.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>For example, for the class named <ph id="ph1">`GameService`</ph> in the namespace <ph id="ph2">`UserAndCustomControls`</ph> that contains the attached property definitions shown in preceding snippets, the mapping might look like this.</source>
          <target state="new">For example, for the class named <ph id="ph1">`GameService`</ph> in the namespace <ph id="ph2">`UserAndCustomControls`</ph> that contains the attached property definitions shown in preceding snippets, the mapping might look like this.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Using the mapping, you can set your <ph id="ph1">`GameService.IsMovable`</ph> attached property on any element that matches your target definition, including an existing type that Windows Runtime defines.</source>
          <target state="new">Using the mapping, you can set your <ph id="ph1">`GameService.IsMovable`</ph> attached property on any element that matches your target definition, including an existing type that Windows Runtime defines.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>If you are setting the property on an element that is also within the same mapped XML namespace, you still must include the prefix on the attached property name.</source>
          <target state="new">If you are setting the property on an element that is also within the same mapped XML namespace, you still must include the prefix on the attached property name.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>This is because the prefix qualifies the owner type.</source>
          <target state="new">This is because the prefix qualifies the owner type.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The attached property's attribute cannot be assumed to be within the same XML namespace as the element where the attribute is included, even though, by normal XML rules, attributes can inherit namespace from elements.</source>
          <target state="new">The attached property's attribute cannot be assumed to be within the same XML namespace as the element where the attribute is included, even though, by normal XML rules, attributes can inherit namespace from elements.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>For example, if you are setting <ph id="ph1">`GameService.IsMovable`</ph> on a custom type of <ph id="ph2">`ImageWithLabelControl`</ph> (definition not shown), and even if both were defined in the same code namespace mapped to same prefix, the XAML would still be this.</source>
          <target state="new">For example, if you are setting <ph id="ph1">`GameService.IsMovable`</ph> on a custom type of <ph id="ph2">`ImageWithLabelControl`</ph> (definition not shown), and even if both were defined in the same code namespace mapped to same prefix, the XAML would still be this.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  If you are writing a XAML UI with C++, you must include the header for the custom type that defines the attached property, any time that a XAML page uses that type.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  If you are writing a XAML UI with C++, you must include the header for the custom type that defines the attached property, any time that a XAML page uses that type.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Each XAML page has an associated .xaml.h code-behind header.</source>
          <target state="new">Each XAML page has an associated .xaml.h code-behind header.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>This is where you should include (using <bpt id="p1">**</bpt><ph id="ph1">\#</ph>include<ept id="p1">**</ept>) the header for the definition of the attached property's owner type.</source>
          <target state="new">This is where you should include (using <bpt id="p1">**</bpt><ph id="ph1">\#</ph>include<ept id="p1">**</ept>) the header for the definition of the attached property's owner type.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Value type of a custom attached property</source>
          <target state="new">Value type of a custom attached property</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The type that is used as the value type of a custom attached property affects the usage, the definition, or both the usage and definition.</source>
          <target state="new">The type that is used as the value type of a custom attached property affects the usage, the definition, or both the usage and definition.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>The attached property's value type is declared in several places: in the signatures of both the <bpt id="p1">**</bpt>Get<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Set<ept id="p2">**</ept> accessor methods, and also as the <bpt id="p3">*</bpt>propertyType<ept id="p3">*</ept> parameter of the <bpt id="p4">[</bpt><bpt id="p5">**</bpt>RegisterAttached<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/hh701833)</ept> call.</source>
          <target state="new">The attached property's value type is declared in several places: in the signatures of both the <bpt id="p1">**</bpt>Get<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Set<ept id="p2">**</ept> accessor methods, and also as the <bpt id="p3">*</bpt>propertyType<ept id="p3">*</ept> parameter of the <bpt id="p4">[</bpt><bpt id="p5">**</bpt>RegisterAttached<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/hh701833)</ept> call.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The most common value type for attached properties (custom or otherwise) is a simple string.</source>
          <target state="new">The most common value type for attached properties (custom or otherwise) is a simple string.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>This is because attached properties are generally intended for XAML attribute usage, and using a string as the value type keeps the properties lightweight.</source>
          <target state="new">This is because attached properties are generally intended for XAML attribute usage, and using a string as the value type keeps the properties lightweight.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Other primitives that have native conversion to string methods, such as integer, double, or an enumeration value, are also common as value types for attached properties.</source>
          <target state="new">Other primitives that have native conversion to string methods, such as integer, double, or an enumeration value, are also common as value types for attached properties.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>You can use other value types—ones that don't support native string conversion—as the attached property value.</source>
          <target state="new">You can use other value types—ones that don't support native string conversion—as the attached property value.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>However, this entails making a choice about either the usage or the implementation:</source>
          <target state="new">However, this entails making a choice about either the usage or the implementation:</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You can leave the attached property as it is, but the attached property can support usage only where the attached property is a property element, and the value is declared as an object element.</source>
          <target state="new">You can leave the attached property as it is, but the attached property can support usage only where the attached property is a property element, and the value is declared as an object element.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>In this case, the property type does have to support XAML usage as an object element.</source>
          <target state="new">In this case, the property type does have to support XAML usage as an object element.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>For existing Windows Runtime reference classes, check the XAML syntax to make sure that the type supports XAML object element usage.</source>
          <target state="new">For existing Windows Runtime reference classes, check the XAML syntax to make sure that the type supports XAML object element usage.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>You can leave the attached property as it is, but use it only in an attribute usage through a XAML reference technique such as a <bpt id="p1">**</bpt>Binding<ept id="p1">**</ept> or <bpt id="p2">**</bpt>StaticResource<ept id="p2">**</ept> that can be expressed as a string.</source>
          <target state="new">You can leave the attached property as it is, but use it only in an attribute usage through a XAML reference technique such as a <bpt id="p1">**</bpt>Binding<ept id="p1">**</ept> or <bpt id="p2">**</bpt>StaticResource<ept id="p2">**</ept> that can be expressed as a string.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>More about the <bpt id="p1">**</bpt>Canvas.Left<ept id="p1">**</ept> example</source>
          <target state="new">More about the <bpt id="p1">**</bpt>Canvas.Left<ept id="p1">**</ept> example</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>In earlier examples of attached property usages we showed different ways to set the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas.Left<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh759771)</ept> attached property.</source>
          <target state="new">In earlier examples of attached property usages we showed different ways to set the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas.Left<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh759771)</ept> attached property.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>But what does that change about how a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> interacts with your object, and when does that happen?</source>
          <target state="new">But what does that change about how a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> interacts with your object, and when does that happen?</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>We'll examine this particular example further, because if you implement an attached property, it's interesting to see what else a typical attached property owner class intends to do with its attached property values if it finds them on other objects.</source>
          <target state="new">We'll examine this particular example further, because if you implement an attached property, it's interesting to see what else a typical attached property owner class intends to do with its attached property values if it finds them on other objects.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The main function of a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> is to be an absolute-positioned layout container in UI.</source>
          <target state="new">The main function of a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> is to be an absolute-positioned layout container in UI.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The children of a <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> are stored in a base-class defined property <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Children<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>.</source>
          <target state="new">The children of a <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> are stored in a base-class defined property <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Children<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Of all the panels <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> is the only one that uses absolute positioning.</source>
          <target state="new">Of all the panels <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> is the only one that uses absolute positioning.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>It would've bloated the object model of the common <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElement<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> type to add properties that might only be of concern to <bpt id="p3">**</bpt>Canvas<ept id="p3">**</ept> and those particular <bpt id="p4">**</bpt>UIElement<ept id="p4">**</ept> cases where they are child elements of a <bpt id="p5">**</bpt>UIElement<ept id="p5">**</ept>.</source>
          <target state="new">It would've bloated the object model of the common <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElement<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> type to add properties that might only be of concern to <bpt id="p3">**</bpt>Canvas<ept id="p3">**</ept> and those particular <bpt id="p4">**</bpt>UIElement<ept id="p4">**</ept> cases where they are child elements of a <bpt id="p5">**</bpt>UIElement<ept id="p5">**</ept>.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Defining the layout control properties of a <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> to be attached properties that any <bpt id="p2">**</bpt>UIElement<ept id="p2">**</ept> can use keeps the object model cleaner.</source>
          <target state="new">Defining the layout control properties of a <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> to be attached properties that any <bpt id="p2">**</bpt>UIElement<ept id="p2">**</ept> can use keeps the object model cleaner.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In order to be a practical panel, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> has behavior that overrides the framework-level <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Measure<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Arrange<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> methods.</source>
          <target state="new">In order to be a practical panel, <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> has behavior that overrides the framework-level <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Measure<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Arrange<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> methods.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>This is where <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> actually checks for attached property values on its children.</source>
          <target state="new">This is where <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> actually checks for attached property values on its children.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Part of both the <bpt id="p1">**</bpt>Measure<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Arrange<ept id="p2">**</ept> patterns is a loop that iterates over any content, and a panel has the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Children<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> property that makes it explicit what's supposed to be considered the child of a panel.</source>
          <target state="new">Part of both the <bpt id="p1">**</bpt>Measure<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Arrange<ept id="p2">**</ept> patterns is a loop that iterates over any content, and a panel has the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Children<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> property that makes it explicit what's supposed to be considered the child of a panel.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>So the <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> layout behavior iterates through these children, and makes static <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Canvas.GetLeft<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br209269)</ept> and <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Canvas.GetTop<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br209270)</ept> calls on each child to see whether those attached properties contain a non-default value (default is 0).</source>
          <target state="new">So the <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> layout behavior iterates through these children, and makes static <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Canvas.GetLeft<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br209269)</ept> and <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Canvas.GetTop<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br209270)</ept> calls on each child to see whether those attached properties contain a non-default value (default is 0).</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>These values are then used to absolutely position each child in the <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> available layout space according to the specific values provided by each child, and committed using <bpt id="p2">**</bpt>Arrange<ept id="p2">**</ept>.</source>
          <target state="new">These values are then used to absolutely position each child in the <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> available layout space according to the specific values provided by each child, and committed using <bpt id="p2">**</bpt>Arrange<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The code looks something like this pseudocode:</source>
          <target state="new">The code looks something like this pseudocode:</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  For more info on how panels work, see <bpt id="p2">[</bpt>XAML custom panels overview<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/mt228351)</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  For more info on how panels work, see <bpt id="p2">[</bpt>XAML custom panels overview<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/mt228351)</ept>.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>RegisterAttached</source>
          <target state="new">RegisterAttached</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>Attached properties overview</source>
          <target state="new">Attached properties overview</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Custom dependency properties</source>
          <target state="new">Custom dependency properties</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>XAML overview</source>
          <target state="new">XAML overview</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>