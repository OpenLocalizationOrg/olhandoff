<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\layout\boxpanel-example-custom-panel.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">72c9bec8e96dcea4900e847b16fc2b3f07a9ed07</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Learn to write code for a custom Panel class, implementing ArrangeOverride and MeasureOverride methods, and using the Children property.</source>
          <target state="new">Learn to write code for a custom Panel class, implementing ArrangeOverride and MeasureOverride methods, and using the Children property.</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>BoxPanel, an example custom panel</source>
          <target state="new">BoxPanel, an example custom panel</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>BoxPanel, an example custom panel</source>
          <target state="new">BoxPanel, an example custom panel</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Important APIs</source>
          <target state="new">Important APIs</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Panel</source>
          <target state="new">Panel</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>ArrangeOverride</source>
          <target state="new">ArrangeOverride</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>MeasureOverride</source>
          <target state="new">MeasureOverride</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Learn to write code for a custom <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Panel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> class, implementing <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ArrangeOverride<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>MeasureOverride<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> methods, and using the <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Children<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> property.</source>
          <target state="new">Learn to write code for a custom <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Panel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> class, implementing <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ArrangeOverride<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>MeasureOverride<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> methods, and using the <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Children<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> property.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The example code shows a custom panel implementation, but we don't devote a lot of time explaining the layout concepts that influence how you can customize a panel for different layout scenarios.</source>
          <target state="new">The example code shows a custom panel implementation, but we don't devote a lot of time explaining the layout concepts that influence how you can customize a panel for different layout scenarios.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>If you want more info about these layout concepts and how they might apply to your particular layout scenario, see <bpt id="p1">[</bpt>XAML custom panels overview<ept id="p1">](custom-panels-overview.md)</ept>.</source>
          <target state="new">If you want more info about these layout concepts and how they might apply to your particular layout scenario, see <bpt id="p1">[</bpt>XAML custom panels overview<ept id="p1">](custom-panels-overview.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>panel<ept id="p1">*</ept> is an object that provides a layout behavior for child elements it contains, when the XAML layout system runs and your app UI is rendered.</source>
          <target state="new">A <bpt id="p1">*</bpt>panel<ept id="p1">*</ept> is an object that provides a layout behavior for child elements it contains, when the XAML layout system runs and your app UI is rendered.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can define custom panels for XAML layout by deriving a custom class from the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Panel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> class.</source>
          <target state="new">You can define custom panels for XAML layout by deriving a custom class from the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Panel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept> class.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>You provide behavior for your panel by overriding the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ArrangeOverride<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>MeasureOverride<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> methods, supplying logic that measures and arranges the child elements.</source>
          <target state="new">You provide behavior for your panel by overriding the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ArrangeOverride<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>MeasureOverride<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> methods, supplying logic that measures and arranges the child elements.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>This example derives from <bpt id="p1">**</bpt>Panel<ept id="p1">**</ept>.</source>
          <target state="new">This example derives from <bpt id="p1">**</bpt>Panel<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>When you start from <bpt id="p1">**</bpt>Panel<ept id="p1">**</ept>, <bpt id="p2">**</bpt>ArrangeOverride<ept id="p2">**</ept> and <bpt id="p3">**</bpt>MeasureOverride<ept id="p3">**</ept> methods don't have a starting behavior.</source>
          <target state="new">When you start from <bpt id="p1">**</bpt>Panel<ept id="p1">**</ept>, <bpt id="p2">**</bpt>ArrangeOverride<ept id="p2">**</ept> and <bpt id="p3">**</bpt>MeasureOverride<ept id="p3">**</ept> methods don't have a starting behavior.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Your code is providing the gateway by which child elements become known to the XAML layout system and get rendered in the UI.</source>
          <target state="new">Your code is providing the gateway by which child elements become known to the XAML layout system and get rendered in the UI.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>So, it's really important that your code accounts for all child elements and follows the patterns the layout system expects.</source>
          <target state="new">So, it's really important that your code accounts for all child elements and follows the patterns the layout system expects.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Your layout scenario</source>
          <target state="new">Your layout scenario</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>When you define a custom panel, you're defining a layout scenario.</source>
          <target state="new">When you define a custom panel, you're defining a layout scenario.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>A layout scenario is expressed through:</source>
          <target state="new">A layout scenario is expressed through:</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>What the panel will do when it has child elements</source>
          <target state="new">What the panel will do when it has child elements</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When the panel has constraints on its own space</source>
          <target state="new">When the panel has constraints on its own space</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>How the logic of the panel determines all the measurements, placement, positions, and sizings that eventually result in a rendered UI layout of children</source>
          <target state="new">How the logic of the panel determines all the measurements, placement, positions, and sizings that eventually result in a rendered UI layout of children</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>With that in mind, the <ph id="ph1">`BoxPanel`</ph> shown here is for a particular scenario.</source>
          <target state="new">With that in mind, the <ph id="ph1">`BoxPanel`</ph> shown here is for a particular scenario.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In the interest of keeping the code foremost in this example, we won't explain the scenario in detail yet, and instead concentrate on the steps needed and the coding patterns.</source>
          <target state="new">In the interest of keeping the code foremost in this example, we won't explain the scenario in detail yet, and instead concentrate on the steps needed and the coding patterns.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>If you want to know more about the scenario first, skip ahead to <bpt id="p1">[</bpt>"The scenario for <ph id="ph1">`BoxPanel`</ph>"<ept id="p1">](#scenario)</ept>, and then come back to the code.</source>
          <target state="new">If you want to know more about the scenario first, skip ahead to <bpt id="p1">[</bpt>"The scenario for <ph id="ph1">`BoxPanel`</ph>"<ept id="p1">](#scenario)</ept>, and then come back to the code.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Start by deriving from <bpt id="p1">**</bpt>Panel<ept id="p1">**</ept></source>
          <target state="new">Start by deriving from <bpt id="p1">**</bpt>Panel<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Start by deriving a custom class from <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Panel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept>.</source>
          <target state="new">Start by deriving a custom class from <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Panel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept>.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Probably the easiest way to do this is to define a separate code file for this class, using the <bpt id="p1">**</bpt>Add<ept id="p1">**</ept><ph id="ph1"> | </ph><bpt id="p2">**</bpt>New Item<ept id="p2">**</ept><ph id="ph2"> | </ph><bpt id="p3">**</bpt>Class<ept id="p3">**</ept> context menu options for a project from the <bpt id="p4">**</bpt>Solution Explorer<ept id="p4">**</ept> in Microsoft Visual Studio.</source>
          <target state="new">Probably the easiest way to do this is to define a separate code file for this class, using the <bpt id="p1">**</bpt>Add<ept id="p1">**</ept><ph id="ph1"> | </ph><bpt id="p2">**</bpt>New Item<ept id="p2">**</ept><ph id="ph2"> | </ph><bpt id="p3">**</bpt>Class<ept id="p3">**</ept> context menu options for a project from the <bpt id="p4">**</bpt>Solution Explorer<ept id="p4">**</ept> in Microsoft Visual Studio.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Name the class (and file) <ph id="ph1">`BoxPanel`</ph>.</source>
          <target state="new">Name the class (and file) <ph id="ph1">`BoxPanel`</ph>.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The template file for a class doesn't start with many <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statements because it's not specifically for Universal Windows Platform (UWP) apps.</source>
          <target state="new">The template file for a class doesn't start with many <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statements because it's not specifically for Universal Windows Platform (UWP) apps.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>So first, add <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statements.</source>
          <target state="new">So first, add <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statements.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The template file also starts with a few <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statements that you probably don't need, and can be deleted.</source>
          <target state="new">The template file also starts with a few <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statements that you probably don't need, and can be deleted.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Here's a suggested list of <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statements that can resolve types you'll need for typical custom panel code:</source>
          <target state="new">Here's a suggested list of <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statements that can resolve types you'll need for typical custom panel code:</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Now that you can resolve <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Panel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept>, make it the base class of <ph id="ph1">`BoxPanel`</ph>.</source>
          <target state="new">Now that you can resolve <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Panel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227511)</ept>, make it the base class of <ph id="ph1">`BoxPanel`</ph>.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Also, make <ph id="ph1">`BoxPanel`</ph> public:</source>
          <target state="new">Also, make <ph id="ph1">`BoxPanel`</ph> public:</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>At the class level, define some <bpt id="p1">**</bpt>int<ept id="p1">**</ept> and <bpt id="p2">**</bpt>double<ept id="p2">**</ept> values that will be shared by several of your logic functions, but which won't need to be exposed as public API.</source>
          <target state="new">At the class level, define some <bpt id="p1">**</bpt>int<ept id="p1">**</ept> and <bpt id="p2">**</bpt>double<ept id="p2">**</ept> values that will be shared by several of your logic functions, but which won't need to be exposed as public API.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the example, these are named: <ph id="ph1">`maxrc`</ph>, <ph id="ph2">`rowcount`</ph>, <ph id="ph3">`colcount`</ph>, <ph id="ph4">`cellwidth`</ph>, <ph id="ph5">`cellheight`</ph>, <ph id="ph6">`maxcellheight`</ph>, <ph id="ph7">`aspectratio`</ph>.</source>
          <target state="new">In the example, these are named: <ph id="ph1">`maxrc`</ph>, <ph id="ph2">`rowcount`</ph>, <ph id="ph3">`colcount`</ph>, <ph id="ph4">`cellwidth`</ph>, <ph id="ph5">`cellheight`</ph>, <ph id="ph6">`maxcellheight`</ph>, <ph id="ph7">`aspectratio`</ph>.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>After you've done this, the complete code file looks like this (removing comments on <bpt id="p1">**</bpt>using<ept id="p1">**</ept>, now that you know why we have them):</source>
          <target state="new">After you've done this, the complete code file looks like this (removing comments on <bpt id="p1">**</bpt>using<ept id="p1">**</ept>, now that you know why we have them):</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>From here on out, we'll be showing you one member definition at a time, be that a method override or something supporting such as a dependency property.</source>
          <target state="new">From here on out, we'll be showing you one member definition at a time, be that a method override or something supporting such as a dependency property.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>You can add these to the skeleton above in any order, and we won't be showing the <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statements or the definition of the class scope again in the snippets until we show the final code.</source>
          <target state="new">You can add these to the skeleton above in any order, and we won't be showing the <bpt id="p1">**</bpt>using<ept id="p1">**</ept> statements or the definition of the class scope again in the snippets until we show the final code.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>MeasureOverride</source>
          <target state="new">MeasureOverride</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>The necessary pattern of a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>MeasureOverride<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> implementation is the loop through each element in <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Panel.Children<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>.</source>
          <target state="new">The necessary pattern of a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>MeasureOverride<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept> implementation is the loop through each element in <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Panel.Children<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Always call the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Measure<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> method on each of these elements.</source>
          <target state="new">Always call the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Measure<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> method on each of these elements.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Measure<ept id="p1">**</ept> has a parameter of type <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Size<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Measure<ept id="p1">**</ept> has a parameter of type <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Size<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept>.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>What you're passing here is the size that your panel is committing to have available for that particular child element.</source>
          <target state="new">What you're passing here is the size that your panel is committing to have available for that particular child element.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>So, before you can do the loop and start calling <bpt id="p1">**</bpt>Measure<ept id="p1">**</ept>, you need to know how much space each cell can devote.</source>
          <target state="new">So, before you can do the loop and start calling <bpt id="p1">**</bpt>Measure<ept id="p1">**</ept>, you need to know how much space each cell can devote.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>From the <bpt id="p1">**</bpt>MeasureOverride<ept id="p1">**</ept> method itself, you have the <bpt id="p2">*</bpt>availableSize<ept id="p2">*</ept> value.</source>
          <target state="new">From the <bpt id="p1">**</bpt>MeasureOverride<ept id="p1">**</ept> method itself, you have the <bpt id="p2">*</bpt>availableSize<ept id="p2">*</ept> value.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>That is the size that the panel's parent used when it called <bpt id="p1">**</bpt>Measure<ept id="p1">**</ept>, which was the trigger for this <bpt id="p2">**</bpt>MeasureOverride<ept id="p2">**</ept> being called in the first place.</source>
          <target state="new">That is the size that the panel's parent used when it called <bpt id="p1">**</bpt>Measure<ept id="p1">**</ept>, which was the trigger for this <bpt id="p2">**</bpt>MeasureOverride<ept id="p2">**</ept> being called in the first place.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>So a typical logic is to devise a scheme whereby each child element divides the space of the panel's overall <bpt id="p1">*</bpt>availableSize<ept id="p1">*</ept>.</source>
          <target state="new">So a typical logic is to devise a scheme whereby each child element divides the space of the panel's overall <bpt id="p1">*</bpt>availableSize<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>You then pass each division of size to <bpt id="p1">**</bpt>Measure<ept id="p1">**</ept> of each child element.</source>
          <target state="new">You then pass each division of size to <bpt id="p1">**</bpt>Measure<ept id="p1">**</ept> of each child element.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>How <ph id="ph1">`BoxPanel`</ph> divides size is fairly simple: it divides its space into a number of boxes that's largely controlled by the number of items.</source>
          <target state="new">How <ph id="ph1">`BoxPanel`</ph> divides size is fairly simple: it divides its space into a number of boxes that's largely controlled by the number of items.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Boxes are sized based on row and column count and the available size.</source>
          <target state="new">Boxes are sized based on row and column count and the available size.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Sometimes one row or column from a square isn't needed, so it's dropped and the panel becomes a rectangle rather than square in terms of its row : column ratio.</source>
          <target state="new">Sometimes one row or column from a square isn't needed, so it's dropped and the panel becomes a rectangle rather than square in terms of its row : column ratio.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For more info about how this logic was arrived at, skip ahead to <bpt id="p1">[</bpt>"The scenario for <ph id="ph1">`BoxPanel`</ph>"<ept id="p1">](#scenario)</ept>.</source>
          <target state="new">For more info about how this logic was arrived at, skip ahead to <bpt id="p1">[</bpt>"The scenario for <ph id="ph1">`BoxPanel`</ph>"<ept id="p1">](#scenario)</ept>.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>So what does the measure pass do?</source>
          <target state="new">So what does the measure pass do?</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>It sets a value for the read-only <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DesiredSize<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> property on each element where <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Measure<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> was called.</source>
          <target state="new">It sets a value for the read-only <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DesiredSize<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> property on each element where <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Measure<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> was called.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Having a <bpt id="p1">**</bpt>DesiredSize<ept id="p1">**</ept> value is possibly important once you get to the arrange pass, because the <bpt id="p2">**</bpt>DesiredSize<ept id="p2">**</ept> communicates what the size can or should be when arranging and in the final rendering.</source>
          <target state="new">Having a <bpt id="p1">**</bpt>DesiredSize<ept id="p1">**</ept> value is possibly important once you get to the arrange pass, because the <bpt id="p2">**</bpt>DesiredSize<ept id="p2">**</ept> communicates what the size can or should be when arranging and in the final rendering.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Even if you don't use <bpt id="p1">**</bpt>DesiredSize<ept id="p1">**</ept> in your own logic, the system still needs it.</source>
          <target state="new">Even if you don't use <bpt id="p1">**</bpt>DesiredSize<ept id="p1">**</ept> in your own logic, the system still needs it.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>It's possible for this panel to be used when the height component of <bpt id="p1">*</bpt>availableSize<ept id="p1">*</ept> is unbounded.</source>
          <target state="new">It's possible for this panel to be used when the height component of <bpt id="p1">*</bpt>availableSize<ept id="p1">*</ept> is unbounded.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>If that's true, the panel doesn't have a known height to divide.</source>
          <target state="new">If that's true, the panel doesn't have a known height to divide.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>In this case, the logic for the measure pass informs each child that it doesn't have a bounded height, yet.</source>
          <target state="new">In this case, the logic for the measure pass informs each child that it doesn't have a bounded height, yet.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>It does so by passing a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Size<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> to the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Measure<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> call for children where <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Size.Height<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/hh763910)</ept> is infinite.</source>
          <target state="new">It does so by passing a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Size<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> to the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Measure<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> call for children where <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Size.Height<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/hh763910)</ept> is infinite.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>That's legal.</source>
          <target state="new">That's legal.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>When <bpt id="p1">**</bpt>Measure<ept id="p1">**</ept> is called, the logic is that the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DesiredSize<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> is set as the minimum of these: what was passed to <bpt id="p4">**</bpt>Measure<ept id="p4">**</ept>, or that element's natural size from factors such as explicitly-set <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Height<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208718)</ept> and <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Width<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept>.</source>
          <target state="new">When <bpt id="p1">**</bpt>Measure<ept id="p1">**</ept> is called, the logic is that the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DesiredSize<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> is set as the minimum of these: what was passed to <bpt id="p4">**</bpt>Measure<ept id="p4">**</ept>, or that element's natural size from factors such as explicitly-set <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Height<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208718)</ept> and <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Width<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept>.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>????The internal logic of <bpt id="p2">[</bpt><bpt id="p3">**</bpt>StackPanel<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br209635)</ept> also has this behavior: <bpt id="p4">**</bpt>StackPanel<ept id="p4">**</ept> passes an infinite dimension value to <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Measure<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> on children, indicating that there is no constraint on children in the orientation dimension.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>????The internal logic of <bpt id="p2">[</bpt><bpt id="p3">**</bpt>StackPanel<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br209635)</ept> also has this behavior: <bpt id="p4">**</bpt>StackPanel<ept id="p4">**</ept> passes an infinite dimension value to <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Measure<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> on children, indicating that there is no constraint on children in the orientation dimension.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>StackPanel<ept id="p1">**</ept> typically sizes itself dynamically, to accommodate all children in a stack that grows in that dimension.</source>
          <target state="new"><bpt id="p1">**</bpt>StackPanel<ept id="p1">**</ept> typically sizes itself dynamically, to accommodate all children in a stack that grows in that dimension.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>??</source>
          <target state="new">??</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>However, the panel itself can't return a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Size<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> with an infinite value from <bpt id="p3">[</bpt><bpt id="p4">**</bpt>MeasureOverride<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept>; that throws an exception during layout.</source>
          <target state="new">However, the panel itself can't return a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Size<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> with an infinite value from <bpt id="p3">[</bpt><bpt id="p4">**</bpt>MeasureOverride<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept>; that throws an exception during layout.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>So, part of the logic is to find out the maximum height that any child requests, and use that height as the cell height in case that isn't coming from the panel's own size constraints already.</source>
          <target state="new">So, part of the logic is to find out the maximum height that any child requests, and use that height as the cell height in case that isn't coming from the panel's own size constraints already.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Here's the helper function <ph id="ph1">`LimitUnboundedSize`</ph> that was referenced in previous code, which then takes that maximum cell height and uses it to give the panel a finite height to return, as well as assuring that <ph id="ph2">`cellheight`</ph> is a finite number before the arrange pass is initiated:</source>
          <target state="new">Here's the helper function <ph id="ph1">`LimitUnboundedSize`</ph> that was referenced in previous code, which then takes that maximum cell height and uses it to give the panel a finite height to return, as well as assuring that <ph id="ph2">`cellheight`</ph> is a finite number before the arrange pass is initiated:</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>ArrangeOverride</source>
          <target state="new">ArrangeOverride</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The necessary pattern of an <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ArrangeOverride<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> implementation is the loop through each element in <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Panel.Children<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>.</source>
          <target state="new">The necessary pattern of an <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ArrangeOverride<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> implementation is the loop through each element in <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Panel.Children<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Always call the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Arrange<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> method on each of these elements.</source>
          <target state="new">Always call the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Arrange<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept> method on each of these elements.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Note how there aren't as many calculations as in <bpt id="p1">[</bpt><bpt id="p2">**</bpt>MeasureOverride<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept>; that's typical.</source>
          <target state="new">Note how there aren't as many calculations as in <bpt id="p1">[</bpt><bpt id="p2">**</bpt>MeasureOverride<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208730)</ept>; that's typical.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>The size of children is already known from the panel's own <bpt id="p1">**</bpt>MeasureOverride<ept id="p1">**</ept> logic, or from the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DesiredSize<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> value of each child set during the measure pass.</source>
          <target state="new">The size of children is already known from the panel's own <bpt id="p1">**</bpt>MeasureOverride<ept id="p1">**</ept> logic, or from the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>DesiredSize<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> value of each child set during the measure pass.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>However, we still need to decide the location within the panel where each child will appear.</source>
          <target state="new">However, we still need to decide the location within the panel where each child will appear.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>In a typical panel, each child should render at a different position.</source>
          <target state="new">In a typical panel, each child should render at a different position.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>A panel that creates overlapping elements isn't desirable for typical scenarios (although it's not out of the question to create panels that have purposeful overlaps, if that's really your intended scenario).</source>
          <target state="new">A panel that creates overlapping elements isn't desirable for typical scenarios (although it's not out of the question to create panels that have purposeful overlaps, if that's really your intended scenario).</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>This panel arranges by the concept of rows and columns.</source>
          <target state="new">This panel arranges by the concept of rows and columns.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The number of rows and columns was already calculated (it was necessary for measurement).</source>
          <target state="new">The number of rows and columns was already calculated (it was necessary for measurement).</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>So now the shape of the rows and columns plus the known sizes of each cell contribute to the logic of defining a rendering position (the <ph id="ph1">`anchorPoint`</ph>) for each element that this panel contains.</source>
          <target state="new">So now the shape of the rows and columns plus the known sizes of each cell contribute to the logic of defining a rendering position (the <ph id="ph1">`anchorPoint`</ph>) for each element that this panel contains.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>That <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Point<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225870)</ept>, along with the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Size<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> already known from measure, are used as the two components that construct a <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Rect<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br225994)</ept>.</source>
          <target state="new">That <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Point<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225870)</ept>, along with the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Size<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> already known from measure, are used as the two components that construct a <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Rect<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br225994)</ept>.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Rect<ept id="p1">**</ept> is the input type for <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Arrange<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Rect<ept id="p1">**</ept> is the input type for <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Arrange<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept>.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Panels sometimes need to clip their content.</source>
          <target state="new">Panels sometimes need to clip their content.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>If they do, the clipped size is the size that's present in <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DesiredSize<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept>, because the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Measure<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> logic sets it as the minimum of what was passed to <bpt id="p5">**</bpt>Measure<ept id="p5">**</ept>, or other natural size factors.</source>
          <target state="new">If they do, the clipped size is the size that's present in <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DesiredSize<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept>, because the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Measure<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208952)</ept> logic sets it as the minimum of what was passed to <bpt id="p5">**</bpt>Measure<ept id="p5">**</ept>, or other natural size factors.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>So you don't typically need to specifically check for clipping during <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Arrange<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept>; the clipping just happens based on passing the <bpt id="p3">**</bpt>DesiredSize<ept id="p3">**</ept> through to each <bpt id="p4">**</bpt>Arrange<ept id="p4">**</ept> call.</source>
          <target state="new">So you don't typically need to specifically check for clipping during <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Arrange<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208914)</ept>; the clipping just happens based on passing the <bpt id="p3">**</bpt>DesiredSize<ept id="p3">**</ept> through to each <bpt id="p4">**</bpt>Arrange<ept id="p4">**</ept> call.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>You don't always need a count while going through the loop if all the info you need for defining the rendering position is known by other means.</source>
          <target state="new">You don't always need a count while going through the loop if all the info you need for defining the rendering position is known by other means.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>For example, in <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> layout logic, the position in the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Children<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> collection doesn't matter.</source>
          <target state="new">For example, in <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> layout logic, the position in the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Children<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept> collection doesn't matter.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>All the info needed to position each element in a <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> is known by reading <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Canvas.Left<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/hh759771)</ept> and <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Canvas.Top<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/hh759772)</ept> values of children as part of the arrange logic.</source>
          <target state="new">All the info needed to position each element in a <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> is known by reading <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Canvas.Left<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/hh759771)</ept> and <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Canvas.Top<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/hh759772)</ept> values of children as part of the arrange logic.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`BoxPanel`</ph> logic happens to need a count to compare to the <bpt id="p1">*</bpt>colcount<ept id="p1">*</ept> so it's known when to begin a new row and offset the <bpt id="p2">*</bpt>y<ept id="p2">*</ept> value.</source>
          <target state="new">The <ph id="ph1">`BoxPanel`</ph> logic happens to need a count to compare to the <bpt id="p1">*</bpt>colcount<ept id="p1">*</ept> so it's known when to begin a new row and offset the <bpt id="p2">*</bpt>y<ept id="p2">*</ept> value.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>It's typical that the input <bpt id="p1">*</bpt>finalSize<ept id="p1">*</ept> and the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Size<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> you return from a <bpt id="p4">[</bpt><bpt id="p5">**</bpt>ArrangeOverride<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> implementation are the same.</source>
          <target state="new">It's typical that the input <bpt id="p1">*</bpt>finalSize<ept id="p1">*</ept> and the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Size<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept> you return from a <bpt id="p4">[</bpt><bpt id="p5">**</bpt>ArrangeOverride<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept> implementation are the same.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>For more info about why, see "<bpt id="p1">**</bpt>ArrangeOverride<ept id="p1">**</ept>" section of <bpt id="p2">[</bpt>XAML custom panels overview<ept id="p2">](custom-panels-overview.md)</ept>.</source>
          <target state="new">For more info about why, see "<bpt id="p1">**</bpt>ArrangeOverride<ept id="p1">**</ept>" section of <bpt id="p2">[</bpt>XAML custom panels overview<ept id="p2">](custom-panels-overview.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>A refinement: controlling the row vs. column count</source>
          <target state="new">A refinement: controlling the row vs. column count</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>You could compile and use this panel just as it is now.</source>
          <target state="new">You could compile and use this panel just as it is now.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>However, we'll add one more refinement.</source>
          <target state="new">However, we'll add one more refinement.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>In the code just shown, the logic puts the extra row or column on the side that's longest in aspect ratio.</source>
          <target state="new">In the code just shown, the logic puts the extra row or column on the side that's longest in aspect ratio.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>But for greater control over the shapes of cells, it might be desirable to choose a 4??3 set of cells instead of 3??4 even if the panel's own aspect ratio is "portrait."</source>
          <target state="new">But for greater control over the shapes of cells, it might be desirable to choose a 4??3 set of cells instead of 3??4 even if the panel's own aspect ratio is "portrait."</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>So we'll add an optional dependency property that the panel consumer can set to control that behavior.</source>
          <target state="new">So we'll add an optional dependency property that the panel consumer can set to control that behavior.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Here's the dependency property definition, which is very basic:</source>
          <target state="new">Here's the dependency property definition, which is very basic:</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>And here's how using <ph id="ph1">`UseOppositeRCRatio`</ph> impacts the measure logic.</source>
          <target state="new">And here's how using <ph id="ph1">`UseOppositeRCRatio`</ph> impacts the measure logic.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Really all it's doing is changing how <ph id="ph1">`rowcount`</ph> and <ph id="ph2">`colcount`</ph> are derived from <ph id="ph3">`maxrc`</ph> and the true aspect ratio, and there are corresponding size differences for each cell because of that.</source>
          <target state="new">Really all it's doing is changing how <ph id="ph1">`rowcount`</ph> and <ph id="ph2">`colcount`</ph> are derived from <ph id="ph3">`maxrc`</ph> and the true aspect ratio, and there are corresponding size differences for each cell because of that.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>When <ph id="ph1">`UseOppositeRCRatio`</ph> is <bpt id="p1">**</bpt>true<ept id="p1">**</ept>, it inverts the value of the true aspect ratio before using it for row and column counts.</source>
          <target state="new">When <ph id="ph1">`UseOppositeRCRatio`</ph> is <bpt id="p1">**</bpt>true<ept id="p1">**</ept>, it inverts the value of the true aspect ratio before using it for row and column counts.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The scenario for</source>
          <target state="new">The scenario for</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The particular scenario for <ph id="ph1">`BoxPanel`</ph> is that it's a panel where one of the main determinants of how to divide space is by knowing the number of child items, and dividing the known available space for the panel.</source>
          <target state="new">The particular scenario for <ph id="ph1">`BoxPanel`</ph> is that it's a panel where one of the main determinants of how to divide space is by knowing the number of child items, and dividing the known available space for the panel.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>Panels are innately rectangle shapes.</source>
          <target state="new">Panels are innately rectangle shapes.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>Many panels operate by dividing that rectangle space into further rectangles; that's what <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Grid<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242704)</ept> does for its cells.</source>
          <target state="new">Many panels operate by dividing that rectangle space into further rectangles; that's what <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Grid<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242704)</ept> does for its cells.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">**</bpt>Grid<ept id="p1">**</ept>'s case, the size of the cells is set by <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ColumnDefinition<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br209324)</ept> and <bpt id="p4">[</bpt><bpt id="p5">**</bpt>RowDefinition<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br227606)</ept> values, and elements declare the exact cell they go into with <bpt id="p6">[</bpt><bpt id="p7">**</bpt>Grid.Row<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/hh759795)</ept> and <bpt id="p8">[</bpt><bpt id="p9">**</bpt>Grid.Column<ept id="p9">**</ept><ept id="p8">](https://msdn.microsoft.com/library/windows/apps/hh759774)</ept> attached properties.</source>
          <target state="new">In <bpt id="p1">**</bpt>Grid<ept id="p1">**</ept>'s case, the size of the cells is set by <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ColumnDefinition<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br209324)</ept> and <bpt id="p4">[</bpt><bpt id="p5">**</bpt>RowDefinition<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br227606)</ept> values, and elements declare the exact cell they go into with <bpt id="p6">[</bpt><bpt id="p7">**</bpt>Grid.Row<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/hh759795)</ept> and <bpt id="p8">[</bpt><bpt id="p9">**</bpt>Grid.Column<ept id="p9">**</ept><ept id="p8">](https://msdn.microsoft.com/library/windows/apps/hh759774)</ept> attached properties.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Getting good layout from a <bpt id="p1">**</bpt>Grid<ept id="p1">**</ept> usually requires knowing the number of child elements beforehand, so that there are enough cells and each child element sets its attached properties to fit into its own cell.</source>
          <target state="new">Getting good layout from a <bpt id="p1">**</bpt>Grid<ept id="p1">**</ept> usually requires knowing the number of child elements beforehand, so that there are enough cells and each child element sets its attached properties to fit into its own cell.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>But what if the number of children is dynamic?</source>
          <target state="new">But what if the number of children is dynamic?</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>That's certainly possible; your app code can add items to collections, in response to any dynamic run-time condition you consider to be important enough to be worth updating your UI.</source>
          <target state="new">That's certainly possible; your app code can add items to collections, in response to any dynamic run-time condition you consider to be important enough to be worth updating your UI.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>If you're using data binding to backing collections/business objects, getting such updates and updating the UI is handled automatically, so that's often the preferred technique (see <bpt id="p1">[</bpt>Data binding in depth<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/mt210946)</ept>).</source>
          <target state="new">If you're using data binding to backing collections/business objects, getting such updates and updating the UI is handled automatically, so that's often the preferred technique (see <bpt id="p1">[</bpt>Data binding in depth<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/mt210946)</ept>).</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>But not all app scenarios lend themselves to data binding.</source>
          <target state="new">But not all app scenarios lend themselves to data binding.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Sometimes, you need to create new UI elements at runtime and make them visible.</source>
          <target state="new">Sometimes, you need to create new UI elements at runtime and make them visible.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>is for this scenario.</source>
          <target state="new">is for this scenario.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>A changing number of child items is no problem for <ph id="ph1">`BoxPanel`</ph> because it's using the child count in calculations, and adjusts both the existing and new child elements into a new layout so they all fit.</source>
          <target state="new">A changing number of child items is no problem for <ph id="ph1">`BoxPanel`</ph> because it's using the child count in calculations, and adjusts both the existing and new child elements into a new layout so they all fit.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>An advanced scenario for extending <ph id="ph1">`BoxPanel`</ph> further (not shown here) could both accommodate dynamic children and use a child's <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DesiredSize<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> as a stronger factor for the sizing of individual cells.</source>
          <target state="new">An advanced scenario for extending <ph id="ph1">`BoxPanel`</ph> further (not shown here) could both accommodate dynamic children and use a child's <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DesiredSize<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208921)</ept> as a stronger factor for the sizing of individual cells.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>This scenario might use varying row or column sizes or non-grid shapes so that there's less "wasted" space.</source>
          <target state="new">This scenario might use varying row or column sizes or non-grid shapes so that there's less "wasted" space.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>This requires a strategy for how multiple rectangles of various sizes and aspect ratios can all fit into a containing rectangle both for aesthetics and smallest size.</source>
          <target state="new">This requires a strategy for how multiple rectangles of various sizes and aspect ratios can all fit into a containing rectangle both for aesthetics and smallest size.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>doesn't do that; it's using a simpler technique for dividing space.</source>
          <target state="new">doesn't do that; it's using a simpler technique for dividing space.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>'s technique is to determine the least square number that's greater than the child count.</source>
          <target state="new">'s technique is to determine the least square number that's greater than the child count.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>For example, 9 items would fit in a 3??3 square.</source>
          <target state="new">For example, 9 items would fit in a 3??3 square.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>10 items require a 4??4 square.</source>
          <target state="new">10 items require a 4??4 square.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>However, you can often fit items while still removing one row or column of the starting square, to save space.</source>
          <target state="new">However, you can often fit items while still removing one row or column of the starting square, to save space.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>In the count=10 example, that fits in a 4??3 or 3??4 rectangle.</source>
          <target state="new">In the count=10 example, that fits in a 4??3 or 3??4 rectangle.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>You might wonder why the panel wouldn't instead choose 5??2 for 10 items, because that fits the item number neatly.</source>
          <target state="new">You might wonder why the panel wouldn't instead choose 5??2 for 10 items, because that fits the item number neatly.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>However, in practice, panels are sized as rectangles that seldom have a strongly oriented aspect ratio.</source>
          <target state="new">However, in practice, panels are sized as rectangles that seldom have a strongly oriented aspect ratio.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The least-squares technique is a way to bias the sizing logic to work well with typical layout shapes and not encourage sizing where the cell shapes get odd aspect ratios.</source>
          <target state="new">The least-squares technique is a way to bias the sizing logic to work well with typical layout shapes and not encourage sizing where the cell shapes get odd aspect ratios.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>????</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>????</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
          <target state="new">This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>If you???re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id="p1">[</bpt>archived documentation<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.</source>
          <target state="new">If you???re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id="p1">[</bpt>archived documentation<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>??</source>
          <target state="new">??</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Reference<ept id="p1">**</ept><ph id="ph1">
*</ph><bpt id="p2">[</bpt><bpt id="p3">**</bpt>FrameworkElement.ArrangeOverride<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept></source>
          <target state="new"><bpt id="p1">**</bpt>Reference<ept id="p1">**</ept><ph id="ph1">
*</ph><bpt id="p2">[</bpt><bpt id="p3">**</bpt>FrameworkElement.ArrangeOverride<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208711)</ept></target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>FrameworkElement.MeasureOverride</source>
          <target state="new">FrameworkElement.MeasureOverride</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>Panel</source>
          <target state="new">Panel</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>Concepts</source>
          <target state="new">Concepts</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>Alignment, margin, and padding</source>
          <target state="new">Alignment, margin, and padding</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>