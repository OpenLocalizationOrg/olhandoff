<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="zh-cn" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">windows-apps-src\xbox-apps\cpusets-games.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">f125ae7e268a8d35b477a1557c498762869f859b</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-781aacf</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>CPUSets for game development</source>
          <target>CPUSets for game development</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>This article provides an overview of the CPUSets API new to the Universal Windows Platform (UWP), and covers the core information pertinent to game and application development.</source>
          <target>This article provides an overview of the CPUSets API new to the Universal Windows Platform (UWP), and covers the core information pertinent to game and application development.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>CPUSets for game development</source>
          <target>CPUSets for game development</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>Introduction</source>
          <target>Introduction</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source>The Universal Windows Platform (UWP) is at the core of a wide range of consumer electronic devices.</source>
          <target>The Universal Windows Platform (UWP) is at the core of a wide range of consumer electronic devices.</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>As such, it requires a general purpose API to address the needs of all types of applications from games to embedded apps to enterprise software running on servers.</source>
          <target>As such, it requires a general purpose API to address the needs of all types of applications from games to embedded apps to enterprise software running on servers.</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>By leveraging the right information provided by the API, you can ensure your game runs at its best on any hardware.</source>
          <target>By leveraging the right information provided by the API, you can ensure your game runs at its best on any hardware.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source>CPUSets API</source>
          <target>CPUSets API</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source>The CPUSets API provides control over which CPU sets are available for threads to be scheduled on.</source>
          <target>The CPUSets API provides control over which CPU sets are available for threads to be scheduled on.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>Two functions are available to control where threads are scheduled:</source>
          <target>Two functions are available to control where threads are scheduled:</target>
        </segment>
      </unit>
      <unit id="111">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetProcessDefaultCpuSets</pc> – This function can be used to specify which CPU sets new threads may run on if they are not assigned to specific CPU sets.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetProcessDefaultCpuSets</pc> – This function can be used to specify which CPU sets new threads may run on if they are not assigned to specific CPU sets.</target>
        </segment>
      </unit>
      <unit id="112">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadSelectedCpuSets</pc> – This function allows you to limit the CPU sets a specific thread may run on.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadSelectedCpuSets</pc> – This function allows you to limit the CPU sets a specific thread may run on.</target>
        </segment>
      </unit>
      <unit id="113">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>If the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetProcessDefaultCpuSets</pc> function is never used, newly created threads may be scheduled on any CPU set available to your process.</source>
          <target>If the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetProcessDefaultCpuSets</pc> function is never used, newly created threads may be scheduled on any CPU set available to your process.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source>This section goes over the basics of the CPUSets API.</source>
          <target>This section goes over the basics of the CPUSets API.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source>GetSystemCpuSetInformation</source>
          <target>GetSystemCpuSetInformation</target>
        </segment>
      </unit>
      <unit id="116">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The first API used for gathering information is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetSystemCpuSetInformation</pc> function.</source>
          <target>The first API used for gathering information is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetSystemCpuSetInformation</pc> function.</target>
        </segment>
      </unit>
      <unit id="117">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>This function populates information in an array of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SYSTEM_CPU_SET_INFORMATION</pc> objects provided by title code.</source>
          <target>This function populates information in an array of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SYSTEM_CPU_SET_INFORMATION</pc> objects provided by title code.</target>
        </segment>
      </unit>
      <unit id="118">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The memory for the destination must be allocated by game code, the size of which is determined by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetSystemCpuSetInformation</pc> itself.</source>
          <target>The memory for the destination must be allocated by game code, the size of which is determined by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetSystemCpuSetInformation</pc> itself.</target>
        </segment>
      </unit>
      <unit id="119">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>This requires two calls to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetSystemCpuSetInformation</pc> as demonstrated in the following example.</source>
          <target>This requires two calls to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetSystemCpuSetInformation</pc> as demonstrated in the following example.</target>
        </segment>
      </unit>
      <unit id="120">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Each instance of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SYSTEM_CPU_SET_INFORMATION</pc> returned contains information about one unique processing unit, also known as a CPU set.</source>
          <target>Each instance of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SYSTEM_CPU_SET_INFORMATION</pc> returned contains information about one unique processing unit, also known as a CPU set.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>This does not necessarily mean that it represents a unique physical piece of hardware.</source>
          <target>This does not necessarily mean that it represents a unique physical piece of hardware.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>CPUs that utilize hyperthreading will have multiple logical cores running on a single physical processing core.</source>
          <target>CPUs that utilize hyperthreading will have multiple logical cores running on a single physical processing core.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>Scheduling multiple threads on different logical cores that reside on the same physical core allows hardware-level resource optimization that would otherwise require extra work to be done at the kernel level.</source>
          <target>Scheduling multiple threads on different logical cores that reside on the same physical core allows hardware-level resource optimization that would otherwise require extra work to be done at the kernel level.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>Two threads scheduled on separate logical cores on the same physical core must share CPU time, but would run more efficiently than if they were scheduled to the same logical core.</source>
          <target>Two threads scheduled on separate logical cores on the same physical core must share CPU time, but would run more efficiently than if they were scheduled to the same logical core.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>SYSTEM_CPU_SET_INFORMATION</source>
          <target>SYSTEM_CPU_SET_INFORMATION</target>
        </segment>
      </unit>
      <unit id="126">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The information in each instance of this data structure returned from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetSystemCpuSetInformation</pc> contains information about a unique processing unit that threads may be scheduled on.</source>
          <target>The information in each instance of this data structure returned from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetSystemCpuSetInformation</pc> contains information about a unique processing unit that threads may be scheduled on.</target>
        </segment>
      </unit>
      <unit id="127">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Given the possible range of target devices, a lot of the information in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SYSTEM_CPU_SET_INFORMATION</pc> data structure may not applicable for game development.</source>
          <target>Given the possible range of target devices, a lot of the information in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SYSTEM_CPU_SET_INFORMATION</pc> data structure may not applicable for game development.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source>Table 1 provides an explanation of data members that are useful for game development.</source>
          <target>Table 1 provides an explanation of data members that are useful for game development.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source>Table 1.</source>
          <target>Table 1.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source>Data members useful for game development.</source>
          <target>Data members useful for game development.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>Member name</source>
          <target>Member name</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>Data type</source>
          <target>Data type</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>Type</source>
          <target>Type</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source>CPU_SET_INFORMATION_TYPE</source>
          <target>CPU_SET_INFORMATION_TYPE</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source>The type of information in the structure.</source>
          <target>The type of information in the structure.</target>
        </segment>
      </unit>
      <unit id="137">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>If the value of this is not <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CpuSetInformation</pc>, it should be ignored.</source>
          <target>If the value of this is not <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CpuSetInformation</pc>, it should be ignored.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source>Id</source>
          <target>Id</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source>unsigned long</source>
          <target>unsigned long</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source>The ID of the specified CPU set.</source>
          <target>The ID of the specified CPU set.</target>
        </segment>
      </unit>
      <unit id="141">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>This is the ID that should be used with CPU set functions such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadSelectedCpuSets</pc>.</source>
          <target>This is the ID that should be used with CPU set functions such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadSelectedCpuSets</pc>.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source>Group</source>
          <target>Group</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source>unsigned short</source>
          <target>unsigned short</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>Specifies the “processor group” of the CPU set.</source>
          <target>Specifies the “processor group” of the CPU set.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source>Processor groups allow a PC to have more than 64 logical cores, and allow for hot swapping of CPUs while the system is running.</source>
          <target>Processor groups allow a PC to have more than 64 logical cores, and allow for hot swapping of CPUs while the system is running.</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source>It is uncommon to see a PC that is not a server with more than one group.</source>
          <target>It is uncommon to see a PC that is not a server with more than one group.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source>Unless you are writing applications meant to run on large servers or server farms, it is best to use CPU sets in a single group because most consumer PCs will only have one processor group.</source>
          <target>Unless you are writing applications meant to run on large servers or server farms, it is best to use CPU sets in a single group because most consumer PCs will only have one processor group.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source>All other values in this structure are relative to the Group.</source>
          <target>All other values in this structure are relative to the Group.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>LogicalProcessorIndex</source>
          <target>LogicalProcessorIndex</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source>unsigned char</source>
          <target>unsigned char</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source>Group relative index of the CPU set</source>
          <target>Group relative index of the CPU set</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>CoreIndex</source>
          <target>CoreIndex</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source>unsigned char</source>
          <target>unsigned char</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>Group relative index of the physical CPU core where the CPU set is located</source>
          <target>Group relative index of the physical CPU core where the CPU set is located</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>LastLevelCacheIndex</source>
          <target>LastLevelCacheIndex</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source>unsigned char</source>
          <target>unsigned char</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source>Group relative index of the last cache associated with this CPU set.</source>
          <target>Group relative index of the last cache associated with this CPU set.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>This is the slowest cache unless the system utilizes NUMA nodes, usually the L2 or L3 cache.</source>
          <target>This is the slowest cache unless the system utilizes NUMA nodes, usually the L2 or L3 cache.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>The other data members provide information that is unlikely to describe CPUs in consumer PCs or other consumer devices and is unlikely to be useful.</source>
          <target>The other data members provide information that is unlikely to describe CPUs in consumer PCs or other consumer devices and is unlikely to be useful.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source>The information provided by the data returned can then be used to organize threads in various ways.</source>
          <target>The information provided by the data returned can then be used to organize threads in various ways.</target>
        </segment>
      </unit>
      <unit id="161">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#considerations-for-game-development)</data>
        </originalData>
        <segment state="initial">
          <source>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Considerations for game development</pc> section of this white paper details a few ways to leverage this data to optimize thread allocation.</source>
          <target>The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Considerations for game development</pc> section of this white paper details a few ways to leverage this data to optimize thread allocation.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source>The following are some examples of the type of information gathered from UWP applications running on various types of hardware.</source>
          <target>The following are some examples of the type of information gathered from UWP applications running on various types of hardware.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source>Table 2.</source>
          <target>Table 2.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source>Information returned from a UWP app running on a Microsoft Lumia 950.</source>
          <target>Information returned from a UWP app running on a Microsoft Lumia 950.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source>This is an example of a system that has multiple last level caches.</source>
          <target>This is an example of a system that has multiple last level caches.</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source>The Lumia 950 features a Qualcomm 808 Snapdragon process that contains a dual core ARM Cortex A57 and quad core ARM Cortex A53 CPUs.</source>
          <target>The Lumia 950 features a Qualcomm 808 Snapdragon process that contains a dual core ARM Cortex A57 and quad core ARM Cortex A53 CPUs.</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source>Table 2</source>
          <target>Table 2</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source>Table 3.</source>
          <target>Table 3.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>Information returned from a UWP app running on a typical PC.</source>
          <target>Information returned from a UWP app running on a typical PC.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source>This is an example of a system that uses hyperthreading; each physical core has two logical cores onto which threads can be scheduled.</source>
          <target>This is an example of a system that uses hyperthreading; each physical core has two logical cores onto which threads can be scheduled.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source>In this case, the system contained an Intel Xenon CPU E5-2620.</source>
          <target>In this case, the system contained an Intel Xenon CPU E5-2620.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source>Table 3</source>
          <target>Table 3</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source>Table 4.</source>
          <target>Table 4.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source>Information returned from a UWP app running on a quad core Microsoft Surface Pro 4.</source>
          <target>Information returned from a UWP app running on a quad core Microsoft Surface Pro 4.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source>This system had an Intel Core i5-6300 CPU.</source>
          <target>This system had an Intel Core i5-6300 CPU.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source>Table 4</source>
          <target>Table 4</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source>SetThreadSelectedCpuSets</source>
          <target>SetThreadSelectedCpuSets</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source>Now that information about the CPU sets is available, it can be used to organize threads.</source>
          <target>Now that information about the CPU sets is available, it can be used to organize threads.</target>
        </segment>
      </unit>
      <unit id="179">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>The handle of a thread created with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateThread</pc> is passed to this function along with an array of IDs of the CPU sets that the thread can be scheduled on.</source>
          <target>The handle of a thread created with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">CreateThread</pc> is passed to this function along with an array of IDs of the CPU sets that the thread can be scheduled on.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source>One example of its usage is demonstrated in the following code.</source>
          <target>One example of its usage is demonstrated in the following code.</target>
        </segment>
      </unit>
      <unit id="181">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>In this example, a thread is created based on a function declared as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AudioThread</pc>.</source>
          <target>In this example, a thread is created based on a function declared as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AudioThread</pc>.</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source>This thread is then allowed to be scheduled on one of two CPU sets.</source>
          <target>This thread is then allowed to be scheduled on one of two CPU sets.</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source>Thread ownership of the CPU set is not exclusive.</source>
          <target>Thread ownership of the CPU set is not exclusive.</target>
        </segment>
      </unit>
      <unit id="184">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>Threads that are created without being locked to a specific CPU set may take time from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AudioThread</pc>.</source>
          <target>Threads that are created without being locked to a specific CPU set may take time from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AudioThread</pc>.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source>Likewise, other threads created may also be locked to one or both of these CPU sets at a later time.</source>
          <target>Likewise, other threads created may also be locked to one or both of these CPU sets at a later time.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source>SetProcessDefaultCpuSets</source>
          <target>SetProcessDefaultCpuSets</target>
        </segment>
      </unit>
      <unit id="187">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>The converse to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadSelectedCpuSets</pc> is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetProcessDefaultCpuSets</pc>.</source>
          <target>The converse to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadSelectedCpuSets</pc> is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetProcessDefaultCpuSets</pc>.</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source>When threads are created, they do not need to be locked into certain CPU sets.</source>
          <target>When threads are created, they do not need to be locked into certain CPU sets.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source>If you do not want these threads to run on specific CPU sets (those used by your render thread or audio thread for example), you can use this function to specify which cores these threads are allowed to be scheduled on.</source>
          <target>If you do not want these threads to run on specific CPU sets (those used by your render thread or audio thread for example), you can use this function to specify which cores these threads are allowed to be scheduled on.</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source>Considerations for game development</source>
          <target>Considerations for game development</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source>As we've seen, the CPUSets API provides a lot of information and flexibility when it comes to scheduling threads.</source>
          <target>As we've seen, the CPUSets API provides a lot of information and flexibility when it comes to scheduling threads.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source>Instead of taking the bottom-up approach of trying to find uses for this data, it is more effective to take the top-down approach of finding how the data can be used to accommodate common scenarios.</source>
          <target>Instead of taking the bottom-up approach of trying to find uses for this data, it is more effective to take the top-down approach of finding how the data can be used to accommodate common scenarios.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source>Working with time critical threads and hyperthreading</source>
          <target>Working with time critical threads and hyperthreading</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source>This method is effective if your game has a few threads that must run in real time along with other worker threads that require relatively little CPU time.</source>
          <target>This method is effective if your game has a few threads that must run in real time along with other worker threads that require relatively little CPU time.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source>Some tasks, like continuous background music, must run without interruption for an optimal gaming experience.</source>
          <target>Some tasks, like continuous background music, must run without interruption for an optimal gaming experience.</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source>Even a single frame of starvation for an audio thread may cause popping or glitching, so it is critical that it receives the necessary amount of CPU time every frame.</source>
          <target>Even a single frame of starvation for an audio thread may cause popping or glitching, so it is critical that it receives the necessary amount of CPU time every frame.</target>
        </segment>
      </unit>
      <unit id="197">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadSelectedCpuSets</pc> in conjunction with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetProcessDefaultCpuSets</pc> can ensure your heavy threads remain uninterrupted by any worker threads.</source>
          <target>Using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadSelectedCpuSets</pc> in conjunction with <pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetProcessDefaultCpuSets</pc> can ensure your heavy threads remain uninterrupted by any worker threads.</target>
        </segment>
      </unit>
      <unit id="198">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadSelectedCpuSets</pc> can be used to assign your heavy threads to specific CPU sets.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetThreadSelectedCpuSets</pc> can be used to assign your heavy threads to specific CPU sets.</target>
        </segment>
      </unit>
      <unit id="199">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetProcessDefaultCpuSets</pc> can then be used to make sure any unassigned threads created are put on other CPU sets.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">SetProcessDefaultCpuSets</pc> can then be used to make sure any unassigned threads created are put on other CPU sets.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source>In the case of CPUs that utilize hyperthreading, it's also important to account for logical cores on the same physical core.</source>
          <target>In the case of CPUs that utilize hyperthreading, it's also important to account for logical cores on the same physical core.</target>
        </segment>
      </unit>
      <unit id="201">
        <segment state="initial">
          <source>Worker threads should not be allowed to run on logical cores that share the same physical core as a thread that you want to run with real time responsiveness.</source>
          <target>Worker threads should not be allowed to run on logical cores that share the same physical core as a thread that you want to run with real time responsiveness.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source>The following code demonstrates how to determine whether a PC uses hyperthreading.</source>
          <target>The following code demonstrates how to determine whether a PC uses hyperthreading.</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source>If the system utilizes hyperthreading, it is important that the set of default CPU sets does not include any logical cores on the same physical core as any real time threads.</source>
          <target>If the system utilizes hyperthreading, it is important that the set of default CPU sets does not include any logical cores on the same physical core as any real time threads.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source>If the system is not hyperthreading, it is only necessary to make sure that the default CPU sets do not include the same core as the CPU set running your audio thread.</source>
          <target>If the system is not hyperthreading, it is only necessary to make sure that the default CPU sets do not include the same core as the CPU set running your audio thread.</target>
        </segment>
      </unit>
      <unit id="205">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](#additional-resources)</data>
        </originalData>
        <segment state="initial">
          <source>An example of organizing threads based on physical cores can be found in the CPUSets sample available on the GitHub repository linked in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Additional resources</pc> section.</source>
          <target>An example of organizing threads based on physical cores can be found in the CPUSets sample available on the GitHub repository linked in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Additional resources</pc> section.</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source>Reducing the cost of cache coherence with last level cache</source>
          <target>Reducing the cost of cache coherence with last level cache</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source>Cache coherency is the concept that cached memory is the same across multiple hardware resources that act on the same data.</source>
          <target>Cache coherency is the concept that cached memory is the same across multiple hardware resources that act on the same data.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source>If threads are scheduled on different cores, but work on the same data, they may be working on separate copies of that data in different caches.</source>
          <target>If threads are scheduled on different cores, but work on the same data, they may be working on separate copies of that data in different caches.</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source>In order to get correct results, these caches must be kept coherent with each other.</source>
          <target>In order to get correct results, these caches must be kept coherent with each other.</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source>Maintaining coherency between multiple caches is relatively expensive, but necessary for any multi-core system to operate.</source>
          <target>Maintaining coherency between multiple caches is relatively expensive, but necessary for any multi-core system to operate.</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source>Additionally, it is completely out of the control of client code; the underlying system works independently to keep caches up to date by accessing shared memory resources between cores.</source>
          <target>Additionally, it is completely out of the control of client code; the underlying system works independently to keep caches up to date by accessing shared memory resources between cores.</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source>If your game has multiple threads that share an especially large amount of data, you can minimize the cost of cache coherency by ensuring that they are scheduled on CPU sets that share a last level cache.</source>
          <target>If your game has multiple threads that share an especially large amount of data, you can minimize the cost of cache coherency by ensuring that they are scheduled on CPU sets that share a last level cache.</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source>The last level cache is the slowest cache available to a core on systems that do not utilize NUMA nodes.</source>
          <target>The last level cache is the slowest cache available to a core on systems that do not utilize NUMA nodes.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source>It is extremely rare for a gaming PC to utilize NUMA nodes.</source>
          <target>It is extremely rare for a gaming PC to utilize NUMA nodes.</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source>If cores do not share a last level cache, maintaining coherency would require accessing higher level, and therefore slower, memory resources.</source>
          <target>If cores do not share a last level cache, maintaining coherency would require accessing higher level, and therefore slower, memory resources.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source>Locking two threads to separate CPU sets that share a cache and a physical core may provide even better performance than scheduling them on separate physical cores if they do not require more than 50% of the time in any given frame.</source>
          <target>Locking two threads to separate CPU sets that share a cache and a physical core may provide even better performance than scheduling them on separate physical cores if they do not require more than 50% of the time in any given frame.</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source>This code example shows how to determine whether threads that communicate frequently can share a last level cache.</source>
          <target>This code example shows how to determine whether threads that communicate frequently can share a last level cache.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source>The cache layout illustrated in Figure 1 is an example of the type of layout you might see from a system.</source>
          <target>The cache layout illustrated in Figure 1 is an example of the type of layout you might see from a system.</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source>This figure is an illustration of the caches found in a Microsoft Lumia 950.</source>
          <target>This figure is an illustration of the caches found in a Microsoft Lumia 950.</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source>Inter-thread communication occurring between CPU 256 and CPU 260 would incur significant overhead because it would require the system to keep their L2 caches coherent.</source>
          <target>Inter-thread communication occurring between CPU 256 and CPU 260 would incur significant overhead because it would require the system to keep their L2 caches coherent.</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source>Figure 1.</source>
          <target>Figure 1.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source>Cache architecture found on a Microsoft Lumia 950 device.</source>
          <target>Cache architecture found on a Microsoft Lumia 950 device.</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source>Lumia 950 cache</source>
          <target>Lumia 950 cache</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source>Summary</source>
          <target>Summary</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source>The CPUSets API available for UWP development provides a considerable amount of information and control over your multithreading options.</source>
          <target>The CPUSets API available for UWP development provides a considerable amount of information and control over your multithreading options.</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source>The added complexities compared to previous multithreaded APIs for Windows development has some learning curve, but the increased flexibility ultimately allows for better performance across a range of consumer PCs and other hardware targets.</source>
          <target>The added complexities compared to previous multithreaded APIs for Windows development has some learning curve, but the increased flexibility ultimately allows for better performance across a range of consumer PCs and other hardware targets.</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source>Additional resources</source>
          <target>Additional resources</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source>CPU Sets (MSDN)</source>
          <target>CPU Sets (MSDN)</target>
        </segment>
      </unit>
      <unit id="229">
        <segment state="initial">
          <source>CPUSets sample provided by ATG</source>
          <target>CPUSets sample provided by ATG</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>