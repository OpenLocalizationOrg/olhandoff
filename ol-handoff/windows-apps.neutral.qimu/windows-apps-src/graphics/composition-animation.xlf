<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="zh-cn" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">windows-apps-src\graphics\composition-animation.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">9d0c05c6c75ce5ee42b56e3b94235a7cf3631f2c</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-781aacf</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>Composition animations</source>
          <target>Composition animations</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>Many composition object and effect properties can be animated using key frame and expression animations allowing properties of a UI element to change over time or based on a calculation.</source>
          <target>Many composition object and effect properties can be animated using key frame and expression animations allowing properties of a UI element to change over time or based on a calculation.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>Composition animations</source>
          <target>Composition animations</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>Updated for UWP apps on Windows 10.</source>
          <target>Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="105">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></source>
          <target>For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc></target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>The Windows.UI.Composition WinRT API allows you to create, animate, transform and manipulate compositor objects in a unified API layer.</source>
          <target>The Windows.UI.Composition WinRT API allows you to create, animate, transform and manipulate compositor objects in a unified API layer.</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>Composition Animations provide a powerful and efficient way to run animations in your application UI.</source>
          <target>Composition Animations provide a powerful and efficient way to run animations in your application UI.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source>They have been designed from the ground up to ensure that your animations run at 60 FPS independent of the UI thread and to give you the flexibility to build amazing experiences using not only time, but input and other properties, to drive animations.</source>
          <target>They have been designed from the ground up to ensure that your animations run at 60 FPS independent of the UI thread and to give you the flexibility to build amazing experiences using not only time, but input and other properties, to drive animations.</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source>This topic provides an overview of the functionality available that allows you to animate properties of the Composition Object.</source>
          <target>This topic provides an overview of the functionality available that allows you to animate properties of the Composition Object.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>This document assumes you are familiar with the basics of the Visual Layer structure.</source>
          <target>This document assumes you are familiar with the basics of the Visual Layer structure.</target>
        </segment>
      </unit>
      <unit id="111">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](./composition-visual-tree.md)</data>
        </originalData>
        <segment state="initial">
          <source>For more information, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">see here</pc>.</source>
          <target>For more information, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">see here</pc>.</target>
        </segment>
      </unit>
      <unit id="112">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>There are two types of Composition Animations: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KeyFrame Animations</pc>, and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Expression Animations</pc></source>
          <target>There are two types of Composition Animations: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KeyFrame Animations</pc>, and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Expression Animations</pc></target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source>Types of Composition Animations</source>
          <target>Types of Composition Animations</target>
        </segment>
      </unit>
      <unit id="114">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KeyFrame Animations</pc> provide your traditional time-driven, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">frame-by-frame</pc> animation experiences.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">KeyFrame Animations</pc> provide your traditional time-driven, <pc dataRefEnd="id4" dataRefStart="id3" id="p2">frame-by-frame</pc> animation experiences.</target>
        </segment>
      </unit>
      <unit id="115">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Developers can explicitly define <pc dataRefEnd="id2" dataRefStart="id1" id="p1">control points</pc> describing values an animating property needs to be at specific points in the animation timeline.</source>
          <target>Developers can explicitly define <pc dataRefEnd="id2" dataRefStart="id1" id="p1">control points</pc> describing values an animating property needs to be at specific points in the animation timeline.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source>More importantly you are able to use Easing Functions (otherwise called Interpolators) to describe how to transition between these control points.</source>
          <target>More importantly you are able to use Easing Functions (otherwise called Interpolators) to describe how to transition between these control points.</target>
        </segment>
      </unit>
      <unit id="117">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Expression Animations</pc> are a new type of animation introduced in the Visual Layer with the Windows 10 November Update (Build 10586).</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Expression Animations</pc> are a new type of animation introduced in the Visual Layer with the Windows 10 November Update (Build 10586).</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source>The idea behind Expression Animations is a developer can create mathematical relationships between Visual properties and discrete values that will get evaluated and updated every frame.</source>
          <target>The idea behind Expression Animations is a developer can create mathematical relationships between Visual properties and discrete values that will get evaluated and updated every frame.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source>Developers can reference properties on Composition objects or Property Sets, use mathematical function helpers and even reference Input to derive these mathematical relationships.</source>
          <target>Developers can reference properties on Composition objects or Property Sets, use mathematical function helpers and even reference Input to derive these mathematical relationships.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source>Expressions make experiences like Parallax and Sticky headers possible and smooth on the Windows platform.</source>
          <target>Expressions make experiences like Parallax and Sticky headers possible and smooth on the Windows platform.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>Why Composition Animations?</source>
          <target>Why Composition Animations?</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>Performance</source>
          <target>Performance</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>When building Universal Windows applications, most developer code runs on the UI thread.</source>
          <target>When building Universal Windows applications, most developer code runs on the UI thread.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>Thus, to ensure that the animations run smoothly across the different device categories, the system performs the animation calculations and work on an independent thread in order to maintain 60 FPS.</source>
          <target>Thus, to ensure that the animations run smoothly across the different device categories, the system performs the animation calculations and work on an independent thread in order to maintain 60 FPS.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>This means developers can count on the system to provide smooth animations while their applications perform other complex operations for advanced user experiences.</source>
          <target>This means developers can count on the system to provide smooth animations while their applications perform other complex operations for advanced user experiences.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source>Possibilities</source>
          <target>Possibilities</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source>The goal for Composition Animations in the Visual Layer is to make beautiful UI possible.</source>
          <target>The goal for Composition Animations in the Visual Layer is to make beautiful UI possible.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source>We want to provide developers with the flexibility and different types of animations to build out their amazing ideas and push the envelope on UWP forward</source>
          <target>We want to provide developers with the flexibility and different types of animations to build out their amazing ideas and push the envelope on UWP forward</target>
        </segment>
      </unit>
      <unit id="129">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/?LinkID=789439)</data>
        </originalData>
        <segment state="initial">
          <source>(You can also check out the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Composition GitHub</pc> for samples on how to use the APIs and some higher fidelity samples of the APIs in action)</source>
          <target>(You can also check out the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Composition GitHub</pc> for samples on how to use the APIs and some higher fidelity samples of the APIs in action)</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source>Templating</source>
          <target>Templating</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>All Composition Animations in the Visual Layer are templates – this means that developers can use an animation on multiple objects without the need to create separate animations.</source>
          <target>All Composition Animations in the Visual Layer are templates – this means that developers can use an animation on multiple objects without the need to create separate animations.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>This allows developers to use the same animation and tweak properties or parameters to meet some other needs without the worry of obstructing the previous uses.</source>
          <target>This allows developers to use the same animation and tweak properties or parameters to meet some other needs without the worry of obstructing the previous uses.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>What can you animate with Composition Animations?</source>
          <target>What can you animate with Composition Animations?</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>Composition Animations can be applied to most properties of Composition objects such as Visual, and InsetClip.</source>
          <target>Composition Animations can be applied to most properties of Composition objects such as Visual, and InsetClip.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source>You can also apply Composition Animations to Composition Effects and Property Sets.</source>
          <target>You can also apply Composition Animations to Composition Effects and Property Sets.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source>When choosing what to animate, take note of the type – use this to determine what type of KeyFrame Animation you construct or what type your Expression must resolve to.</source>
          <target>When choosing what to animate, take note of the type – use this to determine what type of KeyFrame Animation you construct or what type your Expression must resolve to.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>Visual</source>
          <target>Visual</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source>Animatable Visual Properties</source>
          <target>Animatable Visual Properties</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source>Type</source>
          <target>Type</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source>AnchorPoint</source>
          <target>AnchorPoint</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source>CenterPoint</source>
          <target>CenterPoint</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source>Vector3</source>
          <target>Vector3</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>Offset</source>
          <target>Offset</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source>Vector3</source>
          <target>Vector3</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source>Opacity</source>
          <target>Opacity</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source>Orientation</source>
          <target>Orientation</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>Quaternion</source>
          <target>Quaternion</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source>RotationAngle</source>
          <target>RotationAngle</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>RotationAngleInDegrees</source>
          <target>RotationAngleInDegrees</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>RotationAxis</source>
          <target>RotationAxis</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>Vector3</source>
          <target>Vector3</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source>Scale</source>
          <target>Scale</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source>Vector3</source>
          <target>Vector3</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>Size</source>
          <target>Size</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source>TransformMatrix*</source>
          <target>TransformMatrix*</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source>Matrix4x4</source>
          <target>Matrix4x4</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source>*If you want to animate the entire TransformMatrix property as a Matrix4x4, you need to use an Expression Animation to do so.</source>
          <target>*If you want to animate the entire TransformMatrix property as a Matrix4x4, you need to use an Expression Animation to do so.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source>Otherwise, you can target individual cells of the matrix and can use either KeyFrame or Expression animations there.</source>
          <target>Otherwise, you can target individual cells of the matrix and can use either KeyFrame or Expression animations there.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source>InsetClip</source>
          <target>InsetClip</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source>Animatable InsetClip Properties</source>
          <target>Animatable InsetClip Properties</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source>Type</source>
          <target>Type</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source>BottomInset</source>
          <target>BottomInset</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>LeftInset</source>
          <target>LeftInset</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source>RightInset</source>
          <target>RightInset</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source>TopInset</source>
          <target>TopInset</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source>Visual Sub Channel Properties</source>
          <target>Visual Sub Channel Properties</target>
        </segment>
      </unit>
      <unit id="176">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>In addition to being able to animate properties of Visual, you are also able to target the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sub channel</pc> components of these properties for animations as well.</source>
          <target>In addition to being able to animate properties of Visual, you are also able to target the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">sub channel</pc> components of these properties for animations as well.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source>For example, say you simply want to animate the X Offset of a Visual rather than the entire Offset.</source>
          <target>For example, say you simply want to animate the X Offset of a Visual rather than the entire Offset.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source>The animation can either target the Vector3 Offset property, or the Scalar X component of the Offset property.</source>
          <target>The animation can either target the Vector3 Offset property, or the Scalar X component of the Offset property.</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source>In addition to being able to target an individual sub channel component of a property, you are also able to target multiple components.</source>
          <target>In addition to being able to target an individual sub channel component of a property, you are also able to target multiple components.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source>For example, you can target the X and Y component of Scale.</source>
          <target>For example, you can target the X and Y component of Scale.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source>Animatable Visual Sub Channel Properties</source>
          <target>Animatable Visual Sub Channel Properties</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source>Type</source>
          <target>Type</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source>AnchorPoint.x, y</source>
          <target>AnchorPoint.x, y</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source>AnchorPoint.xy</source>
          <target>AnchorPoint.xy</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source>CenterPoint.x, y, z</source>
          <target>CenterPoint.x, y, z</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source>CenterPoint.xy, xz, yz</source>
          <target>CenterPoint.xy, xz, yz</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source>Offset.x, y, z</source>
          <target>Offset.x, y, z</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source>Offset.xy, xz, yz</source>
          <target>Offset.xy, xz, yz</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source>RotationAxis.x, y, z</source>
          <target>RotationAxis.x, y, z</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source>RotationAxis.xy, xz, yz</source>
          <target>RotationAxis.xy, xz, yz</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source>Scale.x, y, z</source>
          <target>Scale.x, y, z</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="201">
        <segment state="initial">
          <source>Scale.xy, xz, yz</source>
          <target>Scale.xy, xz, yz</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source>Size.x, y</source>
          <target>Size.x, y</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source>Size.xy</source>
          <target>Size.xy</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source>TransformMatrix._11 ... TransformMatrix._NN,</source>
          <target>TransformMatrix._11 ... TransformMatrix._NN,</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source>TransformMatrix._11_12 ... TransformMatrix._NN_NN</source>
          <target>TransformMatrix._11_12 ... TransformMatrix._NN_NN</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source>TransformMatrix._11_12_13 ... TransformMatrix._NN_NN_NN</source>
          <target>TransformMatrix._11_12_13 ... TransformMatrix._NN_NN_NN</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source>Vector3</source>
          <target>Vector3</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source>TransformMatrix._11_12_13_14</source>
          <target>TransformMatrix._11_12_13_14</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source>Vector4</source>
          <target>Vector4</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source>Color*</source>
          <target>Color*</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source>Colors (Windows.UI)</source>
          <target>Colors (Windows.UI)</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source>*Animating the Color subchannel of the Brush property is a bit different.</source>
          <target>*Animating the Color subchannel of the Brush property is a bit different.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source>You attach StartAnimation() to the Visual.Brush, and declare the property to animate in the parameter as "Color".</source>
          <target>You attach StartAnimation() to the Visual.Brush, and declare the property to animate in the parameter as "Color".</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source>(More details about animating color discussed later)</source>
          <target>(More details about animating color discussed later)</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source>Property Sets and Effects</source>
          <target>Property Sets and Effects</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source>In addition to animating properties of Composition Visual and InsetClip, you are also able to animate properties in a PropertySet or an Effect.</source>
          <target>In addition to animating properties of Composition Visual and InsetClip, you are also able to animate properties in a PropertySet or an Effect.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source>For property sets, you define a property and store it in a Composition Property Set – that property can later be the target of an animation (and also be referenced simultaneously in another).</source>
          <target>For property sets, you define a property and store it in a Composition Property Set – that property can later be the target of an animation (and also be referenced simultaneously in another).</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source>This will be discussed in more detail in the following sections.</source>
          <target>This will be discussed in more detail in the following sections.</target>
        </segment>
      </unit>
      <unit id="224">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](./composition-effects.md)</data>
        </originalData>
        <segment state="initial">
          <source>For Effects, you are able to define graphical effects using the Composition Effects APIs (See here for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Effects Overview</pc>.</source>
          <target>For Effects, you are able to define graphical effects using the Composition Effects APIs (See here for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Effects Overview</pc>.</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source>In addition to defining Effects, you are also able to animate the property values of the Effect.</source>
          <target>In addition to defining Effects, you are also able to animate the property values of the Effect.</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source>This is done by targeting the properties component of the Brush property on Sprite Visuals.</source>
          <target>This is done by targeting the properties component of the Brush property on Sprite Visuals.</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source>Quick Formula: Getting Started with Composition Animations</source>
          <target>Quick Formula: Getting Started with Composition Animations</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source>Before diving into the details on how to construct and use the different types of animations, below is a quick, high level formula for how to put together Composition Animations.</source>
          <target>Before diving into the details on how to construct and use the different types of animations, below is a quick, high level formula for how to put together Composition Animations.</target>
        </segment>
      </unit>
      <unit id="229">
        <segment state="initial">
          <source>Decide which property, sub channel property or Effect you want to animate - make note of the type.</source>
          <target>Decide which property, sub channel property or Effect you want to animate - make note of the type.</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source>Create a new object for your animation – this will either be a KeyFrame or Expression Animation.</source>
          <target>Create a new object for your animation – this will either be a KeyFrame or Expression Animation.</target>
        </segment>
      </unit>
      <unit id="231">
        <segment state="initial">
          <source>For KeyFrame animations, make sure you create a KeyFrame Animation type that matches the type of property you want to animate.</source>
          <target>For KeyFrame animations, make sure you create a KeyFrame Animation type that matches the type of property you want to animate.</target>
        </segment>
      </unit>
      <unit id="232">
        <segment state="initial">
          <source>There is only a single type of Expression Animation.</source>
          <target>There is only a single type of Expression Animation.</target>
        </segment>
      </unit>
      <unit id="233">
        <segment state="initial">
          <source>Define the content for animation – Insert your Keyframes or define the Expression string</source>
          <target>Define the content for animation – Insert your Keyframes or define the Expression string</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source>For KeyFrame animations, make sure the value of your KeyFrames are the same type as the property you want to animate.</source>
          <target>For KeyFrame animations, make sure the value of your KeyFrames are the same type as the property you want to animate.</target>
        </segment>
      </unit>
      <unit id="235">
        <segment state="initial">
          <source>For Expression animations, make sure your Expression string will resolve to the same type as the property you want to animate.</source>
          <target>For Expression animations, make sure your Expression string will resolve to the same type as the property you want to animate.</target>
        </segment>
      </unit>
      <unit id="236">
        <segment state="initial">
          <source>Start your animation on the Visual whose property you want to animate – call StartAnimation and include as parameters:   the name of the property you want to animate (in string form) and the object for your animation.</source>
          <target>Start your animation on the Visual whose property you want to animate – call StartAnimation and include as parameters:   the name of the property you want to animate (in string form) and the object for your animation.</target>
        </segment>
      </unit>
      <unit id="237">
        <segment state="initial">
          <source>Using KeyFrame Animations</source>
          <target>Using KeyFrame Animations</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source>KeyFrame Animations are time-based animations that use one or more key frames to specify how the animated value should change over time.</source>
          <target>KeyFrame Animations are time-based animations that use one or more key frames to specify how the animated value should change over time.</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source>The frames represent markers or control points, allowing you to define what the animated value should be at a specific time.</source>
          <target>The frames represent markers or control points, allowing you to define what the animated value should be at a specific time.</target>
        </segment>
      </unit>
      <unit id="240">
        <segment state="initial">
          <source>Creating your animation and defining KeyFrames</source>
          <target>Creating your animation and defining KeyFrames</target>
        </segment>
      </unit>
      <unit id="241">
        <segment state="initial">
          <source>To construct a KeyFrame Animation, use the constructor method of your Compositor object that correlates to the type of the property you wish to animate.</source>
          <target>To construct a KeyFrame Animation, use the constructor method of your Compositor object that correlates to the type of the property you wish to animate.</target>
        </segment>
      </unit>
      <unit id="242">
        <segment state="initial">
          <source>The different types of KeyFrame Animation are:</source>
          <target>The different types of KeyFrame Animation are:</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source>ColorKeyFrameAnimation</source>
          <target>ColorKeyFrameAnimation</target>
        </segment>
      </unit>
      <unit id="244">
        <segment state="initial">
          <source>QuaternionKeyFrameAnimation</source>
          <target>QuaternionKeyFrameAnimation</target>
        </segment>
      </unit>
      <unit id="245">
        <segment state="initial">
          <source>ScalarKeyFrameAnimation</source>
          <target>ScalarKeyFrameAnimation</target>
        </segment>
      </unit>
      <unit id="246">
        <segment state="initial">
          <source>Vector2KeyFrameAnimation</source>
          <target>Vector2KeyFrameAnimation</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source>Vector3KeyFrameAnimation</source>
          <target>Vector3KeyFrameAnimation</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source>Vector4KeyFrameAnimation</source>
          <target>Vector4KeyFrameAnimation</target>
        </segment>
      </unit>
      <unit id="249">
        <segment state="initial">
          <source>An example that creates a Vector3 KeyFrame Animation:</source>
          <target>An example that creates a Vector3 KeyFrame Animation:</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source>Each KeyFrame animation is constructed by inserting individual KeyFrame segments that define two components (with an optional third)</source>
          <target>Each KeyFrame animation is constructed by inserting individual KeyFrame segments that define two components (with an optional third)</target>
        </segment>
      </unit>
      <unit id="251">
        <segment state="initial">
          <source>Time: normalized progress state of the KeyFrame between 0.0 – 1.0</source>
          <target>Time: normalized progress state of the KeyFrame between 0.0 – 1.0</target>
        </segment>
      </unit>
      <unit id="252">
        <segment state="initial">
          <source>Value: specific value of the animating value at the time state</source>
          <target>Value: specific value of the animating value at the time state</target>
        </segment>
      </unit>
      <unit id="253">
        <segment state="initial">
          <source>(Optional) Easing function: function to describe interpolation between previous and current KeyFrame (discussed later in this topic)</source>
          <target>(Optional) Easing function: function to describe interpolation between previous and current KeyFrame (discussed later in this topic)</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source>An example that inserts a KeyFrame at the halfway point of the animation:</source>
          <target>An example that inserts a KeyFrame at the halfway point of the animation:</target>
        </segment>
      </unit>
      <unit id="255">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note:</pc> When animating color with KeyFrame Animations, there are a few additional things to keep in mind:</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note:</pc> When animating color with KeyFrame Animations, there are a few additional things to keep in mind:</target>
        </segment>
      </unit>
      <unit id="256">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>You attach StartAnimation to the Visual.Brush, instead of Visual, with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Color</pc> as the property parameter you wish to animate.</source>
          <target>You attach StartAnimation to the Visual.Brush, instead of Visual, with <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Color</pc> as the property parameter you wish to animate.</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source>The "value" component of the KeyFrame is defined by the Colors object off of the Windows.UI namespace.</source>
          <target>The "value" component of the KeyFrame is defined by the Colors object off of the Windows.UI namespace.</target>
        </segment>
      </unit>
      <unit id="258">
        <segment state="initial">
          <source>You have the option to define the color space that the interpolation will go through by setting the InterpolationColorSpace property.</source>
          <target>You have the option to define the color space that the interpolation will go through by setting the InterpolationColorSpace property.</target>
        </segment>
      </unit>
      <unit id="259">
        <segment state="initial">
          <source>Possible values include: a.</source>
          <target>Possible values include: a.</target>
        </segment>
      </unit>
      <unit id="260">
        <segment state="initial">
          <source>CompositionColorSpace.Rgb b.</source>
          <target>CompositionColorSpace.Rgb b.</target>
        </segment>
      </unit>
      <unit id="261">
        <segment state="initial">
          <source>CompositionColorSpace.Hsl</source>
          <target>CompositionColorSpace.Hsl</target>
        </segment>
      </unit>
      <unit id="262">
        <segment state="initial">
          <source>KeyFrame Animation Properties</source>
          <target>KeyFrame Animation Properties</target>
        </segment>
      </unit>
      <unit id="263">
        <segment state="initial">
          <source>Once you've defined your KeyFrame Animation and the individual KeyFrames, you are able to define multiple properties off of your animation:</source>
          <target>Once you've defined your KeyFrame Animation and the individual KeyFrames, you are able to define multiple properties off of your animation:</target>
        </segment>
      </unit>
      <unit id="264">
        <segment state="initial">
          <source>DelayTime – time before an animation starts after StartAnimation() is called</source>
          <target>DelayTime – time before an animation starts after StartAnimation() is called</target>
        </segment>
      </unit>
      <unit id="265">
        <segment state="initial">
          <source>Duration – duration of the animation</source>
          <target>Duration – duration of the animation</target>
        </segment>
      </unit>
      <unit id="266">
        <segment state="initial">
          <source>IterationBehavior – count or infinite repeat behavior for an animation</source>
          <target>IterationBehavior – count or infinite repeat behavior for an animation</target>
        </segment>
      </unit>
      <unit id="267">
        <segment state="initial">
          <source>IterationCount – number of finite times a KeyFrame Animation will repeat</source>
          <target>IterationCount – number of finite times a KeyFrame Animation will repeat</target>
        </segment>
      </unit>
      <unit id="268">
        <segment state="initial">
          <source>KeyFrame Count – read of how many KeyFrames in a particular KeyFrame Animation</source>
          <target>KeyFrame Count – read of how many KeyFrames in a particular KeyFrame Animation</target>
        </segment>
      </unit>
      <unit id="269">
        <segment state="initial">
          <source>StopBehavior – specifies the behavior of an animating property value when StopAnimation is called.</source>
          <target>StopBehavior – specifies the behavior of an animating property value when StopAnimation is called.</target>
        </segment>
      </unit>
      <unit id="270">
        <segment state="initial">
          <source>An example that sets the Duration of the animation to 5 seconds:</source>
          <target>An example that sets the Duration of the animation to 5 seconds:</target>
        </segment>
      </unit>
      <unit id="271">
        <segment state="initial">
          <source>Easing Functions</source>
          <target>Easing Functions</target>
        </segment>
      </unit>
      <unit id="272">
        <segment state="initial">
          <source>Easing functions (CompositionEasingFunction) indicate how intermediate values progress from the previous key frame value to the current key frame value.</source>
          <target>Easing functions (CompositionEasingFunction) indicate how intermediate values progress from the previous key frame value to the current key frame value.</target>
        </segment>
      </unit>
      <unit id="273">
        <segment state="initial">
          <source>If you do not provide an easing function for the KeyFrame, a default curve will be used.</source>
          <target>If you do not provide an easing function for the KeyFrame, a default curve will be used.</target>
        </segment>
      </unit>
      <unit id="274">
        <segment state="initial">
          <source>There are two types of easing functions supported:</source>
          <target>There are two types of easing functions supported:</target>
        </segment>
      </unit>
      <unit id="275">
        <segment state="initial">
          <source>Linear</source>
          <target>Linear</target>
        </segment>
      </unit>
      <unit id="276">
        <segment state="initial">
          <source>Cubic Bezier</source>
          <target>Cubic Bezier</target>
        </segment>
      </unit>
      <unit id="277">
        <segment state="initial">
          <source>Cubic Beziers are a parametric function frequently used to describe smooth curves that can be scaled.</source>
          <target>Cubic Beziers are a parametric function frequently used to describe smooth curves that can be scaled.</target>
        </segment>
      </unit>
      <unit id="278">
        <segment state="initial">
          <source>When using with Composition KeyFrame Animations, you define two control points that are Vector2 objects.</source>
          <target>When using with Composition KeyFrame Animations, you define two control points that are Vector2 objects.</target>
        </segment>
      </unit>
      <unit id="279">
        <segment state="initial">
          <source>These control points are used to define the shape of the curve.</source>
          <target>These control points are used to define the shape of the curve.</target>
        </segment>
      </unit>
      <unit id="280">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://cubic-bezier.com/#0,-0.01,.48,.99)</data>
        </originalData>
        <segment state="initial">
          <source>It is recommended to use similar sites such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">this</pc> to visualize how the two control points construct the curve for a Cubic Bezier.</source>
          <target>It is recommended to use similar sites such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">this</pc> to visualize how the two control points construct the curve for a Cubic Bezier.</target>
        </segment>
      </unit>
      <unit id="281">
        <segment state="initial">
          <source>To create an easing function, utilize the constructor method off your Compositor object.</source>
          <target>To create an easing function, utilize the constructor method off your Compositor object.</target>
        </segment>
      </unit>
      <unit id="282">
        <segment state="initial">
          <source>Two examples below that create a Linear easing function and a basic easeIn Cubic Bezier.</source>
          <target>Two examples below that create a Linear easing function and a basic easeIn Cubic Bezier.</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source>To add your easing function into your KeyFrame, simply add in the third parameter to the KeyFrame when inserting into the Animation.</source>
          <target>To add your easing function into your KeyFrame, simply add in the third parameter to the KeyFrame when inserting into the Animation.</target>
        </segment>
      </unit>
      <unit id="284">
        <segment state="initial">
          <source>An example that adds in a easeIn easing function with the KeyFrame:</source>
          <target>An example that adds in a easeIn easing function with the KeyFrame:</target>
        </segment>
      </unit>
      <unit id="285">
        <segment state="initial">
          <source>Starting and Stopping KeyFrame Animations</source>
          <target>Starting and Stopping KeyFrame Animations</target>
        </segment>
      </unit>
      <unit id="286">
        <segment state="initial">
          <source>After you have defined your animation and KeyFrames, you are ready to hook up your animation.</source>
          <target>After you have defined your animation and KeyFrames, you are ready to hook up your animation.</target>
        </segment>
      </unit>
      <unit id="287">
        <segment state="initial">
          <source>When starting your animation, you specify the Visual to be animated, the target property to be animated and a reference to the animation.</source>
          <target>When starting your animation, you specify the Visual to be animated, the target property to be animated and a reference to the animation.</target>
        </segment>
      </unit>
      <unit id="288">
        <segment state="initial">
          <source>You do so by calling the StartAnimation() function.</source>
          <target>You do so by calling the StartAnimation() function.</target>
        </segment>
      </unit>
      <unit id="289">
        <segment state="initial">
          <source>Remember that calling StartAnimation() on a property will disconnect and remove any previously running animations.</source>
          <target>Remember that calling StartAnimation() on a property will disconnect and remove any previously running animations.</target>
        </segment>
      </unit>
      <unit id="290">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note:</pc> The reference to the property you choose to animate is in the form of a string.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note:</pc> The reference to the property you choose to animate is in the form of a string.</target>
        </segment>
      </unit>
      <unit id="291">
        <segment state="initial">
          <source>An example that sets and starts an animation on the Visual’s Offset property:</source>
          <target>An example that sets and starts an animation on the Visual’s Offset property:</target>
        </segment>
      </unit>
      <unit id="292">
        <segment state="initial">
          <source>If you want to target a sub channel property, you add the subchannel into the string defining the property you want to animate.</source>
          <target>If you want to target a sub channel property, you add the subchannel into the string defining the property you want to animate.</target>
        </segment>
      </unit>
      <unit id="293">
        <segment state="initial">
          <source>In the examples above, the syntax would change to StartAnimation("Offset.X, animation2), where animation2 is a ScalarKeyFrameAnimation.</source>
          <target>In the examples above, the syntax would change to StartAnimation("Offset.X, animation2), where animation2 is a ScalarKeyFrameAnimation.</target>
        </segment>
      </unit>
      <unit id="294">
        <segment state="initial">
          <source>After starting your animation, you also have the ability to stop it before it finishes.</source>
          <target>After starting your animation, you also have the ability to stop it before it finishes.</target>
        </segment>
      </unit>
      <unit id="295">
        <segment state="initial">
          <source>This is done by using the StopAnimation() function.</source>
          <target>This is done by using the StopAnimation() function.</target>
        </segment>
      </unit>
      <unit id="296">
        <segment state="initial">
          <source>An example that stops an animation on the Visual’s Offset property:</source>
          <target>An example that stops an animation on the Visual’s Offset property:</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source>You also have the ability to define the behavior of the animation when it is explicitly stopped.</source>
          <target>You also have the ability to define the behavior of the animation when it is explicitly stopped.</target>
        </segment>
      </unit>
      <unit id="298">
        <segment state="initial">
          <source>To do so, you define the Stop Behavior property off your animation.</source>
          <target>To do so, you define the Stop Behavior property off your animation.</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source>There are three options:</source>
          <target>There are three options:</target>
        </segment>
      </unit>
      <unit id="300">
        <segment state="initial">
          <source>LeaveCurrentValue: The animation will mark the value of the animated property to be the last calculated value of the animation</source>
          <target>LeaveCurrentValue: The animation will mark the value of the animated property to be the last calculated value of the animation</target>
        </segment>
      </unit>
      <unit id="301">
        <segment state="initial">
          <source>SetToFinalValue: The animation will mark the value of the animated property to be the value of the final keyframe</source>
          <target>SetToFinalValue: The animation will mark the value of the animated property to be the value of the final keyframe</target>
        </segment>
      </unit>
      <unit id="302">
        <segment state="initial">
          <source>SetToInitialValue: The animation will mark the value of the animated property to be the value of the first keyframe</source>
          <target>SetToInitialValue: The animation will mark the value of the animated property to be the value of the first keyframe</target>
        </segment>
      </unit>
      <unit id="303">
        <segment state="initial">
          <source>An example that sets the StopBehavior property for a KeyFrame Animation:</source>
          <target>An example that sets the StopBehavior property for a KeyFrame Animation:</target>
        </segment>
      </unit>
      <unit id="304">
        <segment state="initial">
          <source>Animation Completion Events</source>
          <target>Animation Completion Events</target>
        </segment>
      </unit>
      <unit id="305">
        <segment state="initial">
          <source>With KeyFrame Animations, developers can use an Animation Batches to aggregate when a select animation (or group of animations) have completed.</source>
          <target>With KeyFrame Animations, developers can use an Animation Batches to aggregate when a select animation (or group of animations) have completed.</target>
        </segment>
      </unit>
      <unit id="306">
        <segment state="initial">
          <source>Only KeyFrame animation completion events can be batched.</source>
          <target>Only KeyFrame animation completion events can be batched.</target>
        </segment>
      </unit>
      <unit id="307">
        <segment state="initial">
          <source>Expressions do not have a definite end so they do not fire a completion event.</source>
          <target>Expressions do not have a definite end so they do not fire a completion event.</target>
        </segment>
      </unit>
      <unit id="308">
        <segment state="initial">
          <source>If an Expression animation is started within a batch, the animation will execute as expected and it will not affect when the batch fires.</source>
          <target>If an Expression animation is started within a batch, the animation will execute as expected and it will not affect when the batch fires.</target>
        </segment>
      </unit>
      <unit id="309">
        <segment state="initial">
          <source>A batch completion event fires when all animations within the batch have completed.</source>
          <target>A batch completion event fires when all animations within the batch have completed.</target>
        </segment>
      </unit>
      <unit id="310">
        <segment state="initial">
          <source>The time it takes for a batch’s event to fire depends on the longest or most delayed animation in the batch.</source>
          <target>The time it takes for a batch’s event to fire depends on the longest or most delayed animation in the batch.</target>
        </segment>
      </unit>
      <unit id="311">
        <segment state="initial">
          <source>Aggregating end states is useful when you need to know when groups of select animations complete in order to schedule some other work.</source>
          <target>Aggregating end states is useful when you need to know when groups of select animations complete in order to schedule some other work.</target>
        </segment>
      </unit>
      <unit id="312">
        <segment state="initial">
          <source>Batches will dispose once the completion event is fired.</source>
          <target>Batches will dispose once the completion event is fired.</target>
        </segment>
      </unit>
      <unit id="313">
        <segment state="initial">
          <source>You can also call Dispose() at any time to release the resource early.</source>
          <target>You can also call Dispose() at any time to release the resource early.</target>
        </segment>
      </unit>
      <unit id="314">
        <segment state="initial">
          <source>You may want to manually dispose the batch object if a batched animation is ended early and you do not wish to pick up the completion event.</source>
          <target>You may want to manually dispose the batch object if a batched animation is ended early and you do not wish to pick up the completion event.</target>
        </segment>
      </unit>
      <unit id="315">
        <segment state="initial">
          <source>If an animation is interrupted or canceled the completion event will fire and count towards the batch it was set in.</source>
          <target>If an animation is interrupted or canceled the completion event will fire and count towards the batch it was set in.</target>
        </segment>
      </unit>
      <unit id="316">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?LinkId=789439)</data>
        </originalData>
        <segment state="initial">
          <source>This is demonstrated in the Animation_Batch SDK sample on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows/Composition GitHub</pc>.</source>
          <target>This is demonstrated in the Animation_Batch SDK sample on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows/Composition GitHub</pc>.</target>
        </segment>
      </unit>
      <unit id="317">
        <segment state="initial">
          <source>Scoped batches</source>
          <target>Scoped batches</target>
        </segment>
      </unit>
      <unit id="318">
        <segment state="initial">
          <source>To aggregate a specific group of animations or target a single animation’s completion event, you create a Scoped batch.</source>
          <target>To aggregate a specific group of animations or target a single animation’s completion event, you create a Scoped batch.</target>
        </segment>
      </unit>
      <unit id="319">
        <segment state="initial">
          <source>After creating a Scoped batch, all started animations aggregate until the batch is explicitly suspended or ended using the Suspend or End function.</source>
          <target>After creating a Scoped batch, all started animations aggregate until the batch is explicitly suspended or ended using the Suspend or End function.</target>
        </segment>
      </unit>
      <unit id="320">
        <segment state="initial">
          <source>Calling the Suspend function stops aggregating animates end states until Resume is called.</source>
          <target>Calling the Suspend function stops aggregating animates end states until Resume is called.</target>
        </segment>
      </unit>
      <unit id="321">
        <segment state="initial">
          <source>This allows you to explicitly exclude content from a given batch.</source>
          <target>This allows you to explicitly exclude content from a given batch.</target>
        </segment>
      </unit>
      <unit id="322">
        <segment state="initial">
          <source>In the example below, the animation targeting the Offset property of VisualA will not be included in the batch:</source>
          <target>In the example below, the animation targeting the Offset property of VisualA will not be included in the batch:</target>
        </segment>
      </unit>
      <unit id="323">
        <segment state="initial">
          <source>In order to complete your batch you must call End().</source>
          <target>In order to complete your batch you must call End().</target>
        </segment>
      </unit>
      <unit id="324">
        <segment state="initial">
          <source>Without an End call, the batch will remain open forever-collecting objects.</source>
          <target>Without an End call, the batch will remain open forever-collecting objects.</target>
        </segment>
      </unit>
      <unit id="325">
        <segment state="initial">
          <source>The following code snippet and diagram below shows an example of how the Batch will aggregate animations to track end states.</source>
          <target>The following code snippet and diagram below shows an example of how the Batch will aggregate animations to track end states.</target>
        </segment>
      </unit>
      <unit id="326">
        <segment state="initial">
          <source>Note that in this example, Animations 1, 3, and 4 will have end states tracked by this Batch, but Animation 2 will not.</source>
          <target>Note that in this example, Animations 1, 3, and 4 will have end states tracked by this Batch, but Animation 2 will not.</target>
        </segment>
      </unit>
      <unit id="327">
        <segment state="initial">
          <source>Batching a single animation's completion event</source>
          <target>Batching a single animation's completion event</target>
        </segment>
      </unit>
      <unit id="328">
        <segment state="initial">
          <source>If you want to know when a single animation ends, you need to create a Scoped batch that will include just the animation you are targeting.</source>
          <target>If you want to know when a single animation ends, you need to create a Scoped batch that will include just the animation you are targeting.</target>
        </segment>
      </unit>
      <unit id="329">
        <segment state="initial">
          <source>For example:</source>
          <target>For example:</target>
        </segment>
      </unit>
      <unit id="330">
        <segment state="initial">
          <source>Retrieving a batch's completion event</source>
          <target>Retrieving a batch's completion event</target>
        </segment>
      </unit>
      <unit id="331">
        <segment state="initial">
          <source>When batching an animation or multiple animations, you will retrieve the batch’s completion event the same way.</source>
          <target>When batching an animation or multiple animations, you will retrieve the batch’s completion event the same way.</target>
        </segment>
      </unit>
      <unit id="332">
        <segment state="initial">
          <source>You register the event-handling method for the Completed event of the targeted batch.</source>
          <target>You register the event-handling method for the Completed event of the targeted batch.</target>
        </segment>
      </unit>
      <unit id="333">
        <segment state="initial">
          <source>Batch states</source>
          <target>Batch states</target>
        </segment>
      </unit>
      <unit id="334">
        <segment state="initial">
          <source>There are two properties you can use to determine the state of an existing batch; IsActive and IsEnded.</source>
          <target>There are two properties you can use to determine the state of an existing batch; IsActive and IsEnded.</target>
        </segment>
      </unit>
      <unit id="335">
        <segment state="initial">
          <source>The IsActive property returns true if a targeted batch is open to aggregating animations.</source>
          <target>The IsActive property returns true if a targeted batch is open to aggregating animations.</target>
        </segment>
      </unit>
      <unit id="336">
        <segment state="initial">
          <source>IsActive will return false when a batch is suspended or ended.</source>
          <target>IsActive will return false when a batch is suspended or ended.</target>
        </segment>
      </unit>
      <unit id="337">
        <segment state="initial">
          <source>The IsEnded property returns true when you cannot add an animation to that specific batch.</source>
          <target>The IsEnded property returns true when you cannot add an animation to that specific batch.</target>
        </segment>
      </unit>
      <unit id="338">
        <segment state="initial">
          <source>A batch will be ended when you call explicitly call End() for a specific batch.</source>
          <target>A batch will be ended when you call explicitly call End() for a specific batch.</target>
        </segment>
      </unit>
      <unit id="339">
        <segment state="initial">
          <source>Using Expression Animations</source>
          <target>Using Expression Animations</target>
        </segment>
      </unit>
      <unit id="340">
        <segment state="initial">
          <source>Expression Animations are a new type of animation the Composition Team introduced with the November Update for Windows 10 (10586).</source>
          <target>Expression Animations are a new type of animation the Composition Team introduced with the November Update for Windows 10 (10586).</target>
        </segment>
      </unit>
      <unit id="341">
        <segment state="initial">
          <source>At a high level, Expression Animations are based on a mathematical equation/relationship between discrete values and references to other Composition object properties.</source>
          <target>At a high level, Expression Animations are based on a mathematical equation/relationship between discrete values and references to other Composition object properties.</target>
        </segment>
      </unit>
      <unit id="342">
        <segment state="initial">
          <source>In contrast to KeyFrame Animations that use an interpolator function (Cubic Bezier, Quad, Quintic, etc.) to describe how the value changes over time, Expression Animations use a mathematical equation to define how the animated value is calculated each frame.</source>
          <target>In contrast to KeyFrame Animations that use an interpolator function (Cubic Bezier, Quad, Quintic, etc.) to describe how the value changes over time, Expression Animations use a mathematical equation to define how the animated value is calculated each frame.</target>
        </segment>
      </unit>
      <unit id="343">
        <segment state="initial">
          <source>It’s important to point out that Expression Animations do not have a defined duration – once started, they will run and use the mathematical equation to determine the value of the animating property until they are explicitly stopped.</source>
          <target>It’s important to point out that Expression Animations do not have a defined duration – once started, they will run and use the mathematical equation to determine the value of the animating property until they are explicitly stopped.</target>
        </segment>
      </unit>
      <unit id="344">
        <segment state="initial">
          <source>So why are Expression Animations useful?</source>
          <target>So why are Expression Animations useful?</target>
        </segment>
      </unit>
      <unit id="345">
        <segment state="initial">
          <source>The real power of Expression Animations comes from their ability to create a mathematical relationship that includes references to parameters or properties on other objects.</source>
          <target>The real power of Expression Animations comes from their ability to create a mathematical relationship that includes references to parameters or properties on other objects.</target>
        </segment>
      </unit>
      <unit id="346">
        <segment state="initial">
          <source>This means you can have an equation referencing values of properties on other Composition objects, local variables, or even shared values in Composition Property Sets.</source>
          <target>This means you can have an equation referencing values of properties on other Composition objects, local variables, or even shared values in Composition Property Sets.</target>
        </segment>
      </unit>
      <unit id="347">
        <segment state="initial">
          <source>Because of this reference model, and that the equation is evaluated every frame, if the values that define an equation change, so will the output of the equation.</source>
          <target>Because of this reference model, and that the equation is evaluated every frame, if the values that define an equation change, so will the output of the equation.</target>
        </segment>
      </unit>
      <unit id="348">
        <segment state="initial">
          <source>This opens up bigger possibilities beyond traditional KeyFrame Animations where values must be discrete and pre-defined.</source>
          <target>This opens up bigger possibilities beyond traditional KeyFrame Animations where values must be discrete and pre-defined.</target>
        </segment>
      </unit>
      <unit id="349">
        <segment state="initial">
          <source>For example, experiences like Sticky Headers and Parallax can be easily described using Expression Animations.</source>
          <target>For example, experiences like Sticky Headers and Parallax can be easily described using Expression Animations.</target>
        </segment>
      </unit>
      <unit id="350">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note:</pc> We use the terms "Expression" or "Expression String" as reference to your mathematical equation that defines your Expression Animation object.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note:</pc> We use the terms "Expression" or "Expression String" as reference to your mathematical equation that defines your Expression Animation object.</target>
        </segment>
      </unit>
      <unit id="351">
        <segment state="initial">
          <source>Creating and Attaching your Expression Animation</source>
          <target>Creating and Attaching your Expression Animation</target>
        </segment>
      </unit>
      <unit id="352">
        <segment state="initial">
          <source>Before we jump into the syntax of creating Expression Animations, there are a few core principles to mention:</source>
          <target>Before we jump into the syntax of creating Expression Animations, there are a few core principles to mention:</target>
        </segment>
      </unit>
      <unit id="353">
        <segment state="initial">
          <source>Expression Animations use a defined mathematical equation to determine the value of the animating property every frame.</source>
          <target>Expression Animations use a defined mathematical equation to determine the value of the animating property every frame.</target>
        </segment>
      </unit>
      <unit id="354">
        <segment state="initial">
          <source>The mathematical equation is inputted into the Expression as a string.</source>
          <target>The mathematical equation is inputted into the Expression as a string.</target>
        </segment>
      </unit>
      <unit id="355">
        <segment state="initial">
          <source>The output of the mathematical equation must resolve to the same type as the property you plan to animate.</source>
          <target>The output of the mathematical equation must resolve to the same type as the property you plan to animate.</target>
        </segment>
      </unit>
      <unit id="356">
        <segment state="initial">
          <source>If they don't match, you will get an error when the Expression gets calculated.</source>
          <target>If they don't match, you will get an error when the Expression gets calculated.</target>
        </segment>
      </unit>
      <unit id="357">
        <segment state="initial">
          <source>If your equation resolves to Nan (number/0), the system will use the last previously calculated value.</source>
          <target>If your equation resolves to Nan (number/0), the system will use the last previously calculated value.</target>
        </segment>
      </unit>
      <unit id="358">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>Expression Animations have an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">infinite lifetime</pc> – they will continue to run until they are stopped.</source>
          <target>Expression Animations have an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">infinite lifetime</pc> – they will continue to run until they are stopped.</target>
        </segment>
      </unit>
      <unit id="359">
        <segment state="initial">
          <source>To create your Expression Animation, simply use the constructor off your Composition object, where you define your Mathematical expression.</source>
          <target>To create your Expression Animation, simply use the constructor off your Composition object, where you define your Mathematical expression.</target>
        </segment>
      </unit>
      <unit id="360">
        <segment state="initial">
          <source>An example of the constructor where a very basic expression is defined that sums two Scalar values together (We will dive into more complicated expressions in the next section):</source>
          <target>An example of the constructor where a very basic expression is defined that sums two Scalar values together (We will dive into more complicated expressions in the next section):</target>
        </segment>
      </unit>
      <unit id="361">
        <segment state="initial">
          <source>Similar to KeyFrame Animations, once you have defined your Expression Animation, you need to attach it to the Visual and declare the property you wish the animation to animate.</source>
          <target>Similar to KeyFrame Animations, once you have defined your Expression Animation, you need to attach it to the Visual and declare the property you wish the animation to animate.</target>
        </segment>
      </unit>
      <unit id="362">
        <segment state="initial">
          <source>Below, we continue with the above example and attach our Expression Animation to the Visual’s Opacity property (A Scalar type):</source>
          <target>Below, we continue with the above example and attach our Expression Animation to the Visual’s Opacity property (A Scalar type):</target>
        </segment>
      </unit>
      <unit id="363">
        <segment state="initial">
          <source>Components of your Expression String</source>
          <target>Components of your Expression String</target>
        </segment>
      </unit>
      <unit id="364">
        <segment state="initial">
          <source>The example in the previous section demonstrated two simple Scalar values being added together.</source>
          <target>The example in the previous section demonstrated two simple Scalar values being added together.</target>
        </segment>
      </unit>
      <unit id="365">
        <segment state="initial">
          <source>Although this is a valid example of Expressions, it does not fully demonstrate the potential of what you can do with Expressions.</source>
          <target>Although this is a valid example of Expressions, it does not fully demonstrate the potential of what you can do with Expressions.</target>
        </segment>
      </unit>
      <unit id="366">
        <segment state="initial">
          <source>One thing to note about the example above is that because these are discrete values, every frame the equation will resolve to 0.5 and never change throughout the lifetime of the animation.</source>
          <target>One thing to note about the example above is that because these are discrete values, every frame the equation will resolve to 0.5 and never change throughout the lifetime of the animation.</target>
        </segment>
      </unit>
      <unit id="367">
        <segment state="initial">
          <source>The real potential of Expressions comes from defining a mathematical relationship in which the values could change periodically or all the time.</source>
          <target>The real potential of Expressions comes from defining a mathematical relationship in which the values could change periodically or all the time.</target>
        </segment>
      </unit>
      <unit id="368">
        <segment state="initial">
          <source>Let’s walk through the different pieces that can make up these types of Expressions.</source>
          <target>Let’s walk through the different pieces that can make up these types of Expressions.</target>
        </segment>
      </unit>
      <unit id="369">
        <segment state="initial">
          <source>Operators, Precedence and Associativity</source>
          <target>Operators, Precedence and Associativity</target>
        </segment>
      </unit>
      <unit id="370">
        <segment state="initial">
          <source>The Expression string supports usage of typical operators you would expect to describe mathematical relationships between different components of the equation:</source>
          <target>The Expression string supports usage of typical operators you would expect to describe mathematical relationships between different components of the equation:</target>
        </segment>
      </unit>
      <unit id="371">
        <segment state="initial">
          <source>Category</source>
          <target>Category</target>
        </segment>
      </unit>
      <unit id="372">
        <segment state="initial">
          <source>Operators</source>
          <target>Operators</target>
        </segment>
      </unit>
      <unit id="373">
        <segment state="initial">
          <source>Unary</source>
          <target>Unary</target>
        </segment>
      </unit>
      <unit id="374">
        <segment state="initial">
          <source>Multiplicative</source>
          <target>Multiplicative</target>
        </segment>
      </unit>
      <unit id="375">
        <segment state="initial">
          <source>* /</source>
          <target>* /</target>
        </segment>
      </unit>
      <unit id="376">
        <segment state="initial">
          <source>Additive</source>
          <target>Additive</target>
        </segment>
      </unit>
      <unit id="377">
        <segment state="initial">
          <source>+ -</source>
          <target>+ -</target>
        </segment>
      </unit>
      <unit id="378">
        <segment state="initial">
          <source>Similarly, when the Expression is evaluated, it will adhere to operator precedence and associativity as defined in the C# Language specification.</source>
          <target>Similarly, when the Expression is evaluated, it will adhere to operator precedence and associativity as defined in the C# Language specification.</target>
        </segment>
      </unit>
      <unit id="379">
        <segment state="initial">
          <source>Put another way, it will adhere to basic order of operations.</source>
          <target>Put another way, it will adhere to basic order of operations.</target>
        </segment>
      </unit>
      <unit id="380">
        <segment state="initial">
          <source>In the example below, when evaluated, the parentheses will be resolved first before resolving the rest of the equation based on order of operations:</source>
          <target>In the example below, when evaluated, the parentheses will be resolved first before resolving the rest of the equation based on order of operations:</target>
        </segment>
      </unit>
      <unit id="381">
        <segment state="initial">
          <source>Property Parameters</source>
          <target>Property Parameters</target>
        </segment>
      </unit>
      <unit id="382">
        <segment state="initial">
          <source>Property parameters are one of the most powerful components of Expression Animations.</source>
          <target>Property parameters are one of the most powerful components of Expression Animations.</target>
        </segment>
      </unit>
      <unit id="383">
        <segment state="initial">
          <source>In the Expression string, you can reference values of properties from other objects such as Composition Visual, Composition Property Set or other C# objects.</source>
          <target>In the Expression string, you can reference values of properties from other objects such as Composition Visual, Composition Property Set or other C# objects.</target>
        </segment>
      </unit>
      <unit id="384">
        <segment state="initial">
          <source>To use these in an Expression string, you simply need to define the references as parameters to the Expression Animation.</source>
          <target>To use these in an Expression string, you simply need to define the references as parameters to the Expression Animation.</target>
        </segment>
      </unit>
      <unit id="385">
        <segment state="initial">
          <source>This is done by mapping the string used in the Expression to the actual object.</source>
          <target>This is done by mapping the string used in the Expression to the actual object.</target>
        </segment>
      </unit>
      <unit id="386">
        <segment state="initial">
          <source>This allows the system when evaluating the equation to know what to inspect to calculate the value.</source>
          <target>This allows the system when evaluating the equation to know what to inspect to calculate the value.</target>
        </segment>
      </unit>
      <unit id="387">
        <segment state="initial">
          <source>There are different types of parameters that correlate to the type of the object you wish to include in the equation:</source>
          <target>There are different types of parameters that correlate to the type of the object you wish to include in the equation:</target>
        </segment>
      </unit>
      <unit id="388">
        <segment state="initial">
          <source>Type</source>
          <target>Type</target>
        </segment>
      </unit>
      <unit id="389">
        <segment state="initial">
          <source>Function to create parameter</source>
          <target>Function to create parameter</target>
        </segment>
      </unit>
      <unit id="390">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="391">
        <segment state="initial">
          <source>SetScalarParameter(String ref, Scalar obj)</source>
          <target>SetScalarParameter(String ref, Scalar obj)</target>
        </segment>
      </unit>
      <unit id="392">
        <segment state="initial">
          <source>Vector</source>
          <target>Vector</target>
        </segment>
      </unit>
      <unit id="393">
        <segment state="initial">
          <source>SetVector2Parameter(String ref, Vector2 obj)</source>
          <target>SetVector2Parameter(String ref, Vector2 obj)</target>
        </segment>
      </unit>
      <unit id="394">
        <segment state="initial">
          <source>SetVector3Parameter(String ref, Vector3 obj)</source>
          <target>SetVector3Parameter(String ref, Vector3 obj)</target>
        </segment>
      </unit>
      <unit id="395">
        <segment state="initial">
          <source>SetVector4Parameter(String ref, Vector4 obj)</source>
          <target>SetVector4Parameter(String ref, Vector4 obj)</target>
        </segment>
      </unit>
      <unit id="396">
        <segment state="initial">
          <source>Matrix</source>
          <target>Matrix</target>
        </segment>
      </unit>
      <unit id="397">
        <segment state="initial">
          <source>SetMatrix3x2Parameter(String ref, Matrix3x2 obj)</source>
          <target>SetMatrix3x2Parameter(String ref, Matrix3x2 obj)</target>
        </segment>
      </unit>
      <unit id="398">
        <segment state="initial">
          <source>SetMatrix4x4Parameter(String ref, Matrix4x4 obj)</source>
          <target>SetMatrix4x4Parameter(String ref, Matrix4x4 obj)</target>
        </segment>
      </unit>
      <unit id="399">
        <segment state="initial">
          <source>Quaternion</source>
          <target>Quaternion</target>
        </segment>
      </unit>
      <unit id="400">
        <segment state="initial">
          <source>SetQuaternionParameter(String ref, Quaternion obj)</source>
          <target>SetQuaternionParameter(String ref, Quaternion obj)</target>
        </segment>
      </unit>
      <unit id="401">
        <segment state="initial">
          <source>Color</source>
          <target>Color</target>
        </segment>
      </unit>
      <unit id="402">
        <segment state="initial">
          <source>SetColorParameter(String ref, Color obj)</source>
          <target>SetColorParameter(String ref, Color obj)</target>
        </segment>
      </unit>
      <unit id="403">
        <segment state="initial">
          <source>CompositionObject</source>
          <target>CompositionObject</target>
        </segment>
      </unit>
      <unit id="404">
        <segment state="initial">
          <source>SetReferenceParameter(String ref, Composition object obj)</source>
          <target>SetReferenceParameter(String ref, Composition object obj)</target>
        </segment>
      </unit>
      <unit id="405">
        <segment state="initial">
          <source>In the example below, we create an Expression Animation that will reference the Offset of two other Composition Visuals and a basic System.Numerics Vector3 object.</source>
          <target>In the example below, we create an Expression Animation that will reference the Offset of two other Composition Visuals and a basic System.Numerics Vector3 object.</target>
        </segment>
      </unit>
      <unit id="406">
        <segment state="initial">
          <source>Additionally, you can reference a value in a Property Set from an expression using the same model described above.</source>
          <target>Additionally, you can reference a value in a Property Set from an expression using the same model described above.</target>
        </segment>
      </unit>
      <unit id="407">
        <segment state="initial">
          <source>Composition Property Sets are a useful way to store data used by animations, and are useful for creating sharable, reusable data that isn’t tied to the lifetime of any other Composition objects.</source>
          <target>Composition Property Sets are a useful way to store data used by animations, and are useful for creating sharable, reusable data that isn’t tied to the lifetime of any other Composition objects.</target>
        </segment>
      </unit>
      <unit id="408">
        <segment state="initial">
          <source>Property Set values can be referenced in an expression similar to other property references.</source>
          <target>Property Set values can be referenced in an expression similar to other property references.</target>
        </segment>
      </unit>
      <unit id="409">
        <segment state="initial">
          <source>(Property Sets are discussed in more detail in a later section)</source>
          <target>(Property Sets are discussed in more detail in a later section)</target>
        </segment>
      </unit>
      <unit id="410">
        <segment state="initial">
          <source>We can modify the example directly above, such that a property set is used to define the commonOffset instead of a local variable:</source>
          <target>We can modify the example directly above, such that a property set is used to define the commonOffset instead of a local variable:</target>
        </segment>
      </unit>
      <unit id="411">
        <segment state="initial">
          <source>Finally, when referencing properties of other objects, it also possible to reference the subchannel properties either in the Expression string or as part of the reference parameter.</source>
          <target>Finally, when referencing properties of other objects, it also possible to reference the subchannel properties either in the Expression string or as part of the reference parameter.</target>
        </segment>
      </unit>
      <unit id="412">
        <segment state="initial">
          <source>In the example below, we reference the x subchannel of Offset properties from two Visuals – one in the Expression string itself and the other when creating the parameter reference.</source>
          <target>In the example below, we reference the x subchannel of Offset properties from two Visuals – one in the Expression string itself and the other when creating the parameter reference.</target>
        </segment>
      </unit>
      <unit id="413">
        <segment state="initial">
          <source>Notice that when referencing the X component of Offset, we change our parameter type to a Scalar Parameter instead of a Vector3 like in the previous example:</source>
          <target>Notice that when referencing the X component of Offset, we change our parameter type to a Scalar Parameter instead of a Vector3 like in the previous example:</target>
        </segment>
      </unit>
      <unit id="414">
        <segment state="initial">
          <source>Expression Helper Functions and Constructors</source>
          <target>Expression Helper Functions and Constructors</target>
        </segment>
      </unit>
      <unit id="415">
        <segment state="initial">
          <source>In addition to having access to Operators and Property Parameters, you can leverage a list of mathematical functions to use in their expressions.</source>
          <target>In addition to having access to Operators and Property Parameters, you can leverage a list of mathematical functions to use in their expressions.</target>
        </segment>
      </unit>
      <unit id="416">
        <segment state="initial">
          <source>These functions are provided to perform calculations and operations on different types that you would similarly do with System.Numerics objects.</source>
          <target>These functions are provided to perform calculations and operations on different types that you would similarly do with System.Numerics objects.</target>
        </segment>
      </unit>
      <unit id="417">
        <segment state="initial">
          <source>An example below creates an Expression targeted towards Scalars that takes advantage of the Clamp helper function:</source>
          <target>An example below creates an Expression targeted towards Scalars that takes advantage of the Clamp helper function:</target>
        </segment>
      </unit>
      <unit id="418">
        <segment state="initial">
          <source>In addition to a list of Helper functions, you are also able to use built-in Constructor methods inside an Expression string that will generate an instance of that type based on the provided parameters.</source>
          <target>In addition to a list of Helper functions, you are also able to use built-in Constructor methods inside an Expression string that will generate an instance of that type based on the provided parameters.</target>
        </segment>
      </unit>
      <unit id="419">
        <segment state="initial">
          <source>An example below creates an Expression that defines a new Vector3 in the Expression string:</source>
          <target>An example below creates an Expression that defines a new Vector3 in the Expression string:</target>
        </segment>
      </unit>
      <unit id="420">
        <segment state="initial">
          <source>You can find the full extensive list of helper functions and constructors in the Appendix section, or for each type in the list below:</source>
          <target>You can find the full extensive list of helper functions and constructors in the Appendix section, or for each type in the list below:</target>
        </segment>
      </unit>
      <unit id="421">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="422">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="423">
        <segment state="initial">
          <source>Vector3</source>
          <target>Vector3</target>
        </segment>
      </unit>
      <unit id="424">
        <segment state="initial">
          <source>Matrix3x2</source>
          <target>Matrix3x2</target>
        </segment>
      </unit>
      <unit id="425">
        <segment state="initial">
          <source>Matrix4x4</source>
          <target>Matrix4x4</target>
        </segment>
      </unit>
      <unit id="426">
        <segment state="initial">
          <source>Quaternion</source>
          <target>Quaternion</target>
        </segment>
      </unit>
      <unit id="427">
        <segment state="initial">
          <source>Color</source>
          <target>Color</target>
        </segment>
      </unit>
      <unit id="428">
        <segment state="initial">
          <source>Expression Keywords</source>
          <target>Expression Keywords</target>
        </segment>
      </unit>
      <unit id="429">
        <segment state="initial">
          <source>You can take advantage of special "keywords" that are treated differently when the Expression string is evaluated.</source>
          <target>You can take advantage of special "keywords" that are treated differently when the Expression string is evaluated.</target>
        </segment>
      </unit>
      <unit id="430">
        <segment state="initial">
          <source>Because they are considered "keywords" they can’t be used as the string parameter portion of their Property references.</source>
          <target>Because they are considered "keywords" they can’t be used as the string parameter portion of their Property references.</target>
        </segment>
      </unit>
      <unit id="431">
        <segment state="initial">
          <source>Keyword</source>
          <target>Keyword</target>
        </segment>
      </unit>
      <unit id="432">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="433">
        <segment state="initial">
          <source>This.StartingValue</source>
          <target>This.StartingValue</target>
        </segment>
      </unit>
      <unit id="434">
        <segment state="initial">
          <source>Provides a reference to the original starting value of the property that is being animated.</source>
          <target>Provides a reference to the original starting value of the property that is being animated.</target>
        </segment>
      </unit>
      <unit id="435">
        <segment state="initial">
          <source>This.CurrentValue</source>
          <target>This.CurrentValue</target>
        </segment>
      </unit>
      <unit id="436">
        <segment state="initial">
          <source>Provides a reference to the currently "known" value of the property</source>
          <target>Provides a reference to the currently "known" value of the property</target>
        </segment>
      </unit>
      <unit id="437">
        <segment state="initial">
          <source>Pi</source>
          <target>Pi</target>
        </segment>
      </unit>
      <unit id="438">
        <segment state="initial">
          <source>Provides a keyword reference to the value of PI</source>
          <target>Provides a keyword reference to the value of PI</target>
        </segment>
      </unit>
      <unit id="439">
        <segment state="initial">
          <source>An example below that demonstrates using the this.StartingValue keyword:</source>
          <target>An example below that demonstrates using the this.StartingValue keyword:</target>
        </segment>
      </unit>
      <unit id="440">
        <segment state="initial">
          <source>Expressions with Conditionals</source>
          <target>Expressions with Conditionals</target>
        </segment>
      </unit>
      <unit id="441">
        <segment state="initial">
          <source>In addition to supporting mathematical relationships using operators, property references, and functions and constructors, you can also create an expression that contains a ternary operator:</source>
          <target>In addition to supporting mathematical relationships using operators, property references, and functions and constructors, you can also create an expression that contains a ternary operator:</target>
        </segment>
      </unit>
      <unit id="442">
        <segment state="initial">
          <source>Conditional statements enable you to write expressions such that based on a particular condition, different mathematical relationships will be used by the system to calculate the value of the animating property.</source>
          <target>Conditional statements enable you to write expressions such that based on a particular condition, different mathematical relationships will be used by the system to calculate the value of the animating property.</target>
        </segment>
      </unit>
      <unit id="443">
        <segment state="initial">
          <source>Ternary operators can be nested as the expressions for the true or false statements.</source>
          <target>Ternary operators can be nested as the expressions for the true or false statements.</target>
        </segment>
      </unit>
      <unit id="444">
        <segment state="initial">
          <source>The following conditional operators are supported in the condition statement:</source>
          <target>The following conditional operators are supported in the condition statement:</target>
        </segment>
      </unit>
      <unit id="445">
        <segment state="initial">
          <source>Equals (==)</source>
          <target>Equals (==)</target>
        </segment>
      </unit>
      <unit id="446">
        <segment state="initial">
          <source>Not Equals (!=)</source>
          <target>Not Equals (!=)</target>
        </segment>
      </unit>
      <unit id="447">
        <segment state="initial">
          <source>Less than (&lt;)</source>
          <target>Less than (&lt;)</target>
        </segment>
      </unit>
      <unit id="448">
        <segment state="initial">
          <source>Less than or equal to (&lt;=)</source>
          <target>Less than or equal to (&lt;=)</target>
        </segment>
      </unit>
      <unit id="449">
        <segment state="initial">
          <source>Great than (&gt;)</source>
          <target>Great than (&gt;)</target>
        </segment>
      </unit>
      <unit id="450">
        <segment state="initial">
          <source>Great than or equal to (&gt;=)</source>
          <target>Great than or equal to (&gt;=)</target>
        </segment>
      </unit>
      <unit id="451">
        <segment state="initial">
          <source>The following conjunctions are supported as operators or functions in the condition statement:</source>
          <target>The following conjunctions are supported as operators or functions in the condition statement:</target>
        </segment>
      </unit>
      <unit id="452">
        <segment state="initial">
          <source>Not: !</source>
          <target>Not: !</target>
        </segment>
      </unit>
      <unit id="453">
        <segment state="initial">
          <source>/ Not(bool1)</source>
          <target>/ Not(bool1)</target>
        </segment>
      </unit>
      <unit id="454">
        <segment state="initial">
          <source>And: &amp;&amp; / And(bool1, bool2)</source>
          <target>And: &amp;&amp; / And(bool1, bool2)</target>
        </segment>
      </unit>
      <unit id="455">
        <segment state="initial">
          <source>Or: || / Or(bool1, bool2)</source>
          <target>Or: || / Or(bool1, bool2)</target>
        </segment>
      </unit>
      <unit id="456">
        <segment state="initial">
          <source>Below is an example of an Expression Animation using a conditional.</source>
          <target>Below is an example of an Expression Animation using a conditional.</target>
        </segment>
      </unit>
      <unit id="457">
        <segment state="initial">
          <source>Expression KeyFrames</source>
          <target>Expression KeyFrames</target>
        </segment>
      </unit>
      <unit id="458">
        <segment state="initial">
          <source>Earlier in this document, we described how you create KeyFrame Animations and introduced you to Expression Animations and all the different pieces that you can use to make up the Expression string.</source>
          <target>Earlier in this document, we described how you create KeyFrame Animations and introduced you to Expression Animations and all the different pieces that you can use to make up the Expression string.</target>
        </segment>
      </unit>
      <unit id="459">
        <segment state="initial">
          <source>What if you wanted the power from Expressions Animations but wanted time interpolation provided by KeyFrame Animations?</source>
          <target>What if you wanted the power from Expressions Animations but wanted time interpolation provided by KeyFrame Animations?</target>
        </segment>
      </unit>
      <unit id="460">
        <segment state="initial">
          <source>The answer is Expression KeyFrames!</source>
          <target>The answer is Expression KeyFrames!</target>
        </segment>
      </unit>
      <unit id="461">
        <segment state="initial">
          <source>Instead of defining a discrete value for each control points in the KeyFrame Animation, you can have the value be an Expression string.</source>
          <target>Instead of defining a discrete value for each control points in the KeyFrame Animation, you can have the value be an Expression string.</target>
        </segment>
      </unit>
      <unit id="462">
        <segment state="initial">
          <source>In this situation, the system will use the expression string to calculate what the value of the animating property should be at the given point in the timeline.</source>
          <target>In this situation, the system will use the expression string to calculate what the value of the animating property should be at the given point in the timeline.</target>
        </segment>
      </unit>
      <unit id="463">
        <segment state="initial">
          <source>The system will then simply interpolate to this value like in a normal keyframe animation.</source>
          <target>The system will then simply interpolate to this value like in a normal keyframe animation.</target>
        </segment>
      </unit>
      <unit id="464">
        <segment state="initial">
          <source>You don’t need to create special animations to use Expression KeyFrames – just insert an ExpressionKeyFrame into your standard KeyFrame animation, provide the time and your expression string as the value.</source>
          <target>You don’t need to create special animations to use Expression KeyFrames – just insert an ExpressionKeyFrame into your standard KeyFrame animation, provide the time and your expression string as the value.</target>
        </segment>
      </unit>
      <unit id="465">
        <segment state="initial">
          <source>The example below demonstrates this, using an Expression string as the value for one of the KeyFrames:</source>
          <target>The example below demonstrates this, using an Expression string as the value for one of the KeyFrames:</target>
        </segment>
      </unit>
      <unit id="466">
        <segment state="initial">
          <source>Expression Sample</source>
          <target>Expression Sample</target>
        </segment>
      </unit>
      <unit id="467">
        <segment state="initial">
          <source>The code below shows an example of setting up an expression animation for a basic Parallax experience that pulls input values from the Scroll Viewer.</source>
          <target>The code below shows an example of setting up an expression animation for a basic Parallax experience that pulls input values from the Scroll Viewer.</target>
        </segment>
      </unit>
      <unit id="468">
        <segment state="initial">
          <source>Animating With Property Sets</source>
          <target>Animating With Property Sets</target>
        </segment>
      </unit>
      <unit id="469">
        <segment state="initial">
          <source>Composition Property Sets provide you with the ability to store values that can be shared across multiple animations and are not tied to the lifetime of another Composition object.</source>
          <target>Composition Property Sets provide you with the ability to store values that can be shared across multiple animations and are not tied to the lifetime of another Composition object.</target>
        </segment>
      </unit>
      <unit id="470">
        <segment state="initial">
          <source>Property Sets are extremely useful to store common values and then easily reference them later on in animations.</source>
          <target>Property Sets are extremely useful to store common values and then easily reference them later on in animations.</target>
        </segment>
      </unit>
      <unit id="471">
        <segment state="initial">
          <source>You can also use Property Sets to store data based on application logic to drive an expression.</source>
          <target>You can also use Property Sets to store data based on application logic to drive an expression.</target>
        </segment>
      </unit>
      <unit id="472">
        <segment state="initial">
          <source>To create a property set, use the constructor method off your Compositor object:</source>
          <target>To create a property set, use the constructor method off your Compositor object:</target>
        </segment>
      </unit>
      <unit id="473">
        <segment state="initial">
          <source>Once you’ve created your Property Set, you can add a property and value to it:</source>
          <target>Once you’ve created your Property Set, you can add a property and value to it:</target>
        </segment>
      </unit>
      <unit id="474">
        <segment state="initial">
          <source>Similar to what we’ve seen earlier, we can reference this property set value in an Expression Animation:</source>
          <target>Similar to what we’ve seen earlier, we can reference this property set value in an Expression Animation:</target>
        </segment>
      </unit>
      <unit id="475">
        <segment state="initial">
          <source>Property set values can also be animated.</source>
          <target>Property set values can also be animated.</target>
        </segment>
      </unit>
      <unit id="476">
        <segment state="initial">
          <source>This is done by attaching the animation to the PropertySet object, and then referring to the property name in the string.</source>
          <target>This is done by attaching the animation to the PropertySet object, and then referring to the property name in the string.</target>
        </segment>
      </unit>
      <unit id="477">
        <segment state="initial">
          <source>Below, we animate the NewOffset property in the property set using a KeyFrame Animation.</source>
          <target>Below, we animate the NewOffset property in the property set using a KeyFrame Animation.</target>
        </segment>
      </unit>
      <unit id="478">
        <segment state="initial">
          <source>You might be wondering if this code executed in an app, what happens to the animated property value the Expression Animation is attached to.</source>
          <target>You might be wondering if this code executed in an app, what happens to the animated property value the Expression Animation is attached to.</target>
        </segment>
      </unit>
      <unit id="479">
        <segment state="initial">
          <source>In this situation, the expression would initially output to a value, however, once the KeyFrame Animation begins to animate the Property in the Property Set, the Expression value will update as well, since the equation is calculated every frame.</source>
          <target>In this situation, the expression would initially output to a value, however, once the KeyFrame Animation begins to animate the Property in the Property Set, the Expression value will update as well, since the equation is calculated every frame.</target>
        </segment>
      </unit>
      <unit id="480">
        <segment state="initial">
          <source>This is the beauty of Property Sets with Expression and KeyFrame Animations!</source>
          <target>This is the beauty of Property Sets with Expression and KeyFrame Animations!</target>
        </segment>
      </unit>
      <unit id="481">
        <segment state="initial">
          <source>Appendix</source>
          <target>Appendix</target>
        </segment>
      </unit>
      <unit id="482">
        <segment state="initial">
          <source>Expression Functions by Structure Type</source>
          <target>Expression Functions by Structure Type</target>
        </segment>
      </unit>
      <unit id="483">
        <segment state="initial">
          <source>Scalar</source>
          <target>Scalar</target>
        </segment>
      </unit>
      <unit id="484">
        <segment state="initial">
          <source>Function and Constructor Operations</source>
          <target>Function and Constructor Operations</target>
        </segment>
      </unit>
      <unit id="485">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="486">
        <segment state="initial">
          <source>Abs(Float value)</source>
          <target>Abs(Float value)</target>
        </segment>
      </unit>
      <unit id="487">
        <segment state="initial">
          <source>Returns a Float representing the absolute value of the float parameter</source>
          <target>Returns a Float representing the absolute value of the float parameter</target>
        </segment>
      </unit>
      <unit id="488">
        <segment state="initial">
          <source>Clamp(Float value, Float min, Float max)</source>
          <target>Clamp(Float value, Float min, Float max)</target>
        </segment>
      </unit>
      <unit id="489">
        <segment state="initial">
          <source>Returns a  float value that is either greater than min and less than max or min if the value is less than min or max if the value is greater than max</source>
          <target>Returns a  float value that is either greater than min and less than max or min if the value is less than min or max if the value is greater than max</target>
        </segment>
      </unit>
      <unit id="490">
        <segment state="initial">
          <source>Max (Float value1, Float value2)</source>
          <target>Max (Float value1, Float value2)</target>
        </segment>
      </unit>
      <unit id="491">
        <segment state="initial">
          <source>Returns the greater float between value1 and value2.</source>
          <target>Returns the greater float between value1 and value2.</target>
        </segment>
      </unit>
      <unit id="492">
        <segment state="initial">
          <source>Min (Float value1, Float value2)</source>
          <target>Min (Float value1, Float value2)</target>
        </segment>
      </unit>
      <unit id="493">
        <segment state="initial">
          <source>Returns the lesser float between value1 and value2.</source>
          <target>Returns the lesser float between value1 and value2.</target>
        </segment>
      </unit>
      <unit id="494">
        <segment state="initial">
          <source>Lerp(Float value1, Float value2, Float progress)</source>
          <target>Lerp(Float value1, Float value2, Float progress)</target>
        </segment>
      </unit>
      <unit id="495">
        <segment state="initial">
          <source>Returns a float that represents the calculated linear interpolation calculation between the two Scalar values based on the progress (Note: Progress is between 0.0 and 1.0)</source>
          <target>Returns a float that represents the calculated linear interpolation calculation between the two Scalar values based on the progress (Note: Progress is between 0.0 and 1.0)</target>
        </segment>
      </unit>
      <unit id="496">
        <segment state="initial">
          <source>Slerp(Float value1, Float value2, Float progress)</source>
          <target>Slerp(Float value1, Float value2, Float progress)</target>
        </segment>
      </unit>
      <unit id="497">
        <segment state="initial">
          <source>Returns a Float that represents the calculated spherical interpolation between the two Float values based on the progress (Note: progress is between 0.0 and 1.0)</source>
          <target>Returns a Float that represents the calculated spherical interpolation between the two Float values based on the progress (Note: progress is between 0.0 and 1.0)</target>
        </segment>
      </unit>
      <unit id="498">
        <segment state="initial">
          <source>Mod(Float value1, Float value2)</source>
          <target>Mod(Float value1, Float value2)</target>
        </segment>
      </unit>
      <unit id="499">
        <segment state="initial">
          <source>Returns the Float remainder resulting from the division of value1 and value2</source>
          <target>Returns the Float remainder resulting from the division of value1 and value2</target>
        </segment>
      </unit>
      <unit id="500">
        <segment state="initial">
          <source>Ceil(Float value)</source>
          <target>Ceil(Float value)</target>
        </segment>
      </unit>
      <unit id="501">
        <segment state="initial">
          <source>Returns the Float parameter rounded to next greater whole number</source>
          <target>Returns the Float parameter rounded to next greater whole number</target>
        </segment>
      </unit>
      <unit id="502">
        <segment state="initial">
          <source>Floor(Float value)</source>
          <target>Floor(Float value)</target>
        </segment>
      </unit>
      <unit id="503">
        <segment state="initial">
          <source>Returns the Float parameter to the next lesser whole number</source>
          <target>Returns the Float parameter to the next lesser whole number</target>
        </segment>
      </unit>
      <unit id="504">
        <segment state="initial">
          <source>Sqrt(Float value)</source>
          <target>Sqrt(Float value)</target>
        </segment>
      </unit>
      <unit id="505">
        <segment state="initial">
          <source>Returns the square root of the Float parameter</source>
          <target>Returns the square root of the Float parameter</target>
        </segment>
      </unit>
      <unit id="506">
        <segment state="initial">
          <source>Square(Float value)</source>
          <target>Square(Float value)</target>
        </segment>
      </unit>
      <unit id="507">
        <segment state="initial">
          <source>Returns the square of the Float parameter</source>
          <target>Returns the square of the Float parameter</target>
        </segment>
      </unit>
      <unit id="508">
        <segment state="initial">
          <source>Sin(Float value1)</source>
          <target>Sin(Float value1)</target>
        </segment>
      </unit>
      <unit id="509">
        <segment state="initial">
          <source>Asin(Float value2)</source>
          <target>Asin(Float value2)</target>
        </segment>
      </unit>
      <unit id="510">
        <segment state="initial">
          <source>Returns the Sin or ArcSin of the Float parameter</source>
          <target>Returns the Sin or ArcSin of the Float parameter</target>
        </segment>
      </unit>
      <unit id="511">
        <segment state="initial">
          <source>Cos(Float value1)</source>
          <target>Cos(Float value1)</target>
        </segment>
      </unit>
      <unit id="512">
        <segment state="initial">
          <source>ACos(Float value2)</source>
          <target>ACos(Float value2)</target>
        </segment>
      </unit>
      <unit id="513">
        <segment state="initial">
          <source>Returns the Cos or ArcCos of the Float parameter</source>
          <target>Returns the Cos or ArcCos of the Float parameter</target>
        </segment>
      </unit>
      <unit id="514">
        <segment state="initial">
          <source>Tan(Float value1)</source>
          <target>Tan(Float value1)</target>
        </segment>
      </unit>
      <unit id="515">
        <segment state="initial">
          <source>ATan(Float value2)</source>
          <target>ATan(Float value2)</target>
        </segment>
      </unit>
      <unit id="516">
        <segment state="initial">
          <source>Returns the Tan or ArcTan of the Float parameter</source>
          <target>Returns the Tan or ArcTan of the Float parameter</target>
        </segment>
      </unit>
      <unit id="517">
        <segment state="initial">
          <source>Round(Float value)</source>
          <target>Round(Float value)</target>
        </segment>
      </unit>
      <unit id="518">
        <segment state="initial">
          <source>Returns the Float parameter rounded to the nearest whole number</source>
          <target>Returns the Float parameter rounded to the nearest whole number</target>
        </segment>
      </unit>
      <unit id="519">
        <segment state="initial">
          <source>Log10(Float value)</source>
          <target>Log10(Float value)</target>
        </segment>
      </unit>
      <unit id="520">
        <segment state="initial">
          <source>Returns the Log (base 10) result of the Float parameter</source>
          <target>Returns the Log (base 10) result of the Float parameter</target>
        </segment>
      </unit>
      <unit id="521">
        <segment state="initial">
          <source>Ln(Float value)</source>
          <target>Ln(Float value)</target>
        </segment>
      </unit>
      <unit id="522">
        <segment state="initial">
          <source>Returns the Natural Log result of the Float parameter</source>
          <target>Returns the Natural Log result of the Float parameter</target>
        </segment>
      </unit>
      <unit id="523">
        <segment state="initial">
          <source>Pow(Float value, Float power)</source>
          <target>Pow(Float value, Float power)</target>
        </segment>
      </unit>
      <unit id="524">
        <segment state="initial">
          <source>Returns the result of the Float parameter raised to a particular power</source>
          <target>Returns the result of the Float parameter raised to a particular power</target>
        </segment>
      </unit>
      <unit id="525">
        <segment state="initial">
          <source>ToDegrees(Float radians)</source>
          <target>ToDegrees(Float radians)</target>
        </segment>
      </unit>
      <unit id="526">
        <segment state="initial">
          <source>Returns the Float parameter converted into Degrees</source>
          <target>Returns the Float parameter converted into Degrees</target>
        </segment>
      </unit>
      <unit id="527">
        <segment state="initial">
          <source>ToRadians(Float degrees)</source>
          <target>ToRadians(Float degrees)</target>
        </segment>
      </unit>
      <unit id="528">
        <segment state="initial">
          <source>Returns the Float parameter converted into Radians</source>
          <target>Returns the Float parameter converted into Radians</target>
        </segment>
      </unit>
      <unit id="529">
        <segment state="initial">
          <source>Vector2</source>
          <target>Vector2</target>
        </segment>
      </unit>
      <unit id="530">
        <segment state="initial">
          <source>Function and Constructor Operations</source>
          <target>Function and Constructor Operations</target>
        </segment>
      </unit>
      <unit id="531">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="532">
        <segment state="initial">
          <source>Abs (Vector2 value)</source>
          <target>Abs (Vector2 value)</target>
        </segment>
      </unit>
      <unit id="533">
        <segment state="initial">
          <source>Returns a Vector2 with absolute value applied to each component</source>
          <target>Returns a Vector2 with absolute value applied to each component</target>
        </segment>
      </unit>
      <unit id="534">
        <segment state="initial">
          <source>Clamp (Vector2 value1, Vector2 min, Vector2 max)</source>
          <target>Clamp (Vector2 value1, Vector2 min, Vector2 max)</target>
        </segment>
      </unit>
      <unit id="535">
        <segment state="initial">
          <source>Returns a Vector2 that contains the clamped values for each respective component</source>
          <target>Returns a Vector2 that contains the clamped values for each respective component</target>
        </segment>
      </unit>
      <unit id="536">
        <segment state="initial">
          <source>Max (Vector2 value1, Vector2 value2)</source>
          <target>Max (Vector2 value1, Vector2 value2)</target>
        </segment>
      </unit>
      <unit id="537">
        <segment state="initial">
          <source>Returns a Vector2 that has performed a Max on each of the corresponding components from value1 and value2</source>
          <target>Returns a Vector2 that has performed a Max on each of the corresponding components from value1 and value2</target>
        </segment>
      </unit>
      <unit id="538">
        <segment state="initial">
          <source>Min (Vector2 value1, Vector2 value2)</source>
          <target>Min (Vector2 value1, Vector2 value2)</target>
        </segment>
      </unit>
      <unit id="539">
        <segment state="initial">
          <source>Returns a Vector2 that has performed a Min on each of the corresponding components from value1 and value2</source>
          <target>Returns a Vector2 that has performed a Min on each of the corresponding components from value1 and value2</target>
        </segment>
      </unit>
      <unit id="540">
        <segment state="initial">
          <source>Scale(Vector2 value, Float factor)</source>
          <target>Scale(Vector2 value, Float factor)</target>
        </segment>
      </unit>
      <unit id="541">
        <segment state="initial">
          <source>Returns a Vector2 with each component of the vector multiplied by the scaling factor.</source>
          <target>Returns a Vector2 with each component of the vector multiplied by the scaling factor.</target>
        </segment>
      </unit>
      <unit id="542">
        <segment state="initial">
          <source>Transform(Vector2 value, Matrix3x2 matrix)</source>
          <target>Transform(Vector2 value, Matrix3x2 matrix)</target>
        </segment>
      </unit>
      <unit id="543">
        <segment state="initial">
          <source>Returns a Vector2 resulting from the linear transformation between a Vector2 and a Matrix3x2 (aka multiplying a vector by a matrix).</source>
          <target>Returns a Vector2 resulting from the linear transformation between a Vector2 and a Matrix3x2 (aka multiplying a vector by a matrix).</target>
        </segment>
      </unit>
      <unit id="544">
        <segment state="initial">
          <source>Lerp(Vector2 value1, Vector2 value2, Float progress)</source>
          <target>Lerp(Vector2 value1, Vector2 value2, Float progress)</target>
        </segment>
      </unit>
      <unit id="545">
        <segment state="initial">
          <source>Returns a Vector2 that represents the calculated linear interpolation calculation between the two Vector2 values based on the progress (Note: Progress is between 0.0 and 1.0)</source>
          <target>Returns a Vector2 that represents the calculated linear interpolation calculation between the two Vector2 values based on the progress (Note: Progress is between 0.0 and 1.0)</target>
        </segment>
      </unit>
      <unit id="546">
        <segment state="initial">
          <source>Length(Vector2 value)</source>
          <target>Length(Vector2 value)</target>
        </segment>
      </unit>
      <unit id="547">
        <segment state="initial">
          <source>Returns a Float value representing the length/magnitude of the Vector2</source>
          <target>Returns a Float value representing the length/magnitude of the Vector2</target>
        </segment>
      </unit>
      <unit id="548">
        <segment state="initial">
          <source>LengthSquared(Vector2)</source>
          <target>LengthSquared(Vector2)</target>
        </segment>
      </unit>
      <unit id="549">
        <segment state="initial">
          <source>Returns a Float value representing the square of the length/magnitude of a Vector2</source>
          <target>Returns a Float value representing the square of the length/magnitude of a Vector2</target>
        </segment>
      </unit>
      <unit id="550">
        <segment state="initial">
          <source>Distance(Vector2 value1, Vector2 value2)</source>
          <target>Distance(Vector2 value1, Vector2 value2)</target>
        </segment>
      </unit>
      <unit id="551">
        <segment state="initial">
          <source>Returns a Float value representing the distance between two Vector2 values</source>
          <target>Returns a Float value representing the distance between two Vector2 values</target>
        </segment>
      </unit>
      <unit id="552">
        <segment state="initial">
          <source>DistanceSquared(Vector2 value1, Vector2 value2)</source>
          <target>DistanceSquared(Vector2 value1, Vector2 value2)</target>
        </segment>
      </unit>
      <unit id="553">
        <segment state="initial">
          <source>Returns a Float value representing the square of the distance between two Vector2 values</source>
          <target>Returns a Float value representing the square of the distance between two Vector2 values</target>
        </segment>
      </unit>
      <unit id="554">
        <segment state="initial">
          <source>Normalize(Vector2 value)</source>
          <target>Normalize(Vector2 value)</target>
        </segment>
      </unit>
      <unit id="555">
        <segment state="initial">
          <source>Returns a Vector2 representing the unit vector of the parameter where all components have been normalized</source>
          <target>Returns a Vector2 representing the unit vector of the parameter where all components have been normalized</target>
        </segment>
      </unit>
      <unit id="556">
        <segment state="initial">
          <source>Vector2(Float x, Float y)</source>
          <target>Vector2(Float x, Float y)</target>
        </segment>
      </unit>
      <unit id="557">
        <segment state="initial">
          <source>Constructs a Vector2 using two Float parameters</source>
          <target>Constructs a Vector2 using two Float parameters</target>
        </segment>
      </unit>
      <unit id="558">
        <segment state="initial">
          <source>Vector3</source>
          <target>Vector3</target>
        </segment>
      </unit>
      <unit id="559">
        <segment state="initial">
          <source>Function and Constructor Operations</source>
          <target>Function and Constructor Operations</target>
        </segment>
      </unit>
      <unit id="560">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="561">
        <segment state="initial">
          <source>Abs (Vector3 value)</source>
          <target>Abs (Vector3 value)</target>
        </segment>
      </unit>
      <unit id="562">
        <segment state="initial">
          <source>Returns a Vector3 with absolute value applied to each component</source>
          <target>Returns a Vector3 with absolute value applied to each component</target>
        </segment>
      </unit>
      <unit id="563">
        <segment state="initial">
          <source>Clamp (Vector3 value1, Vector3 min, Vector3 max)</source>
          <target>Clamp (Vector3 value1, Vector3 min, Vector3 max)</target>
        </segment>
      </unit>
      <unit id="564">
        <segment state="initial">
          <source>Returns a Vector3 that contains the clamped values for each respective component</source>
          <target>Returns a Vector3 that contains the clamped values for each respective component</target>
        </segment>
      </unit>
      <unit id="565">
        <segment state="initial">
          <source>Max (Vector3 value1, Vector3 value2)</source>
          <target>Max (Vector3 value1, Vector3 value2)</target>
        </segment>
      </unit>
      <unit id="566">
        <segment state="initial">
          <source>Returns a Vector3 that has performed a Max on each of the corresponding components from value1 and value2</source>
          <target>Returns a Vector3 that has performed a Max on each of the corresponding components from value1 and value2</target>
        </segment>
      </unit>
      <unit id="567">
        <segment state="initial">
          <source>Min (Vector3 value1, Vector3 value2)</source>
          <target>Min (Vector3 value1, Vector3 value2)</target>
        </segment>
      </unit>
      <unit id="568">
        <segment state="initial">
          <source>Returns a Vector3 that has performed a Min on each of the corresponding components from value1 and value2</source>
          <target>Returns a Vector3 that has performed a Min on each of the corresponding components from value1 and value2</target>
        </segment>
      </unit>
      <unit id="569">
        <segment state="initial">
          <source>Scale(Vector3 value, Float factor)</source>
          <target>Scale(Vector3 value, Float factor)</target>
        </segment>
      </unit>
      <unit id="570">
        <segment state="initial">
          <source>Returns a Vector3 with each component of the vector multiplied by the scaling factor.</source>
          <target>Returns a Vector3 with each component of the vector multiplied by the scaling factor.</target>
        </segment>
      </unit>
      <unit id="571">
        <segment state="initial">
          <source>Lerp(Vector3 value1, Vector3 value2, Float progress)</source>
          <target>Lerp(Vector3 value1, Vector3 value2, Float progress)</target>
        </segment>
      </unit>
      <unit id="572">
        <segment state="initial">
          <source>Returns a Vector3 that represents the calculated linear interpolation calculation between the two Vector3 values based on the progress (Note: Progress is between 0.0 and 1.0)</source>
          <target>Returns a Vector3 that represents the calculated linear interpolation calculation between the two Vector3 values based on the progress (Note: Progress is between 0.0 and 1.0)</target>
        </segment>
      </unit>
      <unit id="573">
        <segment state="initial">
          <source>Length(Vector3 value)</source>
          <target>Length(Vector3 value)</target>
        </segment>
      </unit>
      <unit id="574">
        <segment state="initial">
          <source>Returns a Float value representing the length/magnitude of the Vector3</source>
          <target>Returns a Float value representing the length/magnitude of the Vector3</target>
        </segment>
      </unit>
      <unit id="575">
        <segment state="initial">
          <source>LengthSquared(Vector3)</source>
          <target>LengthSquared(Vector3)</target>
        </segment>
      </unit>
      <unit id="576">
        <segment state="initial">
          <source>Returns a Float value representing the square of the length/magnitude of a Vector3</source>
          <target>Returns a Float value representing the square of the length/magnitude of a Vector3</target>
        </segment>
      </unit>
      <unit id="577">
        <segment state="initial">
          <source>Distance(Vector3 value1, Vector3 value2)</source>
          <target>Distance(Vector3 value1, Vector3 value2)</target>
        </segment>
      </unit>
      <unit id="578">
        <segment state="initial">
          <source>Returns a Float value representing the distance between two Vector3 values</source>
          <target>Returns a Float value representing the distance between two Vector3 values</target>
        </segment>
      </unit>
      <unit id="579">
        <segment state="initial">
          <source>DistanceSquared(Vector3 value1, Vector3 value2)</source>
          <target>DistanceSquared(Vector3 value1, Vector3 value2)</target>
        </segment>
      </unit>
      <unit id="580">
        <segment state="initial">
          <source>Returns a Float value representing the square of the distance between two Vector3 values</source>
          <target>Returns a Float value representing the square of the distance between two Vector3 values</target>
        </segment>
      </unit>
      <unit id="581">
        <segment state="initial">
          <source>Normalize(Vector3 value)</source>
          <target>Normalize(Vector3 value)</target>
        </segment>
      </unit>
      <unit id="582">
        <segment state="initial">
          <source>Returns a Vector3 representing the unit vector of the parameter where all components have been normalized</source>
          <target>Returns a Vector3 representing the unit vector of the parameter where all components have been normalized</target>
        </segment>
      </unit>
      <unit id="583">
        <segment state="initial">
          <source>Vector3(Float x, Float y, Float z)</source>
          <target>Vector3(Float x, Float y, Float z)</target>
        </segment>
      </unit>
      <unit id="584">
        <segment state="initial">
          <source>Constructs a Vector3 using three Float parameters</source>
          <target>Constructs a Vector3 using three Float parameters</target>
        </segment>
      </unit>
      <unit id="585">
        <segment state="initial">
          <source>Vector4</source>
          <target>Vector4</target>
        </segment>
      </unit>
      <unit id="586">
        <segment state="initial">
          <source>Function and Constructor Operations</source>
          <target>Function and Constructor Operations</target>
        </segment>
      </unit>
      <unit id="587">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="588">
        <segment state="initial">
          <source>Abs (Vector4 value)</source>
          <target>Abs (Vector4 value)</target>
        </segment>
      </unit>
      <unit id="589">
        <segment state="initial">
          <source>Returns a Vector3 with absolute value applied to each component</source>
          <target>Returns a Vector3 with absolute value applied to each component</target>
        </segment>
      </unit>
      <unit id="590">
        <segment state="initial">
          <source>Clamp (Vector4 value1, Vector4 min, Vector4 max)</source>
          <target>Clamp (Vector4 value1, Vector4 min, Vector4 max)</target>
        </segment>
      </unit>
      <unit id="591">
        <segment state="initial">
          <source>Returns a Vector4 that contains the clamped values for each respective component</source>
          <target>Returns a Vector4 that contains the clamped values for each respective component</target>
        </segment>
      </unit>
      <unit id="592">
        <segment state="initial">
          <source>Max (Vector4 value1 Vector4 value2)</source>
          <target>Max (Vector4 value1 Vector4 value2)</target>
        </segment>
      </unit>
      <unit id="593">
        <segment state="initial">
          <source>Returns a Vector4 that has performed a Max on each of the corresponding components from value1 and value2</source>
          <target>Returns a Vector4 that has performed a Max on each of the corresponding components from value1 and value2</target>
        </segment>
      </unit>
      <unit id="594">
        <segment state="initial">
          <source>Min (Vector4 value1 Vector4 value2)</source>
          <target>Min (Vector4 value1 Vector4 value2)</target>
        </segment>
      </unit>
      <unit id="595">
        <segment state="initial">
          <source>Returns a Vector4 that has performed a Min on each of the corresponding components from value1 and value2</source>
          <target>Returns a Vector4 that has performed a Min on each of the corresponding components from value1 and value2</target>
        </segment>
      </unit>
      <unit id="596">
        <segment state="initial">
          <source>Scale(Vector3 value, Float factor)</source>
          <target>Scale(Vector3 value, Float factor)</target>
        </segment>
      </unit>
      <unit id="597">
        <segment state="initial">
          <source>Returns a Vector3 with each component of the vector multiplied by the scaling factor.</source>
          <target>Returns a Vector3 with each component of the vector multiplied by the scaling factor.</target>
        </segment>
      </unit>
      <unit id="598">
        <segment state="initial">
          <source>Transform(Vector4 value, Matrix4x4 matrix)</source>
          <target>Transform(Vector4 value, Matrix4x4 matrix)</target>
        </segment>
      </unit>
      <unit id="599">
        <segment state="initial">
          <source>Returns a Vector4 resulting from the linear transformation between a Vector4 and a Matrix4x4 (aka multiplying a vector by a matrix).</source>
          <target>Returns a Vector4 resulting from the linear transformation between a Vector4 and a Matrix4x4 (aka multiplying a vector by a matrix).</target>
        </segment>
      </unit>
      <unit id="600">
        <segment state="initial">
          <source>Lerp(Vector4 value1, Vector4 value2, Float progress)</source>
          <target>Lerp(Vector4 value1, Vector4 value2, Float progress)</target>
        </segment>
      </unit>
      <unit id="601">
        <segment state="initial">
          <source>Returns a Vector4 that represents the calculated linear interpolation calculation between the two Vector4 values based on the progress (Note: progress is between 0.0 and 1.0)</source>
          <target>Returns a Vector4 that represents the calculated linear interpolation calculation between the two Vector4 values based on the progress (Note: progress is between 0.0 and 1.0)</target>
        </segment>
      </unit>
      <unit id="602">
        <segment state="initial">
          <source>Length(Vector4 value)</source>
          <target>Length(Vector4 value)</target>
        </segment>
      </unit>
      <unit id="603">
        <segment state="initial">
          <source>Returns a Float value representing the length/magnitude of the Vector4</source>
          <target>Returns a Float value representing the length/magnitude of the Vector4</target>
        </segment>
      </unit>
      <unit id="604">
        <segment state="initial">
          <source>LengthSquared(Vector4)</source>
          <target>LengthSquared(Vector4)</target>
        </segment>
      </unit>
      <unit id="605">
        <segment state="initial">
          <source>Returns a Float value representing the square of the length/magnitude of a Vector4</source>
          <target>Returns a Float value representing the square of the length/magnitude of a Vector4</target>
        </segment>
      </unit>
      <unit id="606">
        <segment state="initial">
          <source>Distance(Vector4 value1, Vector4 value2)</source>
          <target>Distance(Vector4 value1, Vector4 value2)</target>
        </segment>
      </unit>
      <unit id="607">
        <segment state="initial">
          <source>Returns a Float value representing the distance between two Vector4 values</source>
          <target>Returns a Float value representing the distance between two Vector4 values</target>
        </segment>
      </unit>
      <unit id="608">
        <segment state="initial">
          <source>DistanceSquared(Vector4 value1, Vector4 value2)</source>
          <target>DistanceSquared(Vector4 value1, Vector4 value2)</target>
        </segment>
      </unit>
      <unit id="609">
        <segment state="initial">
          <source>Returns a Float value representing the square of the distance between two Vector4 values</source>
          <target>Returns a Float value representing the square of the distance between two Vector4 values</target>
        </segment>
      </unit>
      <unit id="610">
        <segment state="initial">
          <source>Normalize(Vector4 value)</source>
          <target>Normalize(Vector4 value)</target>
        </segment>
      </unit>
      <unit id="611">
        <segment state="initial">
          <source>Returns a Vector4 representing the unit vector of the parameter where all components have been normalized</source>
          <target>Returns a Vector4 representing the unit vector of the parameter where all components have been normalized</target>
        </segment>
      </unit>
      <unit id="612">
        <segment state="initial">
          <source>Vector4(Float x, Float y, Float z, Float w)</source>
          <target>Vector4(Float x, Float y, Float z, Float w)</target>
        </segment>
      </unit>
      <unit id="613">
        <segment state="initial">
          <source>Constructs a Vector4 using four Float parameters</source>
          <target>Constructs a Vector4 using four Float parameters</target>
        </segment>
      </unit>
      <unit id="614">
        <segment state="initial">
          <source>Matrix3x2</source>
          <target>Matrix3x2</target>
        </segment>
      </unit>
      <unit id="615">
        <segment state="initial">
          <source>Function and Constructor Operations</source>
          <target>Function and Constructor Operations</target>
        </segment>
      </unit>
      <unit id="616">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="617">
        <segment state="initial">
          <source>Scale(Matrix3x2 value, Float factor)</source>
          <target>Scale(Matrix3x2 value, Float factor)</target>
        </segment>
      </unit>
      <unit id="618">
        <segment state="initial">
          <source>Returns a Matrix3x2 with each component of the matrix multiplied by the scaling factor.</source>
          <target>Returns a Matrix3x2 with each component of the matrix multiplied by the scaling factor.</target>
        </segment>
      </unit>
      <unit id="619">
        <segment state="initial">
          <source>Inverse(Matrix 3x2 value)</source>
          <target>Inverse(Matrix 3x2 value)</target>
        </segment>
      </unit>
      <unit id="620">
        <segment state="initial">
          <source>Returns a Matrix3x2 object that represents the reciprocal matrix</source>
          <target>Returns a Matrix3x2 object that represents the reciprocal matrix</target>
        </segment>
      </unit>
      <unit id="621">
        <segment state="initial">
          <source>Lerp(Matrix3x2 value1, Matrix3x2 value2, Float progress)</source>
          <target>Lerp(Matrix3x2 value1, Matrix3x2 value2, Float progress)</target>
        </segment>
      </unit>
      <unit id="622">
        <segment state="initial">
          <source>Returns a Matrix3x2 that represents the calculated linear interpolation calculation between the two Matrix3x2 values based on the progress (Note: progress is between 0.0 and 1.0)</source>
          <target>Returns a Matrix3x2 that represents the calculated linear interpolation calculation between the two Matrix3x2 values based on the progress (Note: progress is between 0.0 and 1.0)</target>
        </segment>
      </unit>
      <unit id="623">
        <segment state="initial">
          <source>Matrix3x2(Float M11, Float M12, Float M21, Float M22, Float M31, Float M32)</source>
          <target>Matrix3x2(Float M11, Float M12, Float M21, Float M22, Float M31, Float M32)</target>
        </segment>
      </unit>
      <unit id="624">
        <segment state="initial">
          <source>Constructs a Matrix3x2 using 6 Float parameters</source>
          <target>Constructs a Matrix3x2 using 6 Float parameters</target>
        </segment>
      </unit>
      <unit id="625">
        <segment state="initial">
          <source>Matrix3x2.CreateFromScale(Vector2 scale)</source>
          <target>Matrix3x2.CreateFromScale(Vector2 scale)</target>
        </segment>
      </unit>
      <unit id="626">
        <segment state="initial">
          <source>Constructs a Matrix3x2 from a Vector2   representing scale</source>
          <target>Constructs a Matrix3x2 from a Vector2   representing scale</target>
        </segment>
      </unit>
      <unit id="627">
        <segment state="initial">
          <source>scale.X, 0.0</source>
          <target>scale.X, 0.0</target>
        </segment>
      </unit>
      <unit id="628">
        <segment state="initial">
          <source>0.0, scale.Y</source>
          <target>0.0, scale.Y</target>
        </segment>
      </unit>
      <unit id="629">
        <segment state="initial">
          <source>0.0, 0.0</source>
          <target>0.0, 0.0</target>
        </segment>
      </unit>
      <unit id="630">
        <segment state="initial">
          <source>Matrix3x2.CreateFromTranslation(Vector2 translation)</source>
          <target>Matrix3x2.CreateFromTranslation(Vector2 translation)</target>
        </segment>
      </unit>
      <unit id="631">
        <segment state="initial">
          <source>Constructs a Matrix3x2 from a Vector2 representing translation</source>
          <target>Constructs a Matrix3x2 from a Vector2 representing translation</target>
        </segment>
      </unit>
      <unit id="632">
        <segment state="initial">
          <source>1.0, 0.0,</source>
          <target>1.0, 0.0,</target>
        </segment>
      </unit>
      <unit id="633">
        <segment state="initial">
          <source>0.0, 1.0,</source>
          <target>0.0, 1.0,</target>
        </segment>
      </unit>
      <unit id="634">
        <segment state="initial">
          <source>translation.X, translation.Y</source>
          <target>translation.X, translation.Y</target>
        </segment>
      </unit>
      <unit id="635">
        <segment state="initial">
          <source>Matrix4x4</source>
          <target>Matrix4x4</target>
        </segment>
      </unit>
      <unit id="636">
        <segment state="initial">
          <source>Function and Constructor Operations</source>
          <target>Function and Constructor Operations</target>
        </segment>
      </unit>
      <unit id="637">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="638">
        <segment state="initial">
          <source>Scale(Matrix4x4 value, Float factor)</source>
          <target>Scale(Matrix4x4 value, Float factor)</target>
        </segment>
      </unit>
      <unit id="639">
        <segment state="initial">
          <source>Returns a Matrix 4x4 with each component of the matrix multiplied by the scaling factor.</source>
          <target>Returns a Matrix 4x4 with each component of the matrix multiplied by the scaling factor.</target>
        </segment>
      </unit>
      <unit id="640">
        <segment state="initial">
          <source>Inverse(Matrix4x4)</source>
          <target>Inverse(Matrix4x4)</target>
        </segment>
      </unit>
      <unit id="641">
        <segment state="initial">
          <source>Returns a Matrix4x4 object that represents the reciprocal matrix</source>
          <target>Returns a Matrix4x4 object that represents the reciprocal matrix</target>
        </segment>
      </unit>
      <unit id="642">
        <segment state="initial">
          <source>Lerp(Matrix4x4 value1, Matrix4x4 value2, Float progress)</source>
          <target>Lerp(Matrix4x4 value1, Matrix4x4 value2, Float progress)</target>
        </segment>
      </unit>
      <unit id="643">
        <segment state="initial">
          <source>Returns a Matrix4x4 that represents the calculated linear interpolation calculation between the two Matrix4x4 values based on the progress (Note: progress is between 0.0 and 1.0)</source>
          <target>Returns a Matrix4x4 that represents the calculated linear interpolation calculation between the two Matrix4x4 values based on the progress (Note: progress is between 0.0 and 1.0)</target>
        </segment>
      </unit>
      <unit id="644">
        <segment state="initial">
          <source>Matrix4x4(Float M11, Float M12, Float M13, Float M14,</source>
          <target>Matrix4x4(Float M11, Float M12, Float M13, Float M14,</target>
        </segment>
      </unit>
      <unit id="645">
        <segment state="initial">
          <source>Float M21, Float M22, Float M23, Float M24,</source>
          <target>Float M21, Float M22, Float M23, Float M24,</target>
        </segment>
      </unit>
      <unit id="646">
        <segment state="initial">
          <source>Float M31, Float M32, Float M33, Float M34,</source>
          <target>Float M31, Float M32, Float M33, Float M34,</target>
        </segment>
      </unit>
      <unit id="647">
        <segment state="initial">
          <source>Float M41, Float M42, Float M43, Float M44)</source>
          <target>Float M41, Float M42, Float M43, Float M44)</target>
        </segment>
      </unit>
      <unit id="648">
        <segment state="initial">
          <source>Constructs a Matrix4x4 using 16 Float parameters</source>
          <target>Constructs a Matrix4x4 using 16 Float parameters</target>
        </segment>
      </unit>
      <unit id="649">
        <segment state="initial">
          <source>Matrix4x4.CreateFromScale(Vector3 scale)</source>
          <target>Matrix4x4.CreateFromScale(Vector3 scale)</target>
        </segment>
      </unit>
      <unit id="650">
        <segment state="initial">
          <source>Constructs a Matrix4x4 from a Vector3 representing scale</source>
          <target>Constructs a Matrix4x4 from a Vector3 representing scale</target>
        </segment>
      </unit>
      <unit id="651">
        <segment state="initial">
          <source>scale.X, 0.0, 0.0, 0.0,</source>
          <target>scale.X, 0.0, 0.0, 0.0,</target>
        </segment>
      </unit>
      <unit id="652">
        <segment state="initial">
          <source>0.0, scale.Y, 0.0, 0.0,</source>
          <target>0.0, scale.Y, 0.0, 0.0,</target>
        </segment>
      </unit>
      <unit id="653">
        <segment state="initial">
          <source>0.0, 0.0, scale.Z, 0.0,</source>
          <target>0.0, 0.0, scale.Z, 0.0,</target>
        </segment>
      </unit>
      <unit id="654">
        <segment state="initial">
          <source>0.0, 0.0, 0.0, 1.0</source>
          <target>0.0, 0.0, 0.0, 1.0</target>
        </segment>
      </unit>
      <unit id="655">
        <segment state="initial">
          <source>Matrix4x4.CreateFromTranslation(Vector3 translation)</source>
          <target>Matrix4x4.CreateFromTranslation(Vector3 translation)</target>
        </segment>
      </unit>
      <unit id="656">
        <segment state="initial">
          <source>Constructs a Matrix4x4 from a Vector3 representing translation</source>
          <target>Constructs a Matrix4x4 from a Vector3 representing translation</target>
        </segment>
      </unit>
      <unit id="657">
        <segment state="initial">
          <source>1.0, 0.0, 0.0, 0.0,</source>
          <target>1.0, 0.0, 0.0, 0.0,</target>
        </segment>
      </unit>
      <unit id="658">
        <segment state="initial">
          <source>0.0, 1.0, 0.0, 0.0,</source>
          <target>0.0, 1.0, 0.0, 0.0,</target>
        </segment>
      </unit>
      <unit id="659">
        <segment state="initial">
          <source>0.0, 0.0, 1.0, 0.0,</source>
          <target>0.0, 0.0, 1.0, 0.0,</target>
        </segment>
      </unit>
      <unit id="660">
        <segment state="initial">
          <source>translation.X, translation.Y, translation.Z, 1.0</source>
          <target>translation.X, translation.Y, translation.Z, 1.0</target>
        </segment>
      </unit>
      <unit id="661">
        <segment state="initial">
          <source>Matrix4x4.CreateFromAxisAngle(Vector3 axis, Float angle)</source>
          <target>Matrix4x4.CreateFromAxisAngle(Vector3 axis, Float angle)</target>
        </segment>
      </unit>
      <unit id="662">
        <segment state="initial">
          <source>Constructs a Matrix4x4 from a Vector3 axis and a Float representing an angle</source>
          <target>Constructs a Matrix4x4 from a Vector3 axis and a Float representing an angle</target>
        </segment>
      </unit>
      <unit id="663">
        <segment state="initial">
          <source>Quaternion</source>
          <target>Quaternion</target>
        </segment>
      </unit>
      <unit id="664">
        <segment state="initial">
          <source>Function and Constructor Operations</source>
          <target>Function and Constructor Operations</target>
        </segment>
      </unit>
      <unit id="665">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="666">
        <segment state="initial">
          <source>Slerp(Quaternion value1, Quaternion value2, Float progress)</source>
          <target>Slerp(Quaternion value1, Quaternion value2, Float progress)</target>
        </segment>
      </unit>
      <unit id="667">
        <segment state="initial">
          <source>Returns a Quaternion that represents the calculated spherical interpolation between the two Quaternion values based on the progress (Note: progress is between 0.0 and 1.0)</source>
          <target>Returns a Quaternion that represents the calculated spherical interpolation between the two Quaternion values based on the progress (Note: progress is between 0.0 and 1.0)</target>
        </segment>
      </unit>
      <unit id="668">
        <segment state="initial">
          <source>Concatenate(Quaternion value1 Quaternion value2)</source>
          <target>Concatenate(Quaternion value1 Quaternion value2)</target>
        </segment>
      </unit>
      <unit id="669">
        <segment state="initial">
          <source>Returns a Quaternion representing a concatenation of two Quaternions (aka a Quaternion that represents a combined two individual rotations)</source>
          <target>Returns a Quaternion representing a concatenation of two Quaternions (aka a Quaternion that represents a combined two individual rotations)</target>
        </segment>
      </unit>
      <unit id="670">
        <segment state="initial">
          <source>Length(Quaternion value)</source>
          <target>Length(Quaternion value)</target>
        </segment>
      </unit>
      <unit id="671">
        <segment state="initial">
          <source>Returns a Float value representing the length/magnitude of the Quaternion.</source>
          <target>Returns a Float value representing the length/magnitude of the Quaternion.</target>
        </segment>
      </unit>
      <unit id="672">
        <segment state="initial">
          <source>LengthSquared(Quaternion)</source>
          <target>LengthSquared(Quaternion)</target>
        </segment>
      </unit>
      <unit id="673">
        <segment state="initial">
          <source>Returns a Float value representing the square of the length/magnitude of a Quaternion</source>
          <target>Returns a Float value representing the square of the length/magnitude of a Quaternion</target>
        </segment>
      </unit>
      <unit id="674">
        <segment state="initial">
          <source>Normalize(Quaternion value)</source>
          <target>Normalize(Quaternion value)</target>
        </segment>
      </unit>
      <unit id="675">
        <segment state="initial">
          <source>Returns a Quaternion whose components have been normalized</source>
          <target>Returns a Quaternion whose components have been normalized</target>
        </segment>
      </unit>
      <unit id="676">
        <segment state="initial">
          <source>Quaternion.CreateFromAxisAngle(Vector3 axis, Scalar angle)</source>
          <target>Quaternion.CreateFromAxisAngle(Vector3 axis, Scalar angle)</target>
        </segment>
      </unit>
      <unit id="677">
        <segment state="initial">
          <source>Constructs a Quaternion from a Vector3 axis and a Scalar representing an angle</source>
          <target>Constructs a Quaternion from a Vector3 axis and a Scalar representing an angle</target>
        </segment>
      </unit>
      <unit id="678">
        <segment state="initial">
          <source>Quaternion(Float x, Float y, Float z, Float w)</source>
          <target>Quaternion(Float x, Float y, Float z, Float w)</target>
        </segment>
      </unit>
      <unit id="679">
        <segment state="initial">
          <source>Constructs a Quaternion from four Float values</source>
          <target>Constructs a Quaternion from four Float values</target>
        </segment>
      </unit>
      <unit id="680">
        <segment state="initial">
          <source>Color</source>
          <target>Color</target>
        </segment>
      </unit>
      <unit id="681">
        <segment state="initial">
          <source>Function and Constructor Operations</source>
          <target>Function and Constructor Operations</target>
        </segment>
      </unit>
      <unit id="682">
        <segment state="initial">
          <source>Description</source>
          <target>Description</target>
        </segment>
      </unit>
      <unit id="683">
        <segment state="initial">
          <source>ColorLerp(Color colorTo, Color colorFrom, Float progress)</source>
          <target>ColorLerp(Color colorTo, Color colorFrom, Float progress)</target>
        </segment>
      </unit>
      <unit id="684">
        <segment state="initial">
          <source>Returns a Color object that represents the calculated linear interpolation value between two color objects based on a given progress.</source>
          <target>Returns a Color object that represents the calculated linear interpolation value between two color objects based on a given progress.</target>
        </segment>
      </unit>
      <unit id="685">
        <segment state="initial">
          <source>(Note: Progress is between 0.0 and 1.0)</source>
          <target>(Note: Progress is between 0.0 and 1.0)</target>
        </segment>
      </unit>
      <unit id="686">
        <segment state="initial">
          <source>ColorLerpRGB(Color colorTo, Color colorFrom, Float progress)</source>
          <target>ColorLerpRGB(Color colorTo, Color colorFrom, Float progress)</target>
        </segment>
      </unit>
      <unit id="687">
        <segment state="initial">
          <source>Returns a Color object that represents the calculated linear interpolation value between two objects based on a given progress in the RGB color space.</source>
          <target>Returns a Color object that represents the calculated linear interpolation value between two objects based on a given progress in the RGB color space.</target>
        </segment>
      </unit>
      <unit id="688">
        <segment state="initial">
          <source>ColorLerpHSL(Color colorTo, Color colorFrom, Float progress)</source>
          <target>ColorLerpHSL(Color colorTo, Color colorFrom, Float progress)</target>
        </segment>
      </unit>
      <unit id="689">
        <segment state="initial">
          <source>Returns a Color object that represents the calculated linear interpolation value between two objects based on a given progress in the HSL color space.</source>
          <target>Returns a Color object that represents the calculated linear interpolation value between two objects based on a given progress in the HSL color space.</target>
        </segment>
      </unit>
      <unit id="690">
        <segment state="initial">
          <source>ColorArgb(Float a, Float r, Float g, Float b)</source>
          <target>ColorArgb(Float a, Float r, Float g, Float b)</target>
        </segment>
      </unit>
      <unit id="691">
        <segment state="initial">
          <source>Constructs an object representing Color defined by ARGB components</source>
          <target>Constructs an object representing Color defined by ARGB components</target>
        </segment>
      </unit>
      <unit id="692">
        <segment state="initial">
          <source>ColorHsl(Float h, Float s, Float l)</source>
          <target>ColorHsl(Float h, Float s, Float l)</target>
        </segment>
      </unit>
      <unit id="693">
        <segment state="initial">
          <source>Constructs an object representing Color defined by HSL components (Note: Hue is defined from 0 and 2pi)</source>
          <target>Constructs an object representing Color defined by HSL components (Note: Hue is defined from 0 and 2pi)</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>