<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0" srcLang="en-US" trgLang="zh-cn" version="2.0" xml:space="default" xmlns="urn:oasis:names:tc:xliff:document:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="oltranslationpriority">
        </mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilepath">windows-apps-src\debug-test-perf\version-adaptive-code.md</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">485fdc19f8fc04c2f7fa01bb3aaf4eda6c8b0fd2</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="tool-id">mdxliff</mda:meta>
        <mda:meta type="tool-name">mdxliff</mda:meta>
        <mda:meta type="tool-version">1.0-781aacf</mda:meta>
        <mda:meta type="tool-company">Microsoft</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source>Version adaptive code</source>
          <target>Version adaptive code</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source>Learn how to take advantage of new APIs while maintaining compatibility with previous versions</source>
          <target>Learn how to take advantage of new APIs while maintaining compatibility with previous versions</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source>Version adaptive code: Use new APIs while maintaining compatability with previous versions</source>
          <target>Version adaptive code: Use new APIs while maintaining compatability with previous versions</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source>Each release of the Windows 10 SDK adds exciting new functionality that you'll want to take advantage of.</source>
          <target>Each release of the Windows 10 SDK adds exciting new functionality that you'll want to take advantage of.</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source>However, not all your customers will update their devices to the latest version of Windows 10 at the same time, and you want to make sure your app works on the broadest possible range of devices.</source>
          <target>However, not all your customers will update their devices to the latest version of Windows 10 at the same time, and you want to make sure your app works on the broadest possible range of devices.</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source>Here, we show you how to design your app so that it runs on earlier versions of Windows 10, but also takes advantage of new features whenever your app runs on a device with the latest update installed.</source>
          <target>Here, we show you how to design your app so that it runs on earlier versions of Windows 10, but also takes advantage of new features whenever your app runs on a device with the latest update installed.</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source>There are 2 steps to take to make sure your app supports the broadest range of Windows 10 devices.</source>
          <target>There are 2 steps to take to make sure your app supports the broadest range of Windows 10 devices.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source>First, configure your Visual Studio project to target the latest APIs.</source>
          <target>First, configure your Visual Studio project to target the latest APIs.</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source>This affects what happens when you compile your app.</source>
          <target>This affects what happens when you compile your app.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source>Second, perform runtime checks to ensure that you only call APIs that are present on the device your app is running on.</source>
          <target>Second, perform runtime checks to ensure that you only call APIs that are present on the device your app is running on.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source>This article uses examples from the Windows Insider Preview SDK for Windows 10, version 1607 (Anniversary Update).</source>
          <target>This article uses examples from the Windows Insider Preview SDK for Windows 10, version 1607 (Anniversary Update).</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source>The Preview SDK is a pre-release and cannot be used in a production environment.</source>
          <target>The Preview SDK is a pre-release and cannot be used in a production environment.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source>Please only install the SDK on your test machine.</source>
          <target>Please only install the SDK on your test machine.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source>The Preview SDK contains bug fixes and under-development changes to the API surface area.</source>
          <target>The Preview SDK contains bug fixes and under-development changes to the API surface area.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source>If you are working on an application that you need to submit to the store, you should not install the preview.</source>
          <target>If you are working on an application that you need to submit to the store, you should not install the preview.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source>Configure your Visual Studio project</source>
          <target>Configure your Visual Studio project</target>
        </segment>
      </unit>
      <unit id="117">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source>The first step in supporting multiple Windows 10 versions is to specify the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Target</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Minimum</pc> supported OS/SDK versions in your Visual Studio project.</source>
          <target>The first step in supporting multiple Windows 10 versions is to specify the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Target</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Minimum</pc> supported OS/SDK versions in your Visual Studio project.</target>
        </segment>
      </unit>
      <unit id="118">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Target</pc>: The SDK version that Visual Studio compiles your app code and run all tools against.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Target</pc>: The SDK version that Visual Studio compiles your app code and run all tools against.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source>All APIs and resources in this SDK version are available in your app code at compile time.</source>
          <target>All APIs and resources in this SDK version are available in your app code at compile time.</target>
        </segment>
      </unit>
      <unit id="120">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Minimum</pc>: The SDK version that supports the earliest OS version that your app can run on (and will be deployed to by the store) and the version that Visual Studio compiles your app markup code against.</source>
          <target>
            <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Minimum</pc>: The SDK version that supports the earliest OS version that your app can run on (and will be deployed to by the store) and the version that Visual Studio compiles your app markup code against.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source>During runtime your app will run against the OS version that it is deployed to, so your app will throw exceptions if you use resources or call APIs that are not available in that version.</source>
          <target>During runtime your app will run against the OS version that it is deployed to, so your app will throw exceptions if you use resources or call APIs that are not available in that version.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source>We show you how to use runtime checks to call the correct APIs later in this article.</source>
          <target>We show you how to use runtime checks to call the correct APIs later in this article.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source>The Target and Minimum settings specify the ends of a range of OS/SDK versions.</source>
          <target>The Target and Minimum settings specify the ends of a range of OS/SDK versions.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source>However, if you test your app on the minimum version, you can be sure it will run on any versions between the Minimum and Target.</source>
          <target>However, if you test your app on the minimum version, you can be sure it will run on any versions between the Minimum and Target.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source>Visual Studio does not warn you about API compatibility.</source>
          <target>Visual Studio does not warn you about API compatibility.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source>It is your responsibility to test and ensure that your app performs as expected on all OS versions between and including the Minimum and Target.</source>
          <target>It is your responsibility to test and ensure that your app performs as expected on all OS versions between and including the Minimum and Target.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source>When you create a new project in Visual Studio 2015, Update 2 or later, you are prompted to set the Target and Minimum versions that your app supports.</source>
          <target>When you create a new project in Visual Studio 2015, Update 2 or later, you are prompted to set the Target and Minimum versions that your app supports.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source>By default, the Target Version is the highest installed SDK version, and the Minimum Version is the lowest installed SDK version.</source>
          <target>By default, the Target Version is the highest installed SDK version, and the Minimum Version is the lowest installed SDK version.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source>You can choose Target and Minimum only from SDK versions that are installed on your machine.</source>
          <target>You can choose Target and Minimum only from SDK versions that are installed on your machine.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source>Set the target SDK in Visual Studio</source>
          <target>Set the target SDK in Visual Studio</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source>We typically recommend that you leave the defaults.</source>
          <target>We typically recommend that you leave the defaults.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source>However, if you have a Preview version of the SDK installed and you are writing production code, you should change the Target Version from the Preview SDK to the latest official SDK version.</source>
          <target>However, if you have a Preview version of the SDK installed and you are writing production code, you should change the Target Version from the Preview SDK to the latest official SDK version.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source>To change the Minimum and Target version for a project that has already been created in Visual Studio, go to Project -&gt; Properties -&gt; Application tab -&gt; Targeting.</source>
          <target>To change the Minimum and Target version for a project that has already been created in Visual Studio, go to Project -&gt; Properties -&gt; Application tab -&gt; Targeting.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source>Change the target SDK in Visual Studio</source>
          <target>Change the target SDK in Visual Studio</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source>For reference these are the build numbers for each SDK:</source>
          <target>For reference these are the build numbers for each SDK:</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source>Windows 10, version 1506: SDK version 10240</source>
          <target>Windows 10, version 1506: SDK version 10240</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source>Windows 10, version 1511 (November Update): SDK version 10586</source>
          <target>Windows 10, version 1511 (November Update): SDK version 10586</target>
        </segment>
      </unit>
      <unit id="138">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://blogs.windows.com/buildingapps/2016/04/28/windows-10-anniversary-sdk-preview-build-14332-released/)</data>
        </originalData>
        <segment state="initial">
          <source>Windows 10, version 1607 Insider Preview (Anniversary Update): As of this writing, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">the latest Insider Preview SDK version is 14332</pc>.</source>
          <target>Windows 10, version 1607 Insider Preview (Anniversary Update): As of this writing, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">the latest Insider Preview SDK version is 14332</pc>.</target>
        </segment>
      </unit>
      <unit id="139">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://developer.microsoft.com/downloads/sdk-archive)</data>
        </originalData>
        <segment state="initial">
          <source>You can download any released version of the SDK from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows SDK and emulator archive</pc>.</source>
          <target>You can download any released version of the SDK from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows SDK and emulator archive</pc>.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://insider.windows.com/)</data>
        </originalData>
        <segment state="initial">
          <source>You can download the latest Windows Insider Preview SDK from the developer section of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Insider</pc> site.</source>
          <target>You can download the latest Windows Insider Preview SDK from the developer section of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows Insider</pc> site.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source>Write adaptive code</source>
          <target>Write adaptive code</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/windows/uwp/layout/layouts-with-xaml)</data>
        </originalData>
        <segment state="initial">
          <source>You can think about writing adaptive code similarly to how you think about <pc dataRefEnd="id2" dataRefStart="id1" id="p1">creating an adaptive UI</pc>.</source>
          <target>You can think about writing adaptive code similarly to how you think about <pc dataRefEnd="id2" dataRefStart="id1" id="p1">creating an adaptive UI</pc>.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source>You might design your base UI to run on the smallest screen, and then move or add elements when you detect that your app is running on a larger screen.</source>
          <target>You might design your base UI to run on the smallest screen, and then move or add elements when you detect that your app is running on a larger screen.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source>With adaptive code, you write your base code to run on the lowest OS version, and you can add hand-selected features when you detect that your app is running on a higher version where the new feature is available.</source>
          <target>With adaptive code, you write your base code to run on the lowest OS version, and you can add hand-selected features when you detect that your app is running on a higher version where the new feature is available.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source>Runtime API checks</source>
          <target>Runtime API checks</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>You use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows.Foundation.Metadata.ApiInformation</pc> class in a condition in your code to test for the presence of the API you want to call.</source>
          <target>You use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows.Foundation.Metadata.ApiInformation</pc> class in a condition in your code to test for the presence of the API you want to call.</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>This condition is evaluated wherever your app runs, but it evaluates to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc> only on devices where the API is present and therefore available to call.</source>
          <target>This condition is evaluated wherever your app runs, but it evaluates to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc> only on devices where the API is present and therefore available to call.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source>This lets you to write version adaptive code in order to create apps that use APIs that are available only on certain OS versions.</source>
          <target>This lets you to write version adaptive code in order to create apps that use APIs that are available only on certain OS versions.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source>Here we look at specific examples for targeting new features in the Windows Insider Preview.</source>
          <target>Here we look at specific examples for targeting new features in the Windows Insider Preview.</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/windows/uwp/get-started/universal-application-platform-guide)</data>
          <data id="id5">[</data>
          <data id="id6">](https://blogs.windows.com/buildingapps/2015/09/15/dynamically-detecting-features-with-api-contracts-10-by-10/)</data>
        </originalData>
        <segment state="initial">
          <source>For a general overview of using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ApiInformation</pc>, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Guide to UWP apps</pc> and the blog post <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Dynamically detecting features with API contracts</pc>.</source>
          <target>For a general overview of using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ApiInformation</pc>, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Guide to UWP apps</pc> and the blog post <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Dynamically detecting features with API contracts</pc>.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source>Numerous runtime API checks can affect the performance of your app.</source>
          <target>Numerous runtime API checks can affect the performance of your app.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source>We show the checks inline in these examples.</source>
          <target>We show the checks inline in these examples.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source>In production code, you should perform the check once and cache the result, then used the cached result throughout your app.</source>
          <target>In production code, you should perform the check once and cache the result, then used the cached result throughout your app.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source>Unsupported scenarios</source>
          <target>Unsupported scenarios</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source>In most cases, you can keep your app's Minimum Version set to SDK version 10240 and use runtime checks to enable any new APIs when your app runs on later a version.</source>
          <target>In most cases, you can keep your app's Minimum Version set to SDK version 10240 and use runtime checks to enable any new APIs when your app runs on later a version.</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source>However, there are some cases where you must increase your app's Minimum Version in order to use new features.</source>
          <target>However, there are some cases where you must increase your app's Minimum Version in order to use new features.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source>You must increase your app's Minimum Version if you use:</source>
          <target>You must increase your app's Minimum Version if you use:</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source>a new API that requires a capability that isn't available in an earlier version.</source>
          <target>a new API that requires a capability that isn't available in an earlier version.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source>You must increase the minimum supported version to one that includes that capability.</source>
          <target>You must increase the minimum supported version to one that includes that capability.</target>
        </segment>
      </unit>
      <unit id="160">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](../packaging/app-capability-declarations.md)</data>
        </originalData>
        <segment state="initial">
          <source>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">App capability declarations</pc>.</source>
          <target>For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">App capability declarations</pc>.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source>any new resource keys added to generic.xaml and not available in a previous version.</source>
          <target>any new resource keys added to generic.xaml and not available in a previous version.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source>The version of generic.xaml used at runtime is determined by the OS version the device is running on.</source>
          <target>The version of generic.xaml used at runtime is determined by the OS version the device is running on.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source>You can't use runtime API checks to determine the presence of XAML resources.</source>
          <target>You can't use runtime API checks to determine the presence of XAML resources.</target>
        </segment>
      </unit>
      <unit id="164">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.markup.xamlparseexception.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>So, you must only use resource keys that are available in the minimum version that your app supports or a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAMLParseException</pc> will cause your app to crash at runtime.</source>
          <target>So, you must only use resource keys that are available in the minimum version that your app supports or a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAMLParseException</pc> will cause your app to crash at runtime.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source>Adaptive code options</source>
          <target>Adaptive code options</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source>There are two ways to create adaptive code.</source>
          <target>There are two ways to create adaptive code.</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source>In most cases, you write your app markup to run on the Minimum version, then use your app code to tap into newer OS features when present.</source>
          <target>In most cases, you write your app markup to run on the Minimum version, then use your app code to tap into newer OS features when present.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source>However, if you need to update a property in a visual state, and there is only a property or enumeration value change between OS versions, you can create an extensible state trigger that’s activated based on the presence of an API.</source>
          <target>However, if you need to update a property in a visual state, and there is only a property or enumeration value change between OS versions, you can create an extensible state trigger that’s activated based on the presence of an API.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source>Here, we compare these options.</source>
          <target>Here, we compare these options.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source>App code</source>
          <target>App code</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source>When to use:</source>
          <target>When to use:</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source>Recommended for all adaptive code scenarios except for specific cases defined below for extensible triggers.</source>
          <target>Recommended for all adaptive code scenarios except for specific cases defined below for extensible triggers.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source>Benefits:</source>
          <target>Benefits:</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source>Avoids developer overhead/complexity of tying API differences into markup.</source>
          <target>Avoids developer overhead/complexity of tying API differences into markup.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source>Drawbacks:</source>
          <target>Drawbacks:</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source>No Designer support.</source>
          <target>No Designer support.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source>State Triggers</source>
          <target>State Triggers</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source>When to use:</source>
          <target>When to use:</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source>Use when there is only a property or enum change between OS versions that doesn’t require logic changes, and is connected to a visual state.</source>
          <target>Use when there is only a property or enum change between OS versions that doesn’t require logic changes, and is connected to a visual state.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source>Benefits:</source>
          <target>Benefits:</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source>Lets you create specific visual states that are triggered based on the presence of an API.</source>
          <target>Lets you create specific visual states that are triggered based on the presence of an API.</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source>Some designer support available.</source>
          <target>Some designer support available.</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source>Drawbacks:</source>
          <target>Drawbacks:</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source>Use of custom triggers is restricted to visual states, which doesn’t lend itself to complicated adaptive layouts.</source>
          <target>Use of custom triggers is restricted to visual states, which doesn’t lend itself to complicated adaptive layouts.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source>Must use Setters to specify value changes, so only simple changes are possible.</source>
          <target>Must use Setters to specify value changes, so only simple changes are possible.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source>Custom state triggers are fairly verbose to set up and use.</source>
          <target>Custom state triggers are fairly verbose to set up and use.</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source>Adaptive code examples</source>
          <target>Adaptive code examples</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source>In this section, we show several examples of adaptive code that use APIs that are new in Windows 10, version 1607 (Windows Insider Preview).</source>
          <target>In this section, we show several examples of adaptive code that use APIs that are new in Windows 10, version 1607 (Windows Insider Preview).</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source>Example 1: New enum value</source>
          <target>Example 1: New enum value</target>
        </segment>
      </unit>
      <unit id="190">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.input.inputscopenamevalue.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Windows 10, version 1607 adds a new value to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InputScopeNameValue</pc> enumeration: <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChatWithoutEmoji</pc>.</source>
          <target>Windows 10, version 1607 adds a new value to the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InputScopeNameValue</pc> enumeration: <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChatWithoutEmoji</pc>.</target>
        </segment>
      </unit>
      <unit id="191">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>This new input scope has the same input behavior as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Chat</pc> input scope (spellchecking, auto-complete, auto-capitalization), but it maps to a touch keyboard without an emoji button.</source>
          <target>This new input scope has the same input behavior as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Chat</pc> input scope (spellchecking, auto-complete, auto-capitalization), but it maps to a touch keyboard without an emoji button.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source>This is useful if you create your own emoji picker and want to disable the built-in emoji button in the touch keyboard.</source>
          <target>This is useful if you create your own emoji picker and want to disable the built-in emoji button in the touch keyboard.</target>
        </segment>
      </unit>
      <unit id="193">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textbox.inputscope.aspx)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>This example shows how to check if the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChatWithoutEmoji</pc> enum value is present and sets the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">InputScope</pc> property of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">TextBox</pc> if it is.</source>
          <target>This example shows how to check if the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ChatWithoutEmoji</pc> enum value is present and sets the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">InputScope</pc> property of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">TextBox</pc> if it is.</target>
        </segment>
      </unit>
      <unit id="194">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>If it’s not present on the system the app is run on, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InputScope</pc> is set to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Chat</pc> instead.</source>
          <target>If it’s not present on the system the app is run on, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">InputScope</pc> is set to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Chat</pc> instead.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source>The code shown could be placed in a Page consructor or Page.Loaded event handler.</source>
          <target>The code shown could be placed in a Page consructor or Page.Loaded event handler.</target>
        </segment>
      </unit>
      <unit id="196">
        <segment state="initial">
          <source>When you check an API, use static strings instead of relying on .NET language features, otherwise your app might try to access a type that isn’t defined and crash at runtime.</source>
          <target>When you check an API, use static strings instead of relying on .NET language features, otherwise your app might try to access a type that isn’t defined and crash at runtime.</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source>C</source>
          <target>C</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source>In the previous example, the TextBox is created and all properties are set in code.</source>
          <target>In the previous example, the TextBox is created and all properties are set in code.</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source>However, if you have existing XAML, and just need to change the InputScope property on systems where the new value is supported, you can do that without changing your XAML, as shown here.</source>
          <target>However, if you have existing XAML, and just need to change the InputScope property on systems where the new value is supported, you can do that without changing your XAML, as shown here.</target>
        </segment>
      </unit>
      <unit id="200">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>You set the default value to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Chat</pc> in XAML, but you override it in code if the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChatWithoutEmoji</pc> value is present.</source>
          <target>You set the default value to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Chat</pc> in XAML, but you override it in code if the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ChatWithoutEmoji</pc> value is present.</target>
        </segment>
      </unit>
      <unit id="201">
        <segment state="initial">
          <source>XAML</source>
          <target>XAML</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source>C</source>
          <target>C</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source>Now that we have a concrete example, let’s see how the Target and Minimum version settings apply to it.</source>
          <target>Now that we have a concrete example, let’s see how the Target and Minimum version settings apply to it.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source>In these examples, you can use the Chat enum value in XAML, or in code without a check, because it’s present in the minimum supported OS version.</source>
          <target>In these examples, you can use the Chat enum value in XAML, or in code without a check, because it’s present in the minimum supported OS version.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source>If you use the ChatWithoutEmoji value in XAML, or in code without a check, it will compile without error because it's present in the Target OS version.</source>
          <target>If you use the ChatWithoutEmoji value in XAML, or in code without a check, it will compile without error because it's present in the Target OS version.</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source>It will also run without error on a system with the Target OS version.</source>
          <target>It will also run without error on a system with the Target OS version.</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source>However, when the app runs on a system with an OS using the Minimum version, it will crash at runtime because the ChatWithoutEmoji enum value is not present.</source>
          <target>However, when the app runs on a system with an OS using the Minimum version, it will crash at runtime because the ChatWithoutEmoji enum value is not present.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source>Therefore, you must use this value only in code, and wrap it in a runtime API check so it’s called only if it’s supported on the current system.</source>
          <target>Therefore, you must use this value only in code, and wrap it in a runtime API check so it’s called only if it’s supported on the current system.</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source>Example 2: New control</source>
          <target>Example 2: New control</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source>A new version of Windows typically brings new controls to the UWP API surface that bring new functionality to the platform.</source>
          <target>A new version of Windows typically brings new controls to the UWP API surface that bring new functionality to the platform.</target>
        </segment>
      </unit>
      <unit id="211">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.istypepresent.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>To leverage the presence of a new control, use the  <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ApiInformation.IsTypePresent</pc> method.</source>
          <target>To leverage the presence of a new control, use the  <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ApiInformation.IsTypePresent</pc> method.</target>
        </segment>
      </unit>
      <unit id="212">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaplayerelement.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>Windows 10, version 1607 introduces a new media control called <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaPlayerElement</pc></pc>.</source>
          <target>Windows 10, version 1607 introduces a new media control called <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaPlayerElement</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="213">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplayer.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>This control builds on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaPlayer</pc> class, so it brings features like the ability to easily tie into background audio, and it makes use of architectural improvements in the media stack.</source>
          <target>This control builds on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">MediaPlayer</pc> class, so it brings features like the ability to easily tie into background audio, and it makes use of architectural improvements in the media stack.</target>
        </segment>
      </unit>
      <unit id="214">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source>However, if the app runs on a device that’s running a version of Windows 10 older than version 1607, you must use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> control instead of the new <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MediaPlayerElement</pc> control.</source>
          <target>However, if the app runs on a device that’s running a version of Windows 10 older than version 1607, you must use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MediaElement</pc></pc> control instead of the new <pc dataRefEnd="id6" dataRefStart="id5" id="p3">MediaPlayerElement</pc> control.</target>
        </segment>
      </unit>
      <unit id="215">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.istypepresent.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ApiInformation.IsTypePresent</pc></pc> method to check for the presence of the MediaPlayerElement control at runtime, and load whichever control is suitable for the system where the app is running.</source>
          <target>You can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ApiInformation.IsTypePresent</pc></pc> method to check for the presence of the MediaPlayerElement control at runtime, and load whichever control is suitable for the system where the app is running.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source>This example shows how to create an app that uses either the new MediaPlayerElement or the old MediaElement depending on whether MediaPlayerElement type is present.</source>
          <target>This example shows how to create an app that uses either the new MediaPlayerElement or the old MediaElement depending on whether MediaPlayerElement type is present.</target>
        </segment>
      </unit>
      <unit id="217">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.usercontrol.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>In this code, you use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserControl</pc> class to componentize the controls and their related UI and code so that you can switch them in and out based on the OS version.</source>
          <target>In this code, you use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UserControl</pc> class to componentize the controls and their related UI and code so that you can switch them in and out based on the OS version.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source>As an alternative, you can use a custom control, which provides more functionality and custom behavior than what’s needed for this simple example.</source>
          <target>As an alternative, you can use a custom control, which provides more functionality and custom behavior than what’s needed for this simple example.</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source>MediaPlayerUserControl</source>
          <target>MediaPlayerUserControl</target>
        </segment>
      </unit>
      <unit id="220">
        <originalData>
          <data id="id1">`MediaPlayerUserControl`</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
        </originalData>
        <segment state="initial">
          <source>The <ph dataRef="id1" id="ph1" /> encapsulates a <pc dataRefEnd="id3" dataRefStart="id2" id="p1">MediaPlayerElement</pc> and several buttons that are used to skip through the media frame by frame.</source>
          <target>The <ph dataRef="id1" id="ph1" /> encapsulates a <pc dataRefEnd="id3" dataRefStart="id2" id="p1">MediaPlayerElement</pc> and several buttons that are used to skip through the media frame by frame.</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source>The UserControl lets you treat these controls as a single entity and makes it easier to switch with a MediaElement on older systems.</source>
          <target>The UserControl lets you treat these controls as a single entity and makes it easier to switch with a MediaElement on older systems.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source>This user control should be used only on systems where MediaPlayerElement is present, so you don’t use ApiInformation checks in the code inside this user control.</source>
          <target>This user control should be used only on systems where MediaPlayerElement is present, so you don’t use ApiInformation checks in the code inside this user control.</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source>To keep this example simple and focused, the frame step buttons are placed outside of the media player.</source>
          <target>To keep this example simple and focused, the frame step buttons are placed outside of the media player.</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source>For a better user experiance, you should customize the MediaTransportControls to include your custom buttons.</source>
          <target>For a better user experiance, you should customize the MediaTransportControls to include your custom buttons.</target>
        </segment>
      </unit>
      <unit id="225">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/windows/uwp/controls-and-patterns/custom-transport-controls)</data>
        </originalData>
        <segment state="initial">
          <source>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom transport controls</pc> for more info.</source>
          <target>See <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom transport controls</pc> for more info.</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source>XAML</source>
          <target>XAML</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source>C</source>
          <target>C</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source>MediaElementUserControl</source>
          <target>MediaElementUserControl</target>
        </segment>
      </unit>
      <unit id="229">
        <originalData>
          <data id="id1">`MediaElementUserControl`</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
        </originalData>
        <segment state="initial">
          <source>The <ph dataRef="id1" id="ph1" /> encapsulates a <pc dataRefEnd="id3" dataRefStart="id2" id="p1">MediaElement</pc> control.</source>
          <target>The <ph dataRef="id1" id="ph1" /> encapsulates a <pc dataRefEnd="id3" dataRefStart="id2" id="p1">MediaElement</pc> control.</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source>XAML</source>
          <target>XAML</target>
        </segment>
      </unit>
      <unit id="231">
        <originalData>
          <data id="id1">`MediaElementUserControl`</data>
        </originalData>
        <segment state="initial">
          <source>The code page for <ph dataRef="id1" id="ph1" /> contains only generated code, so it's not shown.</source>
          <target>The code page for <ph dataRef="id1" id="ph1" /> contains only generated code, so it's not shown.</target>
        </segment>
      </unit>
      <unit id="232">
        <segment state="initial">
          <source>Initialize a control based on IsTypePresent</source>
          <target>Initialize a control based on IsTypePresent</target>
        </segment>
      </unit>
      <unit id="233">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>At runtime, you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ApiInformation.IsTypePresent</pc> to check for MediaPlayerElement.</source>
          <target>At runtime, you call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ApiInformation.IsTypePresent</pc> to check for MediaPlayerElement.</target>
        </segment>
      </unit>
      <unit id="234">
        <originalData>
          <data id="id1">`MediaPlayerUserControl`</data>
          <data id="id2">`MediaElementUserControl`</data>
        </originalData>
        <segment state="initial">
          <source>If it's present, you load <ph dataRef="id1" id="ph1" />, if it's not, you load <ph dataRef="id2" id="ph2" />.</source>
          <target>If it's present, you load <ph dataRef="id1" id="ph1" />, if it's not, you load <ph dataRef="id2" id="ph2" />.</target>
        </segment>
      </unit>
      <unit id="235">
        <segment state="initial">
          <source>C</source>
          <target>C</target>
        </segment>
      </unit>
      <unit id="236">
        <originalData>
          <data id="id1">`mediaControl`</data>
          <data id="id2">`MediaPlayerUserControl`</data>
          <data id="id3">`MediaElementUserControl`</data>
        </originalData>
        <segment state="initial">
          <source>Remember that this check only sets the <ph dataRef="id1" id="ph1" /> object to either <ph dataRef="id2" id="ph2" /> or <ph dataRef="id3" id="ph3" />.</source>
          <target>Remember that this check only sets the <ph dataRef="id1" id="ph1" /> object to either <ph dataRef="id2" id="ph2" /> or <ph dataRef="id3" id="ph3" />.</target>
        </segment>
      </unit>
      <unit id="237">
        <segment state="initial">
          <source>You need to perform these conditional checks anywhere else in your code that you need to determine whether to use MediaPlayerElement or MediaElement APIs.</source>
          <target>You need to perform these conditional checks anywhere else in your code that you need to determine whether to use MediaPlayerElement or MediaElement APIs.</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source>You should perform the check once and cache the result, then used the cached result throughout your app.</source>
          <target>You should perform the check once and cache the result, then used the cached result throughout your app.</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source>State trigger examples</source>
          <target>State trigger examples</target>
        </segment>
      </unit>
      <unit id="240">
        <segment state="initial">
          <source>Extensible state triggers let you use markup and code together to trigger visual state changes based on a condition that you check in code; in this case, the presence of a specific API.</source>
          <target>Extensible state triggers let you use markup and code together to trigger visual state changes based on a condition that you check in code; in this case, the presence of a specific API.</target>
        </segment>
      </unit>
      <unit id="241">
        <segment state="initial">
          <source>We don’t recommend state triggers for common adaptive code scenarios because of the overhead involved, and the restriction to only visual states.</source>
          <target>We don’t recommend state triggers for common adaptive code scenarios because of the overhead involved, and the restriction to only visual states.</target>
        </segment>
      </unit>
      <unit id="242">
        <segment state="initial">
          <source>You should use state triggers for adaptive code only when you have small UI changes between different OS versions that won’t impact the remaining UI, such as a property or enum value change on a control.</source>
          <target>You should use state triggers for adaptive code only when you have small UI changes between different OS versions that won’t impact the remaining UI, such as a property or enum value change on a control.</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source>Example 1: New property</source>
          <target>Example 1: New property</target>
        </segment>
      </unit>
      <unit id="244">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.statetriggerbase.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>The first step in setting up an extensible state trigger is subclassing the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StateTriggerBase</pc> class to create a custom trigger that will be active based on the presence of an API.</source>
          <target>The first step in setting up an extensible state trigger is subclassing the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StateTriggerBase</pc> class to create a custom trigger that will be active based on the presence of an API.</target>
        </segment>
      </unit>
      <unit id="245">
        <originalData>
          <data id="id1">`_isPresent`</data>
        </originalData>
        <segment state="initial">
          <source>This example shows a trigger that activates if the property presence matches the <ph dataRef="id1" id="ph1" /> variable set in XAML.</source>
          <target>This example shows a trigger that activates if the property presence matches the <ph dataRef="id1" id="ph1" /> variable set in XAML.</target>
        </segment>
      </unit>
      <unit id="246">
        <segment state="initial">
          <source>C</source>
          <target>C</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source>The next step is setting up the visual state trigger in XAML so that two different visual states result based on the presence of the API.</source>
          <target>The next step is setting up the visual state trigger in XAML so that two different visual states result based on the presence of the API.</target>
        </segment>
      </unit>
      <unit id="248">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.frameworkelement.aspx)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.frameworkelement.allowfocusoninteraction.aspx)</data>
        </originalData>
        <segment state="initial">
          <source>Windows 10, version 1607 introduces a new property on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElement</pc> class called <pc dataRefEnd="id4" dataRefStart="id3" id="p2">AllowFocusOnInteraction</pc> that determines whether a control takes focus when  a user interacts with it.</source>
          <target>Windows 10, version 1607 introduces a new property on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">FrameworkElement</pc> class called <pc dataRefEnd="id4" dataRefStart="id3" id="p2">AllowFocusOnInteraction</pc> that determines whether a control takes focus when  a user interacts with it.</target>
        </segment>
      </unit>
      <unit id="249">
        <segment state="initial">
          <source>This is useful if you want to keep focus on a text box for data entry (and keep the touch keyboard showing) while the user clicks a button.</source>
          <target>This is useful if you want to keep focus on a text box for data entry (and keep the touch keyboard showing) while the user clicks a button.</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source>The trigger in this example checks if the property is present.</source>
          <target>The trigger in this example checks if the property is present.</target>
        </segment>
      </unit>
      <unit id="251">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source>If the property is present it sets the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AllowFocusOnInteraction</pc> property on a Button to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">false</pc>; if the property isn’t present, the Button retains its original state.</source>
          <target>If the property is present it sets the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AllowFocusOnInteraction</pc> property on a Button to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">false</pc>; if the property isn’t present, the Button retains its original state.</target>
        </segment>
      </unit>
      <unit id="252">
        <segment state="initial">
          <source>The TextBox is included to make it easier to see the effect of this property when you run the code.</source>
          <target>The TextBox is included to make it easier to see the effect of this property when you run the code.</target>
        </segment>
      </unit>
      <unit id="253">
        <segment state="initial">
          <source>XAML</source>
          <target>XAML</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source>Example 2: New enum value</source>
          <target>Example 2: New enum value</target>
        </segment>
      </unit>
      <unit id="255">
        <segment state="initial">
          <source>This example shows how to set different enumeration values based on whether a value is present.</source>
          <target>This example shows how to set different enumeration values based on whether a value is present.</target>
        </segment>
      </unit>
      <unit id="256">
        <segment state="initial">
          <source>It uses a custom state trigger to achieve the same result as the previous chat example.</source>
          <target>It uses a custom state trigger to achieve the same result as the previous chat example.</target>
        </segment>
      </unit>
      <unit id="257">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source>In this example, you use the new ChatWithoutEmoji input scope if the device is running Windows 10, version 1607, otherwise the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Chat</pc> input scope is used.</source>
          <target>In this example, you use the new ChatWithoutEmoji input scope if the device is running Windows 10, version 1607, otherwise the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Chat</pc> input scope is used.</target>
        </segment>
      </unit>
      <unit id="258">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source>The visual states that use this trigger are set up in an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">if-else</pc> style where the input scope is chosen based on the presence of the new enum value.</source>
          <target>The visual states that use this trigger are set up in an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">if-else</pc> style where the input scope is chosen based on the presence of the new enum value.</target>
        </segment>
      </unit>
      <unit id="259">
        <segment state="initial">
          <source>C</source>
          <target>C</target>
        </segment>
      </unit>
      <unit id="260">
        <segment state="initial">
          <source>XAML</source>
          <target>XAML</target>
        </segment>
      </unit>
      <unit id="261">
        <segment state="initial">
          <source>Related articles</source>
          <target>Related articles</target>
        </segment>
      </unit>
      <unit id="262">
        <segment state="initial">
          <source>Guide to UWP apps</source>
          <target>Guide to UWP apps</target>
        </segment>
      </unit>
      <unit id="263">
        <segment state="initial">
          <source>Dynamically detecting features with API contracts</source>
          <target>Dynamically detecting features with API contracts</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>