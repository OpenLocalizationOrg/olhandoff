<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="de-de" original="foo.file" tool-id="025aa46a-1c88-46a5-9493-13e273ded94f" product-name="foo" product-version="1.0" build-num="1">
    <header>
      <tool tool-id="025aa46a-1c88-46a5-9493-13e273ded94f" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
      <olfilehash xmlns="">51689a4533ba47ce22bed502089aaf485de7a27c</olfilehash>
    </header>
    <body>
      <group id="b71707a6-6aa9-432e-bc8d-b5dc713de658">
        <trans-unit id="6e5a0e59-930c-4b05-bcf6-8bf9d1311983" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="new">Garbage Collection</target>
        </trans-unit>
        <trans-unit id="2e89b197-5194-42cd-a61e-611077c3a0c8" xml:space="preserve">
          <source>Garbage collection is one of most important features of the .NET managed
code platform.</source>
          <target state="new">Garbage collection is one of most important features of the .NET managed
code platform.</target>
        </trans-unit>
        <trans-unit id="5aa38483-5a19-40d3-854b-9c4ee21e5204" xml:space="preserve">
          <source>The garbage collector (GC) manages allocating and
releasing memory for you.</source>
          <target state="new">The garbage collector (GC) manages allocating and
releasing memory for you.</target>
        </trans-unit>
        <trans-unit id="93382a81-a411-4e56-a51a-cdbd1e3e2b9e" xml:space="preserve">
          <source>You do not need to how to allocate and release
memory or manage the lifetime of the objects that use that memory.</source>
          <target state="new">You do not need to how to allocate and release
memory or manage the lifetime of the objects that use that memory.</target>
        </trans-unit>
        <trans-unit id="1b28e927-8601-476e-b770-6df73863d2c5" xml:space="preserve">
          <source>An
allocation is made any time you <bpt id="a828275b-cef7-4ebc-93f3-d6800b3491b8">&lt;em&gt;</bpt>new<ept id="a828275b-cef7-4ebc-93f3-d6800b3491b8">&lt;/em&gt;</ept> an object or a value type is
boxed.</source>
          <target state="new">An
allocation is made any time you <bpt id="a828275b-cef7-4ebc-93f3-d6800b3491b8">&lt;em&gt;</bpt>new<ept id="a828275b-cef7-4ebc-93f3-d6800b3491b8">&lt;/em&gt;</ept> an object or a value type is
boxed.</target>
        </trans-unit>
        <trans-unit id="2abf1a91-93a6-4859-b144-aa3feb22d1f3" xml:space="preserve">
          <source>Allocations are typically very fast.</source>
          <target state="new">Allocations are typically very fast.</target>
        </trans-unit>
        <trans-unit id="ee74d9d6-362f-48d3-b7ab-850581b28377" xml:space="preserve">
          <source>When there isn't enough
memory to allocate an object, the GC must collect and dispose of garbage
memory to make memory available for new allocations.</source>
          <target state="new">When there isn't enough
memory to allocate an object, the GC must collect and dispose of garbage
memory to make memory available for new allocations.</target>
        </trans-unit>
        <trans-unit id="8af053cd-025c-4ea9-89bc-d0148871c454" xml:space="preserve">
          <source>This process is
called "garbage collection".</source>
          <target state="new">This process is
called "garbage collection".</target>
        </trans-unit>
        <trans-unit id="91201553-648b-4ad4-a90a-0eb40f285fce" xml:space="preserve">
          <source>The garbage collector serves as an automatic memory manager.</source>
          <target state="new">The garbage collector serves as an automatic memory manager.</target>
        </trans-unit>
        <trans-unit id="a4367162-9fa3-438d-8d22-21a770de30f2" xml:space="preserve">
          <source>It provides
the following benefits:</source>
          <target state="new">It provides
the following benefits:</target>
        </trans-unit>
        <trans-unit id="a1e1ac35-abe9-4fa4-a244-276ccb536f77" xml:space="preserve">
          <source>Enables you to develop your application without having to
free memory.</source>
          <target state="new">Enables you to develop your application without having to
free memory.</target>
        </trans-unit>
        <trans-unit id="f60e6643-8bcc-4d11-a85a-594ffb779742" xml:space="preserve">
          <source>Allocates objects on the managed heap efficiently.</source>
          <target state="new">Allocates objects on the managed heap efficiently.</target>
        </trans-unit>
        <trans-unit id="2cafd921-c324-406d-b916-073b304d69c3" xml:space="preserve">
          <source>Reclaims objects that are no longer being used, clears their memory,
and keeps the memory available for future allocations.</source>
          <target state="new">Reclaims objects that are no longer being used, clears their memory,
and keeps the memory available for future allocations.</target>
        </trans-unit>
        <trans-unit id="9a0b4033-9bb0-4aed-91ce-610169774b1c" xml:space="preserve">
          <source>Managed
objects automatically get clean content to start with, so their
constructors do not have to initialize every data field.</source>
          <target state="new">Managed
objects automatically get clean content to start with, so their
constructors do not have to initialize every data field.</target>
        </trans-unit>
        <trans-unit id="1bed22e2-a223-435a-b6d5-14f76938c97f" xml:space="preserve">
          <source>Provides memory safety by making sure that an object cannot use the
content of another object.</source>
          <target state="new">Provides memory safety by making sure that an object cannot use the
content of another object.</target>
        </trans-unit>
        <trans-unit id="3454635e-2744-4ccc-98a7-6d8544779e15" xml:space="preserve">
          <source>The .NET GC is generational and has 3 generations.</source>
          <target state="new">The .NET GC is generational and has 3 generations.</target>
        </trans-unit>
        <trans-unit id="4d9919c2-fe6b-4f38-bf2a-3143c4c03a3a" xml:space="preserve">
          <source>Each generation has
its own heap that it uses for storage of allocated objects.</source>
          <target state="new">Each generation has
its own heap that it uses for storage of allocated objects.</target>
        </trans-unit>
        <trans-unit id="43c27c6d-4fa1-4539-8f88-372b712b3906" xml:space="preserve">
          <source>There is a
basic principle that most objects are either short lived or long lived.</source>
          <target state="new">There is a
basic principle that most objects are either short lived or long lived.</target>
        </trans-unit>
        <trans-unit id="70582440-9e4a-409f-8bee-34ecc4e01bea" xml:space="preserve">
          <source>Generation 0 is where objects are first allocated.</source>
          <target state="new">Generation 0 is where objects are first allocated.</target>
        </trans-unit>
        <trans-unit id="47b5c021-f255-46b1-94a1-ffe4a4a404a6" xml:space="preserve">
          <source>Objects often don't
live past the first generation, since they are no longer in use (out of
scope) by the time the next garbage collection occurs.</source>
          <target state="new">Objects often don't
live past the first generation, since they are no longer in use (out of
scope) by the time the next garbage collection occurs.</target>
        </trans-unit>
        <trans-unit id="0df76e8f-77de-4a11-9d33-97ca53a1a331" xml:space="preserve">
          <source>Generation 0 is
quick to collect because its associated heap is small.</source>
          <target state="new">Generation 0 is
quick to collect because its associated heap is small.</target>
        </trans-unit>
        <trans-unit id="49a0bcdb-a5ba-4817-b3bb-f856fe94b2bb" xml:space="preserve">
          <source>Generation 1 is
really a second chance space.</source>
          <target state="new">Generation 1 is
really a second chance space.</target>
        </trans-unit>
        <trans-unit id="472ef266-6bfd-4a2d-a645-f5fbc305530f" xml:space="preserve">
          <source>Objects that are short lived but survive
the generation 0 collection (often based on coincidental timing) go to
generation 1.</source>
          <target state="new">Objects that are short lived but survive
the generation 0 collection (often based on coincidental timing) go to
generation 1.</target>
        </trans-unit>
        <trans-unit id="37ab2675-d573-4365-9f77-b107bec2fc6a" xml:space="preserve">
          <source>Generation 1 collections are also quick because its
associated heap is also small.</source>
          <target state="new">Generation 1 collections are also quick because its
associated heap is also small.</target>
        </trans-unit>
        <trans-unit id="8da9715a-a148-4dcf-82f1-56405a0256ca" xml:space="preserve">
          <source>The first two heaps remain small because
objects are either collected or are promoted to the next generation
heap.</source>
          <target state="new">The first two heaps remain small because
objects are either collected or are promoted to the next generation
heap.</target>
        </trans-unit>
        <trans-unit id="bfd0a8a2-91dd-4144-b21e-7f4801426ef3" xml:space="preserve">
          <source>Generation 2 is where all long lived objects are.</source>
          <target state="new">Generation 2 is where all long lived objects are.</target>
        </trans-unit>
        <trans-unit id="005331b5-9d17-4d58-8452-bd77a682bac8" xml:space="preserve">
          <source>The generation 2
heap can grow to be very large, since the objects it contains can
survive a long time and there is no generation 3 heap to further promote
objects.</source>
          <target state="new">The generation 2
heap can grow to be very large, since the objects it contains can
survive a long time and there is no generation 3 heap to further promote
objects.</target>
        </trans-unit>
        <trans-unit id="9e62d323-db69-49db-938f-492159c912a7" xml:space="preserve">
          <source>The GC has has an additional heap for large objects called the Large
Object Heap (LOH).</source>
          <target state="new">The GC has has an additional heap for large objects called the Large
Object Heap (LOH).</target>
        </trans-unit>
        <trans-unit id="561da0fb-2750-4b0a-98e6-ce4f78c507d1" xml:space="preserve">
          <source>It is reserved for objects that are 85,000 bytes or
greater.</source>
          <target state="new">It is reserved for objects that are 85,000 bytes or
greater.</target>
        </trans-unit>
        <trans-unit id="12f57e6d-d004-46e0-97eb-50e87bc9f747" xml:space="preserve">
          <source>A byte array (Byte\[\]) with 85k elements would be an example
of a large object.</source>
          <target state="new">A byte array (Byte\[\]) with 85k elements would be an example
of a large object.</target>
        </trans-unit>
        <trans-unit id="478fdbb3-7fcf-42e0-ab63-2d30986b6eed" xml:space="preserve">
          <source>Large objects are not allocated to the generational
heaps but are allocated directly to the LOH.</source>
          <target state="new">Large objects are not allocated to the generational
heaps but are allocated directly to the LOH.</target>
        </trans-unit>
        <trans-unit id="806a4da4-86bc-4a25-ac51-ae4488420e96" xml:space="preserve">
          <source>Generation 2 and LOH collections can take noticeable time for programs
that have run for a long time or operate over large amounts of data.</source>
          <target state="new">Generation 2 and LOH collections can take noticeable time for programs
that have run for a long time or operate over large amounts of data.</target>
        </trans-unit>
        <trans-unit id="efe44131-50f6-4859-b0c7-baf0a2199d32" xml:space="preserve">
          <source>Large server programs are known to have heaps in the 10s of GBs.</source>
          <target state="new">Large server programs are known to have heaps in the 10s of GBs.</target>
        </trans-unit>
        <trans-unit id="414039a6-a533-47f7-8494-566ee7458af0" xml:space="preserve">
          <source>The GC
employs a variety of techniques to reduce the amount of time that it
blocks program execution.</source>
          <target state="new">The GC
employs a variety of techniques to reduce the amount of time that it
blocks program execution.</target>
        </trans-unit>
        <trans-unit id="70bff50a-a095-4468-8fd4-0d6974a868cc" xml:space="preserve">
          <source>The primary approach is to do as much garbage
collection work as possible on a background thread in a way that does
not interfere with program execution.</source>
          <target state="new">The primary approach is to do as much garbage
collection work as possible on a background thread in a way that does
not interfere with program execution.</target>
        </trans-unit>
        <trans-unit id="27147120-08de-4514-b24b-929400d93184" xml:space="preserve">
          <source>The GC also exposes a few ways for
developers to influence its behavior, which can be quite useful to
improve performance.</source>
          <target state="new">The GC also exposes a few ways for
developers to influence its behavior, which can be quite useful to
improve performance.</target>
        </trans-unit>
        <trans-unit id="a04104cc-846e-4c57-b9b9-bceb15738fac" xml:space="preserve">
          <source>For more information, see <bpt id="f91dbf96-51f8-42d1-bc32-e13a4c9a8d55CapsExtId1">&lt;linkText&gt;</bpt>Garbage
Collection<ept id="f91dbf96-51f8-42d1-bc32-e13a4c9a8d55CapsExtId1">&lt;/linkText&gt;</ept><bpt id="f91dbf96-51f8-42d1-bc32-e13a4c9a8d55CapsExtId2">&lt;title&gt;</bpt><ept id="f91dbf96-51f8-42d1-bc32-e13a4c9a8d55CapsExtId2">&lt;/title&gt;</ept> on MSDN.</source>
          <target state="new">For more information, see <bpt id="f91dbf96-51f8-42d1-bc32-e13a4c9a8d55CapsExtId1">&lt;linkText&gt;</bpt>Garbage
Collection<ept id="f91dbf96-51f8-42d1-bc32-e13a4c9a8d55CapsExtId1">&lt;/linkText&gt;</ept><bpt id="f91dbf96-51f8-42d1-bc32-e13a4c9a8d55CapsExtId2">&lt;title&gt;</bpt><ept id="f91dbf96-51f8-42d1-bc32-e13a4c9a8d55CapsExtId2">&lt;/title&gt;</ept> on MSDN.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>