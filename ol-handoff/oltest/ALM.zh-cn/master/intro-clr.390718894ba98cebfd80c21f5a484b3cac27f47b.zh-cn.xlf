<?xml version="1.0" encoding="utf-8"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-us" target-language="zh-cn" original="foo.file" tool-id="4f512078-fb16-4aea-8401-3b9774dee7eb" product-name="foo" product-version="1.0" build-num="1">
    <header>
      <tool tool-id="4f512078-fb16-4aea-8401-3b9774dee7eb" tool-name="MarkdownToXliff" tool-version="1.0" tool-company="Microsoft" />
      <olfilehash xmlns="">cd8ba36caa1f918598f5e21d8bc319fcd46a3dbc</olfilehash>
    </header>
    <body>
      <group id="8623596b-44b9-4a1b-80b8-bcb9434606be">
        <trans-unit id="16355124-a0d1-41ea-b6da-5d8915f04691" xml:space="preserve">
          <source>Introduction to the Common Language Runtime (CLR)</source>
          <target state="new">Introduction to the Common Language Runtime (CLR)</target>
        </trans-unit>
        <trans-unit id="31b5b4d4-a780-41b3-933e-51d5f1e735a9" xml:space="preserve">
          <source>By Vance Morrison - 2007</source>
          <target state="new">By Vance Morrison - 2007</target>
        </trans-unit>
        <trans-unit id="356d1b93-ecfa-4f99-8611-f20e3a8ee305" xml:space="preserve">
          <source>What is the Common Language Runtime (CLR)?</source>
          <target state="new">What is the Common Language Runtime (CLR)?</target>
        </trans-unit>
        <trans-unit id="df249a8b-aa30-43c8-aa49-a0c461aa347e" xml:space="preserve">
          <source>To put it succinctly:</source>
          <target state="new">To put it succinctly:</target>
        </trans-unit>
        <trans-unit id="779e60a3-f42f-4f94-b461-e6472abe2475" xml:space="preserve">
          <source>The Common Language Runtime (CLR) is a complete, high level virtual
machine designed to support a broad variety of programming languages
and interoperation among them.</source>
          <target state="new">The Common Language Runtime (CLR) is a complete, high level virtual
machine designed to support a broad variety of programming languages
and interoperation among them.</target>
        </trans-unit>
        <trans-unit id="26322842-914a-4e3e-b58e-88887583ce92" xml:space="preserve">
          <source>Phew, that was a mouthful.</source>
          <target state="new">Phew, that was a mouthful.</target>
        </trans-unit>
        <trans-unit id="847a9c85-8c0b-406c-a906-b9dbb171af30" xml:space="preserve">
          <source>It also in and of itself is not very
illuminating.</source>
          <target state="new">It also in and of itself is not very
illuminating.</target>
        </trans-unit>
        <trans-unit id="dfbeecfe-6a10-4ad1-b8ae-c12500c1a991" xml:space="preserve">
          <source>The statement above <bpt id="fc507b08-f8db-4b39-84fa-d32597e8dd79">&lt;em&gt;</bpt>is<ept id="fc507b08-f8db-4b39-84fa-d32597e8dd79">&lt;/em&gt;</ept> useful however, because it is the
first step in taking the large and complicated piece of software known
as the <bpt id="8186b353-e24a-42d4-97ea-ec836779419fCapsExtId1">&lt;linkText&gt;</bpt>CLR<ept id="8186b353-e24a-42d4-97ea-ec836779419fCapsExtId1">&lt;/linkText&gt;</ept><bpt id="8186b353-e24a-42d4-97ea-ec836779419fCapsExtId2">&lt;title&gt;</bpt><ept id="8186b353-e24a-42d4-97ea-ec836779419fCapsExtId2">&lt;/title&gt;</ept> and
grouping its features in an understandable way.</source>
          <target state="new">The statement above <bpt id="fc507b08-f8db-4b39-84fa-d32597e8dd79">&lt;em&gt;</bpt>is<ept id="fc507b08-f8db-4b39-84fa-d32597e8dd79">&lt;/em&gt;</ept> useful however, because it is the
first step in taking the large and complicated piece of software known
as the <bpt id="8186b353-e24a-42d4-97ea-ec836779419fCapsExtId1">&lt;linkText&gt;</bpt>CLR<ept id="8186b353-e24a-42d4-97ea-ec836779419fCapsExtId1">&lt;/linkText&gt;</ept><bpt id="8186b353-e24a-42d4-97ea-ec836779419fCapsExtId2">&lt;title&gt;</bpt><ept id="8186b353-e24a-42d4-97ea-ec836779419fCapsExtId2">&lt;/title&gt;</ept> and
grouping its features in an understandable way.</target>
        </trans-unit>
        <trans-unit id="753147fc-bba7-448b-a00e-5e65c9f6e72d" xml:space="preserve">
          <source>It gives us a "10,000
foot" view of the runtime from which we can understand the broad goals
and purpose of the runtime.</source>
          <target state="new">It gives us a "10,000
foot" view of the runtime from which we can understand the broad goals
and purpose of the runtime.</target>
        </trans-unit>
        <trans-unit id="644c0a31-8c68-4bde-95a7-c9627bd2b04e" xml:space="preserve">
          <source>After understanding the CLR at this high
level, it is easier to look more deeply into sub-components without as
much chance of getting lost in the details.</source>
          <target state="new">After understanding the CLR at this high
level, it is easier to look more deeply into sub-components without as
much chance of getting lost in the details.</target>
        </trans-unit>
        <trans-unit id="0d19d516-f2e1-4a42-a01a-b12f4f752e07" xml:space="preserve">
          <source>The CLR: A (very rare) Complete Programming Platform</source>
          <target state="new">The CLR: A (very rare) Complete Programming Platform</target>
        </trans-unit>
        <trans-unit id="efcfd527-acd9-4507-93f7-50fb79f15bb9" xml:space="preserve">
          <source>Every program has a surprising number of dependencies on its runtime
environment.</source>
          <target state="new">Every program has a surprising number of dependencies on its runtime
environment.</target>
        </trans-unit>
        <trans-unit id="29fdbda9-c357-4220-b360-5265ecf4af87" xml:space="preserve">
          <source>Most obviously, the program is written in a particular
programming language, but that is only the first of many assumptions a
programmer weaves into the program.</source>
          <target state="new">Most obviously, the program is written in a particular
programming language, but that is only the first of many assumptions a
programmer weaves into the program.</target>
        </trans-unit>
        <trans-unit id="1b55bda0-b319-4cfd-9815-2d12243ecd60" xml:space="preserve">
          <source>All interesting programs need some
<bpt id="d2c06df7-4b1a-4150-96b8-f37f39d0c2df">&lt;em&gt;</bpt>runtime library<ept id="d2c06df7-4b1a-4150-96b8-f37f39d0c2df">&lt;/em&gt;</ept> that allows them to interact with the other resources
of the machine (such as user input, disk files, network communications,
etc).</source>
          <target state="new">All interesting programs need some
<bpt id="d2c06df7-4b1a-4150-96b8-f37f39d0c2df">&lt;em&gt;</bpt>runtime library<ept id="d2c06df7-4b1a-4150-96b8-f37f39d0c2df">&lt;/em&gt;</ept> that allows them to interact with the other resources
of the machine (such as user input, disk files, network communications,
etc).</target>
        </trans-unit>
        <trans-unit id="0794c048-8d24-4511-b24a-0e3ac5dbd0f6" xml:space="preserve">
          <source>The program also needs to be converted in some way (either by
interpretation or compilation) to a form that the native hardware can
execute directly.</source>
          <target state="new">The program also needs to be converted in some way (either by
interpretation or compilation) to a form that the native hardware can
execute directly.</target>
        </trans-unit>
        <trans-unit id="5e6a6874-bb18-46ad-b543-d51077c0ebde" xml:space="preserve">
          <source>These dependencies of a program are so numerous,
interdependent and diverse that implementers of programming languages
almost always defer to other standards to specify them.</source>
          <target state="new">These dependencies of a program are so numerous,
interdependent and diverse that implementers of programming languages
almost always defer to other standards to specify them.</target>
        </trans-unit>
        <trans-unit id="788911f7-62b4-4cb3-b676-07fe65ccaeda" xml:space="preserve">
          <source>For example, the
C++ language does not specify the format of a C++ executable.</source>
          <target state="new">For example, the
C++ language does not specify the format of a C++ executable.</target>
        </trans-unit>
        <trans-unit id="2cbd3db3-c929-4aef-9b06-9a9b4be93499" xml:space="preserve">
          <source>Instead,
each C++ compiler is bound to a particular hardware architecture (e.g.,
X86) and to an operating system environment (e.g., Windows, Linux, or
Mac OS), which describes the format of the executable file format and
specifies how it will be loaded.</source>
          <target state="new">Instead,
each C++ compiler is bound to a particular hardware architecture (e.g.,
X86) and to an operating system environment (e.g., Windows, Linux, or
Mac OS), which describes the format of the executable file format and
specifies how it will be loaded.</target>
        </trans-unit>
        <trans-unit id="9f930df0-fe9d-4271-ab1e-e4c9c79dbbb5" xml:space="preserve">
          <source>Thus, programmers don't make a "C++
executable," but rather a "Windows X86 executable" or a "Power PC Mac OS
executable."</source>
          <target state="new">Thus, programmers don't make a "C++
executable," but rather a "Windows X86 executable" or a "Power PC Mac OS
executable."</target>
        </trans-unit>
        <trans-unit id="c246c3cf-ca99-4e87-a6cc-1a7675ae4bb4" xml:space="preserve">
          <source>While leveraging existing hardware and operating system standards is
usually a good thing, it has the disadvantage of tying the specification
to the level of abstraction of the existing standards.</source>
          <target state="new">While leveraging existing hardware and operating system standards is
usually a good thing, it has the disadvantage of tying the specification
to the level of abstraction of the existing standards.</target>
        </trans-unit>
        <trans-unit id="4d8217fb-74d9-4244-af43-6764984f06af" xml:space="preserve">
          <source>For example, no
common operating system today has the concept of a garbage-collected
heap.</source>
          <target state="new">For example, no
common operating system today has the concept of a garbage-collected
heap.</target>
        </trans-unit>
        <trans-unit id="05fa0508-b5a9-49d5-9644-57976b28b6a8" xml:space="preserve">
          <source>Thus, there is no way to use existing standards to describe an
interface that takes advantage of garbage collection (e.g., passing
strings back and forth, without worrying about who is responsible for
deleting them).</source>
          <target state="new">Thus, there is no way to use existing standards to describe an
interface that takes advantage of garbage collection (e.g., passing
strings back and forth, without worrying about who is responsible for
deleting them).</target>
        </trans-unit>
        <trans-unit id="aefd4cd2-1b87-4bcc-be89-e566be49b237" xml:space="preserve">
          <source>Similarly, a typical executable file format provides
just enough information to run a program but not enough information for
a compiler to bind other binaries to the executable.</source>
          <target state="new">Similarly, a typical executable file format provides
just enough information to run a program but not enough information for
a compiler to bind other binaries to the executable.</target>
        </trans-unit>
        <trans-unit id="edbdc2bb-021e-41a0-aeed-979768c89e65" xml:space="preserve">
          <source>For example, C++
programs typically use a standard library (on Windows, called
msvcrt.dll) which contains most of the common functionality (e.g.,
printf), but the existence of that library alone is not enough.</source>
          <target state="new">For example, C++
programs typically use a standard library (on Windows, called
msvcrt.dll) which contains most of the common functionality (e.g.,
printf), but the existence of that library alone is not enough.</target>
        </trans-unit>
        <trans-unit id="4e8f8525-718e-478b-9e20-d7138fe16ad0" xml:space="preserve">
          <source>Without
the matching header files that go along with it (e.g., stdio.h),
programmers can't use the library.</source>
          <target state="new">Without
the matching header files that go along with it (e.g., stdio.h),
programmers can't use the library.</target>
        </trans-unit>
        <trans-unit id="8865fd04-d95f-4e7d-abe2-2406925e3779" xml:space="preserve">
          <source>Thus, existing executable file format
standards cannot be used both to describe a file format that can be run
and to specify other information or binaries necessary to make the
program complete.</source>
          <target state="new">Thus, existing executable file format
standards cannot be used both to describe a file format that can be run
and to specify other information or binaries necessary to make the
program complete.</target>
        </trans-unit>
        <trans-unit id="1c5a2a03-68d6-4521-8193-1dec7ee1d6c3" xml:space="preserve">
          <source>The CLR fixes problems like these by defining a <bpt id="166d44d8-8ec1-49eb-8771-2af6f80ba495CapsExtId1">&lt;linkText&gt;</bpt>very complete
specification<ept id="166d44d8-8ec1-49eb-8771-2af6f80ba495CapsExtId1">&lt;/linkText&gt;</ept><bpt id="166d44d8-8ec1-49eb-8771-2af6f80ba495CapsExtId2">&lt;title&gt;</bpt><ept id="166d44d8-8ec1-49eb-8771-2af6f80ba495CapsExtId2">&lt;/title&gt;</ept> (standardized by ECMA) containing
the details you need for the COMPLETE lifecycle of a program, from
construction and binding through deployment and execution.</source>
          <target state="new">The CLR fixes problems like these by defining a <bpt id="166d44d8-8ec1-49eb-8771-2af6f80ba495CapsExtId1">&lt;linkText&gt;</bpt>very complete
specification<ept id="166d44d8-8ec1-49eb-8771-2af6f80ba495CapsExtId1">&lt;/linkText&gt;</ept><bpt id="166d44d8-8ec1-49eb-8771-2af6f80ba495CapsExtId2">&lt;title&gt;</bpt><ept id="166d44d8-8ec1-49eb-8771-2af6f80ba495CapsExtId2">&lt;/title&gt;</ept> (standardized by ECMA) containing
the details you need for the COMPLETE lifecycle of a program, from
construction and binding through deployment and execution.</target>
        </trans-unit>
        <trans-unit id="77f1481b-fb43-4679-ad1a-b66846266686" xml:space="preserve">
          <source>Thus, among
other things, the CLR specifies:</source>
          <target state="new">Thus, among
other things, the CLR specifies:</target>
        </trans-unit>
        <trans-unit id="f31a1e33-4e36-4e7f-93ea-9080c75fb980" xml:space="preserve">
          <source>A GC-aware virtual machine with its own instruction set (called the
Common Intermediate Language (CIL)) used to specify the primitive
operations that programs perform.</source>
          <target state="new">A GC-aware virtual machine with its own instruction set (called the
Common Intermediate Language (CIL)) used to specify the primitive
operations that programs perform.</target>
        </trans-unit>
        <trans-unit id="e5bccf7f-6725-4777-8f98-1fedddade9b5" xml:space="preserve">
          <source>This means the CLR is not
dependent on a particular type of CPU.</source>
          <target state="new">This means the CLR is not
dependent on a particular type of CPU.</target>
        </trans-unit>
        <trans-unit id="73dc878d-1def-4107-933b-d8fbb939ac71" xml:space="preserve">
          <source>A rich meta data representation for program declarations (e.g.,
types, fields, methods, etc), so that compilers generating other
executables have the information they need to call functionality
from 'outside'.</source>
          <target state="new">A rich meta data representation for program declarations (e.g.,
types, fields, methods, etc), so that compilers generating other
executables have the information they need to call functionality
from 'outside'.</target>
        </trans-unit>
        <trans-unit id="a4596033-97f5-4672-bf1b-50001f87fac5" xml:space="preserve">
          <source>A file format that specifies exactly how to lay the bits down in a
file, so that you can properly speak of a CLR EXE that is not tied
to a particular operating system or computer hardware.</source>
          <target state="new">A file format that specifies exactly how to lay the bits down in a
file, so that you can properly speak of a CLR EXE that is not tied
to a particular operating system or computer hardware.</target>
        </trans-unit>
        <trans-unit id="6e3b03a9-4835-495a-9969-a99591f5bc3d" xml:space="preserve">
          <source>The lifetime semantics of a loaded program, the mechanism by which
one CLR EXE file can refer to another CLR EXE and the rules on how
the runtime finds the referenced files at execution time.</source>
          <target state="new">The lifetime semantics of a loaded program, the mechanism by which
one CLR EXE file can refer to another CLR EXE and the rules on how
the runtime finds the referenced files at execution time.</target>
        </trans-unit>
        <trans-unit id="122ee964-e562-40aa-b368-e4682dcf00a7" xml:space="preserve">
          <source>A class library that leverages the features that the CLR provides
(e.g., garbage collection, exceptions, or generic types) to give
access both to basic functionality (e.g., integers, strings, arrays,
lists, or dictionaries) as well as to operating system services
(e.g., files, network, or user interaction).</source>
          <target state="new">A class library that leverages the features that the CLR provides
(e.g., garbage collection, exceptions, or generic types) to give
access both to basic functionality (e.g., integers, strings, arrays,
lists, or dictionaries) as well as to operating system services
(e.g., files, network, or user interaction).</target>
        </trans-unit>
        <trans-unit id="33c68985-0ad9-4a1b-9d97-1d70fd4749f7" xml:space="preserve">
          <source>Multi-language Support</source>
          <target state="new">Multi-language Support</target>
        </trans-unit>
        <trans-unit id="e8559f0b-7bc4-4b58-8d24-3177e6b4d8e0" xml:space="preserve">
          <source>Defining, specifying and implementing all of these details is a huge
undertaking, which is why complete abstractions like the CLR are very
rare.</source>
          <target state="new">Defining, specifying and implementing all of these details is a huge
undertaking, which is why complete abstractions like the CLR are very
rare.</target>
        </trans-unit>
        <trans-unit id="091da3dd-cc7b-4ed8-990d-d5e77d2ba7ac" xml:space="preserve">
          <source>In fact, the vast majority of such reasonably complete
abstractions were built for single languages.</source>
          <target state="new">In fact, the vast majority of such reasonably complete
abstractions were built for single languages.</target>
        </trans-unit>
        <trans-unit id="5491ef08-2716-49e5-9bd2-ef0415c1a6a9" xml:space="preserve">
          <source>For example, the Java
runtime, the Perl interpreter or the early version of the Visual Basic
runtime offer similarly complete abstraction boundaries.</source>
          <target state="new">For example, the Java
runtime, the Perl interpreter or the early version of the Visual Basic
runtime offer similarly complete abstraction boundaries.</target>
        </trans-unit>
        <trans-unit id="ff169797-8a40-429d-95b8-df86c2367a09" xml:space="preserve">
          <source>What
distinguishes the CLR from these earlier efforts is its multi-language
nature.</source>
          <target state="new">What
distinguishes the CLR from these earlier efforts is its multi-language
nature.</target>
        </trans-unit>
        <trans-unit id="5718738b-9657-4db5-86da-c0bbac44f41b" xml:space="preserve">
          <source>With the possible exception of Visual Basic (because it
leverages the COM object model), the experience within the language is
often very good, but interoperating with programs written in other
languages is very difficult at best.</source>
          <target state="new">With the possible exception of Visual Basic (because it
leverages the COM object model), the experience within the language is
often very good, but interoperating with programs written in other
languages is very difficult at best.</target>
        </trans-unit>
        <trans-unit id="3ed930e7-4b5e-455a-a6ad-a2848b5bc33d" xml:space="preserve">
          <source>Interoperation is difficult because
these languages can only communicate with "foreign" languages by using
the primitives provided by the operating system.</source>
          <target state="new">Interoperation is difficult because
these languages can only communicate with "foreign" languages by using
the primitives provided by the operating system.</target>
        </trans-unit>
        <trans-unit id="beb8cbe9-026a-423c-aa65-e42f3fd4e685" xml:space="preserve">
          <source>Because the OS
abstraction level is so low (e.g., the operating system has no concept
of a garbage-collected heap), needlessly complicated techniques are
necessary.</source>
          <target state="new">Because the OS
abstraction level is so low (e.g., the operating system has no concept
of a garbage-collected heap), needlessly complicated techniques are
necessary.</target>
        </trans-unit>
        <trans-unit id="30f6a9fc-01b3-46fa-9d4e-50931cfa4acd" xml:space="preserve">
          <source>By providing a COMMON LANGUAGE RUNTIME, the CLR allows
languages to communicate with each other with high-level constructs
(e.g., GC-collected structures), easing the interoperation burden
dramatically.</source>
          <target state="new">By providing a COMMON LANGUAGE RUNTIME, the CLR allows
languages to communicate with each other with high-level constructs
(e.g., GC-collected structures), easing the interoperation burden
dramatically.</target>
        </trans-unit>
        <trans-unit id="66ca4a37-ffb3-47f6-98e8-e2966e0a53ca" xml:space="preserve">
          <source>Because the runtime is shared among <bpt id="9ddc461f-c88c-4f7b-941c-9e0524d498a7">&lt;em&gt;</bpt>many<ept id="9ddc461f-c88c-4f7b-941c-9e0524d498a7">&lt;/em&gt;</ept> languages, it means that more
resources can be put into supporting it well.</source>
          <target state="new">Because the runtime is shared among <bpt id="9ddc461f-c88c-4f7b-941c-9e0524d498a7">&lt;em&gt;</bpt>many<ept id="9ddc461f-c88c-4f7b-941c-9e0524d498a7">&lt;/em&gt;</ept> languages, it means that more
resources can be put into supporting it well.</target>
        </trans-unit>
        <trans-unit id="49c575d7-ef06-416d-bcc5-56650577f125" xml:space="preserve">
          <source>Building good debuggers
and profilers for a language is a lot of work, and thus they exist in a
full-featured form only for the most important programming languages.</source>
          <target state="new">Building good debuggers
and profilers for a language is a lot of work, and thus they exist in a
full-featured form only for the most important programming languages.</target>
        </trans-unit>
        <trans-unit id="77222821-f14d-4ade-8542-47a335b53029" xml:space="preserve">
          <source>Nevertheless, because languages that are implemented on the CLR can
reuse this infrastructure, the burden on any particular language is
reduced substantially.</source>
          <target state="new">Nevertheless, because languages that are implemented on the CLR can
reuse this infrastructure, the burden on any particular language is
reduced substantially.</target>
        </trans-unit>
        <trans-unit id="c9087d11-b463-46be-98ad-b954219ca823" xml:space="preserve">
          <source>Perhaps even more important, any language built
on the CLR immediately has access to <bpt id="7304e382-b52e-49ce-b109-f15f008e5d50">&lt;em&gt;</bpt>all<ept id="7304e382-b52e-49ce-b109-f15f008e5d50">&lt;/em&gt;</ept> the class libraries built on
top of the CLR.</source>
          <target state="new">Perhaps even more important, any language built
on the CLR immediately has access to <bpt id="7304e382-b52e-49ce-b109-f15f008e5d50">&lt;em&gt;</bpt>all<ept id="7304e382-b52e-49ce-b109-f15f008e5d50">&lt;/em&gt;</ept> the class libraries built on
top of the CLR.</target>
        </trans-unit>
        <trans-unit id="d24e90b6-5a4d-4746-b02d-9915170d81eb" xml:space="preserve">
          <source>This large (and growing) body of (debugged and
supported) functionality is a huge reason why the CLR has been so
successful.</source>
          <target state="new">This large (and growing) body of (debugged and
supported) functionality is a huge reason why the CLR has been so
successful.</target>
        </trans-unit>
        <trans-unit id="5737f0a1-1c30-4889-bbf0-212c20d5b2dc" xml:space="preserve">
          <source>In short, the runtime is a complete specification of the exact bits one
has to put in a file to create and run a program.</source>
          <target state="new">In short, the runtime is a complete specification of the exact bits one
has to put in a file to create and run a program.</target>
        </trans-unit>
        <trans-unit id="a11b7d2c-227f-4bed-8640-62018ec5c183" xml:space="preserve">
          <source>The virtual machine
that runs these files is at a high level appropriate for implementing a
broad class of programming languages.</source>
          <target state="new">The virtual machine
that runs these files is at a high level appropriate for implementing a
broad class of programming languages.</target>
        </trans-unit>
        <trans-unit id="9686d1d4-c347-4de9-a593-3a0447fbd71f" xml:space="preserve">
          <source>This virtual machine, along with
an ever growing body of class libraries that run on that virtual
machine, is what we call the common language runtime (CLR).</source>
          <target state="new">This virtual machine, along with
an ever growing body of class libraries that run on that virtual
machine, is what we call the common language runtime (CLR).</target>
        </trans-unit>
        <trans-unit id="11a6689f-b393-4ec6-87c0-2e748bf137e8" xml:space="preserve">
          <source>The Primary Goal of the CLR</source>
          <target state="new">The Primary Goal of the CLR</target>
        </trans-unit>
        <trans-unit id="c6804b6f-2ed8-4af0-beca-fb4663280ed0" xml:space="preserve">
          <source>Now that we have basic idea what the CLR is, it is useful to back up
just a bit and understand the problem the runtime was meant to solve.</source>
          <target state="new">Now that we have basic idea what the CLR is, it is useful to back up
just a bit and understand the problem the runtime was meant to solve.</target>
        </trans-unit>
        <trans-unit id="6a4bbcd5-6081-454f-b721-45eae0e17811" xml:space="preserve">
          <source>At
a very high level, the runtime has only one goal:</source>
          <target state="new">At
a very high level, the runtime has only one goal:</target>
        </trans-unit>
        <trans-unit id="c2750b94-7bc4-405f-8e61-da0dbd8d170d" xml:space="preserve">
          <source>The goal of the CLR is to make programming easy.</source>
          <target state="new">The goal of the CLR is to make programming easy.</target>
        </trans-unit>
        <trans-unit id="adb79d50-36e7-467e-8bfa-eaca7bd0149b" xml:space="preserve">
          <source>This statement is useful for two reasons.</source>
          <target state="new">This statement is useful for two reasons.</target>
        </trans-unit>
        <trans-unit id="9a17342e-9a58-4344-9e11-57bc12e9539e" xml:space="preserve">
          <source>First, it is a <bpt id="04c6228f-faa7-4e49-b6e6-a38ecdeee472">&lt;em&gt;</bpt>very<ept id="04c6228f-faa7-4e49-b6e6-a38ecdeee472">&lt;/em&gt;</ept> useful
guiding principle as the runtime evolves.</source>
          <target state="new">First, it is a <bpt id="04c6228f-faa7-4e49-b6e6-a38ecdeee472">&lt;em&gt;</bpt>very<ept id="04c6228f-faa7-4e49-b6e6-a38ecdeee472">&lt;/em&gt;</ept> useful
guiding principle as the runtime evolves.</target>
        </trans-unit>
        <trans-unit id="71de0276-c1ea-4f60-bf3f-0d4ba4a82845" xml:space="preserve">
          <source>For example, fundamentally
only simple things can be easy, so adding <bpt id="736612a1-1540-41c6-be12-0a87be2102a9">&lt;strong&gt;</bpt>user visible<ept id="736612a1-1540-41c6-be12-0a87be2102a9">&lt;/strong&gt;</ept> complexity to
the runtime should always be viewed with suspicion.</source>
          <target state="new">For example, fundamentally
only simple things can be easy, so adding <bpt id="736612a1-1540-41c6-be12-0a87be2102a9">&lt;strong&gt;</bpt>user visible<ept id="736612a1-1540-41c6-be12-0a87be2102a9">&lt;/strong&gt;</ept> complexity to
the runtime should always be viewed with suspicion.</target>
        </trans-unit>
        <trans-unit id="eff30ac0-273e-4cd3-b537-70ad31cb9996" xml:space="preserve">
          <source>More important than
the cost/benefit ratio of a feature is its <bpt id="e555dbe5-a492-44f4-8d52-e14a6e6cdb6c">&lt;em&gt;</bpt>added exposed
complexity/weighted benefit over all scenarios<ept id="e555dbe5-a492-44f4-8d52-e14a6e6cdb6c">&lt;/em&gt;</ept> ratio.</source>
          <target state="new">More important than
the cost/benefit ratio of a feature is its <bpt id="e555dbe5-a492-44f4-8d52-e14a6e6cdb6c">&lt;em&gt;</bpt>added exposed
complexity/weighted benefit over all scenarios<ept id="e555dbe5-a492-44f4-8d52-e14a6e6cdb6c">&lt;/em&gt;</ept> ratio.</target>
        </trans-unit>
        <trans-unit id="64679edd-782e-4943-8a73-103d82368eb1" xml:space="preserve">
          <source>Ideally, this
ratio is negative (that is, the new feature reduces complexity by
removing restrictions or by generalizing existing special cases);
however, more typically it is kept low by minimizing the exposed
complexity and maximizing the number of scenarios to which the feature
adds value.</source>
          <target state="new">Ideally, this
ratio is negative (that is, the new feature reduces complexity by
removing restrictions or by generalizing existing special cases);
however, more typically it is kept low by minimizing the exposed
complexity and maximizing the number of scenarios to which the feature
adds value.</target>
        </trans-unit>
        <trans-unit id="051a734c-81d2-4d82-8a7b-cd858ff9ca13" xml:space="preserve">
          <source>The second reason this goal is so important is that <bpt id="72b480b5-fdf1-499f-afcf-df2bc521c376">&lt;strong&gt;</bpt>ease of use is the
fundamental reason for the CLR's success<ept id="72b480b5-fdf1-499f-afcf-df2bc521c376">&lt;/strong&gt;</ept>.</source>
          <target state="new">The second reason this goal is so important is that <bpt id="72b480b5-fdf1-499f-afcf-df2bc521c376">&lt;strong&gt;</bpt>ease of use is the
fundamental reason for the CLR's success<ept id="72b480b5-fdf1-499f-afcf-df2bc521c376">&lt;/strong&gt;</ept>.</target>
        </trans-unit>
        <trans-unit id="451c4afd-3fd6-471a-b3b7-a58ef88e9c7e" xml:space="preserve">
          <source>The CLR is not successful
because it is faster or smaller than writing native code (in fact,
well-written native code often wins).</source>
          <target state="new">The CLR is not successful
because it is faster or smaller than writing native code (in fact,
well-written native code often wins).</target>
        </trans-unit>
        <trans-unit id="40a9592c-fa39-44d3-9b8f-5554d2844006" xml:space="preserve">
          <source>The CLR is not successful because
of any particular feature it supports (like garbage collection, platform
independence, object-oriented programming or versioning support).</source>
          <target state="new">The CLR is not successful because
of any particular feature it supports (like garbage collection, platform
independence, object-oriented programming or versioning support).</target>
        </trans-unit>
        <trans-unit id="f50f8478-bd55-4865-bd66-04905444b304" xml:space="preserve">
          <source>The
CLR is successful because all of those features, as well as numerous
others, combine to make programming significantly easier than it would
be otherwise.</source>
          <target state="new">The
CLR is successful because all of those features, as well as numerous
others, combine to make programming significantly easier than it would
be otherwise.</target>
        </trans-unit>
        <trans-unit id="7ebed15c-9409-421c-80bd-6bcb6cf0d6b7" xml:space="preserve">
          <source>Some important but often overlooked ease of use features
include:</source>
          <target state="new">Some important but often overlooked ease of use features
include:</target>
        </trans-unit>
        <trans-unit id="e1a2f87c-35ac-454e-908c-15a41c284602" xml:space="preserve">
          <source>Simplified languages (e.g., C\# and Visual Basic are significantly
simpler than C++)</source>
          <target state="new">Simplified languages (e.g., C\# and Visual Basic are significantly
simpler than C++)</target>
        </trans-unit>
        <trans-unit id="59f8ef0a-b1c0-4d63-8b4f-9c316f626fa3" xml:space="preserve">
          <source>A dedication to simplicity in the class library (e.g., we only have
one string type, and it is immutable; this greatly simplifies any
API that uses strings)</source>
          <target state="new">A dedication to simplicity in the class library (e.g., we only have
one string type, and it is immutable; this greatly simplifies any
API that uses strings)</target>
        </trans-unit>
        <trans-unit id="a5f556c6-1748-47db-8488-bff53f91713d" xml:space="preserve">
          <source>Strong consistency in the naming in the class library (e.g.,
requiring APIs to use whole words and consistent naming conventions)</source>
          <target state="new">Strong consistency in the naming in the class library (e.g.,
requiring APIs to use whole words and consistent naming conventions)</target>
        </trans-unit>
        <trans-unit id="5654c905-5657-4bdb-bbb5-ecde94fa4bbe" xml:space="preserve">
          <source>Great support in the tool chain needed to create an application
(e.g., Visual Studio makes building CLR applications very simple,
and Intellisense makes finding the right types and methods to create
the application very easy).</source>
          <target state="new">Great support in the tool chain needed to create an application
(e.g., Visual Studio makes building CLR applications very simple,
and Intellisense makes finding the right types and methods to create
the application very easy).</target>
        </trans-unit>
        <trans-unit id="3d44d862-bc1f-48ec-a137-ce538d87d6ad" xml:space="preserve">
          <source>It is this dedication to ease of use (which goes hand in hand with
simplicity of the user model) that stands out as the reason for the
success of the CLR.</source>
          <target state="new">It is this dedication to ease of use (which goes hand in hand with
simplicity of the user model) that stands out as the reason for the
success of the CLR.</target>
        </trans-unit>
        <trans-unit id="f6489182-f7d4-4435-88bb-cfe267a5aeb0" xml:space="preserve">
          <source>Oddly, some of the most important ease-of-use
features are also the most "boring."</source>
          <target state="new">Oddly, some of the most important ease-of-use
features are also the most "boring."</target>
        </trans-unit>
        <trans-unit id="3aa878e4-ff67-42dd-9b6c-ed4a645d0572" xml:space="preserve">
          <source>For example, any programming
environment could apply consistent naming conventions, yet actually
doing so across a large class library is quite a lot of work.</source>
          <target state="new">For example, any programming
environment could apply consistent naming conventions, yet actually
doing so across a large class library is quite a lot of work.</target>
        </trans-unit>
        <trans-unit id="38e21039-7bc5-4e49-afff-be263c3b9b3f" xml:space="preserve">
          <source>Often such
efforts conflict with other goals (such as retaining compatibility with
existing interfaces), or they run into significant logistical concerns
(such as the cost of renaming a method across a <bpt id="d961e687-06c2-4e86-a692-b9fd64a7898c">&lt;em&gt;</bpt>very<ept id="d961e687-06c2-4e86-a692-b9fd64a7898c">&lt;/em&gt;</ept> large code base).</source>
          <target state="new">Often such
efforts conflict with other goals (such as retaining compatibility with
existing interfaces), or they run into significant logistical concerns
(such as the cost of renaming a method across a <bpt id="d961e687-06c2-4e86-a692-b9fd64a7898c">&lt;em&gt;</bpt>very<ept id="d961e687-06c2-4e86-a692-b9fd64a7898c">&lt;/em&gt;</ept> large code base).</target>
        </trans-unit>
        <trans-unit id="5a44a06d-f896-4d04-ac00-b5e15476ab33" xml:space="preserve">
          <source>It is at times like these that we have to remind ourselves about our
number-one overarching goal of the runtime and ensure that we are have
our priorities straight to reach that goal.</source>
          <target state="new">It is at times like these that we have to remind ourselves about our
number-one overarching goal of the runtime and ensure that we are have
our priorities straight to reach that goal.</target>
        </trans-unit>
        <trans-unit id="c40350c4-b940-4e8e-a22d-f0fb6c7e33da" xml:space="preserve">
          <source>Fundamental Features of the CLR</source>
          <target state="new">Fundamental Features of the CLR</target>
        </trans-unit>
        <trans-unit id="9616b24e-268a-41e3-8393-16640ff5ee18" xml:space="preserve">
          <source>The runtime has many features, so it is useful to categorize them as
follows:</source>
          <target state="new">The runtime has many features, so it is useful to categorize them as
follows:</target>
        </trans-unit>
        <trans-unit id="dd3b00d2-3d59-4dcc-802d-d62c3b539e00" xml:space="preserve">
          <source>Fundamental features – Features that have broad impact on the design
of other features.</source>
          <target state="new">Fundamental features – Features that have broad impact on the design
of other features.</target>
        </trans-unit>
        <trans-unit id="982c3eb7-536e-4a54-88f5-26c2430e3f11" xml:space="preserve">
          <source>These include:</source>
          <target state="new">These include:</target>
        </trans-unit>
        <trans-unit id="428ec388-6c37-4111-b959-ffca418ef03e" xml:space="preserve">
          <source>a.</source>
          <target state="new">a.</target>
        </trans-unit>
        <trans-unit id="2b13e7e3-e5cd-42d5-b103-f4f9d85a1bd4" xml:space="preserve">
          <source>Garbage Collection
b.</source>
          <target state="new">Garbage Collection
b.</target>
        </trans-unit>
        <trans-unit id="eb14b53c-a2d2-4e50-82b9-fda25312c8fd" xml:space="preserve">
          <source>Memory Safety and Type Safety
c.</source>
          <target state="new">Memory Safety and Type Safety
c.</target>
        </trans-unit>
        <trans-unit id="96dc6373-b236-4c5e-848c-68ff5afd8517" xml:space="preserve">
          <source>High level support for programming languages.</source>
          <target state="new">High level support for programming languages.</target>
        </trans-unit>
        <trans-unit id="a1a981b7-a7f4-4c51-aad5-fd234f8c3da3" xml:space="preserve">
          <source>Secondary features – Features enabled by the fundamental features
that may not be required by many useful programs:</source>
          <target state="new">Secondary features – Features enabled by the fundamental features
that may not be required by many useful programs:</target>
        </trans-unit>
        <trans-unit id="3296d89e-4e98-4716-8d74-68016cf8bba2" xml:space="preserve">
          <source>a.</source>
          <target state="new">a.</target>
        </trans-unit>
        <trans-unit id="ff25be29-6924-44e8-8dd4-beeb63a61d48" xml:space="preserve">
          <source>Program isolation with AppDomains
b.</source>
          <target state="new">Program isolation with AppDomains
b.</target>
        </trans-unit>
        <trans-unit id="5c32cc0c-3580-4b3e-87f7-2535cf98e07e" xml:space="preserve">
          <source>Program Security and sandboxing</source>
          <target state="new">Program Security and sandboxing</target>
        </trans-unit>
        <trans-unit id="4e2347de-df4b-45f0-b931-f8a10e741106" xml:space="preserve">
          <source>Other Features – Features that all runtime environments need but
that do not leverage the fundamental features of the CLR.</source>
          <target state="new">Other Features – Features that all runtime environments need but
that do not leverage the fundamental features of the CLR.</target>
        </trans-unit>
        <trans-unit id="9c7092a3-916d-4826-b22d-59fedebacbf4" xml:space="preserve">
          <source>Instead,
they are the result of the desire to create a complete
programming environment.</source>
          <target state="new">Instead,
they are the result of the desire to create a complete
programming environment.</target>
        </trans-unit>
        <trans-unit id="01bfb7c4-84a5-427c-9ecb-b9a09fdf1b98" xml:space="preserve">
          <source>Among them are:</source>
          <target state="new">Among them are:</target>
        </trans-unit>
        <trans-unit id="70afa7dc-4604-40d3-97dc-94a9c0038fc6" xml:space="preserve">
          <source>a.</source>
          <target state="new">a.</target>
        </trans-unit>
        <trans-unit id="531807ed-b447-49f7-8ecd-aac9a695bc34" xml:space="preserve">
          <source>Versioning
b.</source>
          <target state="new">Versioning
b.</target>
        </trans-unit>
        <trans-unit id="093ff0f5-3d1c-4751-9e86-f2ff9af5abf0" xml:space="preserve">
          <source>Debugging/Profiling
c.</source>
          <target state="new">Debugging/Profiling
c.</target>
        </trans-unit>
        <trans-unit id="fd194c8c-a976-4d4b-9d10-e65bfe8faefe" xml:space="preserve">
          <source>Interoperation</source>
          <target state="new">Interoperation</target>
        </trans-unit>
        <trans-unit id="d3bc4501-f2bf-4648-938c-1dcb72c3a9e9" xml:space="preserve">
          <source>The CLR Garbage Collector (GC)</source>
          <target state="new">The CLR Garbage Collector (GC)</target>
        </trans-unit>
        <trans-unit id="aa3b0eaf-eb75-41f6-a1a8-01f28901d97c" xml:space="preserve">
          <source>Of all the features that the CLR provides, the garbage collector
deserves special notice.</source>
          <target state="new">Of all the features that the CLR provides, the garbage collector
deserves special notice.</target>
        </trans-unit>
        <trans-unit id="aca2bd94-7cd0-4b39-bd22-b8b144882459" xml:space="preserve">
          <source>Garbage collection (GC) is the common term for
automatic memory reclamation.</source>
          <target state="new">Garbage collection (GC) is the common term for
automatic memory reclamation.</target>
        </trans-unit>
        <trans-unit id="d17a6bcf-e50d-4f42-8fe3-089cb9a605f1" xml:space="preserve">
          <source>In a garbage-collected system, user
programs no longer need to invoke a special operator to delete memory.</source>
          <target state="new">In a garbage-collected system, user
programs no longer need to invoke a special operator to delete memory.</target>
        </trans-unit>
        <trans-unit id="759e7197-1153-43b2-a775-9e8839385b0e" xml:space="preserve">
          <source>Instead the runtime automatically keeps track of all references to
memory in the garbage-collected heap, and from time-to-time, it will
traverse these references to find out which memory is still reachable by
the program.</source>
          <target state="new">Instead the runtime automatically keeps track of all references to
memory in the garbage-collected heap, and from time-to-time, it will
traverse these references to find out which memory is still reachable by
the program.</target>
        </trans-unit>
        <trans-unit id="8b4cea47-1625-4d88-8a0e-3b02e26690dc" xml:space="preserve">
          <source>All other memory is <bpt id="84ea011a-ff5d-419f-9068-aed7ba0dc670">&lt;em&gt;</bpt>garbage<ept id="84ea011a-ff5d-419f-9068-aed7ba0dc670">&lt;/em&gt;</ept> and can be reused for new
allocations.</source>
          <target state="new">All other memory is <bpt id="84ea011a-ff5d-419f-9068-aed7ba0dc670">&lt;em&gt;</bpt>garbage<ept id="84ea011a-ff5d-419f-9068-aed7ba0dc670">&lt;/em&gt;</ept> and can be reused for new
allocations.</target>
        </trans-unit>
        <trans-unit id="70d6512f-aab6-4f71-ba8c-323a66b5ca87" xml:space="preserve">
          <source>Garbage collection is a wonderful user feature because it simplifies
programming.</source>
          <target state="new">Garbage collection is a wonderful user feature because it simplifies
programming.</target>
        </trans-unit>
        <trans-unit id="fcf60532-c181-4148-9e01-5a5547c0fc33" xml:space="preserve">
          <source>The most obvious simplification is that most explicit
delete operations are no longer necessary.</source>
          <target state="new">The most obvious simplification is that most explicit
delete operations are no longer necessary.</target>
        </trans-unit>
        <trans-unit id="1877790b-ad98-49c8-969e-d505a2c3bc44" xml:space="preserve">
          <source>While removing the delete
operations is important, the real value to the programmer is a bit more
subtle:</source>
          <target state="new">While removing the delete
operations is important, the real value to the programmer is a bit more
subtle:</target>
        </trans-unit>
        <trans-unit id="4c8994b4-b07d-4b99-bad4-ed8cb8d00577" xml:space="preserve">
          <source>Garbage collection simplifies interface design because you no longer
have to carefully specify which side of the interface is responsible
for deleting objects passed across the interface.</source>
          <target state="new">Garbage collection simplifies interface design because you no longer
have to carefully specify which side of the interface is responsible
for deleting objects passed across the interface.</target>
        </trans-unit>
        <trans-unit id="53def7bd-c145-46a8-8828-d84fa65b4b68" xml:space="preserve">
          <source>For example, CLR
interfaces simply return strings; they don't take string buffers
and lengths.</source>
          <target state="new">For example, CLR
interfaces simply return strings; they don't take string buffers
and lengths.</target>
        </trans-unit>
        <trans-unit id="71f8d364-f395-410e-9f1c-c0ff491055bb" xml:space="preserve">
          <source>This means they don't have to deal with the complexity
of what happens when the buffers are too small.</source>
          <target state="new">This means they don't have to deal with the complexity
of what happens when the buffers are too small.</target>
        </trans-unit>
        <trans-unit id="f418c4aa-d8bd-4593-800b-f532bfb64c28" xml:space="preserve">
          <source>Thus, garbage
collection allows ALL interfaces in the runtime to be simpler than
they otherwise would be.</source>
          <target state="new">Thus, garbage
collection allows ALL interfaces in the runtime to be simpler than
they otherwise would be.</target>
        </trans-unit>
        <trans-unit id="7b4c6ad9-3e66-4e68-a6db-e3cb5a759850" xml:space="preserve">
          <source>Garbage collection eliminates a whole class of common user mistakes.</source>
          <target state="new">Garbage collection eliminates a whole class of common user mistakes.</target>
        </trans-unit>
        <trans-unit id="063dd267-8ba9-4cee-afd9-d768e8f7ebdb" xml:space="preserve">
          <source>It is frightfully easy to make mistakes concerning the lifetime of a
particular object, either deleting it too soon (leading to memory
corruption), or too late (unreachable memory leaks).</source>
          <target state="new">It is frightfully easy to make mistakes concerning the lifetime of a
particular object, either deleting it too soon (leading to memory
corruption), or too late (unreachable memory leaks).</target>
        </trans-unit>
        <trans-unit id="4a6c5bc5-e7eb-4ed7-9823-f57df04953e6" xml:space="preserve">
          <source>Since a typical
program uses literally MILLIONS of objects, the probability for
error is quite high.</source>
          <target state="new">Since a typical
program uses literally MILLIONS of objects, the probability for
error is quite high.</target>
        </trans-unit>
        <trans-unit id="90f8d512-11fe-460b-b6ae-d87ce14763e9" xml:space="preserve">
          <source>In addition, tracking down lifetime bugs is
very difficult, especially if the object is referenced by many
other objects.</source>
          <target state="new">In addition, tracking down lifetime bugs is
very difficult, especially if the object is referenced by many
other objects.</target>
        </trans-unit>
        <trans-unit id="ed18323c-7ae3-4ce4-86ea-be1ce00e1683" xml:space="preserve">
          <source>Making this class of mistakes impossible avoids a lot
of grief.</source>
          <target state="new">Making this class of mistakes impossible avoids a lot
of grief.</target>
        </trans-unit>
        <trans-unit id="62538b3f-478e-4b2e-9f0f-33ab7fcb498d" xml:space="preserve">
          <source>Still, it is not the usefulness of garbage collection that makes it
worthy of special note here.</source>
          <target state="new">Still, it is not the usefulness of garbage collection that makes it
worthy of special note here.</target>
        </trans-unit>
        <trans-unit id="cdf310b1-1058-4428-b7ef-fa1ba23d1b4e" xml:space="preserve">
          <source>More important is the simple requirement it
places on the runtime itself:</source>
          <target state="new">More important is the simple requirement it
places on the runtime itself:</target>
        </trans-unit>
        <trans-unit id="34c3082e-9e33-4f0e-b777-0315e106a852" xml:space="preserve">
          <source>Garbage collection requires ALL references to the GC heap to be
tracked.</source>
          <target state="new">Garbage collection requires ALL references to the GC heap to be
tracked.</target>
        </trans-unit>
        <trans-unit id="044f10f9-6979-4d03-b4eb-f4c1d8d7a4bb" xml:space="preserve">
          <source>While this is a very simple requirement, it in fact has profound
ramifications for the runtime.</source>
          <target state="new">While this is a very simple requirement, it in fact has profound
ramifications for the runtime.</target>
        </trans-unit>
        <trans-unit id="84c765ea-a378-4939-b9b3-b3ff0855292a" xml:space="preserve">
          <source>As you can imagine, knowing where every
pointer to an object is at every moment of program execution can be
quite difficult.</source>
          <target state="new">As you can imagine, knowing where every
pointer to an object is at every moment of program execution can be
quite difficult.</target>
        </trans-unit>
        <trans-unit id="f5ee1de7-d6e6-49a5-8355-e816d33de35d" xml:space="preserve">
          <source>We have one mitigating factor, though.</source>
          <target state="new">We have one mitigating factor, though.</target>
        </trans-unit>
        <trans-unit id="6bd7f22e-5033-4d1e-aff7-6dff9037a06d" xml:space="preserve">
          <source>Technically,
this requirement only applies to when a GC actually needs to happen
(thus, in theory we don't need to know where all GC references are all
the time, but only at the time of a GC).</source>
          <target state="new">Technically,
this requirement only applies to when a GC actually needs to happen
(thus, in theory we don't need to know where all GC references are all
the time, but only at the time of a GC).</target>
        </trans-unit>
        <trans-unit id="0a18b906-5b16-4c80-b939-5623315551d4" xml:space="preserve">
          <source>In practice, however, this
mitigation doesn't completely apply because of another feature of the
CLR:</source>
          <target state="new">In practice, however, this
mitigation doesn't completely apply because of another feature of the
CLR:</target>
        </trans-unit>
        <trans-unit id="dcfddf3d-022b-440d-929c-a5645eee9eb4" xml:space="preserve">
          <source>The CLR supports multiple concurrent threads of execution with a
single process.</source>
          <target state="new">The CLR supports multiple concurrent threads of execution with a
single process.</target>
        </trans-unit>
        <trans-unit id="8756afe4-cfd7-4728-8405-b622bbbad0e8" xml:space="preserve">
          <source>At any time some other thread of execution might perform an allocation
that requires a garbage collection.</source>
          <target state="new">At any time some other thread of execution might perform an allocation
that requires a garbage collection.</target>
        </trans-unit>
        <trans-unit id="29c5b695-ef14-4e55-8853-6fa78093b5f1" xml:space="preserve">
          <source>The exact sequence of operations
across concurrently executing threads is non-deterministic.</source>
          <target state="new">The exact sequence of operations
across concurrently executing threads is non-deterministic.</target>
        </trans-unit>
        <trans-unit id="e2045049-0eec-4b66-a0fb-f52406c100b0" xml:space="preserve">
          <source>We can't
tell exactly what one thread will be doing when another thread requests
an allocation that will trigger a GC.</source>
          <target state="new">We can't
tell exactly what one thread will be doing when another thread requests
an allocation that will trigger a GC.</target>
        </trans-unit>
        <trans-unit id="701f40e0-5051-4338-84e0-40c87ac85630" xml:space="preserve">
          <source>Thus, GCs can really happen any
time.</source>
          <target state="new">Thus, GCs can really happen any
time.</target>
        </trans-unit>
        <trans-unit id="52fd9eb3-af4b-4644-a512-66295f43dcdc" xml:space="preserve">
          <source>Now the CLR does NOT need to respond <bpt id="cb672501-058c-4ef5-b9b4-3f4f960dd6fb">&lt;em&gt;</bpt>immediately<ept id="cb672501-058c-4ef5-b9b4-3f4f960dd6fb">&lt;/em&gt;</ept> to another
thread's desire to do a GC, so the CLR has a little "wiggle room" and
doesn't need to track GC references at <bpt id="9e150572-cbc7-484c-9aa4-6ee245dc3bdf">&lt;em&gt;</bpt>all<ept id="9e150572-cbc7-484c-9aa4-6ee245dc3bdf">&lt;/em&gt;</ept> points of execution, but it
<bpt id="53c87de5-5aad-4a2b-9a68-875c4f630966">&lt;em&gt;</bpt>does<ept id="53c87de5-5aad-4a2b-9a68-875c4f630966">&lt;/em&gt;</ept> need to do so at enough places that it can guarantee "timely"
response to the need to do a GC caused by an allocation on another
thread.</source>
          <target state="new">Now the CLR does NOT need to respond <bpt id="cb672501-058c-4ef5-b9b4-3f4f960dd6fb">&lt;em&gt;</bpt>immediately<ept id="cb672501-058c-4ef5-b9b4-3f4f960dd6fb">&lt;/em&gt;</ept> to another
thread's desire to do a GC, so the CLR has a little "wiggle room" and
doesn't need to track GC references at <bpt id="9e150572-cbc7-484c-9aa4-6ee245dc3bdf">&lt;em&gt;</bpt>all<ept id="9e150572-cbc7-484c-9aa4-6ee245dc3bdf">&lt;/em&gt;</ept> points of execution, but it
<bpt id="53c87de5-5aad-4a2b-9a68-875c4f630966">&lt;em&gt;</bpt>does<ept id="53c87de5-5aad-4a2b-9a68-875c4f630966">&lt;/em&gt;</ept> need to do so at enough places that it can guarantee "timely"
response to the need to do a GC caused by an allocation on another
thread.</target>
        </trans-unit>
        <trans-unit id="06bb7b82-4561-44e8-ab6b-98e223dfa7d1" xml:space="preserve">
          <source>What this means is that the CLR needs to track <bpt id="95748b54-c3a7-4f30-ad82-8f3ce61b77d8">&lt;em&gt;</bpt>all<ept id="95748b54-c3a7-4f30-ad82-8f3ce61b77d8">&lt;/em&gt;</ept> references to the
GC heap <bpt id="3233771e-10f5-4088-a9a3-1cdd95083490">&lt;em&gt;</bpt>almost<ept id="3233771e-10f5-4088-a9a3-1cdd95083490">&lt;/em&gt;</ept> all the time.</source>
          <target state="new">What this means is that the CLR needs to track <bpt id="95748b54-c3a7-4f30-ad82-8f3ce61b77d8">&lt;em&gt;</bpt>all<ept id="95748b54-c3a7-4f30-ad82-8f3ce61b77d8">&lt;/em&gt;</ept> references to the
GC heap <bpt id="3233771e-10f5-4088-a9a3-1cdd95083490">&lt;em&gt;</bpt>almost<ept id="3233771e-10f5-4088-a9a3-1cdd95083490">&lt;/em&gt;</ept> all the time.</target>
        </trans-unit>
        <trans-unit id="804f2586-f827-4d96-ab08-4383866b0a51" xml:space="preserve">
          <source>Since GC references may reside in machine
registers, in local variables, statics, or other fields, there is quite
a bit to track.</source>
          <target state="new">Since GC references may reside in machine
registers, in local variables, statics, or other fields, there is quite
a bit to track.</target>
        </trans-unit>
        <trans-unit id="c814507d-6ec4-4759-a22a-12933fe2698c" xml:space="preserve">
          <source>The most problematic of these locations are machine
registers and local variables because they are so intimately related to
the actual execution of user code.</source>
          <target state="new">The most problematic of these locations are machine
registers and local variables because they are so intimately related to
the actual execution of user code.</target>
        </trans-unit>
        <trans-unit id="abbf7944-dd92-4c9a-b810-62b3d7d62b44" xml:space="preserve">
          <source>Effectively, what this means is that
the <bpt id="0f0906fc-3a85-47a2-8281-df79ae567050">&lt;em&gt;</bpt>machine code<ept id="0f0906fc-3a85-47a2-8281-df79ae567050">&lt;/em&gt;</ept> that manipulates GC references has another
requirement: it must track all the GC references that it uses.</source>
          <target state="new">Effectively, what this means is that
the <bpt id="0f0906fc-3a85-47a2-8281-df79ae567050">&lt;em&gt;</bpt>machine code<ept id="0f0906fc-3a85-47a2-8281-df79ae567050">&lt;/em&gt;</ept> that manipulates GC references has another
requirement: it must track all the GC references that it uses.</target>
        </trans-unit>
        <trans-unit id="d0254429-55d5-4f56-acfc-d1c14a575cc6" xml:space="preserve">
          <source>This
implies some extra work for the compiler to emit the instructions to
track the references.</source>
          <target state="new">This
implies some extra work for the compiler to emit the instructions to
track the references.</target>
        </trans-unit>
        <trans-unit id="a2d639b3-6e75-484d-b1eb-05a03897a9ac" xml:space="preserve">
          <source>To learn more, check out the <bpt id="634f27f5-cb32-4b27-9062-6e29150c32acCapsExtId1">&lt;linkText&gt;</bpt>Garbage Collector design
document<ept id="634f27f5-cb32-4b27-9062-6e29150c32acCapsExtId1">&lt;/linkText&gt;</ept><bpt id="634f27f5-cb32-4b27-9062-6e29150c32acCapsExtId2">&lt;title&gt;</bpt><ept id="634f27f5-cb32-4b27-9062-6e29150c32acCapsExtId2">&lt;/title&gt;</ept>.</source>
          <target state="new">To learn more, check out the <bpt id="634f27f5-cb32-4b27-9062-6e29150c32acCapsExtId1">&lt;linkText&gt;</bpt>Garbage Collector design
document<ept id="634f27f5-cb32-4b27-9062-6e29150c32acCapsExtId1">&lt;/linkText&gt;</ept><bpt id="634f27f5-cb32-4b27-9062-6e29150c32acCapsExtId2">&lt;title&gt;</bpt><ept id="634f27f5-cb32-4b27-9062-6e29150c32acCapsExtId2">&lt;/title&gt;</ept>.</target>
        </trans-unit>
        <trans-unit id="2430d018-87d4-45a0-9515-638996746650" xml:space="preserve">
          <source>The Concept of "Managed Code"</source>
          <target state="new">The Concept of "Managed Code"</target>
        </trans-unit>
        <trans-unit id="b3a65a42-da63-4f1a-a3d7-5bfd19a9e68d" xml:space="preserve">
          <source>Code that does the extra bookkeeping so that it can report all of its
live GC references "almost all the time" is called <bpt id="ef3917c5-f459-41a4-ab3e-115ceda6217b">&lt;em&gt;</bpt>managed code<ept id="ef3917c5-f459-41a4-ab3e-115ceda6217b">&lt;/em&gt;</ept>
(because it is "managed" by the CLR).</source>
          <target state="new">Code that does the extra bookkeeping so that it can report all of its
live GC references "almost all the time" is called <bpt id="ef3917c5-f459-41a4-ab3e-115ceda6217b">&lt;em&gt;</bpt>managed code<ept id="ef3917c5-f459-41a4-ab3e-115ceda6217b">&lt;/em&gt;</ept>
(because it is "managed" by the CLR).</target>
        </trans-unit>
        <trans-unit id="6dc794e1-c8b5-4607-a031-3b5c53f98912" xml:space="preserve">
          <source>Code that does not do this is
called <bpt id="5bf68aa8-96d3-4d79-8099-4b977afe68c7">&lt;em&gt;</bpt>unmanaged code<ept id="5bf68aa8-96d3-4d79-8099-4b977afe68c7">&lt;/em&gt;</ept>.</source>
          <target state="new">Code that does not do this is
called <bpt id="5bf68aa8-96d3-4d79-8099-4b977afe68c7">&lt;em&gt;</bpt>unmanaged code<ept id="5bf68aa8-96d3-4d79-8099-4b977afe68c7">&lt;/em&gt;</ept>.</target>
        </trans-unit>
        <trans-unit id="4ab1268f-3300-4d61-bee9-a011d1484285" xml:space="preserve">
          <source>Thus all code that existed before the CLR is
unmanaged code, and in particular, all operating system code is
unmanaged.</source>
          <target state="new">Thus all code that existed before the CLR is
unmanaged code, and in particular, all operating system code is
unmanaged.</target>
        </trans-unit>
        <trans-unit id="464100ea-7869-42de-aa9f-233c569e40d6" xml:space="preserve">
          <source>The stack unwinding problem</source>
          <target state="new">The stack unwinding problem</target>
        </trans-unit>
        <trans-unit id="5d5387ac-bc2d-47f6-a1d5-df64269027c2" xml:space="preserve">
          <source>Clearly, because managed code needs the services of the operating
system, there will be times when managed code calls unmanaged code.</source>
          <target state="new">Clearly, because managed code needs the services of the operating
system, there will be times when managed code calls unmanaged code.</target>
        </trans-unit>
        <trans-unit id="7c6796cd-6c61-4010-8a4c-7497d4668b65" xml:space="preserve">
          <source>Similarly, because the operating system originally started the managed
code, there are also times when unmanaged code calls into managed code.</source>
          <target state="new">Similarly, because the operating system originally started the managed
code, there are also times when unmanaged code calls into managed code.</target>
        </trans-unit>
        <trans-unit id="1ce0fabb-2442-4b2a-8227-69fbcc1d0606" xml:space="preserve">
          <source>Thus, in general, if you stop a managed program at an arbitrary
location, the call stack will have a mixture of frames created by
managed code and frames created by unmanaged code.</source>
          <target state="new">Thus, in general, if you stop a managed program at an arbitrary
location, the call stack will have a mixture of frames created by
managed code and frames created by unmanaged code.</target>
        </trans-unit>
        <trans-unit id="1eb60e1d-63ad-4625-8a71-b2310e50cf36" xml:space="preserve">
          <source>The stack frames for unmanaged code have <bpt id="d0c2e669-cf62-434e-96ea-9efa4925731c">&lt;em&gt;</bpt>no<ept id="d0c2e669-cf62-434e-96ea-9efa4925731c">&lt;/em&gt;</ept> requirements on them over
and above running the program.</source>
          <target state="new">The stack frames for unmanaged code have <bpt id="d0c2e669-cf62-434e-96ea-9efa4925731c">&lt;em&gt;</bpt>no<ept id="d0c2e669-cf62-434e-96ea-9efa4925731c">&lt;/em&gt;</ept> requirements on them over
and above running the program.</target>
        </trans-unit>
        <trans-unit id="ef6b329c-ff34-4514-a02e-fdc623a64c92" xml:space="preserve">
          <source>In particular, there is no requirement
that they can be <bpt id="be94b275-89bb-4e0b-b0c4-79c4b70c7315">&lt;em&gt;</bpt>unwound<ept id="be94b275-89bb-4e0b-b0c4-79c4b70c7315">&lt;/em&gt;</ept> at runtime to find their caller.</source>
          <target state="new">In particular, there is no requirement
that they can be <bpt id="be94b275-89bb-4e0b-b0c4-79c4b70c7315">&lt;em&gt;</bpt>unwound<ept id="be94b275-89bb-4e0b-b0c4-79c4b70c7315">&lt;/em&gt;</ept> at runtime to find their caller.</target>
        </trans-unit>
        <trans-unit id="daadb603-e932-405c-992f-4ce77c7e5e31" xml:space="preserve">
          <source>What this
means is that if you stop a program at an arbitrary place, and it
happens to be in a unmanaged method, there is no way in general\[1\] to
find who the caller was.</source>
          <target state="new">What this
means is that if you stop a program at an arbitrary place, and it
happens to be in a unmanaged method, there is no way in general\[1\] to
find who the caller was.</target>
        </trans-unit>
        <trans-unit id="b46c63d5-c3f4-44ab-bcd3-9cc021f8ca2c" xml:space="preserve">
          <source>You can only do this in the debugger because of
extra information stored in the symbolic information (PDB file).</source>
          <target state="new">You can only do this in the debugger because of
extra information stored in the symbolic information (PDB file).</target>
        </trans-unit>
        <trans-unit id="913c4814-ab04-41c4-b3db-ee2093c0e27f" xml:space="preserve">
          <source>This
information is not guaranteed to be available (which is why you
sometimes don't get good stack traces in a debugger).</source>
          <target state="new">This
information is not guaranteed to be available (which is why you
sometimes don't get good stack traces in a debugger).</target>
        </trans-unit>
        <trans-unit id="0ddf9f4e-0aeb-417b-b38b-48a54c5232b5" xml:space="preserve">
          <source>This is quite
problematic for managed code, because any stack that can't be unwound
might in fact contain managed code frames (which contain GC references
that need to be reported).</source>
          <target state="new">This is quite
problematic for managed code, because any stack that can't be unwound
might in fact contain managed code frames (which contain GC references
that need to be reported).</target>
        </trans-unit>
        <trans-unit id="58d4335a-cbb7-442f-8b46-0386bceecf2b" xml:space="preserve">
          <source>Managed code has additional requirements on it: not only must it track
all the GC references it uses during its execution, but it must also be
able to unwind to its caller.</source>
          <target state="new">Managed code has additional requirements on it: not only must it track
all the GC references it uses during its execution, but it must also be
able to unwind to its caller.</target>
        </trans-unit>
        <trans-unit id="a143ebf1-e2fe-43eb-89a4-22924137a658" xml:space="preserve">
          <source>Additionally, whenever there is a
transition from managed code to unmanaged code (or the reverse), managed
code must also do additional bookkeeping to make up for the fact that
unmanaged code does not know how to unwind its stack frames.</source>
          <target state="new">Additionally, whenever there is a
transition from managed code to unmanaged code (or the reverse), managed
code must also do additional bookkeeping to make up for the fact that
unmanaged code does not know how to unwind its stack frames.</target>
        </trans-unit>
        <trans-unit id="7416f18e-1317-4351-86e0-4622973765f1" xml:space="preserve">
          <source>Effectively, managed code links together the parts of the stack that
contain managed frames.</source>
          <target state="new">Effectively, managed code links together the parts of the stack that
contain managed frames.</target>
        </trans-unit>
        <trans-unit id="3877b29d-2ca7-42fc-baa3-ea1c1bea02b8" xml:space="preserve">
          <source>Thus, while it still may be impossible to unwind
the unmanaged stack frames without additional information, it will
always be possible to find the chunks of the stack that correspond to
managed code and to enumerate the managed frames in those chunks.</source>
          <target state="new">Thus, while it still may be impossible to unwind
the unmanaged stack frames without additional information, it will
always be possible to find the chunks of the stack that correspond to
managed code and to enumerate the managed frames in those chunks.</target>
        </trans-unit>
        <trans-unit id="cb397afd-c687-49b0-a8dd-3584c7de33d1" xml:space="preserve">
          <source>\[1\] More recent platform ABIs (application binary interfaces) define
conventions for encoding this information, however there is typically
not a strict requirement for all code to follow them.</source>
          <target state="new">\[1\] More recent platform ABIs (application binary interfaces) define
conventions for encoding this information, however there is typically
not a strict requirement for all code to follow them.</target>
        </trans-unit>
        <trans-unit id="5e0110d5-6665-41c4-95f2-abfab314c549" xml:space="preserve">
          <source>The "World" of Managed Code</source>
          <target state="new">The "World" of Managed Code</target>
        </trans-unit>
        <trans-unit id="fc4b2c36-f004-4a6d-bba0-1ad76ed116d3" xml:space="preserve">
          <source>The result is that special bookkeeping is needed at every transition to
and from managed code.</source>
          <target state="new">The result is that special bookkeeping is needed at every transition to
and from managed code.</target>
        </trans-unit>
        <trans-unit id="3097e1db-f672-4d3c-b8d6-157b97f8ee1d" xml:space="preserve">
          <source>Managed code effectively lives in its own "world"
where execution can't enter or leave unless the CLR knows about it.</source>
          <target state="new">Managed code effectively lives in its own "world"
where execution can't enter or leave unless the CLR knows about it.</target>
        </trans-unit>
        <trans-unit id="6584afbb-1132-4f18-8801-099002bac22e" xml:space="preserve">
          <source>The
two worlds are in a very real sense distinct from one another (at any
point in time the code is in the <bpt id="a51eb378-2072-4086-a4b7-1b28529f26b4">&lt;em&gt;</bpt>managed world<ept id="a51eb378-2072-4086-a4b7-1b28529f26b4">&lt;/em&gt;</ept> or the <bpt id="6311d3ca-ece2-47a4-97fc-51d2831632b5">&lt;em&gt;</bpt>unmanaged
world<ept id="6311d3ca-ece2-47a4-97fc-51d2831632b5">&lt;/em&gt;</ept>).</source>
          <target state="new">The
two worlds are in a very real sense distinct from one another (at any
point in time the code is in the <bpt id="a51eb378-2072-4086-a4b7-1b28529f26b4">&lt;em&gt;</bpt>managed world<ept id="a51eb378-2072-4086-a4b7-1b28529f26b4">&lt;/em&gt;</ept> or the <bpt id="6311d3ca-ece2-47a4-97fc-51d2831632b5">&lt;em&gt;</bpt>unmanaged
world<ept id="6311d3ca-ece2-47a4-97fc-51d2831632b5">&lt;/em&gt;</ept>).</target>
        </trans-unit>
        <trans-unit id="7ef46886-3371-4ab6-8e0b-396b33ead02c" xml:space="preserve">
          <source>Moreover, because the execution of managed code is specified in
a CLR format (with its <bpt id="40c66e90-933b-408f-8303-34b9743dc76aCapsExtId1">&lt;linkText&gt;</bpt>Common Intermediate
Language<ept id="40c66e90-933b-408f-8303-34b9743dc76aCapsExtId1">&lt;/linkText&gt;</ept><bpt id="40c66e90-933b-408f-8303-34b9743dc76aCapsExtId2">&lt;title&gt;</bpt><ept id="40c66e90-933b-408f-8303-34b9743dc76aCapsExtId2">&lt;/title&gt;</ept>
(CIL)), and it is the CLR that converts it to run on the native
hardware, the CLR has <bpt id="b87616dc-e45a-4ff9-bc78-fff7717a0c03">&lt;em&gt;</bpt>much<ept id="b87616dc-e45a-4ff9-bc78-fff7717a0c03">&lt;/em&gt;</ept> more control over exactly what that
execution does.</source>
          <target state="new">Moreover, because the execution of managed code is specified in
a CLR format (with its <bpt id="40c66e90-933b-408f-8303-34b9743dc76aCapsExtId1">&lt;linkText&gt;</bpt>Common Intermediate
Language<ept id="40c66e90-933b-408f-8303-34b9743dc76aCapsExtId1">&lt;/linkText&gt;</ept><bpt id="40c66e90-933b-408f-8303-34b9743dc76aCapsExtId2">&lt;title&gt;</bpt><ept id="40c66e90-933b-408f-8303-34b9743dc76aCapsExtId2">&lt;/title&gt;</ept>
(CIL)), and it is the CLR that converts it to run on the native
hardware, the CLR has <bpt id="b87616dc-e45a-4ff9-bc78-fff7717a0c03">&lt;em&gt;</bpt>much<ept id="b87616dc-e45a-4ff9-bc78-fff7717a0c03">&lt;/em&gt;</ept> more control over exactly what that
execution does.</target>
        </trans-unit>
        <trans-unit id="b97cbcd8-6af6-48aa-bb80-c48fbeca6528" xml:space="preserve">
          <source>For example, the CLR could change the meaning of what it
means to fetch a field from an object or call a function.</source>
          <target state="new">For example, the CLR could change the meaning of what it
means to fetch a field from an object or call a function.</target>
        </trans-unit>
        <trans-unit id="d72b066c-0e35-42e1-8716-905763330e1d" xml:space="preserve">
          <source>In fact, the
CLR does exactly this to support the ability to create
MarshalByReference objects.</source>
          <target state="new">In fact, the
CLR does exactly this to support the ability to create
MarshalByReference objects.</target>
        </trans-unit>
        <trans-unit id="97ea0574-73cf-4f10-a3ea-d85f050a34f0" xml:space="preserve">
          <source>These appear to be ordinary local objects,
but in fact may exist on another machine.</source>
          <target state="new">These appear to be ordinary local objects,
but in fact may exist on another machine.</target>
        </trans-unit>
        <trans-unit id="f2f2735e-456c-49fe-8b94-654a9dc4d3a4" xml:space="preserve">
          <source>In short, the managed world of
the CLR has a large number of <bpt id="2420f296-9d37-431f-b9dc-f490b30072cd">&lt;em&gt;</bpt>execution hooks<ept id="2420f296-9d37-431f-b9dc-f490b30072cd">&lt;/em&gt;</ept> that it can use to
support powerful features which will be explained in more detail in the
coming sections.</source>
          <target state="new">In short, the managed world of
the CLR has a large number of <bpt id="2420f296-9d37-431f-b9dc-f490b30072cd">&lt;em&gt;</bpt>execution hooks<ept id="2420f296-9d37-431f-b9dc-f490b30072cd">&lt;/em&gt;</ept> that it can use to
support powerful features which will be explained in more detail in the
coming sections.</target>
        </trans-unit>
        <trans-unit id="13fde853-5e0c-4a36-9298-bcbc292e9f44" xml:space="preserve">
          <source>In addition, there is another important ramification of managed code
that may not be so obvious.</source>
          <target state="new">In addition, there is another important ramification of managed code
that may not be so obvious.</target>
        </trans-unit>
        <trans-unit id="8ca8713f-088c-4e8c-801a-38beefc55da4" xml:space="preserve">
          <source>In the unmanaged world, GC pointers are not
allowed (since they can't be tracked), and there is a bookkeeping cost
associated with transitioning from managed to unmanaged code.</source>
          <target state="new">In the unmanaged world, GC pointers are not
allowed (since they can't be tracked), and there is a bookkeeping cost
associated with transitioning from managed to unmanaged code.</target>
        </trans-unit>
        <trans-unit id="2f069f0a-11d4-419b-9024-25b9a7e878af" xml:space="preserve">
          <source>What this
means is that while you <bpt id="bf9222c8-33e0-404d-9d6e-2dfa66f53fbd">&lt;em&gt;</bpt>can<ept id="bf9222c8-33e0-404d-9d6e-2dfa66f53fbd">&lt;/em&gt;</ept> call arbitrary unmanaged functions from
managed code, it is often not pleasant to do so.</source>
          <target state="new">What this
means is that while you <bpt id="bf9222c8-33e0-404d-9d6e-2dfa66f53fbd">&lt;em&gt;</bpt>can<ept id="bf9222c8-33e0-404d-9d6e-2dfa66f53fbd">&lt;/em&gt;</ept> call arbitrary unmanaged functions from
managed code, it is often not pleasant to do so.</target>
        </trans-unit>
        <trans-unit id="c18328fd-148c-4f20-bf74-528cb946cb8f" xml:space="preserve">
          <source>Unmanaged methods don't
use GC objects in their arguments and return types, which means that any
"objects" or "object handles" that those unmanaged functions create and
use need to be explicitly deallocated.</source>
          <target state="new">Unmanaged methods don't
use GC objects in their arguments and return types, which means that any
"objects" or "object handles" that those unmanaged functions create and
use need to be explicitly deallocated.</target>
        </trans-unit>
        <trans-unit id="bf139058-19fe-47ba-97ce-e58ec0daafe3" xml:space="preserve">
          <source>This is quite unfortunate.</source>
          <target state="new">This is quite unfortunate.</target>
        </trans-unit>
        <trans-unit id="6010740e-b875-4d1c-b01e-a238af186f70" xml:space="preserve">
          <source>Because these APIs can't take advantage of CLR functionality such as
exceptions or inheritance, they tend to have a "mismatched" user
experience compared to how the interfaces would have been designed in
managed code.</source>
          <target state="new">Because these APIs can't take advantage of CLR functionality such as
exceptions or inheritance, they tend to have a "mismatched" user
experience compared to how the interfaces would have been designed in
managed code.</target>
        </trans-unit>
        <trans-unit id="49cea4fa-621d-46d2-b1d3-178545bdce97" xml:space="preserve">
          <source>The result of this is that unmanaged interfaces are almost always
<bpt id="42f961ce-11f1-4b29-812c-7118b686bbc3">&lt;em&gt;</bpt>wrapped<ept id="42f961ce-11f1-4b29-812c-7118b686bbc3">&lt;/em&gt;</ept> before being exposed to managed code developers.</source>
          <target state="new">The result of this is that unmanaged interfaces are almost always
<bpt id="42f961ce-11f1-4b29-812c-7118b686bbc3">&lt;em&gt;</bpt>wrapped<ept id="42f961ce-11f1-4b29-812c-7118b686bbc3">&lt;/em&gt;</ept> before being exposed to managed code developers.</target>
        </trans-unit>
        <trans-unit id="ecdd61d3-d66d-4be5-b2e2-7a86bf0bfd99" xml:space="preserve">
          <source>For example,
when accessing files, you don't use the Win32 CreateFile functions
provided by the operating system, but rather the managed System.IO.File
class that wraps this functionality.</source>
          <target state="new">For example,
when accessing files, you don't use the Win32 CreateFile functions
provided by the operating system, but rather the managed System.IO.File
class that wraps this functionality.</target>
        </trans-unit>
        <trans-unit id="8a9962bc-a5d8-4453-9791-28d7ef4ec0c3" xml:space="preserve">
          <source>It is in fact extremely rare that
unmanaged functionality is exposed to users directly.</source>
          <target state="new">It is in fact extremely rare that
unmanaged functionality is exposed to users directly.</target>
        </trans-unit>
        <trans-unit id="1bb36b4a-fb33-4444-9cfe-0758f028cd42" xml:space="preserve">
          <source>While this wrapping may seem to be "bad" in some way (more code that
does not seem do much), it is in fact good because it actually adds
quite a bit of value.</source>
          <target state="new">While this wrapping may seem to be "bad" in some way (more code that
does not seem do much), it is in fact good because it actually adds
quite a bit of value.</target>
        </trans-unit>
        <trans-unit id="5504219d-fa56-41d0-b18d-f3495e989c6a" xml:space="preserve">
          <source>Remember it was always <bpt id="05e5a384-6ee6-47d1-bd66-e065a483080b">&lt;em&gt;</bpt>possible<ept id="05e5a384-6ee6-47d1-bd66-e065a483080b">&lt;/em&gt;</ept> to expose the
unmanaged interfaces directly; we <bpt id="8e3de9e5-35ba-4990-b91d-347d204d162a">&lt;em&gt;</bpt>chose<ept id="8e3de9e5-35ba-4990-b91d-347d204d162a">&lt;/em&gt;</ept> to wrap the functionality.</source>
          <target state="new">Remember it was always <bpt id="05e5a384-6ee6-47d1-bd66-e065a483080b">&lt;em&gt;</bpt>possible<ept id="05e5a384-6ee6-47d1-bd66-e065a483080b">&lt;/em&gt;</ept> to expose the
unmanaged interfaces directly; we <bpt id="8e3de9e5-35ba-4990-b91d-347d204d162a">&lt;em&gt;</bpt>chose<ept id="8e3de9e5-35ba-4990-b91d-347d204d162a">&lt;/em&gt;</ept> to wrap the functionality.</target>
        </trans-unit>
        <trans-unit id="9e2f864d-3d7a-4e2e-a79b-1683d21e1c98" xml:space="preserve">
          <source>Why?</source>
          <target state="new">Why?</target>
        </trans-unit>
        <trans-unit id="a689e2f7-b5f3-458e-b08c-90d7bb1dfccb" xml:space="preserve">
          <source>Because the overarching goal of the runtime is to <bpt id="dda30039-6bbb-4548-b0b9-108981d39376">&lt;strong&gt;</bpt>make
programming easy<ept id="dda30039-6bbb-4548-b0b9-108981d39376">&lt;/strong&gt;</ept>, and typically the unmanaged functions are not easy
enough.</source>
          <target state="new">Because the overarching goal of the runtime is to <bpt id="dda30039-6bbb-4548-b0b9-108981d39376">&lt;strong&gt;</bpt>make
programming easy<ept id="dda30039-6bbb-4548-b0b9-108981d39376">&lt;/strong&gt;</ept>, and typically the unmanaged functions are not easy
enough.</target>
        </trans-unit>
        <trans-unit id="dbda5de4-d026-49d4-96d4-53e33fb6a489" xml:space="preserve">
          <source>Most often, unmanaged interfaces are <bpt id="9f7a9bd5-0b84-4622-aa1c-2862d99a07a3">&lt;em&gt;</bpt>not<ept id="9f7a9bd5-0b84-4622-aa1c-2862d99a07a3">&lt;/em&gt;</ept> designed with ease of
use in mind, but rather are tuned for completeness.</source>
          <target state="new">Most often, unmanaged interfaces are <bpt id="9f7a9bd5-0b84-4622-aa1c-2862d99a07a3">&lt;em&gt;</bpt>not<ept id="9f7a9bd5-0b84-4622-aa1c-2862d99a07a3">&lt;/em&gt;</ept> designed with ease of
use in mind, but rather are tuned for completeness.</target>
        </trans-unit>
        <trans-unit id="2006c355-7475-4b7d-8998-5c7d5ae81dc6" xml:space="preserve">
          <source>Anyone looking at
the arguments to CreateFile or CreateProcess would be hard pressed to
characterize them as "easy."</source>
          <target state="new">Anyone looking at
the arguments to CreateFile or CreateProcess would be hard pressed to
characterize them as "easy."</target>
        </trans-unit>
        <trans-unit id="1fc7e640-7ddc-4725-b2f8-be42dbcf77d6" xml:space="preserve">
          <source>Luckily, the functionality gets a
"facelift" when it enters the managed world, and while this makeover is
often very "low tech" (requiring nothing more complex than renaming,
simplification, and organizing the functionality), it is also profoundly
useful.</source>
          <target state="new">Luckily, the functionality gets a
"facelift" when it enters the managed world, and while this makeover is
often very "low tech" (requiring nothing more complex than renaming,
simplification, and organizing the functionality), it is also profoundly
useful.</target>
        </trans-unit>
        <trans-unit id="8b9a7f35-e595-4a28-84fb-c42fa2897bc1" xml:space="preserve">
          <source>One of the very important documents created for the CLR is the
<bpt id="8ae4b461-c2f9-43ec-b692-50efdf60ccd3CapsExtId1">&lt;linkText&gt;</bpt>Framework Design
Guidelines<ept id="8ae4b461-c2f9-43ec-b692-50efdf60ccd3CapsExtId1">&lt;/linkText&gt;</ept><bpt id="8ae4b461-c2f9-43ec-b692-50efdf60ccd3CapsExtId2">&lt;title&gt;</bpt><ept id="8ae4b461-c2f9-43ec-b692-50efdf60ccd3CapsExtId2">&lt;/title&gt;</ept>.</source>
          <target state="new">One of the very important documents created for the CLR is the
<bpt id="8ae4b461-c2f9-43ec-b692-50efdf60ccd3CapsExtId1">&lt;linkText&gt;</bpt>Framework Design
Guidelines<ept id="8ae4b461-c2f9-43ec-b692-50efdf60ccd3CapsExtId1">&lt;/linkText&gt;</ept><bpt id="8ae4b461-c2f9-43ec-b692-50efdf60ccd3CapsExtId2">&lt;title&gt;</bpt><ept id="8ae4b461-c2f9-43ec-b692-50efdf60ccd3CapsExtId2">&lt;/title&gt;</ept>.</target>
        </trans-unit>
        <trans-unit id="e8ec4027-a81a-4f1b-8d7c-10ba961f4512" xml:space="preserve">
          <source>This
800+ page document details best practices in making new managed class
libraries.</source>
          <target state="new">This
800+ page document details best practices in making new managed class
libraries.</target>
        </trans-unit>
        <trans-unit id="fc8249ff-f939-48ac-99d2-429363fc3d0f" xml:space="preserve">
          <source>Thus, we have now seen that managed code (which is intimately involved
with the CLR) differs from unmanaged code in two important ways:</source>
          <target state="new">Thus, we have now seen that managed code (which is intimately involved
with the CLR) differs from unmanaged code in two important ways:</target>
        </trans-unit>
        <trans-unit id="0729de15-3da2-464f-bf85-d0e61558c23c" xml:space="preserve">
          <source>High Tech: The code lives in a distinct world, where the CLR
controls most aspects of program execution at a very fine level
(potentially to individual instructions), and the CLR detects when
execution enters and exits managed code.</source>
          <target state="new">High Tech: The code lives in a distinct world, where the CLR
controls most aspects of program execution at a very fine level
(potentially to individual instructions), and the CLR detects when
execution enters and exits managed code.</target>
        </trans-unit>
        <trans-unit id="b5257c12-f73d-4cc4-a894-c4ad6450aacf" xml:space="preserve">
          <source>This enables a wide variety
of useful features.</source>
          <target state="new">This enables a wide variety
of useful features.</target>
        </trans-unit>
        <trans-unit id="a7ac5346-dd4f-440e-b0ed-3198a9c0e077" xml:space="preserve">
          <source>Low Tech: The fact that there is a transition cost when going from
managed to unmanaged code, as well as the fact that unmanaged code
cannot use GC objects encourages the practice of wrapping most
unmanaged code in a managed façade.</source>
          <target state="new">Low Tech: The fact that there is a transition cost when going from
managed to unmanaged code, as well as the fact that unmanaged code
cannot use GC objects encourages the practice of wrapping most
unmanaged code in a managed façade.</target>
        </trans-unit>
        <trans-unit id="40251a3d-e896-4ae6-bb39-c4af5c4a5485" xml:space="preserve">
          <source>This means interfaces can get a
"facelift" to simplify them and to conform to a uniform set of
naming and design guidelines that produce a level of consistency and
discoverability that could have existed in the unmanaged world, but
does not.</source>
          <target state="new">This means interfaces can get a
"facelift" to simplify them and to conform to a uniform set of
naming and design guidelines that produce a level of consistency and
discoverability that could have existed in the unmanaged world, but
does not.</target>
        </trans-unit>
        <trans-unit id="b9a62e33-1a99-4fce-8351-ab5732354375" xml:space="preserve">
          <source><bpt id="c47a8bc3-ef3c-4b0f-a7e2-fca7d40ff190">&lt;strong&gt;</bpt>Both<ept id="c47a8bc3-ef3c-4b0f-a7e2-fca7d40ff190">&lt;/strong&gt;</ept> of these characteristics are very important to the success of
managed code.</source>
          <target state="new"><bpt id="c47a8bc3-ef3c-4b0f-a7e2-fca7d40ff190">&lt;strong&gt;</bpt>Both<ept id="c47a8bc3-ef3c-4b0f-a7e2-fca7d40ff190">&lt;/strong&gt;</ept> of these characteristics are very important to the success of
managed code.</target>
        </trans-unit>
        <trans-unit id="221bdb73-0145-4c7c-98d4-2f98de460cc6" xml:space="preserve">
          <source>Memory and Type Safety</source>
          <target state="new">Memory and Type Safety</target>
        </trans-unit>
        <trans-unit id="e5200a14-330d-4ddf-8a1d-cdb54fe56b2c" xml:space="preserve">
          <source>One of the less obvious but quite far-reaching features that a garbage
collector enables is that of memory safety.</source>
          <target state="new">One of the less obvious but quite far-reaching features that a garbage
collector enables is that of memory safety.</target>
        </trans-unit>
        <trans-unit id="b4f9b1dc-48d2-4d88-9886-32572d202aa2" xml:space="preserve">
          <source>The invariant of memory
safety is very simple: a program is memory safe if it accesses only
memory that has been allocated (and not freed).</source>
          <target state="new">The invariant of memory
safety is very simple: a program is memory safe if it accesses only
memory that has been allocated (and not freed).</target>
        </trans-unit>
        <trans-unit id="851043a8-eaed-4270-84fa-8b94181bc3a8" xml:space="preserve">
          <source>This simply means that
you don't have "wild" (dangling) pointers that are pointing at random
locations (more precisely, at memory that was freed prematurely).</source>
          <target state="new">This simply means that
you don't have "wild" (dangling) pointers that are pointing at random
locations (more precisely, at memory that was freed prematurely).</target>
        </trans-unit>
        <trans-unit id="98461836-bc99-4de9-83e9-8bd6e8e11700" xml:space="preserve">
          <source>Clearly, memory safety is a property we want all programs to have.</source>
          <target state="new">Clearly, memory safety is a property we want all programs to have.</target>
        </trans-unit>
        <trans-unit id="852f9950-6efd-4d88-b220-b7ce3007a498" xml:space="preserve">
          <source>Dangling pointers are always bugs, and tracking them down is often quite
difficult.</source>
          <target state="new">Dangling pointers are always bugs, and tracking them down is often quite
difficult.</target>
        </trans-unit>
        <trans-unit id="a57adfca-d0aa-4923-8af2-4f0038765ff3" xml:space="preserve">
          <source>A GC <bpt id="c9e0d8d2-a981-4cfe-859d-01696100f668">&lt;em&gt;</bpt>is<ept id="c9e0d8d2-a981-4cfe-859d-01696100f668">&lt;/em&gt;</ept> necessary to provide memory safety guarantees</source>
          <target state="new">A GC <bpt id="c9e0d8d2-a981-4cfe-859d-01696100f668">&lt;em&gt;</bpt>is<ept id="c9e0d8d2-a981-4cfe-859d-01696100f668">&lt;/em&gt;</ept> necessary to provide memory safety guarantees</target>
        </trans-unit>
        <trans-unit id="87ec7294-00aa-402d-9276-e4eb7215ee7b" xml:space="preserve">
          <source>One can quickly see how a garbage collector helps in ensuring memory
safety because it removes the possibility that users will prematurely
free memory (and thus access memory that was not properly allocated).</source>
          <target state="new">One can quickly see how a garbage collector helps in ensuring memory
safety because it removes the possibility that users will prematurely
free memory (and thus access memory that was not properly allocated).</target>
        </trans-unit>
        <trans-unit id="99198c87-8379-4ee4-9252-8be6b8c6914d" xml:space="preserve">
          <source>What may not be so obvious is that if you want to guarantee memory
safety (that is make it <bpt id="6675d741-484b-4976-a0f3-ab606b421500">&lt;em&gt;</bpt>impossible<ept id="6675d741-484b-4976-a0f3-ab606b421500">&lt;/em&gt;</ept> for programmers to create
memory-unsafe programs), practically speaking you can't avoid having a
garbage collector.</source>
          <target state="new">What may not be so obvious is that if you want to guarantee memory
safety (that is make it <bpt id="6675d741-484b-4976-a0f3-ab606b421500">&lt;em&gt;</bpt>impossible<ept id="6675d741-484b-4976-a0f3-ab606b421500">&lt;/em&gt;</ept> for programmers to create
memory-unsafe programs), practically speaking you can't avoid having a
garbage collector.</target>
        </trans-unit>
        <trans-unit id="0c6a8471-a422-4909-8351-a2f53872f444" xml:space="preserve">
          <source>The reason for this is that non-trivial programs need
<bpt id="8ddbc534-405a-414e-bf9c-1c252c2b01f2">&lt;em&gt;</bpt>heap style<ept id="8ddbc534-405a-414e-bf9c-1c252c2b01f2">&lt;/em&gt;</ept> (dynamic) memory allocations, where the lifetime of the
objects is essentially under arbitrary program control (unlike
stack-allocated, or statically-allocated memory, which has a highly
constrained allocation protocol).</source>
          <target state="new">The reason for this is that non-trivial programs need
<bpt id="8ddbc534-405a-414e-bf9c-1c252c2b01f2">&lt;em&gt;</bpt>heap style<ept id="8ddbc534-405a-414e-bf9c-1c252c2b01f2">&lt;/em&gt;</ept> (dynamic) memory allocations, where the lifetime of the
objects is essentially under arbitrary program control (unlike
stack-allocated, or statically-allocated memory, which has a highly
constrained allocation protocol).</target>
        </trans-unit>
        <trans-unit id="340a4737-31d5-41f9-b156-58369c9b0c74" xml:space="preserve">
          <source>In such an unconstrained environment,
the problem of determining whether a particular explicit delete
statement is correct becomes impossible to predict by program analysis.</source>
          <target state="new">In such an unconstrained environment,
the problem of determining whether a particular explicit delete
statement is correct becomes impossible to predict by program analysis.</target>
        </trans-unit>
        <trans-unit id="3f19c223-d208-4ecc-8752-ed8c87600a16" xml:space="preserve">
          <source>Effectively, the only way you have to determine if a delete is correct
is to check it at runtime.</source>
          <target state="new">Effectively, the only way you have to determine if a delete is correct
is to check it at runtime.</target>
        </trans-unit>
        <trans-unit id="e046d009-c0d1-4bcb-b850-6c7cf5f4917a" xml:space="preserve">
          <source>This is exactly what a GC does (checks to see
if memory is still live).</source>
          <target state="new">This is exactly what a GC does (checks to see
if memory is still live).</target>
        </trans-unit>
        <trans-unit id="e76b80d6-275a-499f-bdbb-7072b5a08704" xml:space="preserve">
          <source>Thus, for any programs that need heap-style
memory allocations, if you want to guarantee memory safety, you <bpt id="2e5d3ded-5630-47b6-a8a7-b412e78fcb3b">&lt;em&gt;</bpt>need<ept id="2e5d3ded-5630-47b6-a8a7-b412e78fcb3b">&lt;/em&gt;</ept> a
GC.</source>
          <target state="new">Thus, for any programs that need heap-style
memory allocations, if you want to guarantee memory safety, you <bpt id="2e5d3ded-5630-47b6-a8a7-b412e78fcb3b">&lt;em&gt;</bpt>need<ept id="2e5d3ded-5630-47b6-a8a7-b412e78fcb3b">&lt;/em&gt;</ept> a
GC.</target>
        </trans-unit>
        <trans-unit id="3b590d9b-4cb0-49ba-b080-47bf27ff6082" xml:space="preserve">
          <source>While a GC is necessary to ensure memory safety, it is not sufficient.</source>
          <target state="new">While a GC is necessary to ensure memory safety, it is not sufficient.</target>
        </trans-unit>
        <trans-unit id="c9d635b5-ce73-44a6-9a01-e189cbb90419" xml:space="preserve">
          <source>The GC will not prevent the program from indexing off the end of an
array or accessing a field off the end of an object (possible if you
compute the field's address using a base and offset computation).</source>
          <target state="new">The GC will not prevent the program from indexing off the end of an
array or accessing a field off the end of an object (possible if you
compute the field's address using a base and offset computation).</target>
        </trans-unit>
        <trans-unit id="458ad6f2-37cc-4234-a60a-933b60d11bf7" xml:space="preserve">
          <source>However, if we do prevent these cases, then we can indeed make it
impossible for a programmer to create memory-unsafe programs.</source>
          <target state="new">However, if we do prevent these cases, then we can indeed make it
impossible for a programmer to create memory-unsafe programs.</target>
        </trans-unit>
        <trans-unit id="789887cf-6532-4965-9593-8178bcd979b1" xml:space="preserve">
          <source>While the <bpt id="61ef8a2a-bdfd-4c92-800c-43452ec034d9CapsExtId1">&lt;linkText&gt;</bpt>common intermediate
language<ept id="61ef8a2a-bdfd-4c92-800c-43452ec034d9CapsExtId1">&lt;/linkText&gt;</ept><bpt id="61ef8a2a-bdfd-4c92-800c-43452ec034d9CapsExtId2">&lt;title&gt;</bpt><ept id="61ef8a2a-bdfd-4c92-800c-43452ec034d9CapsExtId2">&lt;/title&gt;</ept>
(CIL) <bpt id="28bba752-1915-4b6f-b887-b9acf1315cda">&lt;em&gt;</bpt>does<ept id="28bba752-1915-4b6f-b887-b9acf1315cda">&lt;/em&gt;</ept> have operators that can fetch and set arbitrary memory (and
thus violate memory safety), it also has the following memory-safe
operators and the CLR strongly encourages their use in most programming:</source>
          <target state="new">While the <bpt id="61ef8a2a-bdfd-4c92-800c-43452ec034d9CapsExtId1">&lt;linkText&gt;</bpt>common intermediate
language<ept id="61ef8a2a-bdfd-4c92-800c-43452ec034d9CapsExtId1">&lt;/linkText&gt;</ept><bpt id="61ef8a2a-bdfd-4c92-800c-43452ec034d9CapsExtId2">&lt;title&gt;</bpt><ept id="61ef8a2a-bdfd-4c92-800c-43452ec034d9CapsExtId2">&lt;/title&gt;</ept>
(CIL) <bpt id="28bba752-1915-4b6f-b887-b9acf1315cda">&lt;em&gt;</bpt>does<ept id="28bba752-1915-4b6f-b887-b9acf1315cda">&lt;/em&gt;</ept> have operators that can fetch and set arbitrary memory (and
thus violate memory safety), it also has the following memory-safe
operators and the CLR strongly encourages their use in most programming:</target>
        </trans-unit>
        <trans-unit id="4cf9cf05-dae5-4fd2-b5f4-83ff64614e62" xml:space="preserve">
          <source>Field-fetch operators (LDFLD, STFLD, LDFLDA) that fetch (read), set
and take the address of a field by name.</source>
          <target state="new">Field-fetch operators (LDFLD, STFLD, LDFLDA) that fetch (read), set
and take the address of a field by name.</target>
        </trans-unit>
        <trans-unit id="8e805b80-e926-4efb-80dd-e9b588719b3a" xml:space="preserve">
          <source>Array-fetch operators (LDELEM, STELEM, LDELEMA) that fetch, set and
take the address of an array element by index.</source>
          <target state="new">Array-fetch operators (LDELEM, STELEM, LDELEMA) that fetch, set and
take the address of an array element by index.</target>
        </trans-unit>
        <trans-unit id="1f66517b-72c4-42ad-9e20-ce7437d3eaa3" xml:space="preserve">
          <source>All arrays include a
tag specifying their length.</source>
          <target state="new">All arrays include a
tag specifying their length.</target>
        </trans-unit>
        <trans-unit id="8ff23b50-99e9-454b-acf8-9414b8a75626" xml:space="preserve">
          <source>This facilitates an automatic bounds
check before each access.</source>
          <target state="new">This facilitates an automatic bounds
check before each access.</target>
        </trans-unit>
        <trans-unit id="789428cd-af7f-4969-8d5c-8c2be6c30c4b" xml:space="preserve">
          <source>By using these operators instead of the lower-level (and unsafe)
<bpt id="1b017775-1ca4-4c0e-a61b-147c023a60ea">&lt;em&gt;</bpt>memory-fetch<ept id="1b017775-1ca4-4c0e-a61b-147c023a60ea">&lt;/em&gt;</ept> operators in user code, as well as avoiding other unsafe
<bpt id="6754aeef-1c68-4a52-aaec-742142845084CapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="6754aeef-1c68-4a52-aaec-742142845084CapsExtId1">&lt;/linkText&gt;</ept><bpt id="6754aeef-1c68-4a52-aaec-742142845084CapsExtId2">&lt;title&gt;</bpt><ept id="6754aeef-1c68-4a52-aaec-742142845084CapsExtId2">&lt;/title&gt;</ept>
operators (e.g., those that allow you to jump to arbitrary, and thus
possibly bad locations) one could imagine building a system that is
memory-safe but nothing more.</source>
          <target state="new">By using these operators instead of the lower-level (and unsafe)
<bpt id="1b017775-1ca4-4c0e-a61b-147c023a60ea">&lt;em&gt;</bpt>memory-fetch<ept id="1b017775-1ca4-4c0e-a61b-147c023a60ea">&lt;/em&gt;</ept> operators in user code, as well as avoiding other unsafe
<bpt id="6754aeef-1c68-4a52-aaec-742142845084CapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="6754aeef-1c68-4a52-aaec-742142845084CapsExtId1">&lt;/linkText&gt;</ept><bpt id="6754aeef-1c68-4a52-aaec-742142845084CapsExtId2">&lt;title&gt;</bpt><ept id="6754aeef-1c68-4a52-aaec-742142845084CapsExtId2">&lt;/title&gt;</ept>
operators (e.g., those that allow you to jump to arbitrary, and thus
possibly bad locations) one could imagine building a system that is
memory-safe but nothing more.</target>
        </trans-unit>
        <trans-unit id="50e4fcd0-8f3d-494f-a485-8895a434b5fa" xml:space="preserve">
          <source>The CLR does not do this, however.</source>
          <target state="new">The CLR does not do this, however.</target>
        </trans-unit>
        <trans-unit id="5d32c462-7a38-406f-8080-252446d705d4" xml:space="preserve">
          <source>Instead
the CLR enforces a stronger invariant: type safety.</source>
          <target state="new">Instead
the CLR enforces a stronger invariant: type safety.</target>
        </trans-unit>
        <trans-unit id="da895fe7-2f4e-4830-ac6b-cd3b901f3026" xml:space="preserve">
          <source>For type safety, conceptually each memory allocation is associated with
a type.</source>
          <target state="new">For type safety, conceptually each memory allocation is associated with
a type.</target>
        </trans-unit>
        <trans-unit id="9c622148-6ebe-4c83-a6e3-4b470b2d03f3" xml:space="preserve">
          <source>All operators that act on memory locations are also conceptually
tagged with the type for which they are valid.</source>
          <target state="new">All operators that act on memory locations are also conceptually
tagged with the type for which they are valid.</target>
        </trans-unit>
        <trans-unit id="6a76deea-34bf-4683-a5cd-8fba709bc95d" xml:space="preserve">
          <source>Type safety then requires
that memory tagged with a particular type can only undergo operations
allowed for that type.</source>
          <target state="new">Type safety then requires
that memory tagged with a particular type can only undergo operations
allowed for that type.</target>
        </trans-unit>
        <trans-unit id="d590edef-4a7c-43f5-a859-b18562590da6" xml:space="preserve">
          <source>Not only does this ensure memory safety (no
dangling pointers), it also allows additional guarantees for each
individual type.</source>
          <target state="new">Not only does this ensure memory safety (no
dangling pointers), it also allows additional guarantees for each
individual type.</target>
        </trans-unit>
        <trans-unit id="edc13611-e611-4577-b4e4-0c125110f5e9" xml:space="preserve">
          <source>One the most important of these type-specific guarantees is that the
visibility attributes associated with a type (and in particular with
fields) are enforced.</source>
          <target state="new">One the most important of these type-specific guarantees is that the
visibility attributes associated with a type (and in particular with
fields) are enforced.</target>
        </trans-unit>
        <trans-unit id="8eb65041-2418-44a5-8ee0-6ee2684e271e" xml:space="preserve">
          <source>Thus, if a field is declared to be private
(accessible only by the methods of the type), then that privacy will
indeed be respected by all other type-safe code.</source>
          <target state="new">Thus, if a field is declared to be private
(accessible only by the methods of the type), then that privacy will
indeed be respected by all other type-safe code.</target>
        </trans-unit>
        <trans-unit id="c6a5444d-4fce-46bc-ac9c-a19fad10b745" xml:space="preserve">
          <source>For example, a
particular type might declare a count field that represents the count of
items in a table.</source>
          <target state="new">For example, a
particular type might declare a count field that represents the count of
items in a table.</target>
        </trans-unit>
        <trans-unit id="ba8ba2cb-8665-4060-9498-689ebdc128f6" xml:space="preserve">
          <source>Assuming the fields for the count and the table are
private, and assuming that the only code that updates them updates them
together, there is now a strong guarantee (across all type-safe code)
that the count and the number of items in the table are indeed in sync.</source>
          <target state="new">Assuming the fields for the count and the table are
private, and assuming that the only code that updates them updates them
together, there is now a strong guarantee (across all type-safe code)
that the count and the number of items in the table are indeed in sync.</target>
        </trans-unit>
        <trans-unit id="85b0238d-2f38-4802-8ecb-b946abdfe7d6" xml:space="preserve">
          <source>When reasoning about programs, programmers use the concept of type
safety all the time, whether they know it or not.</source>
          <target state="new">When reasoning about programs, programmers use the concept of type
safety all the time, whether they know it or not.</target>
        </trans-unit>
        <trans-unit id="fc686f61-2e67-46bd-b4fe-da656e0673e2" xml:space="preserve">
          <source>The CLR elevates
type-safety from being simply a programming language/compiler
convention, to something that can be strictly enforced at run time.</source>
          <target state="new">The CLR elevates
type-safety from being simply a programming language/compiler
convention, to something that can be strictly enforced at run time.</target>
        </trans-unit>
        <trans-unit id="9dbe5d8c-7e1a-481c-8ea3-d15e032dafd3" xml:space="preserve">
          <source>Verifiable Code - Enforcing Memory and Type Safety</source>
          <target state="new">Verifiable Code - Enforcing Memory and Type Safety</target>
        </trans-unit>
        <trans-unit id="6374b56d-2881-4ac1-a928-67a11d987145" xml:space="preserve">
          <source>Conceptually, to enforce type safety, every operation that the program
performs has to be checked to ensure that it is operating on memory that
was typed in a way that is compatible with the operation.</source>
          <target state="new">Conceptually, to enforce type safety, every operation that the program
performs has to be checked to ensure that it is operating on memory that
was typed in a way that is compatible with the operation.</target>
        </trans-unit>
        <trans-unit id="bb7146bd-35e2-4038-b322-960646f0b522" xml:space="preserve">
          <source>While the
system could do this all at runtime, it would be very slow.</source>
          <target state="new">While the
system could do this all at runtime, it would be very slow.</target>
        </trans-unit>
        <trans-unit id="27672f1d-88a7-4b18-82c7-9a9adcb1f4a4" xml:space="preserve">
          <source>Instead, the
CLR has the concept of
<bpt id="8b963bb2-768f-4763-862d-60ddc5444452CapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="8b963bb2-768f-4763-862d-60ddc5444452CapsExtId1">&lt;/linkText&gt;</ept><bpt id="8b963bb2-768f-4763-862d-60ddc5444452CapsExtId2">&lt;title&gt;</bpt><ept id="8b963bb2-768f-4763-862d-60ddc5444452CapsExtId2">&lt;/title&gt;</ept>
verification, where a static analysis is done on the
<bpt id="614c801f-fd83-4c94-aca5-a3bb3b2ba5cfCapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="614c801f-fd83-4c94-aca5-a3bb3b2ba5cfCapsExtId1">&lt;/linkText&gt;</ept><bpt id="614c801f-fd83-4c94-aca5-a3bb3b2ba5cfCapsExtId2">&lt;title&gt;</bpt><ept id="614c801f-fd83-4c94-aca5-a3bb3b2ba5cfCapsExtId2">&lt;/title&gt;</ept>
(before the code is run) to confirm that most operations are indeed
type-safe.</source>
          <target state="new">Instead, the
CLR has the concept of
<bpt id="8b963bb2-768f-4763-862d-60ddc5444452CapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="8b963bb2-768f-4763-862d-60ddc5444452CapsExtId1">&lt;/linkText&gt;</ept><bpt id="8b963bb2-768f-4763-862d-60ddc5444452CapsExtId2">&lt;title&gt;</bpt><ept id="8b963bb2-768f-4763-862d-60ddc5444452CapsExtId2">&lt;/title&gt;</ept>
verification, where a static analysis is done on the
<bpt id="614c801f-fd83-4c94-aca5-a3bb3b2ba5cfCapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="614c801f-fd83-4c94-aca5-a3bb3b2ba5cfCapsExtId1">&lt;/linkText&gt;</ept><bpt id="614c801f-fd83-4c94-aca5-a3bb3b2ba5cfCapsExtId2">&lt;title&gt;</bpt><ept id="614c801f-fd83-4c94-aca5-a3bb3b2ba5cfCapsExtId2">&lt;/title&gt;</ept>
(before the code is run) to confirm that most operations are indeed
type-safe.</target>
        </trans-unit>
        <trans-unit id="c7466369-828a-47f5-bb55-87ee4bb6d1eb" xml:space="preserve">
          <source>Only when this static analysis can't do a complete job are
runtime checks necessary.</source>
          <target state="new">Only when this static analysis can't do a complete job are
runtime checks necessary.</target>
        </trans-unit>
        <trans-unit id="953bf889-b376-419a-90ac-424ca573d212" xml:space="preserve">
          <source>In practice, the number of run-time checks
needed is actually very small.</source>
          <target state="new">In practice, the number of run-time checks
needed is actually very small.</target>
        </trans-unit>
        <trans-unit id="d6d2d798-cd89-450b-acda-7bfb660b4579" xml:space="preserve">
          <source>They include the following operations:</source>
          <target state="new">They include the following operations:</target>
        </trans-unit>
        <trans-unit id="a8bac3e9-315b-46e3-862e-1fcac2d7f105" xml:space="preserve">
          <source>Casting a pointer to a base type to be a pointer to a derived type
(the opposite direction can be checked statically)</source>
          <target state="new">Casting a pointer to a base type to be a pointer to a derived type
(the opposite direction can be checked statically)</target>
        </trans-unit>
        <trans-unit id="7fa0dae5-e074-47e3-9463-cc4fc37eab5e" xml:space="preserve">
          <source>Array bounds checks (just as we saw for memory safety)</source>
          <target state="new">Array bounds checks (just as we saw for memory safety)</target>
        </trans-unit>
        <trans-unit id="94af4126-883c-4c14-a012-b4ce7e512605" xml:space="preserve">
          <source>Assigning an element in an array of pointers to a new (pointer)
value.</source>
          <target state="new">Assigning an element in an array of pointers to a new (pointer)
value.</target>
        </trans-unit>
        <trans-unit id="97627c20-40e2-4b67-a772-9bc1db2dec38" xml:space="preserve">
          <source>This particular check is only required because CLR arrays
have liberal casting rules (more on that later...)</source>
          <target state="new">This particular check is only required because CLR arrays
have liberal casting rules (more on that later...)</target>
        </trans-unit>
        <trans-unit id="ac5a7335-5e22-4a83-8701-2918d9019e64" xml:space="preserve">
          <source>Note that the need to do these checks places requirements on the
runtime.</source>
          <target state="new">Note that the need to do these checks places requirements on the
runtime.</target>
        </trans-unit>
        <trans-unit id="4d528cb6-a3b2-4e32-8ab4-34346b0bcd4a" xml:space="preserve">
          <source>In particular:</source>
          <target state="new">In particular:</target>
        </trans-unit>
        <trans-unit id="5495c4b2-f260-4285-800a-2bef3f36fb23" xml:space="preserve">
          <source>All memory in the GC heap must be tagged with its type (so the
casting operator can be implemented).</source>
          <target state="new">All memory in the GC heap must be tagged with its type (so the
casting operator can be implemented).</target>
        </trans-unit>
        <trans-unit id="43daf033-d834-4bb6-b5d9-cf6e43e18007" xml:space="preserve">
          <source>This type information must be
available at runtime, and it must be rich enough to determine if
casts are valid (e.g., the runtime needs to know the
inheritance hierarchy).</source>
          <target state="new">This type information must be
available at runtime, and it must be rich enough to determine if
casts are valid (e.g., the runtime needs to know the
inheritance hierarchy).</target>
        </trans-unit>
        <trans-unit id="8fafeb74-4eea-473a-8f56-1ade7f8332be" xml:space="preserve">
          <source>In fact, the first field in every object on
the GC heap points to a runtime data structure that represents
its type.</source>
          <target state="new">In fact, the first field in every object on
the GC heap points to a runtime data structure that represents
its type.</target>
        </trans-unit>
        <trans-unit id="27bcd483-110e-4592-bee5-1a90a056a751" xml:space="preserve">
          <source>All arrays must also have their size (for bounds checking).</source>
          <target state="new">All arrays must also have their size (for bounds checking).</target>
        </trans-unit>
        <trans-unit id="694e14e6-ad80-4ae4-9fbd-8f224fc2f1a0" xml:space="preserve">
          <source>Arrays must have complete type information about their element type.</source>
          <target state="new">Arrays must have complete type information about their element type.</target>
        </trans-unit>
        <trans-unit id="943cda7c-276a-4b60-ad52-f92b2a20b461" xml:space="preserve">
          <source>Luckily, the most expensive requirement (tagging each heap item) was
something that was already necessary to support garbage collection (the
GC needs to know what fields in every object contain references that
need to be scanned), so the additional cost to provide type safety is
low.</source>
          <target state="new">Luckily, the most expensive requirement (tagging each heap item) was
something that was already necessary to support garbage collection (the
GC needs to know what fields in every object contain references that
need to be scanned), so the additional cost to provide type safety is
low.</target>
        </trans-unit>
        <trans-unit id="33835686-4c35-40c1-a263-fac82fc384a0" xml:space="preserve">
          <source>Thus, by verifying the
<bpt id="a52add3f-1c69-457e-af95-c9d09af53c60CapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="a52add3f-1c69-457e-af95-c9d09af53c60CapsExtId1">&lt;/linkText&gt;</ept><bpt id="a52add3f-1c69-457e-af95-c9d09af53c60CapsExtId2">&lt;title&gt;</bpt><ept id="a52add3f-1c69-457e-af95-c9d09af53c60CapsExtId2">&lt;/title&gt;</ept>
of the code and by doing a few run-time checks, the CLR can ensure type
safety (and memory safety).</source>
          <target state="new">Thus, by verifying the
<bpt id="a52add3f-1c69-457e-af95-c9d09af53c60CapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="a52add3f-1c69-457e-af95-c9d09af53c60CapsExtId1">&lt;/linkText&gt;</ept><bpt id="a52add3f-1c69-457e-af95-c9d09af53c60CapsExtId2">&lt;title&gt;</bpt><ept id="a52add3f-1c69-457e-af95-c9d09af53c60CapsExtId2">&lt;/title&gt;</ept>
of the code and by doing a few run-time checks, the CLR can ensure type
safety (and memory safety).</target>
        </trans-unit>
        <trans-unit id="fc865e28-07e1-4994-86b3-8ab06637e3a8" xml:space="preserve">
          <source>Nevertheless, this extra safety exacts a
price in programming flexibility.</source>
          <target state="new">Nevertheless, this extra safety exacts a
price in programming flexibility.</target>
        </trans-unit>
        <trans-unit id="a67eebbb-4701-4a43-9f2d-438a10c89e55" xml:space="preserve">
          <source>While the CLR does have general memory
fetch operators, these operators can only be used in very constrained
ways for the code to be verifiable.</source>
          <target state="new">While the CLR does have general memory
fetch operators, these operators can only be used in very constrained
ways for the code to be verifiable.</target>
        </trans-unit>
        <trans-unit id="bc248668-1d19-4a90-b30a-00e37ee52ad0" xml:space="preserve">
          <source>In particular, all pointer
arithmetic will fail verification today.</source>
          <target state="new">In particular, all pointer
arithmetic will fail verification today.</target>
        </trans-unit>
        <trans-unit id="2e3d8d1f-784a-4733-bbaa-04b6a62b20da" xml:space="preserve">
          <source>Thus many classic C or C++
conventions cannot be used in verifiable code; you must use arrays
instead.</source>
          <target state="new">Thus many classic C or C++
conventions cannot be used in verifiable code; you must use arrays
instead.</target>
        </trans-unit>
        <trans-unit id="18e64eed-26a8-4322-a659-a70078569791" xml:space="preserve">
          <source>While this constrains programming a bit, it really is not bad
(arrays are quite powerful), and the benefits (far fewer "nasty" bugs),
are quite real.</source>
          <target state="new">While this constrains programming a bit, it really is not bad
(arrays are quite powerful), and the benefits (far fewer "nasty" bugs),
are quite real.</target>
        </trans-unit>
        <trans-unit id="827cdfd0-2ad5-4e17-9e7d-87168e46e048" xml:space="preserve">
          <source>The CLR strongly encourages the use of verifiable, type-safe code.</source>
          <target state="new">The CLR strongly encourages the use of verifiable, type-safe code.</target>
        </trans-unit>
        <trans-unit id="8b170653-e73a-457e-8c5f-b208158c5372" xml:space="preserve">
          <source>Even
so, there are times (mostly when dealing with unmanaged code) that
unverifiable programming is needed.</source>
          <target state="new">Even
so, there are times (mostly when dealing with unmanaged code) that
unverifiable programming is needed.</target>
        </trans-unit>
        <trans-unit id="b5185ed4-5acf-4d7b-9b58-fa3eff236f50" xml:space="preserve">
          <source>The CLR allows this, but the best
practice here is to try to confine this unsafe code as much as possible.</source>
          <target state="new">The CLR allows this, but the best
practice here is to try to confine this unsafe code as much as possible.</target>
        </trans-unit>
        <trans-unit id="52140b09-af12-4f9f-84eb-2366fbe6bb4d" xml:space="preserve">
          <source>Typical programs have only a very small fraction of their code that
needs to be unsafe, and the rest can be type-safe.</source>
          <target state="new">Typical programs have only a very small fraction of their code that
needs to be unsafe, and the rest can be type-safe.</target>
        </trans-unit>
        <trans-unit id="e91daa91-b229-42c0-b7b5-e2fa903496cf" xml:space="preserve">
          <source>High Level Features</source>
          <target state="new">High Level Features</target>
        </trans-unit>
        <trans-unit id="278f8bbf-191e-4b32-82e6-5f413d04337c" xml:space="preserve">
          <source>Supporting garbage collection had a profound effect on the runtime
because it requires that all code must support extra bookkeeping.</source>
          <target state="new">Supporting garbage collection had a profound effect on the runtime
because it requires that all code must support extra bookkeeping.</target>
        </trans-unit>
        <trans-unit id="23562eac-57e6-4e17-9103-f8a371c48510" xml:space="preserve">
          <source>The
desire for type-safety also had a profound effect, requiring that the
description of the program (the
<bpt id="09fb74fd-c8dc-4908-8772-518ccfc5d020CapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="09fb74fd-c8dc-4908-8772-518ccfc5d020CapsExtId1">&lt;/linkText&gt;</ept><bpt id="09fb74fd-c8dc-4908-8772-518ccfc5d020CapsExtId2">&lt;title&gt;</bpt><ept id="09fb74fd-c8dc-4908-8772-518ccfc5d020CapsExtId2">&lt;/title&gt;</ept>)
be at a high level, where fields and methods have detailed type
information.</source>
          <target state="new">The
desire for type-safety also had a profound effect, requiring that the
description of the program (the
<bpt id="09fb74fd-c8dc-4908-8772-518ccfc5d020CapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="09fb74fd-c8dc-4908-8772-518ccfc5d020CapsExtId1">&lt;/linkText&gt;</ept><bpt id="09fb74fd-c8dc-4908-8772-518ccfc5d020CapsExtId2">&lt;title&gt;</bpt><ept id="09fb74fd-c8dc-4908-8772-518ccfc5d020CapsExtId2">&lt;/title&gt;</ept>)
be at a high level, where fields and methods have detailed type
information.</target>
        </trans-unit>
        <trans-unit id="cdbfdc77-5183-4d21-a89f-7c516ef1f8e7" xml:space="preserve">
          <source>The desire for type safety also forces the
<bpt id="fc7db281-0bd8-4549-bd7f-7a06c8898b26CapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="fc7db281-0bd8-4549-bd7f-7a06c8898b26CapsExtId1">&lt;/linkText&gt;</ept><bpt id="fc7db281-0bd8-4549-bd7f-7a06c8898b26CapsExtId2">&lt;title&gt;</bpt><ept id="fc7db281-0bd8-4549-bd7f-7a06c8898b26CapsExtId2">&lt;/title&gt;</ept>
to support other high-level programming constructs that are type-safe.</source>
          <target state="new">The desire for type safety also forces the
<bpt id="fc7db281-0bd8-4549-bd7f-7a06c8898b26CapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="fc7db281-0bd8-4549-bd7f-7a06c8898b26CapsExtId1">&lt;/linkText&gt;</ept><bpt id="fc7db281-0bd8-4549-bd7f-7a06c8898b26CapsExtId2">&lt;title&gt;</bpt><ept id="fc7db281-0bd8-4549-bd7f-7a06c8898b26CapsExtId2">&lt;/title&gt;</ept>
to support other high-level programming constructs that are type-safe.</target>
        </trans-unit>
        <trans-unit id="4bcca2f0-bb53-4d30-82ca-ebb3b4fca5ad" xml:space="preserve">
          <source>Expressing these constructs in a type-safe manner also requires runtime
support.</source>
          <target state="new">Expressing these constructs in a type-safe manner also requires runtime
support.</target>
        </trans-unit>
        <trans-unit id="3e7d0e42-d369-40f1-8ade-acff6fe28205" xml:space="preserve">
          <source>The two most important of these high-level features are used to
support two essential elements of object oriented programming:
inheritance and virtual call dispatch.</source>
          <target state="new">The two most important of these high-level features are used to
support two essential elements of object oriented programming:
inheritance and virtual call dispatch.</target>
        </trans-unit>
        <trans-unit id="9c0135c5-bfbf-4f5b-80c6-bfacce0fdc85" xml:space="preserve">
          <source>Object Oriented Programming</source>
          <target state="new">Object Oriented Programming</target>
        </trans-unit>
        <trans-unit id="94566771-4e8a-435d-a844-aa5d61ff64cf" xml:space="preserve">
          <source>Inheritance is relatively simple in a mechanical sense.</source>
          <target state="new">Inheritance is relatively simple in a mechanical sense.</target>
        </trans-unit>
        <trans-unit id="5c74fbc7-f141-476f-a080-b16e51391b5a" xml:space="preserve">
          <source>The basic idea
is that if the fields of type <bpt id="fdff91f9-a1dc-47db-9ec8-4bcf4d5807cb">&lt;code&gt;</bpt>derived<ept id="fdff91f9-a1dc-47db-9ec8-4bcf4d5807cb">&lt;/code&gt;</ept> are a superset of the fields of
type <bpt id="c171769c-7f62-4b17-ac5e-f3b238e53dc9">&lt;code&gt;</bpt>base<ept id="c171769c-7f62-4b17-ac5e-f3b238e53dc9">&lt;/code&gt;</ept>, and <bpt id="65613cba-f9d5-4706-8fd1-6d37f32c0762">&lt;code&gt;</bpt>derived<ept id="65613cba-f9d5-4706-8fd1-6d37f32c0762">&lt;/code&gt;</ept> lays out its fields so the fields of <bpt id="5439a9da-eef6-41ed-87cb-fc6157d10d9d">&lt;code&gt;</bpt>base<ept id="5439a9da-eef6-41ed-87cb-fc6157d10d9d">&lt;/code&gt;</ept>
come first, then any code that expects a pointer to an instance of
<bpt id="45eb5aa3-32d8-4e8b-8fee-3b49857696d3">&lt;code&gt;</bpt>base<ept id="45eb5aa3-32d8-4e8b-8fee-3b49857696d3">&lt;/code&gt;</ept> can be given a pointer to an instance of <bpt id="a56f616d-7f65-410e-8618-703980b9d5fa">&lt;code&gt;</bpt>derived<ept id="a56f616d-7f65-410e-8618-703980b9d5fa">&lt;/code&gt;</ept> and the code
will "just work".</source>
          <target state="new">The basic idea
is that if the fields of type <bpt id="fdff91f9-a1dc-47db-9ec8-4bcf4d5807cb">&lt;code&gt;</bpt>derived<ept id="fdff91f9-a1dc-47db-9ec8-4bcf4d5807cb">&lt;/code&gt;</ept> are a superset of the fields of
type <bpt id="c171769c-7f62-4b17-ac5e-f3b238e53dc9">&lt;code&gt;</bpt>base<ept id="c171769c-7f62-4b17-ac5e-f3b238e53dc9">&lt;/code&gt;</ept>, and <bpt id="65613cba-f9d5-4706-8fd1-6d37f32c0762">&lt;code&gt;</bpt>derived<ept id="65613cba-f9d5-4706-8fd1-6d37f32c0762">&lt;/code&gt;</ept> lays out its fields so the fields of <bpt id="5439a9da-eef6-41ed-87cb-fc6157d10d9d">&lt;code&gt;</bpt>base<ept id="5439a9da-eef6-41ed-87cb-fc6157d10d9d">&lt;/code&gt;</ept>
come first, then any code that expects a pointer to an instance of
<bpt id="45eb5aa3-32d8-4e8b-8fee-3b49857696d3">&lt;code&gt;</bpt>base<ept id="45eb5aa3-32d8-4e8b-8fee-3b49857696d3">&lt;/code&gt;</ept> can be given a pointer to an instance of <bpt id="a56f616d-7f65-410e-8618-703980b9d5fa">&lt;code&gt;</bpt>derived<ept id="a56f616d-7f65-410e-8618-703980b9d5fa">&lt;/code&gt;</ept> and the code
will "just work".</target>
        </trans-unit>
        <trans-unit id="78040b0e-ffd0-4159-acfe-b183913c6e4b" xml:space="preserve">
          <source>Thus, type <bpt id="2ad839cf-7cad-4f6c-9ea1-bbd9151a4d5a">&lt;code&gt;</bpt>derived<ept id="2ad839cf-7cad-4f6c-9ea1-bbd9151a4d5a">&lt;/code&gt;</ept> is said to inherit from <bpt id="cdb10a28-0809-4368-adbd-6be3efd9c8bf">&lt;code&gt;</bpt>base<ept id="cdb10a28-0809-4368-adbd-6be3efd9c8bf">&lt;/code&gt;</ept>,
meaning that it can be used anywhere <bpt id="92a9f6e0-f60f-450c-9a83-5cde1224295b">&lt;code&gt;</bpt>base<ept id="92a9f6e0-f60f-450c-9a83-5cde1224295b">&lt;/code&gt;</ept> can be used.</source>
          <target state="new">Thus, type <bpt id="2ad839cf-7cad-4f6c-9ea1-bbd9151a4d5a">&lt;code&gt;</bpt>derived<ept id="2ad839cf-7cad-4f6c-9ea1-bbd9151a4d5a">&lt;/code&gt;</ept> is said to inherit from <bpt id="cdb10a28-0809-4368-adbd-6be3efd9c8bf">&lt;code&gt;</bpt>base<ept id="cdb10a28-0809-4368-adbd-6be3efd9c8bf">&lt;/code&gt;</ept>,
meaning that it can be used anywhere <bpt id="92a9f6e0-f60f-450c-9a83-5cde1224295b">&lt;code&gt;</bpt>base<ept id="92a9f6e0-f60f-450c-9a83-5cde1224295b">&lt;/code&gt;</ept> can be used.</target>
        </trans-unit>
        <trans-unit id="af3b61d2-a850-455d-8e9b-5f7f48f95bd6" xml:space="preserve">
          <source>Code becomes
<bpt id="43a4c9d0-0e54-4fd0-88e7-a02dfee5a42a">&lt;em&gt;</bpt>polymorphic<ept id="43a4c9d0-0e54-4fd0-88e7-a02dfee5a42a">&lt;/em&gt;</ept> because the same code can be used on many distinct types.</source>
          <target state="new">Code becomes
<bpt id="43a4c9d0-0e54-4fd0-88e7-a02dfee5a42a">&lt;em&gt;</bpt>polymorphic<ept id="43a4c9d0-0e54-4fd0-88e7-a02dfee5a42a">&lt;/em&gt;</ept> because the same code can be used on many distinct types.</target>
        </trans-unit>
        <trans-unit id="05239c8c-fbf5-4a32-a156-4ac06b660b32" xml:space="preserve">
          <source>Because the runtime needs to know what type coercions are possible, the
runtime must formalize the way inheritance is specified so it can
validate type safety.</source>
          <target state="new">Because the runtime needs to know what type coercions are possible, the
runtime must formalize the way inheritance is specified so it can
validate type safety.</target>
        </trans-unit>
        <trans-unit id="f1f45ae5-2af8-40db-89a1-915bfa3d0d6b" xml:space="preserve">
          <source>Virtual call dispatch generalizes inheritance polymorphism.</source>
          <target state="new">Virtual call dispatch generalizes inheritance polymorphism.</target>
        </trans-unit>
        <trans-unit id="3e2345ef-da07-4557-93d8-2dc59094658d" xml:space="preserve">
          <source>It allows
base types to declare methods that will be <bpt id="adb1e74b-43d7-4ab9-a81a-091c70167bda">&lt;em&gt;</bpt>overridden<ept id="adb1e74b-43d7-4ab9-a81a-091c70167bda">&lt;/em&gt;</ept> by derived
types.</source>
          <target state="new">It allows
base types to declare methods that will be <bpt id="adb1e74b-43d7-4ab9-a81a-091c70167bda">&lt;em&gt;</bpt>overridden<ept id="adb1e74b-43d7-4ab9-a81a-091c70167bda">&lt;/em&gt;</ept> by derived
types.</target>
        </trans-unit>
        <trans-unit id="906e8f3d-9ba9-4431-b014-6d21088cce7d" xml:space="preserve">
          <source>Code that uses variables of type <bpt id="046b0a47-3992-45c1-8331-a22f9467ddf0">&lt;code&gt;</bpt>base<ept id="046b0a47-3992-45c1-8331-a22f9467ddf0">&lt;/code&gt;</ept> can expect that calls to
virtual methods will be dispatched to the correct overridden method
based on the actual type of the object at run time.</source>
          <target state="new">Code that uses variables of type <bpt id="046b0a47-3992-45c1-8331-a22f9467ddf0">&lt;code&gt;</bpt>base<ept id="046b0a47-3992-45c1-8331-a22f9467ddf0">&lt;/code&gt;</ept> can expect that calls to
virtual methods will be dispatched to the correct overridden method
based on the actual type of the object at run time.</target>
        </trans-unit>
        <trans-unit id="d8f19d1a-c7c4-4ff7-ac88-fcc96a86303f" xml:space="preserve">
          <source>While such <bpt id="a7db0c7a-d2cc-48c3-aa81-5eba0fc3339b">&lt;em&gt;</bpt>run-time
dispatch logic<ept id="a7db0c7a-d2cc-48c3-aa81-5eba0fc3339b">&lt;/em&gt;</ept> could have been implemented using primitive
<bpt id="55da2184-4057-4d13-9492-19737b47d0bdCapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="55da2184-4057-4d13-9492-19737b47d0bdCapsExtId1">&lt;/linkText&gt;</ept><bpt id="55da2184-4057-4d13-9492-19737b47d0bdCapsExtId2">&lt;title&gt;</bpt><ept id="55da2184-4057-4d13-9492-19737b47d0bdCapsExtId2">&lt;/title&gt;</ept>
instructions without direct support in the runtime, it would have
suffered from two important disadvantages</source>
          <target state="new">While such <bpt id="a7db0c7a-d2cc-48c3-aa81-5eba0fc3339b">&lt;em&gt;</bpt>run-time
dispatch logic<ept id="a7db0c7a-d2cc-48c3-aa81-5eba0fc3339b">&lt;/em&gt;</ept> could have been implemented using primitive
<bpt id="55da2184-4057-4d13-9492-19737b47d0bdCapsExtId1">&lt;linkText&gt;</bpt>CIL<ept id="55da2184-4057-4d13-9492-19737b47d0bdCapsExtId1">&lt;/linkText&gt;</ept><bpt id="55da2184-4057-4d13-9492-19737b47d0bdCapsExtId2">&lt;title&gt;</bpt><ept id="55da2184-4057-4d13-9492-19737b47d0bdCapsExtId2">&lt;/title&gt;</ept>
instructions without direct support in the runtime, it would have
suffered from two important disadvantages</target>
        </trans-unit>
        <trans-unit id="44e2ef86-6932-452b-95c2-941a2e04bee9" xml:space="preserve">
          <source>It would not be type safe (mistakes in the dispatch table are
catastrophic errors)</source>
          <target state="new">It would not be type safe (mistakes in the dispatch table are
catastrophic errors)</target>
        </trans-unit>
        <trans-unit id="e2829d3d-b288-4bae-bf5b-f9df5f62723b" xml:space="preserve">
          <source>Each object-oriented language would likely implement a slightly
different way of implementing its virtual dispatch logic.</source>
          <target state="new">Each object-oriented language would likely implement a slightly
different way of implementing its virtual dispatch logic.</target>
        </trans-unit>
        <trans-unit id="59210b9f-341c-4265-9401-2ac50251866d" xml:space="preserve">
          <source>As result,
interoperability among languages would suffer (one language could
not inherit from a base type implemented in another language).</source>
          <target state="new">As result,
interoperability among languages would suffer (one language could
not inherit from a base type implemented in another language).</target>
        </trans-unit>
        <trans-unit id="a2ed03e3-a28c-4b75-9190-00ff7565206c" xml:space="preserve">
          <source>For this reason, the CLR has direct support for basic object-oriented
features.</source>
          <target state="new">For this reason, the CLR has direct support for basic object-oriented
features.</target>
        </trans-unit>
        <trans-unit id="966f1ffd-32b0-4634-8610-9aee2a15208c" xml:space="preserve">
          <source>To the degree possible, the CLR tried to make its model of
inheritance "language neutral," in the sense that different languages
might still share the same inheritance hierarchy.</source>
          <target state="new">To the degree possible, the CLR tried to make its model of
inheritance "language neutral," in the sense that different languages
might still share the same inheritance hierarchy.</target>
        </trans-unit>
        <trans-unit id="3b63656a-f01f-48f4-89d0-ffb8213c2df8" xml:space="preserve">
          <source>Unfortunately, that
was not always possible.</source>
          <target state="new">Unfortunately, that
was not always possible.</target>
        </trans-unit>
        <trans-unit id="e1d6bcc1-9c5d-4690-a9dc-c402bdecbc44" xml:space="preserve">
          <source>In particular, multiple inheritance can be
implemented in many different ways.</source>
          <target state="new">In particular, multiple inheritance can be
implemented in many different ways.</target>
        </trans-unit>
        <trans-unit id="05996838-96ac-48f0-9744-f7b3bf8a6aa8" xml:space="preserve">
          <source>The CLR chose not to support
multiple inheritance on types with fields, but does support multiple
inheritance from special types (called interfaces) that are constrained
not to have fields.</source>
          <target state="new">The CLR chose not to support
multiple inheritance on types with fields, but does support multiple
inheritance from special types (called interfaces) that are constrained
not to have fields.</target>
        </trans-unit>
        <trans-unit id="84d3ac63-5ce9-45a6-b748-d6eb631ae780" xml:space="preserve">
          <source>It is important to keep in mind that while the runtime supports these
object-oriented concepts, it does not require their use.</source>
          <target state="new">It is important to keep in mind that while the runtime supports these
object-oriented concepts, it does not require their use.</target>
        </trans-unit>
        <trans-unit id="7f1ae51c-eb2a-4697-89c0-3f6e0c22ea8a" xml:space="preserve">
          <source>Languages
without the concept of inheritance (e.g., functional languages) simply
don't use these facilities.</source>
          <target state="new">Languages
without the concept of inheritance (e.g., functional languages) simply
don't use these facilities.</target>
        </trans-unit>
        <trans-unit id="dcc8c8ca-36ca-4352-84dc-8c17c495ab15" xml:space="preserve">
          <source>Value Types (and Boxing)</source>
          <target state="new">Value Types (and Boxing)</target>
        </trans-unit>
        <trans-unit id="e2c4e135-3a76-41cf-8f77-4a15367e3d0a" xml:space="preserve">
          <source>A profound, yet subtle aspect of object oriented programming is the
concept of object identity: the notion that objects (allocated by
separate allocation calls) can be distinguished, even if all their field
values are identical.</source>
          <target state="new">A profound, yet subtle aspect of object oriented programming is the
concept of object identity: the notion that objects (allocated by
separate allocation calls) can be distinguished, even if all their field
values are identical.</target>
        </trans-unit>
        <trans-unit id="08b66397-2ca3-45c5-a4b9-ec5fa1fe2b48" xml:space="preserve">
          <source>Object identity is strongly related to the fact
that objects are accessed by reference (pointer) rather than by value.</source>
          <target state="new">Object identity is strongly related to the fact
that objects are accessed by reference (pointer) rather than by value.</target>
        </trans-unit>
        <trans-unit id="d2163a7d-8de1-4c6c-92c6-d382af9f9505" xml:space="preserve">
          <source>If two variables hold the same object (their pointers address the same
memory), then updates to one of the variables will affect the other
variable.</source>
          <target state="new">If two variables hold the same object (their pointers address the same
memory), then updates to one of the variables will affect the other
variable.</target>
        </trans-unit>
        <trans-unit id="ffb1d1cc-ae72-4833-a383-19926d895afe" xml:space="preserve">
          <source>Unfortunately, the concept of object identity is not a good semantic
match for all types.</source>
          <target state="new">Unfortunately, the concept of object identity is not a good semantic
match for all types.</target>
        </trans-unit>
        <trans-unit id="97c8b97d-819d-4735-b150-9304f834c9c5" xml:space="preserve">
          <source>In particular, programmers don't generally think of
integers as objects.</source>
          <target state="new">In particular, programmers don't generally think of
integers as objects.</target>
        </trans-unit>
        <trans-unit id="5f223440-7f03-4393-87fb-e4ee75644192" xml:space="preserve">
          <source>If the number '1' was allocated at two different
places, programmers generally want to consider those two items equal,
and certainly don't want updates to one of those instances affecting the
other.</source>
          <target state="new">If the number '1' was allocated at two different
places, programmers generally want to consider those two items equal,
and certainly don't want updates to one of those instances affecting the
other.</target>
        </trans-unit>
        <trans-unit id="18429f82-dda3-4bed-977c-36e264530919" xml:space="preserve">
          <source>In fact, a broad class of programming languages called
\`functional languages' avoid object identity and reference semantics
altogether.</source>
          <target state="new">In fact, a broad class of programming languages called
\`functional languages' avoid object identity and reference semantics
altogether.</target>
        </trans-unit>
        <trans-unit id="9e96f8dd-12fa-486c-b84a-ed83872acb55" xml:space="preserve">
          <source>While it is possible to have a "pure" object oriented system, where
everything (including integers) is an object (Smalltalk-80 does this), a
certain amount of implementation "gymnastics" is necessary to undo this
uniformity to get an efficient implementation.</source>
          <target state="new">While it is possible to have a "pure" object oriented system, where
everything (including integers) is an object (Smalltalk-80 does this), a
certain amount of implementation "gymnastics" is necessary to undo this
uniformity to get an efficient implementation.</target>
        </trans-unit>
        <trans-unit id="4574bfb4-bd4f-43ea-b9f9-76f8eef56677" xml:space="preserve">
          <source>Other languages (Perl,
Java, JavaScript) take a pragmatic view and treat some types (like
integers) by value, and others by reference.</source>
          <target state="new">Other languages (Perl,
Java, JavaScript) take a pragmatic view and treat some types (like
integers) by value, and others by reference.</target>
        </trans-unit>
        <trans-unit id="61650320-843a-4ebb-a576-f69326633af9" xml:space="preserve">
          <source>The CLR also chose a mixed
model, but unlike the others, allowed user-defined value types.</source>
          <target state="new">The CLR also chose a mixed
model, but unlike the others, allowed user-defined value types.</target>
        </trans-unit>
        <trans-unit id="6a15746a-1576-48aa-ad35-44880f3177cf" xml:space="preserve">
          <source>The key characteristics of value types are:</source>
          <target state="new">The key characteristics of value types are:</target>
        </trans-unit>
        <trans-unit id="a853ff1c-9dd4-4610-b577-f46e915043c8" xml:space="preserve">
          <source>Each local variable, field, or array element of a value type has a
distinct copy of the data in the value.</source>
          <target state="new">Each local variable, field, or array element of a value type has a
distinct copy of the data in the value.</target>
        </trans-unit>
        <trans-unit id="9ff1e707-a4ca-4033-b82b-8f044fbc3334" xml:space="preserve">
          <source>When one variable, field or array element is assigned to another,
the value is copied.</source>
          <target state="new">When one variable, field or array element is assigned to another,
the value is copied.</target>
        </trans-unit>
        <trans-unit id="837030d3-2234-4c51-935f-78e4edc4d6d6" xml:space="preserve">
          <source>Equality is always defined only in terms of the data in the variable
(not its location).</source>
          <target state="new">Equality is always defined only in terms of the data in the variable
(not its location).</target>
        </trans-unit>
        <trans-unit id="3714565d-3a1f-462a-93b2-6ae57beeed7d" xml:space="preserve">
          <source>Each value type also has a corresponding reference type which has
only one implicit, unnamed field.</source>
          <target state="new">Each value type also has a corresponding reference type which has
only one implicit, unnamed field.</target>
        </trans-unit>
        <trans-unit id="fdc91f09-685e-4068-a6b7-879775d1337a" xml:space="preserve">
          <source>This is called its boxed value.</source>
          <target state="new">This is called its boxed value.</target>
        </trans-unit>
        <trans-unit id="91ea5d86-1ec2-4a76-9342-0d90c83b4201" xml:space="preserve">
          <source>Boxed value types can participate in inheritance and have object
identity (although using the object identity of a boxed value type
is strongly discouraged).</source>
          <target state="new">Boxed value types can participate in inheritance and have object
identity (although using the object identity of a boxed value type
is strongly discouraged).</target>
        </trans-unit>
        <trans-unit id="0cdb6833-68ff-43c0-823c-0451cdef0b50" xml:space="preserve">
          <source>Value types very closely model the C (and C++) notion of a struct (or
C++ class).</source>
          <target state="new">Value types very closely model the C (and C++) notion of a struct (or
C++ class).</target>
        </trans-unit>
        <trans-unit id="0adc16e3-3e77-48ea-8b89-47cf6a3430bd" xml:space="preserve">
          <source>Like C you can have pointers to value types, but the
pointers are a type distinct from the type of the struct.</source>
          <target state="new">Like C you can have pointers to value types, but the
pointers are a type distinct from the type of the struct.</target>
        </trans-unit>
        <trans-unit id="2bbeb248-e528-4d4a-8e65-4d1d8421ee50" xml:space="preserve">
          <source>Exceptions</source>
          <target state="new">Exceptions</target>
        </trans-unit>
        <trans-unit id="ae72569e-894f-454c-9178-ea00445b33cb" xml:space="preserve">
          <source>Another high-level programming construct that the CLR directly supports
is exceptions.</source>
          <target state="new">Another high-level programming construct that the CLR directly supports
is exceptions.</target>
        </trans-unit>
        <trans-unit id="048d4dd8-85a1-4a96-8b11-460d807b3ce8" xml:space="preserve">
          <source>Exceptions are a language feature that allow programmers
to <bpt id="dad93be8-06bc-41a3-a092-5d7795cc6df5">&lt;em&gt;</bpt>throw<ept id="dad93be8-06bc-41a3-a092-5d7795cc6df5">&lt;/em&gt;</ept> an arbitrary object at the point that a failure occurs.</source>
          <target state="new">Exceptions are a language feature that allow programmers
to <bpt id="dad93be8-06bc-41a3-a092-5d7795cc6df5">&lt;em&gt;</bpt>throw<ept id="dad93be8-06bc-41a3-a092-5d7795cc6df5">&lt;/em&gt;</ept> an arbitrary object at the point that a failure occurs.</target>
        </trans-unit>
        <trans-unit id="87c773af-613d-43e0-97d0-e53d19aff192" xml:space="preserve">
          <source>When
an object is thrown, the runtime searches the call stack for a method
that declares that it can <bpt id="3f08a77f-f527-4db8-a7dd-a1a49c64916e">&lt;em&gt;</bpt>catch<ept id="3f08a77f-f527-4db8-a7dd-a1a49c64916e">&lt;/em&gt;</ept> the exception.</source>
          <target state="new">When
an object is thrown, the runtime searches the call stack for a method
that declares that it can <bpt id="3f08a77f-f527-4db8-a7dd-a1a49c64916e">&lt;em&gt;</bpt>catch<ept id="3f08a77f-f527-4db8-a7dd-a1a49c64916e">&lt;/em&gt;</ept> the exception.</target>
        </trans-unit>
        <trans-unit id="e852e0df-e6b8-47db-992a-2ff2040e4828" xml:space="preserve">
          <source>If such a catch
declaration is found, execution continues from that point.</source>
          <target state="new">If such a catch
declaration is found, execution continues from that point.</target>
        </trans-unit>
        <trans-unit id="fa944759-1dc2-40b5-b753-8bb5afba2216" xml:space="preserve">
          <source>The
usefulness of exceptions is that they avoid the very common mistake of
not checking if a called method fails.</source>
          <target state="new">The
usefulness of exceptions is that they avoid the very common mistake of
not checking if a called method fails.</target>
        </trans-unit>
        <trans-unit id="2b7bcc3c-ba83-4b55-9527-ce857d3fb96c" xml:space="preserve">
          <source>Given that exceptions help avoid
programmer mistakes (thus making programming easier), it is not
surprising that the CLR supports them.</source>
          <target state="new">Given that exceptions help avoid
programmer mistakes (thus making programming easier), it is not
surprising that the CLR supports them.</target>
        </trans-unit>
        <trans-unit id="b2e7e7c9-8748-47c8-9cb2-e5132a4c0ad6" xml:space="preserve">
          <source>As an aside, while exceptions avoid one common error (not checking for
failure), they do not prevent another (restoring data structures to a
consistent state in the event of a failure).</source>
          <target state="new">As an aside, while exceptions avoid one common error (not checking for
failure), they do not prevent another (restoring data structures to a
consistent state in the event of a failure).</target>
        </trans-unit>
        <trans-unit id="5aae1162-ff8a-46df-9f2b-5c278f7117f2" xml:space="preserve">
          <source>This means that after an
exception is caught, it is difficult in general to know if continuing
execution will cause additional errors (caused by the first failure).</source>
          <target state="new">This means that after an
exception is caught, it is difficult in general to know if continuing
execution will cause additional errors (caused by the first failure).</target>
        </trans-unit>
        <trans-unit id="b200b678-182a-49b1-a647-dff5c9979e5b" xml:space="preserve">
          <source>This is an area where the CLR is likely to add value in the future.</source>
          <target state="new">This is an area where the CLR is likely to add value in the future.</target>
        </trans-unit>
        <trans-unit id="1a3356fe-6e79-4752-a36c-0e176884580c" xml:space="preserve">
          <source>Even
as currently implemented, however, exceptions are a great step forward
(we just need to go further).</source>
          <target state="new">Even
as currently implemented, however, exceptions are a great step forward
(we just need to go further).</target>
        </trans-unit>
        <trans-unit id="3c6a881d-622c-4c6a-9945-01d524f1a753" xml:space="preserve">
          <source>Parameterized Types (Generics)</source>
          <target state="new">Parameterized Types (Generics)</target>
        </trans-unit>
        <trans-unit id="03626382-f304-4c40-8da8-bc02909a8fe0" xml:space="preserve">
          <source>Previous to version 2.0 of the CLR, the only parameterized types were
arrays.</source>
          <target state="new">Previous to version 2.0 of the CLR, the only parameterized types were
arrays.</target>
        </trans-unit>
        <trans-unit id="ad98cb8d-48f5-4fbd-beab-9a5d0abb9072" xml:space="preserve">
          <source>All other containers (such as hash tables, lists, queues, etc.),
all operated on a generic Object type.</source>
          <target state="new">All other containers (such as hash tables, lists, queues, etc.),
all operated on a generic Object type.</target>
        </trans-unit>
        <trans-unit id="802d4a22-d6ee-4192-9450-6372c2e123e2" xml:space="preserve">
          <source>The inability to create List, or
Dictionary certainly had a negative performance effect because value
types needed to be boxed on entry to a collection, and explicit casting
was needed on element fetch.</source>
          <target state="new">The inability to create List, or
Dictionary certainly had a negative performance effect because value
types needed to be boxed on entry to a collection, and explicit casting
was needed on element fetch.</target>
        </trans-unit>
        <trans-unit id="8b85475e-5776-4671-9dec-86adc65a95af" xml:space="preserve">
          <source>Nevertheless, that is not the overriding
reason for adding parameterized types to the CLR.</source>
          <target state="new">Nevertheless, that is not the overriding
reason for adding parameterized types to the CLR.</target>
        </trans-unit>
        <trans-unit id="a120235e-b109-47b1-9752-8f265049ba1a" xml:space="preserve">
          <source>The main reason is
that <bpt id="0570670e-0f5c-4102-b25e-55017ef251f0">&lt;strong&gt;</bpt>parameterized types make programming easier<ept id="0570670e-0f5c-4102-b25e-55017ef251f0">&lt;/strong&gt;</ept>.</source>
          <target state="new">The main reason is
that <bpt id="0570670e-0f5c-4102-b25e-55017ef251f0">&lt;strong&gt;</bpt>parameterized types make programming easier<ept id="0570670e-0f5c-4102-b25e-55017ef251f0">&lt;/strong&gt;</ept>.</target>
        </trans-unit>
        <trans-unit id="c1bd4f8b-01e5-40d9-8393-93a6929e2b3f" xml:space="preserve">
          <source>The reason for this is subtle.</source>
          <target state="new">The reason for this is subtle.</target>
        </trans-unit>
        <trans-unit id="e3cdde3f-2392-4e71-8f39-0e03d3d46338" xml:space="preserve">
          <source>The easiest way to see the effect is to
imagine what a class library would look like if all types were replaced
with a generic Object type.</source>
          <target state="new">The easiest way to see the effect is to
imagine what a class library would look like if all types were replaced
with a generic Object type.</target>
        </trans-unit>
        <trans-unit id="b15d7df3-c1fd-4a89-bd36-bf2306f98d57" xml:space="preserve">
          <source>This effect is not unlike what happens in
dynamically typed languages like JavaScript.</source>
          <target state="new">This effect is not unlike what happens in
dynamically typed languages like JavaScript.</target>
        </trans-unit>
        <trans-unit id="22a98765-0931-446e-bdac-cd0031a7d0df" xml:space="preserve">
          <source>In such a world, there are
simply far more ways for a programmer to make incorrect (but type-safe)
programs.</source>
          <target state="new">In such a world, there are
simply far more ways for a programmer to make incorrect (but type-safe)
programs.</target>
        </trans-unit>
        <trans-unit id="a0255d3f-508b-42bd-a57e-820fa977dc4b" xml:space="preserve">
          <source>Is the parameter for that method supposed to be a list?</source>
          <target state="new">Is the parameter for that method supposed to be a list?</target>
        </trans-unit>
        <trans-unit id="2aa6491d-6d51-40e6-89d0-f97b905ae8b5" xml:space="preserve">
          <source>a
string?</source>
          <target state="new">a
string?</target>
        </trans-unit>
        <trans-unit id="19212a7b-3784-4d7a-88e0-351cb66d1b41" xml:space="preserve">
          <source>an integer?</source>
          <target state="new">an integer?</target>
        </trans-unit>
        <trans-unit id="1d3c274a-f700-40b3-812d-a75af6adf0e8" xml:space="preserve">
          <source>any of the above?</source>
          <target state="new">any of the above?</target>
        </trans-unit>
        <trans-unit id="81d5047a-e622-4c9f-8dde-cb30871b2e88" xml:space="preserve">
          <source>It is no longer obvious from
looking at the method's signature.</source>
          <target state="new">It is no longer obvious from
looking at the method's signature.</target>
        </trans-unit>
        <trans-unit id="6457de48-8fb3-425a-a7e9-ee92ee2144c1" xml:space="preserve">
          <source>Worse, when a method returns an
Object, what other methods can accept it as a parameter?</source>
          <target state="new">Worse, when a method returns an
Object, what other methods can accept it as a parameter?</target>
        </trans-unit>
        <trans-unit id="978f2d4a-afb0-40bd-a9e0-5a9a4712de34" xml:space="preserve">
          <source>Typical
frameworks have hundreds of methods; if they all take parameters of type
Object, it becomes very difficult to determine which Object instances
are valid for the operations the method will perform.</source>
          <target state="new">Typical
frameworks have hundreds of methods; if they all take parameters of type
Object, it becomes very difficult to determine which Object instances
are valid for the operations the method will perform.</target>
        </trans-unit>
        <trans-unit id="c412a6f0-c30c-4c42-b49c-f43e92192b69" xml:space="preserve">
          <source>In short, strong
typing help a programmer express his intent more clearly, and allows
tools (e.g., the compiler) to enforce his intent.</source>
          <target state="new">In short, strong
typing help a programmer express his intent more clearly, and allows
tools (e.g., the compiler) to enforce his intent.</target>
        </trans-unit>
        <trans-unit id="490f0e24-dc16-42fb-b793-8f5554287d70" xml:space="preserve">
          <source>This results in big
productivity boost.</source>
          <target state="new">This results in big
productivity boost.</target>
        </trans-unit>
        <trans-unit id="e24fe90c-82e1-4c08-a17e-eb36b6101396" xml:space="preserve">
          <source>These benefits do not disappear just because the type gets put into a
List or a Dictionary, so clearly parameterized types have value.</source>
          <target state="new">These benefits do not disappear just because the type gets put into a
List or a Dictionary, so clearly parameterized types have value.</target>
        </trans-unit>
        <trans-unit id="2f4a10c5-f6ac-4453-89e2-e1af0f418635" xml:space="preserve">
          <source>The
only real question is whether parameterized types are best thought of as
a language specific feature which is "compiled out" by the time CIL is
generated, or whether this feature should have first class support in
the runtime.</source>
          <target state="new">The
only real question is whether parameterized types are best thought of as
a language specific feature which is "compiled out" by the time CIL is
generated, or whether this feature should have first class support in
the runtime.</target>
        </trans-unit>
        <trans-unit id="bc49c870-832e-41ba-b297-4072e48ff26b" xml:space="preserve">
          <source>Either implementation is certainly possible.</source>
          <target state="new">Either implementation is certainly possible.</target>
        </trans-unit>
        <trans-unit id="7500880d-61ba-46e9-a99f-d3fdbd7ca7f1" xml:space="preserve">
          <source>The CLR team
chose first class support because without it, parameterized types would
be implemented different ways by different languages.</source>
          <target state="new">The CLR team
chose first class support because without it, parameterized types would
be implemented different ways by different languages.</target>
        </trans-unit>
        <trans-unit id="f9149ad3-ffcf-4245-a217-ceb1f41787ef" xml:space="preserve">
          <source>This would imply
that interoperability would be cumbersome at best.</source>
          <target state="new">This would imply
that interoperability would be cumbersome at best.</target>
        </trans-unit>
        <trans-unit id="108d50ea-fb63-44d5-b167-d9f190cc7bd9" xml:space="preserve">
          <source>In addition,
expressing programmer intent for parameterized types is most valuable
<bpt id="1a1b1dcb-0baf-44b3-bdef-2cf5ac2fffad">&lt;em&gt;</bpt>at the interface<ept id="1a1b1dcb-0baf-44b3-bdef-2cf5ac2fffad">&lt;/em&gt;</ept> of a class library.</source>
          <target state="new">In addition,
expressing programmer intent for parameterized types is most valuable
<bpt id="1a1b1dcb-0baf-44b3-bdef-2cf5ac2fffad">&lt;em&gt;</bpt>at the interface<ept id="1a1b1dcb-0baf-44b3-bdef-2cf5ac2fffad">&lt;/em&gt;</ept> of a class library.</target>
        </trans-unit>
        <trans-unit id="7ea9476c-3d61-413c-9cbb-bc7cf43b1928" xml:space="preserve">
          <source>If the CLR did not officially
support parameterized types, then class libraries could not use them,
and an important usability feature would be lost.</source>
          <target state="new">If the CLR did not officially
support parameterized types, then class libraries could not use them,
and an important usability feature would be lost.</target>
        </trans-unit>
        <trans-unit id="63ca660e-8981-408f-acf1-2093f7bdf63f" xml:space="preserve">
          <source>Programs as Data (Reflection APIs)</source>
          <target state="new">Programs as Data (Reflection APIs)</target>
        </trans-unit>
        <trans-unit id="21963c02-5b6d-477e-8ca4-6b42f26135ba" xml:space="preserve">
          <source>The fundamentals of the CLR are garbage collection, type safety, and
high-level language features.</source>
          <target state="new">The fundamentals of the CLR are garbage collection, type safety, and
high-level language features.</target>
        </trans-unit>
        <trans-unit id="d12ef4ca-f19d-44b2-a90a-33180f8ff2de" xml:space="preserve">
          <source>These basic characteristics forced the
specification of the program (the CIL) to be fairly high level.</source>
          <target state="new">These basic characteristics forced the
specification of the program (the CIL) to be fairly high level.</target>
        </trans-unit>
        <trans-unit id="d0cc4d4c-a85e-48a9-a0f6-98447aae27cb" xml:space="preserve">
          <source>Once
this data existed at run time (something not true for C or C++
programs), it became obvious that it would also be valuable to expose
this rich data to end programmers.</source>
          <target state="new">Once
this data existed at run time (something not true for C or C++
programs), it became obvious that it would also be valuable to expose
this rich data to end programmers.</target>
        </trans-unit>
        <trans-unit id="40ff40f7-20d5-4e38-9573-7ce92825166d" xml:space="preserve">
          <source>This idea resulted in the creation of
the System.Reflection interfaces (so-called because they allow the
program to look at (reflect upon) itself).</source>
          <target state="new">This idea resulted in the creation of
the System.Reflection interfaces (so-called because they allow the
program to look at (reflect upon) itself).</target>
        </trans-unit>
        <trans-unit id="fb890648-790a-46fd-83c0-64216ee52310" xml:space="preserve">
          <source>This interface allows you to
explore almost all aspects of a program (what types it has, the
inheritance relationship, and what methods and fields are present).</source>
          <target state="new">This interface allows you to
explore almost all aspects of a program (what types it has, the
inheritance relationship, and what methods and fields are present).</target>
        </trans-unit>
        <trans-unit id="e34f34e6-9961-4efd-ad1e-c276eb1e25aa" xml:space="preserve">
          <source>In
fact, so little information is lost that very good "decompilers" for
managed code are possible (e.g., <bpt id="cc9ea9b5-780a-4e18-b23f-14fd678db2cdCapsExtId1">&lt;linkText&gt;</bpt>NET
Reflector<ept id="cc9ea9b5-780a-4e18-b23f-14fd678db2cdCapsExtId1">&lt;/linkText&gt;</ept><bpt id="cc9ea9b5-780a-4e18-b23f-14fd678db2cdCapsExtId2">&lt;title&gt;</bpt><ept id="cc9ea9b5-780a-4e18-b23f-14fd678db2cdCapsExtId2">&lt;/title&gt;</ept>).</source>
          <target state="new">In
fact, so little information is lost that very good "decompilers" for
managed code are possible (e.g., <bpt id="cc9ea9b5-780a-4e18-b23f-14fd678db2cdCapsExtId1">&lt;linkText&gt;</bpt>NET
Reflector<ept id="cc9ea9b5-780a-4e18-b23f-14fd678db2cdCapsExtId1">&lt;/linkText&gt;</ept><bpt id="cc9ea9b5-780a-4e18-b23f-14fd678db2cdCapsExtId2">&lt;title&gt;</bpt><ept id="cc9ea9b5-780a-4e18-b23f-14fd678db2cdCapsExtId2">&lt;/title&gt;</ept>).</target>
        </trans-unit>
        <trans-unit id="6391a8c0-c4c8-4739-85d1-2856df583e85" xml:space="preserve">
          <source>While those
concerned with intellectual property protection are aghast at this
capability (which can be fixed by purposefully destroying information
through an operation called <bpt id="a3c20f4c-efd7-4be5-a560-fed109da528f">&lt;em&gt;</bpt>obfuscating<ept id="a3c20f4c-efd7-4be5-a560-fed109da528f">&lt;/em&gt;</ept> the program), the fact that it
is possible is a testament to the richness of the information available
at run time in managed code.</source>
          <target state="new">While those
concerned with intellectual property protection are aghast at this
capability (which can be fixed by purposefully destroying information
through an operation called <bpt id="a3c20f4c-efd7-4be5-a560-fed109da528f">&lt;em&gt;</bpt>obfuscating<ept id="a3c20f4c-efd7-4be5-a560-fed109da528f">&lt;/em&gt;</ept> the program), the fact that it
is possible is a testament to the richness of the information available
at run time in managed code.</target>
        </trans-unit>
        <trans-unit id="2e21cdbf-d120-4171-bad6-bc8c280d9aec" xml:space="preserve">
          <source>In addition to simply inspecting programs at run time, it is also
possible to perform operations on them (e.g., invoke methods, set
fields, etc.), and perhaps most powerfully, to generate code from
scratch at run time (System.Reflection.Emit).</source>
          <target state="new">In addition to simply inspecting programs at run time, it is also
possible to perform operations on them (e.g., invoke methods, set
fields, etc.), and perhaps most powerfully, to generate code from
scratch at run time (System.Reflection.Emit).</target>
        </trans-unit>
        <trans-unit id="9c367b7a-3896-4ab1-b55a-f83b1a9a6c6f" xml:space="preserve">
          <source>In fact, the runtime
libraries use this capability to create specialized code for matching
strings (System.Text.RegularExpressions), and to generate code for
"serializing" objects to store in a file or send across the network.</source>
          <target state="new">In fact, the runtime
libraries use this capability to create specialized code for matching
strings (System.Text.RegularExpressions), and to generate code for
"serializing" objects to store in a file or send across the network.</target>
        </trans-unit>
        <trans-unit id="79b5827f-1af3-413f-a3b8-044adefafe1d" xml:space="preserve">
          <source>Capabilities like this were simply infeasible before (you would have to
write a compiler!)</source>
          <target state="new">Capabilities like this were simply infeasible before (you would have to
write a compiler!)</target>
        </trans-unit>
        <trans-unit id="ef451959-f074-4e8c-8108-904c94b590af" xml:space="preserve">
          <source>but thanks to the runtime, are well within reach of
many more programming problems.</source>
          <target state="new">but thanks to the runtime, are well within reach of
many more programming problems.</target>
        </trans-unit>
        <trans-unit id="c03404c6-fdf0-4b9e-b356-0022574dd251" xml:space="preserve">
          <source>While reflection capabilities are indeed powerful, that power should be
used with care.</source>
          <target state="new">While reflection capabilities are indeed powerful, that power should be
used with care.</target>
        </trans-unit>
        <trans-unit id="dd6bc104-79c1-48b7-b573-ffc2ca37bf25" xml:space="preserve">
          <source>Reflection is usually significantly slower than its
statically compiled counterparts.</source>
          <target state="new">Reflection is usually significantly slower than its
statically compiled counterparts.</target>
        </trans-unit>
        <trans-unit id="2f52f5de-71a7-48f6-9a69-744c98c396a5" xml:space="preserve">
          <source>More importantly, self-referential
systems are inherently harder to understand.</source>
          <target state="new">More importantly, self-referential
systems are inherently harder to understand.</target>
        </trans-unit>
        <trans-unit id="fc12926e-f48e-4a4e-a063-dfa4f96f0e94" xml:space="preserve">
          <source>This means that powerful
features such as Reflection or Reflection.Emit should only be used when
the value is clear and substantial.</source>
          <target state="new">This means that powerful
features such as Reflection or Reflection.Emit should only be used when
the value is clear and substantial.</target>
        </trans-unit>
        <trans-unit id="97b0d317-fafe-43ea-a4e6-a0e37b92c2a9" xml:space="preserve">
          <source>Other Features</source>
          <target state="new">Other Features</target>
        </trans-unit>
        <trans-unit id="51fd8a8b-4d96-4aae-9621-81de9c4b31d0" xml:space="preserve">
          <source>The last grouping of runtime features are those that are not related to
the fundamental architecture of the CLR (GC, type safety, high-level
specification), but nevertheless fill important needs of any complete
runtime system.</source>
          <target state="new">The last grouping of runtime features are those that are not related to
the fundamental architecture of the CLR (GC, type safety, high-level
specification), but nevertheless fill important needs of any complete
runtime system.</target>
        </trans-unit>
        <trans-unit id="637c03da-e647-471b-87e4-3359dd17b916" xml:space="preserve">
          <source>Interoperation with Unmanaged Code</source>
          <target state="new">Interoperation with Unmanaged Code</target>
        </trans-unit>
        <trans-unit id="c26e724e-98ea-46f0-bd40-c53d4e8fb116" xml:space="preserve">
          <source>Managed code needs to be able to use functionality implemented in
unmanaged code.</source>
          <target state="new">Managed code needs to be able to use functionality implemented in
unmanaged code.</target>
        </trans-unit>
        <trans-unit id="c21eb06e-478f-40fa-a244-2b0a9062bb28" xml:space="preserve">
          <source>There are two main "flavors" of interoperation.</source>
          <target state="new">There are two main "flavors" of interoperation.</target>
        </trans-unit>
        <trans-unit id="126ff9d7-517c-491a-a88a-4cda17668ce4" xml:space="preserve">
          <source>First is
the ability simply to call unmanaged functions (this is called Platform
Invoke or PINVOKE).</source>
          <target state="new">First is
the ability simply to call unmanaged functions (this is called Platform
Invoke or PINVOKE).</target>
        </trans-unit>
        <trans-unit id="83f7b92e-e9bc-4b86-898b-29fb9c7dd634" xml:space="preserve">
          <source>Unmanaged code also has an object-oriented model of
interoperation called COM (component object model) which has more
structure than ad hoc method calls.</source>
          <target state="new">Unmanaged code also has an object-oriented model of
interoperation called COM (component object model) which has more
structure than ad hoc method calls.</target>
        </trans-unit>
        <trans-unit id="1922fb11-5d83-4a5d-930c-9123e2022eb3" xml:space="preserve">
          <source>Since both COM and the CLR have
models for objects and other conventions (how errors are handled,
lifetime of objects, etc.), the CLR can do a better job interoperating
with COM code if it has special support.</source>
          <target state="new">Since both COM and the CLR have
models for objects and other conventions (how errors are handled,
lifetime of objects, etc.), the CLR can do a better job interoperating
with COM code if it has special support.</target>
        </trans-unit>
        <trans-unit id="8199964a-2692-469e-af33-f1e4b40802c1" xml:space="preserve">
          <source>Ahead of time Compilation</source>
          <target state="new">Ahead of time Compilation</target>
        </trans-unit>
        <trans-unit id="f5fa8adc-601d-4fe0-915f-63d59bb81356" xml:space="preserve">
          <source>In the CLR model, managed code is distributed as CIL, not native code.</source>
          <target state="new">In the CLR model, managed code is distributed as CIL, not native code.</target>
        </trans-unit>
        <trans-unit id="4ef87eee-54b4-4d29-918b-396126ae034a" xml:space="preserve">
          <source>Translation to native code occurs at run time.</source>
          <target state="new">Translation to native code occurs at run time.</target>
        </trans-unit>
        <trans-unit id="d12815bb-91a7-494d-91c0-aea2dd21e6a3" xml:space="preserve">
          <source>As an optimization, the
native code that is generated from the CIL can be saved in a file using
a tool called crossgen (similar to .NET Framework NGEN tool).</source>
          <target state="new">As an optimization, the
native code that is generated from the CIL can be saved in a file using
a tool called crossgen (similar to .NET Framework NGEN tool).</target>
        </trans-unit>
        <trans-unit id="39c4b9ea-0ada-4a6e-9c2b-a51ff4ce98fb" xml:space="preserve">
          <source>This
avoids large amounts of compilation time at run time and is very
important because the class library is so large.</source>
          <target state="new">This
avoids large amounts of compilation time at run time and is very
important because the class library is so large.</target>
        </trans-unit>
        <trans-unit id="e9f2e496-8dd2-4ef7-a3f0-7b8d666d14bb" xml:space="preserve">
          <source>Threading</source>
          <target state="new">Threading</target>
        </trans-unit>
        <trans-unit id="bc5a5478-34af-47a0-a314-54826a618dc5" xml:space="preserve">
          <source>The CLR fully anticipated the need to support multi-threaded programs in
managed code.</source>
          <target state="new">The CLR fully anticipated the need to support multi-threaded programs in
managed code.</target>
        </trans-unit>
        <trans-unit id="11ba243f-5f1d-42a2-9bee-a1d21bd81c5e" xml:space="preserve">
          <source>From the start, the CLR libraries contained the
System.Threading.Thread class which is a 1-to-1 wrapper over the
operating system notion of a thread of execution.</source>
          <target state="new">From the start, the CLR libraries contained the
System.Threading.Thread class which is a 1-to-1 wrapper over the
operating system notion of a thread of execution.</target>
        </trans-unit>
        <trans-unit id="9ba647ef-e738-4474-ac61-bf874a1a45fe" xml:space="preserve">
          <source>However, because it is
just a wrapper over the operating system thread, creating a
System.Threading.Thread is relatively expensive (it takes milliseconds
to start).</source>
          <target state="new">However, because it is
just a wrapper over the operating system thread, creating a
System.Threading.Thread is relatively expensive (it takes milliseconds
to start).</target>
        </trans-unit>
        <trans-unit id="e93d4127-19cf-4f7a-9853-ba518f6f9cfb" xml:space="preserve">
          <source>While this is fine for many operations, one style of
programming creates very small work items (taking only tens of
milliseconds).</source>
          <target state="new">While this is fine for many operations, one style of
programming creates very small work items (taking only tens of
milliseconds).</target>
        </trans-unit>
        <trans-unit id="cfec3f1c-41ed-449b-b5a4-87f66592abe6" xml:space="preserve">
          <source>This is very common in server code (e.g., each task is
serving just one web page) or in code that tries to take advantage of
multi-processors (e.g., a multi-core sort algorithm).</source>
          <target state="new">This is very common in server code (e.g., each task is
serving just one web page) or in code that tries to take advantage of
multi-processors (e.g., a multi-core sort algorithm).</target>
        </trans-unit>
        <trans-unit id="04b6ddf0-71c6-42af-acad-19c38adc9ec6" xml:space="preserve">
          <source>To support this,
the CLR has the notion of a ThreadPool which allows WorkItems to be
queued.</source>
          <target state="new">To support this,
the CLR has the notion of a ThreadPool which allows WorkItems to be
queued.</target>
        </trans-unit>
        <trans-unit id="c06b24cb-442e-4986-a9d6-37fff39aeeb3" xml:space="preserve">
          <source>In this scheme, the CLR is responsible for creating the
necessary threads to do the work.</source>
          <target state="new">In this scheme, the CLR is responsible for creating the
necessary threads to do the work.</target>
        </trans-unit>
        <trans-unit id="7dafecee-5310-454d-b45b-796c4891fde4" xml:space="preserve">
          <source>While the CLR does expose the
ThreadPool directly as the System.Threading.Threadpool class, the
preferred mechanism is to use the [Task Parallel
Library](https://msdn.microsoft.com/en-us/library/dd460717(v=vs.110).aspx),
which adds additional support for very common forms of concurrency
control.</source>
          <target state="new">While the CLR does expose the
ThreadPool directly as the System.Threading.Threadpool class, the
preferred mechanism is to use the [Task Parallel
Library](https://msdn.microsoft.com/en-us/library/dd460717(v=vs.110).aspx),
which adds additional support for very common forms of concurrency
control.</target>
        </trans-unit>
        <trans-unit id="1ba299a1-e26a-433f-a803-04b14d3227e2" xml:space="preserve">
          <source>From an implementation perspective, the important innovation of the
ThreadPool is that it is responsible for ensuring that the optimal
number of threads are used to dispatch the work.</source>
          <target state="new">From an implementation perspective, the important innovation of the
ThreadPool is that it is responsible for ensuring that the optimal
number of threads are used to dispatch the work.</target>
        </trans-unit>
        <trans-unit id="14ac91d6-3185-4199-aa71-4b96a18cf7e7" xml:space="preserve">
          <source>The CLR does this using
a feedback system where it monitors the throughput rate and the number
of threads and adjusts the number of threads to maximize the throughput.</source>
          <target state="new">The CLR does this using
a feedback system where it monitors the throughput rate and the number
of threads and adjusts the number of threads to maximize the throughput.</target>
        </trans-unit>
        <trans-unit id="15dfe329-0849-4bf8-811c-49bf9f2c94ac" xml:space="preserve">
          <source>This is very nice because now programmers can think mostly in terms of
"exposing parallelism" (that is, creating work items), rather than the
more subtle question of determining the right amount of parallelism
(which depends on the workload and the hardware on which the program is
run).</source>
          <target state="new">This is very nice because now programmers can think mostly in terms of
"exposing parallelism" (that is, creating work items), rather than the
more subtle question of determining the right amount of parallelism
(which depends on the workload and the hardware on which the program is
run).</target>
        </trans-unit>
        <trans-unit id="03f09db0-b09d-4ae6-98bc-96fedb2f6031" xml:space="preserve">
          <source>Summary and Resources</source>
          <target state="new">Summary and Resources</target>
        </trans-unit>
        <trans-unit id="01d26cfd-a9ed-430d-b0f4-be1d88ba6aae" xml:space="preserve">
          <source>Phew!</source>
          <target state="new">Phew!</target>
        </trans-unit>
        <trans-unit id="23187134-31ae-4fdf-bca0-b11276094984" xml:space="preserve">
          <source>The runtime does a lot!</source>
          <target state="new">The runtime does a lot!</target>
        </trans-unit>
        <trans-unit id="ffff2fa7-a952-4c95-94d6-442769c13c66" xml:space="preserve">
          <source>It has taken many pages just to describe
<bpt id="cc2197bf-ee62-44e1-84fd-6f99ec8df433">&lt;em&gt;</bpt>some<ept id="cc2197bf-ee62-44e1-84fd-6f99ec8df433">&lt;/em&gt;</ept> of the features of the runtime, without even starting to talk
about internal details.</source>
          <target state="new">It has taken many pages just to describe
<bpt id="cc2197bf-ee62-44e1-84fd-6f99ec8df433">&lt;em&gt;</bpt>some<ept id="cc2197bf-ee62-44e1-84fd-6f99ec8df433">&lt;/em&gt;</ept> of the features of the runtime, without even starting to talk
about internal details.</target>
        </trans-unit>
        <trans-unit id="ed07174b-6f74-4eee-b49c-f859933c279c" xml:space="preserve">
          <source>The hope is, however, that this introduction
will provide a useful framework for a deeper understanding of those
internal details.</source>
          <target state="new">The hope is, however, that this introduction
will provide a useful framework for a deeper understanding of those
internal details.</target>
        </trans-unit>
        <trans-unit id="cbfa8116-80a0-4141-bd40-90fba6e57008" xml:space="preserve">
          <source>The basic outline of this framework is:</source>
          <target state="new">The basic outline of this framework is:</target>
        </trans-unit>
        <trans-unit id="39dd61b7-1ce5-45cb-b212-21b5828e9609" xml:space="preserve">
          <source>The Runtime is a complete framework for supporting programming languages</source>
          <target state="new">The Runtime is a complete framework for supporting programming languages</target>
        </trans-unit>
        <trans-unit id="a9212884-ee42-4efc-9b6f-2dc991640408" xml:space="preserve">
          <source>The Runtime's goal is to make programming easy.</source>
          <target state="new">The Runtime's goal is to make programming easy.</target>
        </trans-unit>
        <trans-unit id="0eb4cc52-d0d2-48e4-b6ef-e9acad2e049e" xml:space="preserve">
          <source>The Fundamental features of the runtime are:</source>
          <target state="new">The Fundamental features of the runtime are:</target>
        </trans-unit>
        <trans-unit id="e9477963-061e-4eb1-91af-bf66f5fe2388" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="new">Garbage Collection</target>
        </trans-unit>
        <trans-unit id="6f64ca55-7c8f-47ea-8e7f-03868cfc9c1c" xml:space="preserve">
          <source>Memory and Type Safety</source>
          <target state="new">Memory and Type Safety</target>
        </trans-unit>
        <trans-unit id="8acb18a2-6aae-4037-9b0f-ecf51328d741" xml:space="preserve">
          <source>Support for High-Level Language Features</source>
          <target state="new">Support for High-Level Language Features</target>
        </trans-unit>
        <trans-unit id="c07e4048-2ae0-48fb-83ae-fb0574e607e7" xml:space="preserve">
          <source>Useful Links</source>
          <target state="new">Useful Links</target>
        </trans-unit>
        <trans-unit id="763af90e-dfbb-43ed-bd8e-cecbae50a645" xml:space="preserve">
          <source><bpt id="6662339e-a8ca-45ca-9404-67eb9c5ef4acCapsExtId1">&lt;linkText&gt;</bpt>MSDN Entry for the CLR<ept id="6662339e-a8ca-45ca-9404-67eb9c5ef4acCapsExtId1">&lt;/linkText&gt;</ept><bpt id="6662339e-a8ca-45ca-9404-67eb9c5ef4acCapsExtId2">&lt;title&gt;</bpt><ept id="6662339e-a8ca-45ca-9404-67eb9c5ef4acCapsExtId2">&lt;/title&gt;</ept></source>
          <target state="new"><bpt id="6662339e-a8ca-45ca-9404-67eb9c5ef4acCapsExtId1">&lt;linkText&gt;</bpt>MSDN Entry for the CLR<ept id="6662339e-a8ca-45ca-9404-67eb9c5ef4acCapsExtId1">&lt;/linkText&gt;</ept><bpt id="6662339e-a8ca-45ca-9404-67eb9c5ef4acCapsExtId2">&lt;title&gt;</bpt><ept id="6662339e-a8ca-45ca-9404-67eb9c5ef4acCapsExtId2">&lt;/title&gt;</ept></target>
        </trans-unit>
        <trans-unit id="78f0ca7f-5e6d-4813-948e-f855a6031a3d" xml:space="preserve">
          <source><bpt id="dd8bd71b-cc31-42ad-b1a2-8c90a00fbc2cCapsExtId1">&lt;linkText&gt;</bpt>Wikipedia Entry for the CLR<ept id="dd8bd71b-cc31-42ad-b1a2-8c90a00fbc2cCapsExtId1">&lt;/linkText&gt;</ept><bpt id="dd8bd71b-cc31-42ad-b1a2-8c90a00fbc2cCapsExtId2">&lt;title&gt;</bpt><ept id="dd8bd71b-cc31-42ad-b1a2-8c90a00fbc2cCapsExtId2">&lt;/title&gt;</ept></source>
          <target state="new"><bpt id="dd8bd71b-cc31-42ad-b1a2-8c90a00fbc2cCapsExtId1">&lt;linkText&gt;</bpt>Wikipedia Entry for the CLR<ept id="dd8bd71b-cc31-42ad-b1a2-8c90a00fbc2cCapsExtId1">&lt;/linkText&gt;</ept><bpt id="dd8bd71b-cc31-42ad-b1a2-8c90a00fbc2cCapsExtId2">&lt;title&gt;</bpt><ept id="dd8bd71b-cc31-42ad-b1a2-8c90a00fbc2cCapsExtId2">&lt;/title&gt;</ept></target>
        </trans-unit>
        <trans-unit id="4cf94728-5ab4-44b2-92b8-8bac24f373ba" xml:space="preserve">
          <source><bpt id="af834f3c-6646-4c81-930e-4528655f8a9dCapsExtId1">&lt;linkText&gt;</bpt>ECMA Standard for the Common Language Infrastructure CLI<ept id="af834f3c-6646-4c81-930e-4528655f8a9dCapsExtId1">&lt;/linkText&gt;</ept><bpt id="af834f3c-6646-4c81-930e-4528655f8a9dCapsExtId2">&lt;title&gt;</bpt><ept id="af834f3c-6646-4c81-930e-4528655f8a9dCapsExtId2">&lt;/title&gt;</ept></source>
          <target state="new"><bpt id="af834f3c-6646-4c81-930e-4528655f8a9dCapsExtId1">&lt;linkText&gt;</bpt>ECMA Standard for the Common Language Infrastructure CLI<ept id="af834f3c-6646-4c81-930e-4528655f8a9dCapsExtId1">&lt;/linkText&gt;</ept><bpt id="af834f3c-6646-4c81-930e-4528655f8a9dCapsExtId2">&lt;title&gt;</bpt><ept id="af834f3c-6646-4c81-930e-4528655f8a9dCapsExtId2">&lt;/title&gt;</ept></target>
        </trans-unit>
        <trans-unit id="43404881-b2e2-40fe-8512-4cefbf2b8410" xml:space="preserve">
          <source><bpt id="50ee8a6d-def5-4ebb-92f7-09b9f480eebfCapsExtId1">&lt;linkText&gt;</bpt>.NET Framework Design Guidelines<ept id="50ee8a6d-def5-4ebb-92f7-09b9f480eebfCapsExtId1">&lt;/linkText&gt;</ept><bpt id="50ee8a6d-def5-4ebb-92f7-09b9f480eebfCapsExtId2">&lt;title&gt;</bpt><ept id="50ee8a6d-def5-4ebb-92f7-09b9f480eebfCapsExtId2">&lt;/title&gt;</ept></source>
          <target state="new"><bpt id="50ee8a6d-def5-4ebb-92f7-09b9f480eebfCapsExtId1">&lt;linkText&gt;</bpt>.NET Framework Design Guidelines<ept id="50ee8a6d-def5-4ebb-92f7-09b9f480eebfCapsExtId1">&lt;/linkText&gt;</ept><bpt id="50ee8a6d-def5-4ebb-92f7-09b9f480eebfCapsExtId2">&lt;title&gt;</bpt><ept id="50ee8a6d-def5-4ebb-92f7-09b9f480eebfCapsExtId2">&lt;/title&gt;</ept></target>
        </trans-unit>
        <trans-unit id="9c026cfe-649b-45bf-b083-d541de8c13f1" xml:space="preserve">
          <source>
  (function () {
    var articleId = fyre.conv.load.makeArticleId(null);
    fyre.conv.load({}, [{
      el: 'livefyre-comments',
      network: "livefyre.com",
      siteId: "377988",
      articleId: articleId,
      signed: false,
      collectionMeta: {
        articleId: articleId,
        url: fyre.conv.load.makeCollectionUrl(),
      }
    }], function() {});
  }());
</source>
          <target state="new">
  (function () {
    var articleId = fyre.conv.load.makeArticleId(null);
    fyre.conv.load({}, [{
      el: 'livefyre-comments',
      network: "livefyre.com",
      siteId: "377988",
      articleId: articleId,
      signed: false,
      collectionMeta: {
        articleId: articleId,
        url: fyre.conv.load.makeCollectionUrl(),
      }
    }], function() {});
  }());
</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>