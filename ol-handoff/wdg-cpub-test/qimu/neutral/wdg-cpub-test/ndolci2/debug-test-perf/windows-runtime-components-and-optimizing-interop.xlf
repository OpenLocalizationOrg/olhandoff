<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\debug-test-perf\windows-runtime-components-and-optimizing-interop.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f5715887b5b81c8679aca6f0dcbac9f9893ff58c</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Universal Windows Platform Components and optimizing interop</source>
          <target state="new">Universal Windows Platform Components and optimizing interop</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.</source>
          <target state="new">Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Universal Windows Platform Components and optimizing interop</source>
          <target state="new">Universal Windows Platform Components and optimizing interop</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.</source>
          <target state="new">Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Best practices for interoperability with UWP Components</source>
          <target state="new">Best practices for interoperability with UWP Components</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If you are not careful, using UWP Components can have a large impact on your app performance.</source>
          <target state="new">If you are not careful, using UWP Components can have a large impact on your app performance.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>This section discusses how to get good performance when your app uses UWP Components.</source>
          <target state="new">This section discusses how to get good performance when your app uses UWP Components.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="new">Introduction</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Interoperability can have a big impact on performance and you might be using it without even realizing that you are.</source>
          <target state="new">Interoperability can have a big impact on performance and you might be using it without even realizing that you are.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>The UWP handles a lot of the interoperability for you so that you can be more productive and reuse code that was written in other languages.</source>
          <target state="new">The UWP handles a lot of the interoperability for you so that you can be more productive and reuse code that was written in other languages.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>We encourage you to take advantage of what the UWP does for you, but be aware that it can impact performance.</source>
          <target state="new">We encourage you to take advantage of what the UWP does for you, but be aware that it can impact performance.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>This section discusses things you can do to lessen the impact that interoperability has on your app's performance.</source>
          <target state="new">This section discusses things you can do to lessen the impact that interoperability has on your app's performance.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The UWP has a library of types that are accessible from any language that can write a UWP app.</source>
          <target state="new">The UWP has a library of types that are accessible from any language that can write a UWP app.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>You use the UWP types in C# or Microsoft Visual Basic the same way you use .NET objects.</source>
          <target state="new">You use the UWP types in C# or Microsoft Visual Basic the same way you use .NET objects.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>You don't need to make platform invoke method calls to access the UWP components.</source>
          <target state="new">You don't need to make platform invoke method calls to access the UWP components.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This makes writing your apps much less complex, but it is important to realize that there might be more interoperability occurring than you expect.</source>
          <target state="new">This makes writing your apps much less complex, but it is important to realize that there might be more interoperability occurring than you expect.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>If a UWP component is written in a language other than C# or Visual Basic, you cross interoperability boundaries when you use that component.</source>
          <target state="new">If a UWP component is written in a language other than C# or Visual Basic, you cross interoperability boundaries when you use that component.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Crossing interoperability boundaries can impact the performance of an app.</source>
          <target state="new">Crossing interoperability boundaries can impact the performance of an app.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>When you develop a UWP app in C# or Visual Basic, the two most common set of APIs that you use are the UWP APIs and the .NET APIs for UWP apps.</source>
          <target state="new">When you develop a UWP app in C# or Visual Basic, the two most common set of APIs that you use are the UWP APIs and the .NET APIs for UWP apps.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In general, types that are defined in the UWP are in namespaces that begin with "Windows."</source>
          <target state="new">In general, types that are defined in the UWP are in namespaces that begin with "Windows."</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>and .NET types are in namespaces that begin with "System."</source>
          <target state="new">and .NET types are in namespaces that begin with "System."</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>There are exceptions, though.</source>
          <target state="new">There are exceptions, though.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The types in .NET for UWP apps do not require interoperability when they are used.</source>
          <target state="new">The types in .NET for UWP apps do not require interoperability when they are used.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If you find that you have bad performance in an area that uses UWP, you might be able to use .NET for UWP apps instead to get better performance.</source>
          <target state="new">If you find that you have bad performance in an area that uses UWP, you might be able to use .NET for UWP apps instead to get better performance.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="new">Note</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Most of the UWP components that ship with Windows 10 are implemented in C++ so you cross interoperability boundaries when you use them from C# or Visual Basic.</source>
          <target state="new">Most of the UWP components that ship with Windows 10 are implemented in C++ so you cross interoperability boundaries when you use them from C# or Visual Basic.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>As always, make sure to measure your app to see if using UWP components affects your app's performance before you invest in making changes to your code.</source>
          <target state="new">As always, make sure to measure your app to see if using UWP components affects your app's performance before you invest in making changes to your code.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>In this topic, when we say "UWP components", we mean components that are written in a language other than C# or Visual Basic.</source>
          <target state="new">In this topic, when we say "UWP components", we mean components that are written in a language other than C# or Visual Basic.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Each time you access a property or call a method on a UWP component, an interoperability cost is incurred.</source>
          <target state="new">Each time you access a property or call a method on a UWP component, an interoperability cost is incurred.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>In fact, creating a UWP component is more costly than creating a .NET object.</source>
          <target state="new">In fact, creating a UWP component is more costly than creating a .NET object.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The reasons for this are that the UWP must execute code that transitions from your app's language to the component's language.</source>
          <target state="new">The reasons for this are that the UWP must execute code that transitions from your app's language to the component's language.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Also, if you pass data to the component, the data must be converted between managed and unmanaged types.</source>
          <target state="new">Also, if you pass data to the component, the data must be converted between managed and unmanaged types.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Using UWP Components efficiently</source>
          <target state="new">Using UWP Components efficiently</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>If you find that you need to get better performance, you can ensure that your code uses UWP components as efficiently as possible.</source>
          <target state="new">If you find that you need to get better performance, you can ensure that your code uses UWP components as efficiently as possible.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>This section discusses some tips for improving performance when you use UWP components.</source>
          <target state="new">This section discusses some tips for improving performance when you use UWP components.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>It takes a significant number of calls in a short period of time for the performance impact to be noticeable.</source>
          <target state="new">It takes a significant number of calls in a short period of time for the performance impact to be noticeable.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>A well-designed application that encapsulates calls to UWP components from business logic and other managed code should not incur huge interoperability costs.</source>
          <target state="new">A well-designed application that encapsulates calls to UWP components from business logic and other managed code should not incur huge interoperability costs.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>But if your tests indicate that using UWP components is affecting your app's performance, the tips discussed in this section help you improve performance.</source>
          <target state="new">But if your tests indicate that using UWP components is affecting your app's performance, the tips discussed in this section help you improve performance.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Consider using .NET for UWP apps</source>
          <target state="new">Consider using .NET for UWP apps</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>There are certain cases where you can accomplish a task by using either UWP or .NET for UWP apps.</source>
          <target state="new">There are certain cases where you can accomplish a task by using either UWP or .NET for UWP apps.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>It is a good idea to try to not mix .NET types and UWP types.</source>
          <target state="new">It is a good idea to try to not mix .NET types and UWP types.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Try to stay in one or the other.</source>
          <target state="new">Try to stay in one or the other.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>For example, you can parse a stream of xml by using either the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows.Data.Xml.Dom.XmlDocument<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR206173)</ept> type (a UWP type) or the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>System.Xml.XmlReader<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.xml.xmlreader.aspx)</ept> type (a .NET type).</source>
          <target state="new">For example, you can parse a stream of xml by using either the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows.Data.Xml.Dom.XmlDocument<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR206173)</ept> type (a UWP type) or the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>System.Xml.XmlReader<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.xml.xmlreader.aspx)</ept> type (a .NET type).</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Use the API that is from the same technology as the stream.</source>
          <target state="new">Use the API that is from the same technology as the stream.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>For example, if you read xml from a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>MemoryStream<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.memorystream.aspx)</ept>, use the <bpt id="p3">**</bpt>System.Xml.XmlReader<ept id="p3">**</ept> type, because both types are .NET types.</source>
          <target state="new">For example, if you read xml from a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>MemoryStream<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.memorystream.aspx)</ept>, use the <bpt id="p3">**</bpt>System.Xml.XmlReader<ept id="p3">**</ept> type, because both types are .NET types.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>If you read from a file, use the <bpt id="p1">**</bpt>Windows.Data.Xml.Dom.XmlDocument<ept id="p1">**</ept> type because the file APIs and <bpt id="p2">**</bpt>XmlDocument<ept id="p2">**</ept> are UWP components.</source>
          <target state="new">If you read from a file, use the <bpt id="p1">**</bpt>Windows.Data.Xml.Dom.XmlDocument<ept id="p1">**</ept> type because the file APIs and <bpt id="p2">**</bpt>XmlDocument<ept id="p2">**</ept> are UWP components.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Copy Window Runtime objects to .NET types</source>
          <target state="new">Copy Window Runtime objects to .NET types</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>When a UWP component returns a UWP object, it might be beneficial to copy the returned object into a .NET object.</source>
          <target state="new">When a UWP component returns a UWP object, it might be beneficial to copy the returned object into a .NET object.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Two places where this is especially important is when you're working with collections and streams.</source>
          <target state="new">Two places where this is especially important is when you're working with collections and streams.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>If you call a UWP API that returns a collection and then you save and access that collection many times, it might be beneficial to copy the collection into a .NET collection and use the .NET version from then on.</source>
          <target state="new">If you call a UWP API that returns a collection and then you save and access that collection many times, it might be beneficial to copy the collection into a .NET collection and use the .NET version from then on.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Cache the results of calls to UWP components for later use</source>
          <target state="new">Cache the results of calls to UWP components for later use</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>You might be able to get better performance by saving values into local variables instead of accessing a UWP type multiple times.</source>
          <target state="new">You might be able to get better performance by saving values into local variables instead of accessing a UWP type multiple times.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>This can be especially beneficial if you use a value inside of a loop.</source>
          <target state="new">This can be especially beneficial if you use a value inside of a loop.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Measure your app to see if using local variables improves your app's performance.</source>
          <target state="new">Measure your app to see if using local variables improves your app's performance.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>Using cached values can increase your app's speed because it will spend less time on interoperability.</source>
          <target state="new">Using cached values can increase your app's speed because it will spend less time on interoperability.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Combine calls to UWP components</source>
          <target state="new">Combine calls to UWP components</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Try to complete tasks with the fewest number of calls to UWP objects as possible.</source>
          <target state="new">Try to complete tasks with the fewest number of calls to UWP objects as possible.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>For example, it is usually better to read a large amount of data from a stream than to read small amounts at a time.</source>
          <target state="new">For example, it is usually better to read a large amount of data from a stream than to read small amounts at a time.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Use APIs that bundle work in as few calls as possible instead of APIs that do less work and require more calls.</source>
          <target state="new">Use APIs that bundle work in as few calls as possible instead of APIs that do less work and require more calls.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For example, prefer to create an object by calling constructors that initialize multiple properties instead of calling the default constructor and assigning properties one at a time.</source>
          <target state="new">For example, prefer to create an object by calling constructors that initialize multiple properties instead of calling the default constructor and assigning properties one at a time.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Building a UWP components</source>
          <target state="new">Building a UWP components</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>If you write a UWP Component that can be used by apps written in C++ or JavaScript, make sure that your component is designed for good performance.</source>
          <target state="new">If you write a UWP Component that can be used by apps written in C++ or JavaScript, make sure that your component is designed for good performance.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>All the suggestions for getting good performance in apps apply to getting good performance in components.</source>
          <target state="new">All the suggestions for getting good performance in apps apply to getting good performance in components.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Measure your component to find out which APIs have high traffic patterns and for those areas, consider providing APIs that enable your users to do work with few calls.</source>
          <target state="new">Measure your component to find out which APIs have high traffic patterns and for those areas, consider providing APIs that enable your users to do work with few calls.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Keep your app fast when you use interop in managed code</source>
          <target state="new">Keep your app fast when you use interop in managed code</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The UWP makes it easy to interoperate between native and managed code, but if you're not careful it can incur performance costs.</source>
          <target state="new">The UWP makes it easy to interoperate between native and managed code, but if you're not careful it can incur performance costs.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Here we show you how to get good performance when you use interop in your managed UWP apps.</source>
          <target state="new">Here we show you how to get good performance when you use interop in your managed UWP apps.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The UWP allows developers to write apps using XAML with their language of choice thanks to the projections of the UWP APIs available in each language.</source>
          <target state="new">The UWP allows developers to write apps using XAML with their language of choice thanks to the projections of the UWP APIs available in each language.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>When writing an app in C# or Visual Basic, this convenience comes at an interop cost because the UWP APIs are usually implemented in native code, and any UWP invocation from C# or Visual Basic requires that the CLR transition from a managed to a native stack frame and marshal function parameters to representations accessible by native code.</source>
          <target state="new">When writing an app in C# or Visual Basic, this convenience comes at an interop cost because the UWP APIs are usually implemented in native code, and any UWP invocation from C# or Visual Basic requires that the CLR transition from a managed to a native stack frame and marshal function parameters to representations accessible by native code.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This overhead is negligible for most apps.</source>
          <target state="new">This overhead is negligible for most apps.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>But when you make many calls (hundreds of thousands, to millions) to UWP APIs in the critical path of an app, this cost can become noticeable.</source>
          <target state="new">But when you make many calls (hundreds of thousands, to millions) to UWP APIs in the critical path of an app, this cost can become noticeable.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>In general you want to ensure that the time spent in transition between languages is small relative to the execution of the rest of your code.</source>
          <target state="new">In general you want to ensure that the time spent in transition between languages is small relative to the execution of the rest of your code.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>This is illustrated by the following diagram.</source>
          <target state="new">This is illustrated by the following diagram.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Interop transitions should not dominate the program execution time.</source>
          <target state="new">Interop transitions should not dominate the program execution time.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The types listed at <bpt id="p1">[</bpt><bpt id="p2">**</bpt>.NET for Windows apps<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/br230232.aspx)</ept> don't incur this interop cost when used from C# or Visual Basic.</source>
          <target state="new">The types listed at <bpt id="p1">[</bpt><bpt id="p2">**</bpt>.NET for Windows apps<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/br230232.aspx)</ept> don't incur this interop cost when used from C# or Visual Basic.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, you can assume that types in namespaces which begin with “Windows.”</source>
          <target state="new">As a rule of thumb, you can assume that types in namespaces which begin with “Windows.”</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>are part of the UWP, and types in namespaces which begin with “System.”</source>
          <target state="new">are part of the UWP, and types in namespaces which begin with “System.”</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>are .NET types.</source>
          <target state="new">are .NET types.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Keep in mind that even simple usage of UWP types such as allocation or property access incurs an interop cost.</source>
          <target state="new">Keep in mind that even simple usage of UWP types such as allocation or property access incurs an interop cost.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>You should measure your app and determine if interop is taking up a large portion of your apps execution time before optimizing your interop costs.</source>
          <target state="new">You should measure your app and determine if interop is taking up a large portion of your apps execution time before optimizing your interop costs.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>When analyzing your app’s performance with Visual Studio, you can easily get an upper bound on your interop costs by using the <bpt id="p1">**</bpt>Functions<ept id="p1">**</ept> view and looking at inclusive time spent in methods which call into the UWP.</source>
          <target state="new">When analyzing your app’s performance with Visual Studio, you can easily get an upper bound on your interop costs by using the <bpt id="p1">**</bpt>Functions<ept id="p1">**</ept> view and looking at inclusive time spent in methods which call into the UWP.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>If your app is slow because of interop overhead, you can improve its performance by reducing calls to UWP APIs on hot code paths.</source>
          <target state="new">If your app is slow because of interop overhead, you can improve its performance by reducing calls to UWP APIs on hot code paths.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>For example, a game engine that is doing tons of physics calculations by constantly querying the position and dimensions of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElements<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR208911)</ept> can save a lot of time by storing the necessary info from <bpt id="p3">**</bpt>UIElements<ept id="p3">**</ept> to local variables, doing calculations on these cached values, and assigning the end result back to the <bpt id="p4">**</bpt>UIElements<ept id="p4">**</ept> after the calculations are done.</source>
          <target state="new">For example, a game engine that is doing tons of physics calculations by constantly querying the position and dimensions of <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElements<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR208911)</ept> can save a lot of time by storing the necessary info from <bpt id="p3">**</bpt>UIElements<ept id="p3">**</ept> to local variables, doing calculations on these cached values, and assigning the end result back to the <bpt id="p4">**</bpt>UIElements<ept id="p4">**</ept> after the calculations are done.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Another example: if a collection is heavily accessed by C# or Visual Basic code, then it is more efficient to use a collection from the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>System.Collections<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.collections.aspx)</ept> namespace, rather than a collection from the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Windows.Foundation.Collections<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR206657)</ept> namespace.</source>
          <target state="new">Another example: if a collection is heavily accessed by C# or Visual Basic code, then it is more efficient to use a collection from the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>System.Collections<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.collections.aspx)</ept> namespace, rather than a collection from the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Windows.Foundation.Collections<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/BR206657)</ept> namespace.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>You may also consider combining calls to UWP components; one example where this is possible is by using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows.Storage.BulkAccess<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR207676)</ept> APIs.</source>
          <target state="new">You may also consider combining calls to UWP components; one example where this is possible is by using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Windows.Storage.BulkAccess<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/BR207676)</ept> APIs.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Building a UWP component</source>
          <target state="new">Building a UWP component</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>If you write a UWP component for use in apps written in C++ or JavaScript, make sure that your component is designed for good performance.</source>
          <target state="new">If you write a UWP component for use in apps written in C++ or JavaScript, make sure that your component is designed for good performance.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Your API surface defines your interop boundary and defines the degree to which your users will have to think about the guidance in this topic.</source>
          <target state="new">Your API surface defines your interop boundary and defines the degree to which your users will have to think about the guidance in this topic.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>If you are distributing your components to other parties then this becomes especially important.</source>
          <target state="new">If you are distributing your components to other parties then this becomes especially important.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>All of the suggestions for getting good performance in apps apply to getting good performance in components.</source>
          <target state="new">All of the suggestions for getting good performance in apps apply to getting good performance in components.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>Measure your component to find out which APIs have high traffic patterns, and for those areas, consider providing APIs that enable your users to do work with few calls.</source>
          <target state="new">Measure your component to find out which APIs have high traffic patterns, and for those areas, consider providing APIs that enable your users to do work with few calls.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Significant effort was put into designing the UWP to allow apps to use it without requiring frequent crossing of the interop boundary.</source>
          <target state="new">Significant effort was put into designing the UWP to allow apps to use it without requiring frequent crossing of the interop boundary.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>