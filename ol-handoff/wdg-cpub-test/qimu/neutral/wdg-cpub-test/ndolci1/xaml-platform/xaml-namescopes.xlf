<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci1\xaml-platform\xaml-namescopes.md</xliffext:olfilepath>
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">67beb04cc87765a4c2edb249a61ba300cd9a7544</xliffext:olfilehash>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-e58fd48" tool-company="Microsoft" />
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>A XAML namescope stores relationships between the XAML-defined names of objects and their instance equivalents.</source>
          <target state="new">A XAML namescope stores relationships between the XAML-defined names of objects and their instance equivalents.</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This concept is similar to the wider meaning of the term namescope in other programming languages and technologies.</source>
          <target state="new">This concept is similar to the wider meaning of the term namescope in other programming languages and technologies.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>XAML namescopes</source>
          <target state="new">XAML namescopes</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>XAML namescopes</source>
          <target state="new">XAML namescopes</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>Updated for UWP apps on Windows 10.</source>
          <target state="new">Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept></target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>A <bpt id="p1">*</bpt>XAML namescope<ept id="p1">*</ept> stores relationships between the XAML-defined names of objects and their instance equivalents.</source>
          <target state="new">A <bpt id="p1">*</bpt>XAML namescope<ept id="p1">*</ept> stores relationships between the XAML-defined names of objects and their instance equivalents.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>This concept is similar to the wider meaning of the term <bpt id="p1">*</bpt>namescope<ept id="p1">*</ept> in other programming languages and technologies.</source>
          <target state="new">This concept is similar to the wider meaning of the term <bpt id="p1">*</bpt>namescope<ept id="p1">*</ept> in other programming languages and technologies.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>How XAML namescopes are defined</source>
          <target state="new">How XAML namescopes are defined</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Names in XAML namescopes enable user code to reference the objects that were initially declared in XAML.</source>
          <target state="new">Names in XAML namescopes enable user code to reference the objects that were initially declared in XAML.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations.</source>
          <target state="new">The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.</source>
          <target state="new">These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated <bpt id="p1">**</bpt>InitializeComponent<ept id="p1">**</ept> method in the partial class templates.</source>
          <target state="new">The most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated <bpt id="p1">**</bpt>InitializeComponent<ept id="p1">**</ept> method in the partial class templates.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>You can also use the utility method <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> yourself at run time to return a reference to objects that were defined with a name in the XAML markup.</source>
          <target state="new">You can also use the utility method <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> yourself at run time to return a reference to objects that were defined with a name in the XAML markup.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>More about build actions and XAML</source>
          <target state="new">More about build actions and XAML</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>What happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together.</source>
          <target state="new">What happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Each object element with a <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> or <bpt id="p2">[</bpt>x:Name attribute<ept id="p2">](x-name-attribute.md)</ept> defined in the markup generates an internal field with a name that matches the XAML name.</source>
          <target state="new">Each object element with a <bpt id="p1">**</bpt>Name<ept id="p1">**</ept> or <bpt id="p2">[</bpt>x:Name attribute<ept id="p2">](x-name-attribute.md)</ept> defined in the markup generates an internal field with a name that matches the XAML name.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>This field is initially empty.</source>
          <target state="new">This field is initially empty.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Then the class generates an <bpt id="p1">**</bpt>InitializeComponent<ept id="p1">**</ept> method that is called only after all the XAML is loaded.</source>
          <target state="new">Then the class generates an <bpt id="p1">**</bpt>InitializeComponent<ept id="p1">**</ept> method that is called only after all the XAML is loaded.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Within the <bpt id="p1">**</bpt>InitializeComponent<ept id="p1">**</ept> logic, each internal field is then populated with the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>FindName<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> return value for the equivalent name string.</source>
          <target state="new">Within the <bpt id="p1">**</bpt>InitializeComponent<ept id="p1">**</ept> logic, each internal field is then populated with the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>FindName<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> return value for the equivalent name string.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>You can observe this infrastructure for yourself by looking at the ".g" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation.</source>
          <target state="new">You can observe this infrastructure for yourself by looking at the ".g" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You can also see the fields and <bpt id="p1">**</bpt>InitializeComponent<ept id="p1">**</ept> method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.</source>
          <target state="new">You can also see the fields and <bpt id="p1">**</bpt>InitializeComponent<ept id="p1">**</ept> method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Specifically for Visual C++ component extensions (C++/CX) apps, a backing field for an <bpt id="p2">**</bpt>x:Name<ept id="p2">**</ept> reference is not created for the root element of a XAML file.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Specifically for Visual C++ component extensions (C++/CX) apps, a backing field for an <bpt id="p2">**</bpt>x:Name<ept id="p2">**</ept> reference is not created for the root element of a XAML file.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal.</source>
          <target state="new">If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>For example you can call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> for a known named child element and then call <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Parent<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208739)</ept>.</source>
          <target state="new">For example you can call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> for a known named child element and then call <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Parent<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208739)</ept>.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Creating objects at run time with XamlReader.Load</source>
          <target state="new">Creating objects at run time with XamlReader.Load</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>XAML can be also be used as the string input for the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XamlReader.Load<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept> method, which acts analogously to the initial XAML source parse operation.</source>
          <target state="new">XAML can be also be used as the string input for the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XamlReader.Load<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept> method, which acts analogously to the initial XAML source parse operation.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>XamlReader.Load<ept id="p1">**</ept> creates a new disconnected tree of objects at run time.</source>
          <target state="new"><bpt id="p1">**</bpt>XamlReader.Load<ept id="p1">**</ept> creates a new disconnected tree of objects at run time.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The disconnected tree can then be attached to some point on the main object tree.</source>
          <target state="new">The disconnected tree can then be attached to some point on the main object tree.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>You must explicitly connect your created object tree, either by adding it to a content property collection such as <bpt id="p1">**</bpt>Children<ept id="p1">**</ept>, or by setting some other property that takes an object value (for example, loading a new <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ImageBrush<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br210101)</ept> for a <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Fill<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br243378)</ept> property value).</source>
          <target state="new">You must explicitly connect your created object tree, either by adding it to a content property collection such as <bpt id="p1">**</bpt>Children<ept id="p1">**</ept>, or by setting some other property that takes an object value (for example, loading a new <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ImageBrush<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br210101)</ept> for a <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Fill<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br243378)</ept> property value).</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>XAML namescope implications of XamlReader.Load</source>
          <target state="new">XAML namescope implications of XamlReader.Load</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The preliminary XAML namescope defined by the new object tree created by <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XamlReader.Load<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept> evaluates any defined names in the provided XAML for uniqueness.</source>
          <target state="new">The preliminary XAML namescope defined by the new object tree created by <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XamlReader.Load<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept> evaluates any defined names in the provided XAML for uniqueness.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>If names in the provided XAML are not internally unique at this point, <bpt id="p1">**</bpt>XamlReader.Load<ept id="p1">**</ept> throws an exception.</source>
          <target state="new">If names in the provided XAML are not internally unique at this point, <bpt id="p1">**</bpt>XamlReader.Load<ept id="p1">**</ept> throws an exception.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree.</source>
          <target state="new">The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it.</source>
          <target state="new">After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The divisions occur at the connection points between objects, where you set some property to be the value returned from a <bpt id="p1">**</bpt>XamlReader.Load<ept id="p1">**</ept> call.</source>
          <target state="new">The divisions occur at the connection points between objects, where you set some property to be the value returned from a <bpt id="p1">**</bpt>XamlReader.Load<ept id="p1">**</ept> call.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>The complication of having discrete and disconnected XAML namescopes is that calls to the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> method as well as direct managed object references no longer operate against a unified XAML namescope.</source>
          <target state="new">The complication of having discrete and disconnected XAML namescopes is that calls to the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> method as well as direct managed object references no longer operate against a unified XAML namescope.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Instead, the particular object that <bpt id="p1">**</bpt>FindName<ept id="p1">**</ept> is called on implies the scope, with the scope being the XAML namescope that the calling object is within.</source>
          <target state="new">Instead, the particular object that <bpt id="p1">**</bpt>FindName<ept id="p1">**</ept> is called on implies the scope, with the scope being the XAML namescope that the calling object is within.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>In the direct managed object reference case, the scope is implied by the class where the code exists.</source>
          <target state="new">In the direct managed object reference case, the scope is implied by the class where the code exists.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Typically, the code-behind for run-time interaction of a "page" of app content exists in the partial class that backs the root "page", and therefore the XAML namescope is the root XAML namescope.</source>
          <target state="new">Typically, the code-behind for run-time interaction of a "page" of app content exists in the partial class that backs the root "page", and therefore the XAML namescope is the root XAML namescope.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>If you call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by <bpt id="p3">[</bpt><bpt id="p4">**</bpt>XamlReader.Load<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept>.</source>
          <target state="new">If you call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by <bpt id="p3">[</bpt><bpt id="p4">**</bpt>XamlReader.Load<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept>.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Conversely, if you call <bpt id="p1">**</bpt>FindName<ept id="p1">**</ept> from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.</source>
          <target state="new">Conversely, if you call <bpt id="p1">**</bpt>FindName<ept id="p1">**</ept> from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>This discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> call.</source>
          <target state="new">This discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> call.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>To get references to objects that are defined in a different XAML namescope, you can use several techniques:</source>
          <target state="new">To get references to objects that are defined in a different XAML namescope, you can use several techniques:</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Walk the entire tree in discrete steps with <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Parent<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208739)</ept> and/or collection properties that are known to exist in your object tree structure (such as the collection returned by <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Panel.Children<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>).</source>
          <target state="new">Walk the entire tree in discrete steps with <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Parent<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208739)</ept> and/or collection properties that are known to exist in your object tree structure (such as the collection returned by <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Panel.Children<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227514)</ept>).</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed.</source>
          <target state="new">If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call <ph id="ph1">`Window.Current.Content`</ph>.</source>
          <target state="new">You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call <ph id="ph1">`Window.Current.Content`</ph>.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>You can then cast to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FrameworkElement<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept> and call <bpt id="p3">[</bpt><bpt id="p4">**</bpt>FindName<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> from this scope.</source>
          <target state="new">You can then cast to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FrameworkElement<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept> and call <bpt id="p3">[</bpt><bpt id="p4">**</bpt>FindName<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> from this scope.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XamlReader.Load<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept> and then added to the main object tree.</source>
          <target state="new">If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XamlReader.Load<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228048)</ept> and then added to the main object tree.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>This object is now a valid object for calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> within the discrete XAML namescope.</source>
          <target state="new">This object is now a valid object for calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> within the discrete XAML namescope.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>You could keep this object available as a global variable or otherwise pass it by using method parameters.</source>
          <target state="new">You could keep this object available as a global variable or otherwise pass it by using method parameters.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>You can avoid names and XAML namescope considerations entirely by examining the visual tree.</source>
          <target state="new">You can avoid names and XAML namescope considerations entirely by examining the visual tree.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt><bpt id="p2">**</bpt>VisualTreeHelper<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br243038)</ept> API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.</source>
          <target state="new">The <bpt id="p1">[</bpt><bpt id="p2">**</bpt>VisualTreeHelper<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br243038)</ept> API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>XAML namescopes in templates</source>
          <target state="new">XAML namescopes in templates</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Templates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level.</source>
          <target state="new">Templates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>That same template might be used multiple times in a page.</source>
          <target state="new">That same template might be used multiple times in a page.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied.</source>
          <target state="new">For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Consider this example:</source>
          <target state="new">Consider this example:</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Here, the same template is applied to two different controls.</source>
          <target state="new">Here, the same template is applied to two different controls.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>If templates did not have discrete XAML namescopes, the "MyTextBlock" name used in the template would cause a name collision.</source>
          <target state="new">If templates did not have discrete XAML namescopes, the "MyTextBlock" name used in the template would cause a name collision.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</source>
          <target state="new">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>However, the root XAML namescope does not contain the name from either template.</source>
          <target state="new">However, the root XAML namescope does not contain the name from either template.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Because of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique.</source>
          <target state="new">Because of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Rather than calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> on some object in the object tree, you first obtain the object that has the template applied, and then call <bpt id="p3">[</bpt><bpt id="p4">**</bpt>GetTemplateChild<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209416)</ept>.</source>
          <target state="new">Rather than calling <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FindName<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208715)</ept> on some object in the object tree, you first obtain the object that has the template applied, and then call <bpt id="p3">[</bpt><bpt id="p4">**</bpt>GetTemplateChild<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209416)</ept>.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <bpt id="p1">**</bpt>GetTemplateChild<ept id="p1">**</ept> method from your control implementation code.</source>
          <target state="new">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <bpt id="p1">**</bpt>GetTemplateChild<ept id="p1">**</ept> method from your control implementation code.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>GetTemplateChild<ept id="p1">**</ept> method is protected, so only the control author has access to it.</source>
          <target state="new">The <bpt id="p1">**</bpt>GetTemplateChild<ept id="p1">**</ept> method is protected, so only the control author has access to it.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class.</source>
          <target state="new">Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.</source>
          <target state="new">This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>XAML overview</source>
          <target state="new">XAML overview</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>x:Name attribute</source>
          <target state="new">x:Name attribute</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Quickstart: Control templates</source>
          <target state="new">Quickstart: Control templates</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>XamlReader.Load</source>
          <target state="new">XamlReader.Load</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>FindName</source>
          <target state="new">FindName</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>