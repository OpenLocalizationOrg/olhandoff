<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="zh-cn" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">dfb615b990e140b99a70c4978f7d660fc6d77178</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: 34C00F9F-2196-46A3-A32F-0067AB48291B</source>
          <target xml:space="preserve">ms.assetid: 34C00F9F-2196-46A3-A32F-0067AB48291B</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">description: This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the task class defined in the concurrency namespace in ppltasks.h.</source>
          <target xml:space="preserve">description: This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the task class defined in the concurrency namespace in ppltasks.h.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">title: Asynchronous programming in C++</source>
          <target xml:space="preserve">title: Asynchronous programming in C++</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">Asynchronous programming in C++</source>
          <target xml:space="preserve">Asynchronous programming in C++</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="106">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">** Important APIs **</source>
          <target xml:space="preserve">** Important APIs **</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source xml:space="preserve">[task class]</source>
          <target xml:space="preserve">[task class]</target>
        </segment>
      </unit>
      <unit id="109">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">[<pc dataRefEnd="id2" dataRefStart="id1" id="p1">concurrency namespace</pc>][concurrencyNamespace]</source>
          <target xml:space="preserve">[<pc dataRefEnd="id2" dataRefStart="id1" id="p1">concurrency namespace</pc>][concurrencyNamespace]</target>
        </segment>
      </unit>
      <unit id="110">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">[<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncOperation</pc>][IAsyncOperation]</source>
          <target xml:space="preserve">[<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncOperation</pc>][IAsyncOperation]</target>
        </segment>
      </unit>
      <unit id="111">
        <originalData>
          <data id="id1">`task`</data>
          <data id="id2">`concurrency`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the <ph dataRef="id1" id="ph1" /> class that's defined in the <ph dataRef="id2" id="ph2" /> namespace in ppltasks.h.</source>
          <target xml:space="preserve">This article describes the recommended way to consume asynchronous methods in Visual C++ component extensions (C++/CX) by using the <ph dataRef="id1" id="ph1" /> class that's defined in the <ph dataRef="id2" id="ph2" /> namespace in ppltasks.h.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">Universal Windows Platform (UWP) asynchronous types</source>
          <target xml:space="preserve">Universal Windows Platform (UWP) asynchronous types</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">The Universal Windows Platform (UWP) features a well-defined model for calling asynchronous methods and provides the types that you need to consume such methods.</source>
          <target xml:space="preserve">The Universal Windows Platform (UWP) features a well-defined model for calling asynchronous methods and provides the types that you need to consume such methods.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">If you are not familiar with the UWP asynchronous model, read [Asynchronous Programming][AsyncProgramming] before you read the rest of this article.</source>
          <target xml:space="preserve">If you are not familiar with the UWP asynchronous model, read [Asynchronous Programming][AsyncProgramming] before you read the rest of this article.</target>
        </segment>
      </unit>
      <unit id="115">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">`&lt;ppltasks.h&gt;`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Although you can consume the asynchronous UWP APIs directly in C++, the preferred approach is to use the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task class</pc>][task-class] and its related types and functions, which are contained in the [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">concurrency</pc>][concurrencyNamespace] namespace and defined in <ph dataRef="id5" id="ph1" />.</source>
          <target xml:space="preserve">Although you can consume the asynchronous UWP APIs directly in C++, the preferred approach is to use the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task class</pc>][task-class] and its related types and functions, which are contained in the [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">concurrency</pc>][concurrencyNamespace] namespace and defined in <ph dataRef="id5" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="116">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">concurrency::task</pc> is a general-purpose type, but when the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">/ZW</pc> compiler switch—which is required for Universal Windows Platform (UWP) apps and components—is used, the task class encapsulates the UWP asynchronous types so that it's easier to:</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">concurrency::task</pc> is a general-purpose type, but when the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">/ZW</pc> compiler switch—which is required for Universal Windows Platform (UWP) apps and components—is used, the task class encapsulates the UWP asynchronous types so that it's easier to:</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">chain multiple asynchronous and synchronous operations together</source>
          <target xml:space="preserve">chain multiple asynchronous and synchronous operations together</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">handle exceptions in task chains</source>
          <target xml:space="preserve">handle exceptions in task chains</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">perform cancellation in task chains</source>
          <target xml:space="preserve">perform cancellation in task chains</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">ensure that individual tasks run in the appropriate thread context or apartment</source>
          <target xml:space="preserve">ensure that individual tasks run in the appropriate thread context or apartment</target>
        </segment>
      </unit>
      <unit id="121">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This article provides basic guidance about how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> class with the UWP asynchronous APIs.</source>
          <target xml:space="preserve">This article provides basic guidance about how to use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> class with the UWP asynchronous APIs.</target>
        </segment>
      </unit>
      <unit id="122">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more complete documentation about <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> and its related methods including [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">create\_task</pc>][createTask], see [Task Parallelism (Concurrency Runtime)][taskParallelism].</source>
          <target xml:space="preserve">For more complete documentation about <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> and its related methods including [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">create\_task</pc>][createTask], see [Task Parallelism (Concurrency Runtime)][taskParallelism].</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">For more information about how to create asynchronous public methods for consumption by JavaScript or other UWP-compatible languages, see [Creating Asynchronous Operations in C++ for Windows Runtime apps][createAsyncCpp].</source>
          <target xml:space="preserve">For more information about how to create asynchronous public methods for consumption by JavaScript or other UWP-compatible languages, see [Creating Asynchronous Operations in C++ for Windows Runtime apps][createAsyncCpp].</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">Consuming an async operation by using a task</source>
          <target xml:space="preserve">Consuming an async operation by using a task</target>
        </segment>
      </unit>
      <unit id="125">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The following example shows how to use the task class to consume an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> method that returns an [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperation</pc>][IAsyncOperation] interface and whose operation produces a value.</source>
          <target xml:space="preserve">The following example shows how to use the task class to consume an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">async</pc> method that returns an [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperation</pc>][IAsyncOperation] interface and whose operation produces a value.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source xml:space="preserve">Here are the basic steps:</source>
          <target xml:space="preserve">Here are the basic steps:</target>
        </segment>
      </unit>
      <unit id="127">
        <originalData>
          <data id="id1">`create_task`</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Call the <ph dataRef="id1" id="ph1" /> method and pass it the <pc dataRefEnd="id3" dataRefStart="id2" id="p1">IAsyncOperation^</pc> object.</source>
          <target xml:space="preserve">Call the <ph dataRef="id1" id="ph1" /> method and pass it the <pc dataRefEnd="id3" dataRefStart="id2" id="p1">IAsyncOperation^</pc> object.</target>
        </segment>
      </unit>
      <unit id="128">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Call the member function [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::then</pc>][taskThen] on the task and supply a lambda that will be invoked when the asynchronous operation completes.</source>
          <target xml:space="preserve">Call the member function [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::then</pc>][taskThen] on the task and supply a lambda that will be invoked when the asynchronous operation completes.</target>
        </segment>
      </unit>
      <unit id="129">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">*</data>
          <data id="id4">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The task that's created and returned by the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::then</pc>][taskThen] function is known as a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">continuation</pc>.</source>
          <target xml:space="preserve">The task that's created and returned by the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::then</pc>][taskThen] function is known as a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">continuation</pc>.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source xml:space="preserve">The input argument (in this case) to the user-provided lambda is the result that the task operation produces when it completes.</source>
          <target xml:space="preserve">The input argument (in this case) to the user-provided lambda is the result that the task operation produces when it completes.</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br206600)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">It's the same value that would be retrieved by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperation::GetResults</pc></pc> if you were using the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">IAsyncOperation</pc> interface directly.</source>
          <target xml:space="preserve">It's the same value that would be retrieved by calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperation::GetResults</pc></pc> if you were using the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">IAsyncOperation</pc> interface directly.</target>
        </segment>
      </unit>
      <unit id="132">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::then</pc>][taskThen] method returns immediately, and its delegate doesn't run until the asynchronous work completes successfully.</source>
          <target xml:space="preserve">The [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::then</pc>][taskThen] method returns immediately, and its delegate doesn't run until the asynchronous work completes successfully.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">In this example, if the asynchronous operation causes an exception to be thrown, or ends in the canceled state as a result of a cancellation request, the continuation will never execute.</source>
          <target xml:space="preserve">In this example, if the asynchronous operation causes an exception to be thrown, or ends in the canceled state as a result of a cancellation request, the continuation will never execute.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">Later, we’ll describe how to write continuations that execute even if the previous task was cancelled or failed.</source>
          <target xml:space="preserve">Later, we’ll describe how to write continuations that execute even if the previous task was cancelled or failed.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">Although you declare the task variable on the local stack, it manages its lifetime so that it is not deleted until all of its operations complete and all references to it go out of scope, even if the method returns before the operations complete.</source>
          <target xml:space="preserve">Although you declare the task variable on the local stack, it manages its lifetime so that it is not deleted until all of its operations complete and all references to it go out of scope, even if the method returns before the operations complete.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source xml:space="preserve">Creating a chain of tasks</source>
          <target xml:space="preserve">Creating a chain of tasks</target>
        </segment>
      </unit>
      <unit id="137">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In asynchronous programming, it's common to define a sequence of operations, also known as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task chains</pc>, in which each continuation executes only when the previous one completes.</source>
          <target xml:space="preserve">In asynchronous programming, it's common to define a sequence of operations, also known as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task chains</pc>, in which each continuation executes only when the previous one completes.</target>
        </segment>
      </unit>
      <unit id="138">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In some cases, the previous (or <pc dataRefEnd="id2" dataRefStart="id1" id="p1">antecedent</pc>) task produces a value that the continuation accepts as input.</source>
          <target xml:space="preserve">In some cases, the previous (or <pc dataRefEnd="id2" dataRefStart="id1" id="p1">antecedent</pc>) task produces a value that the continuation accepts as input.</target>
        </segment>
      </unit>
      <unit id="139">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">&lt;T&gt;</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">By using the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::then</pc>][taskThen] method, you can create task chains in an intuitive and straightforward manner; the method returns a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task<ph dataRef="id5" id="ph1" /></pc> where <pc dataRefEnd="id7" dataRefStart="id6" id="p3">T</pc> is the return type of the lambda function.</source>
          <target xml:space="preserve">By using the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::then</pc>][taskThen] method, you can create task chains in an intuitive and straightforward manner; the method returns a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task<ph dataRef="id5" id="ph1" /></pc> where <pc dataRefEnd="id7" dataRefStart="id6" id="p3">T</pc> is the return type of the lambda function.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">`myTask.then(…).then(…).then(…);`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can compose multiple continuations into a task chain: <ph dataRef="id1" id="ph1" /></source>
          <target xml:space="preserve">You can compose multiple continuations into a task chain: <ph dataRef="id1" id="ph1" /></target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">Task chains are especially useful when a continuation creates a new asynchronous operation; such a task is known as an asynchronous task.</source>
          <target xml:space="preserve">Task chains are especially useful when a continuation creates a new asynchronous operation; such a task is known as an asynchronous task.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source xml:space="preserve">The following example illustrates a task chain that has two continuations.</source>
          <target xml:space="preserve">The following example illustrates a task chain that has two continuations.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">The initial task acquires the handle to an existing file, and when that operation completes, the first continuation starts up a new asynchronous operation to delete the file.</source>
          <target xml:space="preserve">The initial task acquires the handle to an existing file, and when that operation completes, the first continuation starts up a new asynchronous operation to delete the file.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">When that operation completes, the second continuation runs, and outputs a confirmation message.</source>
          <target xml:space="preserve">When that operation completes, the second continuation runs, and outputs a confirmation message.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source xml:space="preserve">The previous example illustrates four important points:</source>
          <target xml:space="preserve">The previous example illustrates four important points:</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">&lt;void&gt;</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The first continuation converts the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncAction^</pc>][IAsyncAction] object to a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task<ph dataRef="id5" id="ph1" /></pc> and returns the <pc dataRefEnd="id7" dataRefStart="id6" id="p3">task</pc>.</source>
          <target xml:space="preserve">The first continuation converts the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncAction^</pc>][IAsyncAction] object to a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task<ph dataRef="id5" id="ph1" /></pc> and returns the <pc dataRefEnd="id7" dataRefStart="id6" id="p3">task</pc>.</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">&lt;void&gt;</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The second continuation performs no error handling, and therefore takes <pc dataRefEnd="id2" dataRefStart="id1" id="p1">void</pc> and not <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task<ph dataRef="id5" id="ph1" /></pc> as input.</source>
          <target xml:space="preserve">The second continuation performs no error handling, and therefore takes <pc dataRefEnd="id2" dataRefStart="id1" id="p1">void</pc> and not <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task<ph dataRef="id5" id="ph1" /></pc> as input.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source xml:space="preserve">It is a value-based continuation.</source>
          <target xml:space="preserve">It is a value-based continuation.</target>
        </segment>
      </unit>
      <unit id="149">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The second continuation doesn't execute until the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeleteAsync</pc>][deleteAsync] operation completes.</source>
          <target xml:space="preserve">The second continuation doesn't execute until the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeleteAsync</pc>][deleteAsync] operation completes.</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Because the second continuation is value-based, if the operation that was started by the call to [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeleteAsync</pc>][deleteAsync] throws an exception, the second continuation doesn't execute at all.</source>
          <target xml:space="preserve">Because the second continuation is value-based, if the operation that was started by the call to [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">DeleteAsync</pc>][deleteAsync] throws an exception, the second continuation doesn't execute at all.</target>
        </segment>
      </unit>
      <unit id="151">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Creating a task chain is just one of the ways to use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task</pc> class to compose asynchronous operations.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Creating a task chain is just one of the ways to use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task</pc> class to compose asynchronous operations.</target>
        </segment>
      </unit>
      <unit id="152">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can also compose operations by using join and choice operators <pc dataRefEnd="id2" dataRefStart="id1" id="p1">&amp;&amp;</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">||</pc>.</source>
          <target xml:space="preserve">You can also compose operations by using join and choice operators <pc dataRefEnd="id2" dataRefStart="id1" id="p1">&amp;&amp;</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">||</pc>.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source xml:space="preserve">For more information, see [Task Parallelism (Concurrency Runtime)][taskParallelism].</source>
          <target xml:space="preserve">For more information, see [Task Parallelism (Concurrency Runtime)][taskParallelism].</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">Lambda function return types and task return types</source>
          <target xml:space="preserve">Lambda function return types and task return types</target>
        </segment>
      </unit>
      <unit id="155">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In a task continuation, the return type of the lambda function is wrapped in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> object.</source>
          <target xml:space="preserve">In a task continuation, the return type of the lambda function is wrapped in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task</pc> object.</target>
        </segment>
      </unit>
      <unit id="156">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">&lt;double&gt;</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If the lambda returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">double</pc>, then the type of the continuation task is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task<ph dataRef="id5" id="ph1" /></pc>.</source>
          <target xml:space="preserve">If the lambda returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">double</pc>, then the type of the continuation task is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task<ph dataRef="id5" id="ph1" /></pc>.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source xml:space="preserve">However, the task object is designed so that it doesn't produce needlessly nested return types.</source>
          <target xml:space="preserve">However, the task object is designed so that it doesn't produce needlessly nested return types.</target>
        </segment>
      </unit>
      <unit id="158">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If a lambda returns an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncOperation&lt;SyndicationFeed^&gt;^</pc>, the continuation returns a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task&lt;SyndicationFeed^&gt;</pc>, not a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">task&lt;task&lt;SyndicationFeed^&gt;&gt;</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">task&lt;IAsyncOperation&lt;SyndicationFeed^&gt;^&gt;^</pc>.</source>
          <target xml:space="preserve">If a lambda returns an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncOperation&lt;SyndicationFeed^&gt;^</pc>, the continuation returns a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">task&lt;SyndicationFeed^&gt;</pc>, not a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">task&lt;task&lt;SyndicationFeed^&gt;&gt;</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">task&lt;IAsyncOperation&lt;SyndicationFeed^&gt;^&gt;^</pc>.</target>
        </segment>
      </unit>
      <unit id="159">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This process is known as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">asynchronous unwrapping</pc> and it also ensures that the asynchronous operation inside the continuation completes before the next continuation is invoked.</source>
          <target xml:space="preserve">This process is known as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">asynchronous unwrapping</pc> and it also ensures that the asynchronous operation inside the continuation completes before the next continuation is invoked.</target>
        </segment>
      </unit>
      <unit id="160">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">&lt;void&gt;</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In the previous example, notice that the task returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task<ph dataRef="id3" id="ph1" /></pc> even though its lambda returned an [<pc dataRefEnd="id5" dataRefStart="id4" id="p2">IAsyncInfo</pc>][IAsyncInfo] object.</source>
          <target xml:space="preserve">In the previous example, notice that the task returns a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task<ph dataRef="id3" id="ph1" /></pc> even though its lambda returned an [<pc dataRefEnd="id5" dataRefStart="id4" id="p2">IAsyncInfo</pc>][IAsyncInfo] object.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source xml:space="preserve">The following table summarizes the type conversions that occur between a lambda function and the enclosing task:</source>
          <target xml:space="preserve">The following table summarizes the type conversions that occur between a lambda function and the enclosing task:</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">lambda return type</source>
          <target xml:space="preserve">lambda return type</target>
        </segment>
      </unit>
      <unit id="163">
        <originalData>
          <data id="id1">`.then`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<ph dataRef="id1" id="ph1" /> return type</source>
          <target xml:space="preserve">
						<ph dataRef="id1" id="ph1" /> return type</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source xml:space="preserve">TResult</source>
          <target xml:space="preserve">TResult</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">task</source>
          <target xml:space="preserve">task</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source xml:space="preserve">IAsyncOperation</source>
          <target xml:space="preserve">IAsyncOperation</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source xml:space="preserve">task</source>
          <target xml:space="preserve">task</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source xml:space="preserve">IAsyncOperationWithProgress&lt;TResult, TProgress&gt;^</source>
          <target xml:space="preserve">IAsyncOperationWithProgress&lt;TResult, TProgress&gt;^</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source xml:space="preserve">task</source>
          <target xml:space="preserve">task</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source xml:space="preserve">IAsyncAction^</source>
          <target xml:space="preserve">IAsyncAction^</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">task</source>
          <target xml:space="preserve">task</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source xml:space="preserve">IAsyncActionWithProgress</source>
          <target xml:space="preserve">IAsyncActionWithProgress</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">task</source>
          <target xml:space="preserve">task</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source xml:space="preserve">task</source>
          <target xml:space="preserve">task</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source xml:space="preserve">task</source>
          <target xml:space="preserve">task</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source xml:space="preserve">Canceling tasks</source>
          <target xml:space="preserve">Canceling tasks</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source xml:space="preserve">It is often a good idea to give the user the option to cancel an asynchronous operation.</source>
          <target xml:space="preserve">It is often a good idea to give the user the option to cancel an asynchronous operation.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source xml:space="preserve">And in some cases you might have to cancel an operation programmatically from outside the task chain.</source>
          <target xml:space="preserve">And in some cases you might have to cancel an operation programmatically from outside the task chain.</target>
        </segment>
      </unit>
      <unit id="181">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Although each \*<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Async</pc> return type has a [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Cancel</pc>][IAsyncInfoCancel] method that it inherits from [<pc dataRefEnd="id6" dataRefStart="id5" id="p3">IAsyncInfo</pc>][IAsyncInfo], it's awkward to expose it to outside methods.</source>
          <target xml:space="preserve">Although each \*<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Async</pc> return type has a [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Cancel</pc>][IAsyncInfoCancel] method that it inherits from [<pc dataRefEnd="id6" dataRefStart="id5" id="p3">IAsyncInfo</pc>][IAsyncInfo], it's awkward to expose it to outside methods.</target>
        </segment>
      </unit>
      <unit id="182">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749985.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749975.aspx)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The preferred way to support cancellation in a task chain is to use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">cancellation\_token\_source</pc></pc> to create a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">cancellation\_token</pc></pc>, and then pass the token to the constructor of the initial task.</source>
          <target xml:space="preserve">The preferred way to support cancellation in a task chain is to use a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">cancellation\_token\_source</pc></pc> to create a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">cancellation\_token</pc></pc>, and then pass the token to the constructor of the initial task.</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750076.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If an asynchronous task is created with a cancellation token, and <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">cancellation\_token\_source::cancel</pc></pc> is called, the task automatically calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Cancel</pc> on the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">IAsync\*</pc> operation and passes the cancellation request down its continuation chain.</source>
          <target xml:space="preserve">If an asynchronous task is created with a cancellation token, and <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">cancellation\_token\_source::cancel</pc></pc> is called, the task automatically calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Cancel</pc> on the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">IAsync\*</pc> operation and passes the cancellation request down its continuation chain.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source xml:space="preserve">The following pseudocode demonstrates the basic approach.</source>
          <target xml:space="preserve">The following pseudocode demonstrates the basic approach.</target>
        </segment>
      </unit>
      <unit id="185">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When a task is canceled, a [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_canceled</pc>][taskCanceled] exception is propagated down the task chain.</source>
          <target xml:space="preserve">When a task is canceled, a [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_canceled</pc>][taskCanceled] exception is propagated down the task chain.</target>
        </segment>
      </unit>
      <unit id="186">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Value-based continuations will simply not execute, but task-based continuations will cause the exception to be thrown when [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc>][taskGet] is called.</source>
          <target xml:space="preserve">Value-based continuations will simply not execute, but task-based continuations will cause the exception to be thrown when [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc>][taskGet] is called.</target>
        </segment>
      </unit>
      <unit id="187">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you have an error-handling continuation, make sure that it catches the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_canceled</pc> exception explicitly.</source>
          <target xml:space="preserve">If you have an error-handling continuation, make sure that it catches the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_canceled</pc> exception explicitly.</target>
        </segment>
      </unit>
      <unit id="188">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh755825.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">(This exception is not derived from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Platform::Exception</pc></pc>.)</source>
          <target xml:space="preserve">(This exception is not derived from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Platform::Exception</pc></pc>.)</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source xml:space="preserve">Cancellation is cooperative.</source>
          <target xml:space="preserve">Cancellation is cooperative.</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source xml:space="preserve">If your continuation does some long-running work beyond just invoking a UWP method, then it is your responsibility to check the state of the cancellation token periodically and stop execution if it is canceled.</source>
          <target xml:space="preserve">If your continuation does some long-running work beyond just invoking a UWP method, then it is your responsibility to check the state of the cancellation token periodically and stop execution if it is canceled.</target>
        </segment>
      </unit>
      <unit id="191">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749945.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">After you clean up all resources that were allocated in the continuation, call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">cancel\_current\_task</pc></pc> to cancel that task and propagate the cancellation down to any value-based continuations that follow it.</source>
          <target xml:space="preserve">After you clean up all resources that were allocated in the continuation, call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">cancel\_current\_task</pc></pc> to cancel that task and propagate the cancellation down to any value-based continuations that follow it.</target>
        </segment>
      </unit>
      <unit id="192">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR207871)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Here's another example: you can create a task chain that represents the result of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FileSavePicker</pc></pc> operation.</source>
          <target xml:space="preserve">Here's another example: you can create a task chain that represents the result of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FileSavePicker</pc></pc> operation.</target>
        </segment>
      </unit>
      <unit id="193">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If the user chooses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Cancel</pc> button, the [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncInfo::Cancel</pc>][IAsyncInfoCancel] method is not called.</source>
          <target xml:space="preserve">If the user chooses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Cancel</pc> button, the [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncInfo::Cancel</pc>][IAsyncInfoCancel] method is not called.</target>
        </segment>
      </unit>
      <unit id="194">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Instead, the operation succeeds but returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">nullptr</pc>.</source>
          <target xml:space="preserve">Instead, the operation succeeds but returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">nullptr</pc>.</target>
        </segment>
      </unit>
      <unit id="195">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The continuation can test the input parameter and call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cancel\_current\_task</pc> if the input is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">nullptr</pc>.</source>
          <target xml:space="preserve">The continuation can test the input parameter and call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">cancel\_current\_task</pc> if the input is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">nullptr</pc>.</target>
        </segment>
      </unit>
      <unit id="196">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/dd984117.aspx)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Cancellation in the PPL</pc></source>
          <target xml:space="preserve">For more information, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Cancellation in the PPL</pc></target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source xml:space="preserve">Handling errors in a task chain</source>
          <target xml:space="preserve">Handling errors in a task chain</target>
        </segment>
      </unit>
      <unit id="198">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">&lt;TResult&gt;</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">&lt;void&gt;</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you want a continuation to execute even if the antecedent was canceled or threw an exception, then make the continuation a task-based continuation by specifying the input to its lambda function as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task<ph dataRef="id3" id="ph1" /></pc> or <pc dataRefEnd="id5" dataRefStart="id4" id="p2">task<ph dataRef="id6" id="ph2" /></pc> if the lambda of the antecedent task returns an [<pc dataRefEnd="id8" dataRefStart="id7" id="p3">IAsyncAction^</pc>][IAsyncAction].</source>
          <target xml:space="preserve">If you want a continuation to execute even if the antecedent was canceled or threw an exception, then make the continuation a task-based continuation by specifying the input to its lambda function as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task<ph dataRef="id3" id="ph1" /></pc> or <pc dataRefEnd="id5" dataRefStart="id4" id="p2">task<ph dataRef="id6" id="ph2" /></pc> if the lambda of the antecedent task returns an [<pc dataRefEnd="id8" dataRefStart="id7" id="p3">IAsyncAction^</pc>][IAsyncAction].</target>
        </segment>
      </unit>
      <unit id="199">
        <originalData>
          <data id="id1">`try…catch`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To handle errors and cancellation in a task chain, you don't have to make every continuation task-based or enclose every operation that might throw within a <ph dataRef="id1" id="ph1" /> block.</source>
          <target xml:space="preserve">To handle errors and cancellation in a task chain, you don't have to make every continuation task-based or enclose every operation that might throw within a <ph dataRef="id1" id="ph1" /> block.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source xml:space="preserve">Instead, you can add a task-based continuation at the end of the chain and handle all errors there.</source>
          <target xml:space="preserve">Instead, you can add a task-based continuation at the end of the chain and handle all errors there.</target>
        </segment>
      </unit>
      <unit id="201">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Any exception—this includes a [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_canceled</pc>][taskCanceled] exception—will propagate down the task chain and bypass any value-based continuations, so that you can handle it in the error-handling task-based continuation.</source>
          <target xml:space="preserve">Any exception—this includes a [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_canceled</pc>][taskCanceled] exception—will propagate down the task chain and bypass any value-based continuations, so that you can handle it in the error-handling task-based continuation.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source xml:space="preserve">We can rewrite the previous example to use an error-handling task-based continuation:</source>
          <target xml:space="preserve">We can rewrite the previous example to use an error-handling task-based continuation:</target>
        </segment>
      </unit>
      <unit id="203">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In a task-based continuation, we call the member function [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc>][taskGet] to get the results of the task.</source>
          <target xml:space="preserve">In a task-based continuation, we call the member function [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc>][taskGet] to get the results of the task.</target>
        </segment>
      </unit>
      <unit id="204">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">We still have to call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc> even if the operation was an [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncAction</pc>][IAsyncAction] that produces no result because <pc dataRefEnd="id6" dataRefStart="id5" id="p3">task::get</pc> also gets any exceptions that have been transported down to the task.</source>
          <target xml:space="preserve">We still have to call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc> even if the operation was an [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncAction</pc>][IAsyncAction] that produces no result because <pc dataRefEnd="id6" dataRefStart="id5" id="p3">task::get</pc> also gets any exceptions that have been transported down to the task.</target>
        </segment>
      </unit>
      <unit id="205">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If the input task is storing an exception, it is thrown at the call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc>.</source>
          <target xml:space="preserve">If the input task is storing an exception, it is thrown at the call to <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc>.</target>
        </segment>
      </unit>
      <unit id="206">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you don't call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc>, or don't use a task-based continuation at the end of the chain, or don't catch the exception type that was thrown, then an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">unobserved\_task\_exception</pc> is thrown when all references to the task have been deleted.</source>
          <target xml:space="preserve">If you don't call <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::get</pc>, or don't use a task-based continuation at the end of the chain, or don't catch the exception type that was thrown, then an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">unobserved\_task\_exception</pc> is thrown when all references to the task have been deleted.</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source xml:space="preserve">Only catch the exceptions that you can handle.</source>
          <target xml:space="preserve">Only catch the exceptions that you can handle.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source xml:space="preserve">If your app encounters an error that you can't recover from, it's better to let the app crash than to let it continue to run in an unknown state.</source>
          <target xml:space="preserve">If your app encounters an error that you can't recover from, it's better to let the app crash than to let it continue to run in an unknown state.</target>
        </segment>
      </unit>
      <unit id="209">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Also, in general, don't attempt to catch the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">unobserved\_task\_exception</pc> itself.</source>
          <target xml:space="preserve">Also, in general, don't attempt to catch the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">unobserved\_task\_exception</pc> itself.</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source xml:space="preserve">This exception is mainly intended for diagnostic purposes.</source>
          <target xml:space="preserve">This exception is mainly intended for diagnostic purposes.</target>
        </segment>
      </unit>
      <unit id="211">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">unobserved\_task\_exception</pc> is thrown, it usually indicates a bug in the code.</source>
          <target xml:space="preserve">When <pc dataRefEnd="id2" dataRefStart="id1" id="p1">unobserved\_task\_exception</pc> is thrown, it usually indicates a bug in the code.</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source xml:space="preserve">Often the cause is either an exception that should be handled, or an unrecoverable exception that's caused by some other error in the code.</source>
          <target xml:space="preserve">Often the cause is either an exception that should be handled, or an unrecoverable exception that's caused by some other error in the code.</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source xml:space="preserve">Managing the thread context</source>
          <target xml:space="preserve">Managing the thread context</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source xml:space="preserve">The UI of a UWP app runs in a single-threaded apartment (STA).</source>
          <target xml:space="preserve">The UI of a UWP app runs in a single-threaded apartment (STA).</target>
        </segment>
      </unit>
      <unit id="215">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A task whose lambda returns either an [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncAction</pc>][IAsyncAction] or [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperation</pc>][IAsyncOperation] is apartment-aware.</source>
          <target xml:space="preserve">A task whose lambda returns either an [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncAction</pc>][IAsyncAction] or [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperation</pc>][IAsyncOperation] is apartment-aware.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source xml:space="preserve">If the task is created in the STA, then all of its continuations will run also run in it by default, unless you specify otherwise.</source>
          <target xml:space="preserve">If the task is created in the STA, then all of its continuations will run also run in it by default, unless you specify otherwise.</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source xml:space="preserve">In other words, the entire task chain inherits apartment-awareness from the parent task.</source>
          <target xml:space="preserve">In other words, the entire task chain inherits apartment-awareness from the parent task.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source xml:space="preserve">This behavior helps simplify interactions with UI controls, which can only be accessed from the STA.</source>
          <target xml:space="preserve">This behavior helps simplify interactions with UI controls, which can only be accessed from the STA.</target>
        </segment>
      </unit>
      <unit id="219">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242868)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR208211)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, in a UWP app, in the member function of any class that represents a XAML page, you can populate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListBox</pc></pc> control from within a [<pc dataRefEnd="id6" dataRefStart="id5" id="p3">task::then</pc>][taskThen] method without having to use the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Dispatcher</pc></pc> object.</source>
          <target xml:space="preserve">For example, in a UWP app, in the member function of any class that represents a XAML page, you can populate a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListBox</pc></pc> control from within a [<pc dataRefEnd="id6" dataRefStart="id5" id="p3">task::then</pc>][taskThen] method without having to use the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Dispatcher</pc></pc> object.</target>
        </segment>
      </unit>
      <unit id="220">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If a task doesn't return an [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncAction</pc>][IAsyncAction] or [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperation</pc>][IAsyncOperation], then it's not apartment-aware and, by default, its continuations are run on the first available background thread.</source>
          <target xml:space="preserve">If a task doesn't return an [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">IAsyncAction</pc>][IAsyncAction] or [<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperation</pc>][IAsyncOperation], then it's not apartment-aware and, by default, its continuations are run on the first available background thread.</target>
        </segment>
      </unit>
      <unit id="221">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh749968.aspx)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can override the default thread context for either kind of task by using the overload of [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::then</pc>][taskThen] that takes a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">task\_continuation\_context</pc></pc>.</source>
          <target xml:space="preserve">You can override the default thread context for either kind of task by using the overload of [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task::then</pc>][taskThen] that takes a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">task\_continuation\_context</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source xml:space="preserve">For example, in some cases, it might be desirable to schedule the continuation of an apartment-aware task on a background thread.</source>
          <target xml:space="preserve">For example, in some cases, it might be desirable to schedule the continuation of an apartment-aware task on a background thread.</target>
        </segment>
      </unit>
      <unit id="223">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In such a case, you can pass [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_continuation\_context::use\_arbitrary</pc>][useArbitrary] to schedule the task’s work on the next available thread in a multi-threaded apartment.</source>
          <target xml:space="preserve">In such a case, you can pass [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_continuation\_context::use\_arbitrary</pc>][useArbitrary] to schedule the task’s work on the next available thread in a multi-threaded apartment.</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source xml:space="preserve">This can improve the performance of the continuation because its work doesn't have to be synchronized with other work that's happening on the UI thread.</source>
          <target xml:space="preserve">This can improve the performance of the continuation because its work doesn't have to be synchronized with other work that's happening on the UI thread.</target>
        </segment>
      </unit>
      <unit id="225">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The following example demonstrates when it's useful to specify the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_continuation\_context::use\_arbitrary</pc>][useArbitrary] option, and it also shows how the default continuation context is useful for synchronizing concurrent operations on non-thread-safe collections.</source>
          <target xml:space="preserve">The following example demonstrates when it's useful to specify the [<pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_continuation\_context::use\_arbitrary</pc>][useArbitrary] option, and it also shows how the default continuation context is useful for synchronizing concurrent operations on non-thread-safe collections.</target>
        </segment>
      </unit>
      <unit id="226">
        <segment state="initial">
          <source xml:space="preserve">In this code, we loop through a list of URLs for RSS feeds, and for each URL, we start up an async operation to retrieve the feed data.</source>
          <target xml:space="preserve">In this code, we loop through a list of URLs for RSS feeds, and for each URL, we start up an async operation to retrieve the feed data.</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source xml:space="preserve">We can’t control the order in which the feeds are retrieved, and we don't really care.</source>
          <target xml:space="preserve">We can’t control the order in which the feeds are retrieved, and we don't really care.</target>
        </segment>
      </unit>
      <unit id="228">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR210642)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR243485)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">`FeedData^`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When each <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RetrieveFeedAsync</pc></pc> operation completes, the first continuation accepts the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SyndicationFeed^</pc></pc> object and uses it to initialize an app-defined <ph dataRef="id9" id="ph1" /> object.</source>
          <target xml:space="preserve">When each <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RetrieveFeedAsync</pc></pc> operation completes, the first continuation accepts the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SyndicationFeed^</pc></pc> object and uses it to initialize an app-defined <ph dataRef="id9" id="ph1" /> object.</target>
        </segment>
      </unit>
      <unit id="229">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Because each of these operations is independent from the others, we can potentially speed things up by specifying the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_continuation\_context::use\_arbitrary</pc> continuation context.</source>
          <target xml:space="preserve">Because each of these operations is independent from the others, we can potentially speed things up by specifying the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">task\_continuation\_context::use\_arbitrary</pc> continuation context.</target>
        </segment>
      </unit>
      <unit id="230">
        <originalData>
          <data id="id1">`FeedData`</data>
          <data id="id2">[</data>
          <data id="id3">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh441570.aspx)</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">However, after each <ph dataRef="id1" id="ph1" /> object is initialized, we have to add it to a <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">Vector</pc></pc>, which is not a thread-safe collection.</source>
          <target xml:space="preserve">However, after each <ph dataRef="id1" id="ph1" /> object is initialized, we have to add it to a <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">Vector</pc></pc>, which is not a thread-safe collection.</target>
        </segment>
      </unit>
      <unit id="231">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR206632)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Therefore, we create a continuation and specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task\_continuation\_context::use\_current</pc></pc> to ensure that all the calls to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Append</pc></pc> occur in the same Application Single-Threaded Apartment (ASTA) context.</source>
          <target xml:space="preserve">Therefore, we create a continuation and specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task\_continuation\_context::use\_current</pc></pc> to ensure that all the calls to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Append</pc></pc> occur in the same Application Single-Threaded Apartment (ASTA) context.</target>
        </segment>
      </unit>
      <unit id="232">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/hh750085.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Because <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task\_continuation\_context::use\_default</pc></pc> is the default context, we don’t have to specify it explicitly, but we do so here for the sake of clarity.</source>
          <target xml:space="preserve">Because <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">task\_continuation\_context::use\_default</pc></pc> is the default context, we don’t have to specify it explicitly, but we do so here for the sake of clarity.</target>
        </segment>
      </unit>
      <unit id="233">
        <segment state="initial">
          <source xml:space="preserve">Nested tasks, which are new tasks that are created inside a continuation, don't inherit apartment-awareness of the initial task.</source>
          <target xml:space="preserve">Nested tasks, which are new tasks that are created inside a continuation, don't inherit apartment-awareness of the initial task.</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source xml:space="preserve">Handing progress updates</source>
          <target xml:space="preserve">Handing progress updates</target>
        </segment>
      </unit>
      <unit id="235">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR206594)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR206580withprogress_1)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Methods that support <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperationWithProgress</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IAsyncActionWithProgress</pc></pc> provide progress updates periodically while the operation is in progress, before it completes.</source>
          <target xml:space="preserve">Methods that support <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAsyncOperationWithProgress</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IAsyncActionWithProgress</pc></pc> provide progress updates periodically while the operation is in progress, before it completes.</target>
        </segment>
      </unit>
      <unit id="236">
        <segment state="initial">
          <source xml:space="preserve">Progress reporting is independent from the notion of tasks and continuations.</source>
          <target xml:space="preserve">Progress reporting is independent from the notion of tasks and continuations.</target>
        </segment>
      </unit>
      <unit id="237">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br206594)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You just supply the delegate for the object’s <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Progress</pc></pc> property.</source>
          <target xml:space="preserve">You just supply the delegate for the object’s <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Progress</pc></pc> property.</target>
        </segment>
      </unit>
      <unit id="238">
        <segment state="initial">
          <source xml:space="preserve">A typical use of the delegate is to update a progress bar in the UI.</source>
          <target xml:space="preserve">A typical use of the delegate is to update a progress bar in the UI.</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source xml:space="preserve">Related topics</source>
          <target xml:space="preserve">Related topics</target>
        </segment>
      </unit>
      <unit id="240">
        <segment state="initial">
          <source xml:space="preserve">[Creating Asynchronous Operations in C++ for Windows Store apps][createAsyncCpp]</source>
          <target xml:space="preserve">[Creating Asynchronous Operations in C++ for Windows Store apps][createAsyncCpp]</target>
        </segment>
      </unit>
      <unit id="241">
        <segment state="initial">
          <source xml:space="preserve">Visual C++ Language Reference</source>
          <target xml:space="preserve">Visual C++ Language Reference</target>
        </segment>
      </unit>
      <unit id="242">
        <segment state="initial">
          <source xml:space="preserve">[Asynchronous Programming][AsyncProgramming]</source>
          <target xml:space="preserve">[Asynchronous Programming][AsyncProgramming]</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source xml:space="preserve">[Task Parallelism (Concurrency Runtime)][taskParallelism]</source>
          <target xml:space="preserve">[Task Parallelism (Concurrency Runtime)][taskParallelism]</target>
        </segment>
      </unit>
      <unit id="244">
        <segment state="initial">
          <source xml:space="preserve">[task class][task-class]</source>
          <target xml:space="preserve">[task class][task-class]</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>