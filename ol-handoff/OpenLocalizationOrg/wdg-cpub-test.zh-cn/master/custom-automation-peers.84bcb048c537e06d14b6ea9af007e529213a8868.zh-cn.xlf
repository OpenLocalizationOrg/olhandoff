<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="zh-cn" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">b5cb2107a5e635cd0dbf653af5ec7cf785d50e76</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">Description: Describes the concept of automation peers for Microsoft UI Automation, and how you can provide automation support for your own custom UI class.</source>
          <target xml:space="preserve">Description: Describes the concept of automation peers for Microsoft UI Automation, and how you can provide automation support for your own custom UI class.</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">title: Custom automation peers</source>
          <target xml:space="preserve">title: Custom automation peers</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: AA8DA53B-FE6E-40AC-9F0A-CB09637C87B4</source>
          <target xml:space="preserve">ms.assetid: AA8DA53B-FE6E-40AC-9F0A-CB09637C87B4</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">label: Custom automation peers</source>
          <target xml:space="preserve">label: Custom automation peers</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">template: detail.hbs</source>
          <target xml:space="preserve">template: detail.hbs</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source xml:space="preserve">Custom automation peers</source>
          <target xml:space="preserve">Custom automation peers</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">Describes the concept of automation peers for Microsoft UI Automation, and how you can provide automation support for your own custom UI class.</source>
          <target xml:space="preserve">Describes the concept of automation peers for Microsoft UI Automation, and how you can provide automation support for your own custom UI class.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">UI Automation provides a framework that automation clients can use to examine or operate the user interfaces of a variety of UI platforms and frameworks.</source>
          <target xml:space="preserve">UI Automation provides a framework that automation clients can use to examine or operate the user interfaces of a variety of UI platforms and frameworks.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">If you are writing a Universal Windows Platform (UWP) app, the classes that you use for your UI already provide UI Automation support.</source>
          <target xml:space="preserve">If you are writing a Universal Windows Platform (UWP) app, the classes that you use for your UI already provide UI Automation support.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">You can derive from existing, non-sealed classes to define a new kind of UI control or support class.</source>
          <target xml:space="preserve">You can derive from existing, non-sealed classes to define a new kind of UI control or support class.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">In the process of doing so, your class might add behavior that should have accessibility support but that the default UI Automation support does not cover.</source>
          <target xml:space="preserve">In the process of doing so, your class might add behavior that should have accessibility support but that the default UI Automation support does not cover.</target>
        </segment>
      </unit>
      <unit id="114">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In this case, you should extend the existing UI Automation support by deriving from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> class that the base implementation used, adding any necessary support to your peer implementation, and informing the Universal Windows Platform (UWP) control infrastructure that it should create your new peer.</source>
          <target xml:space="preserve">In this case, you should extend the existing UI Automation support by deriving from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> class that the base implementation used, adding any necessary support to your peer implementation, and informing the Universal Windows Platform (UWP) control infrastructure that it should create your new peer.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source xml:space="preserve">UI Automation enables not only accessibility applications and assistive technologies, such as screen readers, but also quality-assurance (test) code.</source>
          <target xml:space="preserve">UI Automation enables not only accessibility applications and assistive technologies, such as screen readers, but also quality-assurance (test) code.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">In either scenario, UI Automation clients can examine user-interface elements and simulate user interaction with your app from other code outside your app.</source>
          <target xml:space="preserve">In either scenario, UI Automation clients can examine user-interface elements and simulate user interaction with your app from other code outside your app.</target>
        </segment>
      </unit>
      <unit id="117">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee684076)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For info about UI Automation across all platforms and in its wider meaning, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Overview</pc>.</source>
          <target xml:space="preserve">For info about UI Automation across all platforms and in its wider meaning, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Overview</pc>.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">There are two distinct audiences who use the UI Automation framework.</source>
          <target xml:space="preserve">There are two distinct audiences who use the UI Automation framework.</target>
        </segment>
      </unit>
      <unit id="119">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">UI Automation <pc dataRefEnd="id2" dataRefStart="id1" id="p1">clients</pc> call UI Automation APIs to learn about all of the UI that is currently displayed to the user.</source>
          <target xml:space="preserve">UI Automation <pc dataRefEnd="id2" dataRefStart="id1" id="p1">clients</pc> call UI Automation APIs to learn about all of the UI that is currently displayed to the user.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">For example, an assistive technology such as a screen reader acts as a UI Automation client.</source>
          <target xml:space="preserve">For example, an assistive technology such as a screen reader acts as a UI Automation client.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">The UI is presented as a tree of automation elements that are related.</source>
          <target xml:space="preserve">The UI is presented as a tree of automation elements that are related.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">The UI Automation client might be interested in just one app at a time, or in the entire tree.</source>
          <target xml:space="preserve">The UI Automation client might be interested in just one app at a time, or in the entire tree.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">The UI Automation client can use UI Automation APIs to navigate the tree and to read or change information in the automation elements.</source>
          <target xml:space="preserve">The UI Automation client can use UI Automation APIs to navigate the tree and to read or change information in the automation elements.</target>
        </segment>
      </unit>
      <unit id="124">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">UI Automation <pc dataRefEnd="id2" dataRefStart="id1" id="p1">providers</pc> contribute information to the UI Automation tree, by implementing APIs that expose the elements in the UI that they introduced as part of their app.</source>
          <target xml:space="preserve">UI Automation <pc dataRefEnd="id2" dataRefStart="id1" id="p1">providers</pc> contribute information to the UI Automation tree, by implementing APIs that expose the elements in the UI that they introduced as part of their app.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">When you create a new control, you should now act as a participant in the UI Automation provider scenario.</source>
          <target xml:space="preserve">When you create a new control, you should now act as a participant in the UI Automation provider scenario.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source xml:space="preserve">As a provider, you should ensure that all UI Automation clients can use the UI Automation framework to interact with your control for both accessibility and testing purposes.</source>
          <target xml:space="preserve">As a provider, you should ensure that all UI Automation clients can use the UI Automation framework to interact with your control for both accessibility and testing purposes.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source xml:space="preserve">Typically there are parallel APIs in the UI Automation framework: one API for UI Automation clients and another, similarly named API for UI Automation providers.</source>
          <target xml:space="preserve">Typically there are parallel APIs in the UI Automation framework: one API for UI Automation clients and another, similarly named API for UI Automation providers.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">For the most part, this topic covers the APIs for the UI Automation provider, and specifically the classes and interfaces that enable provider extensibility in that UI framework.</source>
          <target xml:space="preserve">For the most part, this topic covers the APIs for the UI Automation provider, and specifically the classes and interfaces that enable provider extensibility in that UI framework.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source xml:space="preserve">Occasionally we mention UI Automation APIs that the UI Automation clients use, to provide some perspective, or provide a lookup table that correlates the client and provider APIs.</source>
          <target xml:space="preserve">Occasionally we mention UI Automation APIs that the UI Automation clients use, to provide some perspective, or provide a lookup table that correlates the client and provider APIs.</target>
        </segment>
      </unit>
      <unit id="130">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee684021)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info about the client perspective, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Client Programmer's Guide</pc>.</source>
          <target xml:space="preserve">For more info about the client perspective, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Client Programmer's Guide</pc>.</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>
					</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>
					</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source xml:space="preserve">UI Automation clients don't typically use managed code and aren't typically implemented as a UWP app (they are usually desktop apps).</source>
          <target xml:space="preserve">UI Automation clients don't typically use managed code and aren't typically implemented as a UWP app (they are usually desktop apps).</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">UI Automation is based on a standard and not a specific implementation or framework.</source>
          <target xml:space="preserve">UI Automation is based on a standard and not a specific implementation or framework.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">Many existing UI Automation clients, including assistive technology products such as screen readers, use Component Object Model (COM) interfaces to interact with UI Automation, the system, and the apps that run in child windows.</source>
          <target xml:space="preserve">Many existing UI Automation clients, including assistive technology products such as screen readers, use Component Object Model (COM) interfaces to interact with UI Automation, the system, and the apps that run in child windows.</target>
        </segment>
      </unit>
      <unit id="135">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee684007)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on the COM interfaces and how to write a UI Automation client using COM, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Fundamentals</pc>.</source>
          <target xml:space="preserve">For more info on the COM interfaces and how to write a UI Automation client using COM, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Fundamentals</pc>.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source xml:space="preserve">Determining the existing state of UI Automation support for your custom UI class</source>
          <target xml:space="preserve">Determining the existing state of UI Automation support for your custom UI class</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">Before you attempt to implement an automation peer for a custom control, you should test whether the base class and its automation peer already provides the accessibility or automation support that you need.</source>
          <target xml:space="preserve">Before you attempt to implement an automation peer for a custom control, you should test whether the base class and its automation peer already provides the accessibility or automation support that you need.</target>
        </segment>
      </unit>
      <unit id="138">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In many cases, the combination of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElementAutomationPeer</pc></pc> implementations, specific peers, and the patterns they implement can provide a basic but satisfactory accessibility experience.</source>
          <target xml:space="preserve">In many cases, the combination of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElementAutomationPeer</pc></pc> implementations, specific peers, and the patterns they implement can provide a basic but satisfactory accessibility experience.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">Whether this is true depends on how many changes you made to the object model exposure to your control versus its base class.</source>
          <target xml:space="preserve">Whether this is true depends on how many changes you made to the object model exposure to your control versus its base class.</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source xml:space="preserve">Also, this depends on whether your additions to base class functionality correlate to new UI elements in the template contract or to the visual appearance of the control.</source>
          <target xml:space="preserve">Also, this depends on whether your additions to base class functionality correlate to new UI elements in the template contract or to the visual appearance of the control.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">In some cases your changes might introduce new aspects of user experience that require additional accessibility support.</source>
          <target xml:space="preserve">In some cases your changes might introduce new aspects of user experience that require additional accessibility support.</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Even if using the existing base peer class provides the basic accessibility support, it is still a best practice to define a peer so that you can report precise <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ClassName</pc> information to UI Automation for automated testing scenarios.</source>
          <target xml:space="preserve">Even if using the existing base peer class provides the basic accessibility support, it is still a best practice to define a peer so that you can report precise <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ClassName</pc> information to UI Automation for automated testing scenarios.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">This consideration is especially important if you are writing a control that is intended for third-party consumption.</source>
          <target xml:space="preserve">This consideration is especially important if you are writing a control that is intended for third-party consumption.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">Automation peer classes</source>
          <target xml:space="preserve">Automation peer classes</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source xml:space="preserve">The UWP builds on existing UI Automation techniques and conventions used by previous managed-code UI frameworks such as Windows Forms, Windows Presentation Foundation (WPF) and Microsoft Silverlight.</source>
          <target xml:space="preserve">The UWP builds on existing UI Automation techniques and conventions used by previous managed-code UI frameworks such as Windows Forms, Windows Presentation Foundation (WPF) and Microsoft Silverlight.</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source xml:space="preserve">Many of the control classes and their function and purpose also have their origin in a previous UI framework.</source>
          <target xml:space="preserve">Many of the control classes and their function and purpose also have their origin in a previous UI framework.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source xml:space="preserve">By convention, peer class names begin with the control class name and end with "AutomationPeer".</source>
          <target xml:space="preserve">By convention, peer class names begin with the control class name and end with "AutomationPeer".</target>
        </segment>
      </unit>
      <unit id="148">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242458)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209265)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ButtonAutomationPeer</pc></pc> is the peer class for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Button</pc></pc> control class.</source>
          <target xml:space="preserve">For example, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ButtonAutomationPeer</pc></pc> is the peer class for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Button</pc></pc> control class.</target>
        </segment>
      </unit>
      <unit id="149">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For purposes of this topic, we treat the properties that are related to accessibility as being more important when you implement a control peer.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For purposes of this topic, we treat the properties that are related to accessibility as being more important when you implement a control peer.</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671596)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/desktop/Ee684007)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But for a more general concept of UI Automation support, you should implement a peer in accordance with recommendations as documented by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Provider Programmer's Guide</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">UI Automation Fundamentals</pc>.</source>
          <target xml:space="preserve">But for a more general concept of UI Automation support, you should implement a peer in accordance with recommendations as documented by the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Provider Programmer's Guide</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">UI Automation Fundamentals</pc>.</target>
        </segment>
      </unit>
      <unit id="151">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Those topics don't cover the specific <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> APIs that you would use to provide the information in the UWP framework for UI Automation, but they do describe the properties that identify your class or provide other information or interaction.</source>
          <target xml:space="preserve">Those topics don't cover the specific <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> APIs that you would use to provide the information in the UWP framework for UI Automation, but they do describe the properties that identify your class or provide other information or interaction.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source xml:space="preserve">Peers, patterns and control types</source>
          <target xml:space="preserve">Peers, patterns and control types</target>
        </segment>
      </unit>
      <unit id="153">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">control pattern</pc> is an interface implementation that exposes a particular aspect of a control's functionality to a UI Automation client.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">control pattern</pc> is an interface implementation that exposes a particular aspect of a control's functionality to a UI Automation client.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">UI Automation clients use the properties and methods exposed through a control pattern to retrieve information about capabilities of the control, or to manipulate the control's behavior at run time.</source>
          <target xml:space="preserve">UI Automation clients use the properties and methods exposed through a control pattern to retrieve information about capabilities of the control, or to manipulate the control's behavior at run time.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">Control patterns provide a way to categorize and expose a control's functionality independent of the control type or the appearance of the control.</source>
          <target xml:space="preserve">Control patterns provide a way to categorize and expose a control's functionality independent of the control type or the appearance of the control.</target>
        </segment>
      </unit>
      <unit id="156">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, a control that presents a tabular interface uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Grid</pc> control pattern to expose the number of rows and columns in the table, and to enable a UI Automation client to retrieve items from the table.</source>
          <target xml:space="preserve">For example, a control that presents a tabular interface uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Grid</pc> control pattern to expose the number of rows and columns in the table, and to enable a UI Automation client to retrieve items from the table.</target>
        </segment>
      </unit>
      <unit id="157">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">As other examples, the UI Automation client can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Invoke</pc> control pattern for controls that can be invoked, such as buttons, and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Scroll</pc> control pattern for controls that have scroll bars, such as list boxes, list views, or combo boxes.</source>
          <target xml:space="preserve">As other examples, the UI Automation client can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Invoke</pc> control pattern for controls that can be invoked, such as buttons, and the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Scroll</pc> control pattern for controls that have scroll bars, such as list boxes, list views, or combo boxes.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">Each control pattern represents a separate type of functionality, and control patterns can be combined to describe the full set of functionality supported by a particular control.</source>
          <target xml:space="preserve">Each control pattern represents a separate type of functionality, and control patterns can be combined to describe the full set of functionality supported by a particular control.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source xml:space="preserve">Control patterns relate to UI as interfaces relate to COM objects.</source>
          <target xml:space="preserve">Control patterns relate to UI as interfaces relate to COM objects.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source xml:space="preserve">In COM, you can query an object to ask what interfaces it supports and then use those interfaces to access functionality.</source>
          <target xml:space="preserve">In COM, you can query an object to ask what interfaces it supports and then use those interfaces to access functionality.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source xml:space="preserve">In UI Automation, UI Automation clients can query a UI Automation element to find out which control patterns it supports, and then interact with the element and its peered control through the properties, methods, events, and structures exposed by the supported control patterns.</source>
          <target xml:space="preserve">In UI Automation, UI Automation clients can query a UI Automation element to find out which control patterns it supports, and then interact with the element and its peered control through the properties, methods, events, and structures exposed by the supported control patterns.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">One of the main purposes of an automation peer is to report to a UI Automation client which control patterns the UI element can support through its peer.</source>
          <target xml:space="preserve">One of the main purposes of an automation peer is to report to a UI Automation client which control patterns the UI element can support through its peer.</target>
        </segment>
      </unit>
      <unit id="163">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpattern)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To do this, UI Automation providers implement new peers that change the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> method behavior by overriding the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetPatternCore</pc></pc> method.</source>
          <target xml:space="preserve">To do this, UI Automation providers implement new peers that change the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> method behavior by overriding the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetPatternCore</pc></pc> method.</target>
        </segment>
      </unit>
      <unit id="164">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">UI Automation clients make calls that the UI Automation provider maps to calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPattern</pc>.</source>
          <target xml:space="preserve">UI Automation clients make calls that the UI Automation provider maps to calling <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPattern</pc>.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">UI Automation clients query for each specific pattern that they want to interact with.</source>
          <target xml:space="preserve">UI Automation clients query for each specific pattern that they want to interact with.</target>
        </segment>
      </unit>
      <unit id="166">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If the peer supports the pattern, it returns an object reference to itself; otherwise it returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc>.</source>
          <target xml:space="preserve">If the peer supports the pattern, it returns an object reference to itself; otherwise it returns <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc>.</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If the return is not <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc>, the UI Automation client expects that it can call APIs of the pattern interface as a client, in order to interact with that control pattern.</source>
          <target xml:space="preserve">If the return is not <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc>, the UI Automation client expects that it can call APIs of the pattern interface as a client, in order to interact with that control pattern.</target>
        </segment>
      </unit>
      <unit id="168">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">control type</pc> is a way to broadly define the functionality of a control that the peer represents.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">control type</pc> is a way to broadly define the functionality of a control that the peer represents.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source xml:space="preserve">This is a different concept than a control pattern because while a pattern informs UI Automation what info it can get or what actions it can perform through a particular interface, the control type exists one level above that.</source>
          <target xml:space="preserve">This is a different concept than a control pattern because while a pattern informs UI Automation what info it can get or what actions it can perform through a particular interface, the control type exists one level above that.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source xml:space="preserve">Each control type has guidance about these aspects of UI Automation:</source>
          <target xml:space="preserve">Each control type has guidance about these aspects of UI Automation:</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source xml:space="preserve">UI Automation control patterns: A control type might support more than one pattern, each of which represents a different classification of info or interaction.</source>
          <target xml:space="preserve">UI Automation control patterns: A control type might support more than one pattern, each of which represents a different classification of info or interaction.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">Each control type has a set of control patterns that the control must support, a set that is optional, and a set that the control must not support.</source>
          <target xml:space="preserve">Each control type has a set of control patterns that the control must support, a set that is optional, and a set that the control must not support.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source xml:space="preserve">UI Automation property values: Each control type has a set of properties that the control must support.</source>
          <target xml:space="preserve">UI Automation property values: Each control type has a set of properties that the control must support.</target>
        </segment>
      </unit>
      <unit id="174">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671594)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">These are the general properties, as described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Properties Overview</pc>, not the ones that are pattern-specific.</source>
          <target xml:space="preserve">These are the general properties, as described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Properties Overview</pc>, not the ones that are pattern-specific.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">UI Automation events: Each control type has a set of events that the control must support.</source>
          <target xml:space="preserve">UI Automation events: Each control type has a set of events that the control must support.</target>
        </segment>
      </unit>
      <unit id="176">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671221)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Again these are general, not pattern-specific, as described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Events Overview</pc>.</source>
          <target xml:space="preserve">Again these are general, not pattern-specific, as described in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Events Overview</pc>.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source xml:space="preserve">UI Automation tree structure: Each control type defines how the control must appear in the UI Automation tree structure.</source>
          <target xml:space="preserve">UI Automation tree structure: Each control type defines how the control must appear in the UI Automation tree structure.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source xml:space="preserve">Regardless of how automation peers for the framework are implemented, UI Automation client functionality isn't tied to the UWP, and in fact it's likely that existing UI Automation clients such as assistive technologies will use other programming models, such as COM.</source>
          <target xml:space="preserve">Regardless of how automation peers for the framework are implemented, UI Automation client functionality isn't tied to the UWP, and in fact it's likely that existing UI Automation clients such as assistive technologies will use other programming models, such as COM.</target>
        </segment>
      </unit>
      <unit id="179">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In COM, clients can <pc dataRefEnd="id2" dataRefStart="id1" id="p1">QueryInterface</pc> for the COM control pattern interface that implements the requested pattern or the general UI Automation framework for properties, events or tree examination.</source>
          <target xml:space="preserve">In COM, clients can <pc dataRefEnd="id2" dataRefStart="id1" id="p1">QueryInterface</pc> for the COM control pattern interface that implements the requested pattern or the general UI Automation framework for properties, events or tree examination.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source xml:space="preserve">For the patterns, the UI Automation framework marshals that interface code across into UWP code running against the app's UI Automation provider and the relevant peer.</source>
          <target xml:space="preserve">For the patterns, the UI Automation framework marshals that interface code across into UWP code running against the app's UI Automation provider and the relevant peer.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">When you implement control patterns for a managed-code framework such as a Windows Store app using C\# or Microsoft Visual Basic, you can use .NET Framework interfaces to represent these patterns instead of using the COM interface representation.</source>
          <target xml:space="preserve">When you implement control patterns for a managed-code framework such as a Windows Store app using C\# or Microsoft Visual Basic, you can use .NET Framework interfaces to represent these patterns instead of using the COM interface representation.</target>
        </segment>
      </unit>
      <unit id="182">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242582)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, the UI Automation pattern interface for a Microsoft .NET provider implementation of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Invoke</pc> pattern is <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IInvokeProvider</pc></pc>.</source>
          <target xml:space="preserve">For example, the UI Automation pattern interface for a Microsoft .NET provider implementation of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Invoke</pc> pattern is <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IInvokeProvider</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](control-patterns-and-interfaces.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For a list of control patterns, provider interfaces, and their purpose, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Control patterns and interfaces</pc>.</source>
          <target xml:space="preserve">For a list of control patterns, provider interfaces, and their purpose, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Control patterns and interfaces</pc>.</target>
        </segment>
      </unit>
      <unit id="184">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671197)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For the list of the control types, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Control Types Overview</pc>.</source>
          <target xml:space="preserve">For the list of the control types, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Control Types Overview</pc>.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source xml:space="preserve">Guidance for how to implement control patterns</source>
          <target xml:space="preserve">Guidance for how to implement control patterns</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">The control patterns and what they're intended for are part of a larger definition of the UI Automation framework, and don't just apply to the accessibility support for a Windows Store app.</source>
          <target xml:space="preserve">The control patterns and what they're intended for are part of a larger definition of the UI Automation framework, and don't just apply to the accessibility support for a Windows Store app.</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source xml:space="preserve">When you implement a control pattern you should make sure you're implementing it in a way that matches the guidance as documented on MSDN and also in the UI Automation specification.</source>
          <target xml:space="preserve">When you implement a control pattern you should make sure you're implementing it in a way that matches the guidance as documented on MSDN and also in the UI Automation specification.</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source xml:space="preserve">If you're looking for guidance, you can generally use the MSDN topics and won't need to refer to the specification.</source>
          <target xml:space="preserve">If you're looking for guidance, you can generally use the MSDN topics and won't need to refer to the specification.</target>
        </segment>
      </unit>
      <unit id="189">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671292)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Guidance for each pattern is documented here: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing UI Automation Control Patterns</pc>.</source>
          <target xml:space="preserve">Guidance for each pattern is documented here: <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing UI Automation Control Patterns</pc>.</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source xml:space="preserve">You'll notice that each topic under this area has an "Implementation Guidelines and Conventions" section and "Required Members" section.</source>
          <target xml:space="preserve">You'll notice that each topic under this area has an "Implementation Guidelines and Conventions" section and "Required Members" section.</target>
        </segment>
      </unit>
      <unit id="191">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671201)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The guidance usually refers to specific APIs of the relevant control pattern interface in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Control Pattern Interfaces for Providers</pc> reference.</source>
          <target xml:space="preserve">The guidance usually refers to specific APIs of the relevant control pattern interface in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Control Pattern Interfaces for Providers</pc> reference.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source xml:space="preserve">Those interfaces are the native/COM interfaces (and their APIs use COM-style syntax).</source>
          <target xml:space="preserve">Those interfaces are the native/COM interfaces (and their APIs use COM-style syntax).</target>
        </segment>
      </unit>
      <unit id="193">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209225)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But everything you see there has an equivalent in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Provider</pc></pc> namespace.</source>
          <target xml:space="preserve">But everything you see there has an equivalent in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Provider</pc></pc> namespace.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source xml:space="preserve">If you're using the default automation peers and expanding on their behavior, those peers have already been written in conformance to UI Automation guidelines.</source>
          <target xml:space="preserve">If you're using the default automation peers and expanding on their behavior, those peers have already been written in conformance to UI Automation guidelines.</target>
        </segment>
      </unit>
      <unit id="195">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671292)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If they support control patterns, you can rely on that pattern support conforming with guidance at <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing UI Automation Control Patterns</pc>.</source>
          <target xml:space="preserve">If they support control patterns, you can rely on that pattern support conforming with guidance at <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing UI Automation Control Patterns</pc>.</target>
        </segment>
      </unit>
      <unit id="196">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671633)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If a control peer reports that it's representative of a control type defined by UI Automation, then the guidance documented at <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Supporting UI Automation Control Types</pc> has been followed by that peer.</source>
          <target xml:space="preserve">If a control peer reports that it's representative of a control type defined by UI Automation, then the guidance documented at <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Supporting UI Automation Control Types</pc> has been followed by that peer.</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source xml:space="preserve">Nevertheless you might need additional guidance for control patterns or control types in order to follow the UI Automation recommendations in your peer implementation.</source>
          <target xml:space="preserve">Nevertheless you might need additional guidance for control patterns or control types in order to follow the UI Automation recommendations in your peer implementation.</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source xml:space="preserve">That would be particularly true if you're implementing pattern or control type support that doesn't yet exist as a default implementation in a UWP control.</source>
          <target xml:space="preserve">That would be particularly true if you're implementing pattern or control type support that doesn't yet exist as a default implementation in a UWP control.</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source xml:space="preserve">For example, the pattern for annotations isn't implemented in any of the default XAML controls.</source>
          <target xml:space="preserve">For example, the pattern for annotations isn't implemented in any of the default XAML controls.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source xml:space="preserve">But you might have an app that uses annotations extensively and therefore you want to surface that functionality to be accessible.</source>
          <target xml:space="preserve">But you might have an app that uses annotations extensively and therefore you want to surface that functionality to be accessible.</target>
        </segment>
      </unit>
      <unit id="201">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh738493)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For this scenario, your peer should implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAnnotationProvider</pc></pc> and should probably report itself as the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Document</pc> control type with appropriate properties to indicate that your documents support annotation.</source>
          <target xml:space="preserve">For this scenario, your peer should implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IAnnotationProvider</pc></pc> and should probably report itself as the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Document</pc> control type with appropriate properties to indicate that your documents support annotation.</target>
        </segment>
      </unit>
      <unit id="202">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671292)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/desktop/Ee671633)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">We recommend that you use the guidance that you see for the patterns under <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing UI Automation Control Patterns</pc> or control types under <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Supporting UI Automation Control Types</pc> as orientation and general guidance.</source>
          <target xml:space="preserve">We recommend that you use the guidance that you see for the patterns under <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Implementing UI Automation Control Patterns</pc> or control types under <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Supporting UI Automation Control Types</pc> as orientation and general guidance.</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source xml:space="preserve">You might even try following some of the API links for descriptions and remarks as to the purpose of the APIs.</source>
          <target xml:space="preserve">You might even try following some of the API links for descriptions and remarks as to the purpose of the APIs.</target>
        </segment>
      </unit>
      <unit id="204">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209225)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But for syntax specifics that are needed for UWP app programming, find the equivalent API within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Provider</pc></pc> namespace and use those reference pages for more info.</source>
          <target xml:space="preserve">But for syntax specifics that are needed for UWP app programming, find the equivalent API within the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Provider</pc></pc> namespace and use those reference pages for more info.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source xml:space="preserve">Built-in automation peer classes</source>
          <target xml:space="preserve">Built-in automation peer classes</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source xml:space="preserve">In general, elements implement an automation peer class if they accept UI activity from the user, or if they contain information needed by users of assistive technologies that represent the interactive or meaningful UI of apps.</source>
          <target xml:space="preserve">In general, elements implement an automation peer class if they accept UI activity from the user, or if they contain information needed by users of assistive technologies that represent the interactive or meaningful UI of apps.</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source xml:space="preserve">Not all UWP visual elements have automation peers.</source>
          <target xml:space="preserve">Not all UWP visual elements have automation peers.</target>
        </segment>
      </unit>
      <unit id="208">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209265)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209683)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Examples of classes that implement automation peers are <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBox</pc></pc>.</source>
          <target xml:space="preserve">Examples of classes that implement automation peers are <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBox</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="209">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209250)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR227511)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242704)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">[</data>
          <data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR209267)</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Examples of classes that do not implement automation peers are <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Border</pc></pc> and classes based on <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Panel</pc></pc>, such as <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Grid</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Canvas</pc></pc>.</source>
          <target xml:space="preserve">Examples of classes that do not implement automation peers are <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Border</pc></pc> and classes based on <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Panel</pc></pc>, such as <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Grid</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">Canvas</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="210">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc> has no peer because it is providing a layout behavior that is visual only.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc> has no peer because it is providing a layout behavior that is visual only.</target>
        </segment>
      </unit>
      <unit id="211">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">There is no accessibility-relevant way for the user to interact with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc>.</source>
          <target xml:space="preserve">There is no accessibility-relevant way for the user to interact with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc>.</target>
        </segment>
      </unit>
      <unit id="212">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Whatever child elements a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc> contains are instead reported to UI Automation trees as child elements of the next available parent in the tree that has a peer or element representation.</source>
          <target xml:space="preserve">Whatever child elements a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Panel</pc> contains are instead reported to UI Automation trees as child elements of the next available parent in the tree that has a peer or element representation.</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source xml:space="preserve">UI Automation and UWP process boundaries</source>
          <target xml:space="preserve">UI Automation and UWP process boundaries</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source xml:space="preserve">Typically, UI Automation client code that accesses a UWP app runs out-of-process.</source>
          <target xml:space="preserve">Typically, UI Automation client code that accesses a UWP app runs out-of-process.</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source xml:space="preserve">The UI Automation framework infrastructure enables information to get across the process boundary.</source>
          <target xml:space="preserve">The UI Automation framework infrastructure enables information to get across the process boundary.</target>
        </segment>
      </unit>
      <unit id="216">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee684007)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This concept is explained in more detail in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Fundamentals</pc>.</source>
          <target xml:space="preserve">This concept is explained in more detail in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">UI Automation Fundamentals</pc>.</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source xml:space="preserve">OnCreateAutomationPeer</source>
          <target xml:space="preserve">OnCreateAutomationPeer</target>
        </segment>
      </unit>
      <unit id="218">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">All classes that derive from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> contain the protected virtual method <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnCreateAutomationPeer</pc></pc>.</source>
          <target xml:space="preserve">All classes that derive from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElement</pc></pc> contain the protected virtual method <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnCreateAutomationPeer</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="219">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The object initialization sequence for automation peers calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OnCreateAutomationPeer</pc> to get the automation peer object for each control and thus to construct a UI Automation tree for run-time use.</source>
          <target xml:space="preserve">The object initialization sequence for automation peers calls <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OnCreateAutomationPeer</pc> to get the automation peer object for each control and thus to construct a UI Automation tree for run-time use.</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source xml:space="preserve">UI Automation code can use the peer to get information about a control’s characteristics and features and to simulate interactive use by means of its control patterns.</source>
          <target xml:space="preserve">UI Automation code can use the peer to get information about a control’s characteristics and features and to simulate interactive use by means of its control patterns.</target>
        </segment>
      </unit>
      <unit id="221">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A custom control that supports automation must override <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OnCreateAutomationPeer</pc> and return an instance of a class that derives from <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationPeer</pc></pc>.</source>
          <target xml:space="preserve">A custom control that supports automation must override <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OnCreateAutomationPeer</pc> and return an instance of a class that derives from <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationPeer</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="222">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227736)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR242460)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, if a custom control derives from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ButtonBase</pc></pc> class, the object returned by <pc dataRefEnd="id6" dataRefStart="id5" id="p3">OnCreateAutomationPeer</pc> should derive from <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ButtonBaseAutomationPeer</pc></pc>.</source>
          <target xml:space="preserve">For example, if a custom control derives from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ButtonBase</pc></pc> class, the object returned by <pc dataRefEnd="id6" dataRefStart="id5" id="p3">OnCreateAutomationPeer</pc> should derive from <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">ButtonBaseAutomationPeer</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="223">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you're writing a custom control class and intend to also supply a new automation peer, you should override the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnCreateAutomationPeer</pc></pc> method for your custom control so that it returns a new instance of your peer.</source>
          <target xml:space="preserve">If you're writing a custom control class and intend to also supply a new automation peer, you should override the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnCreateAutomationPeer</pc></pc> method for your custom control so that it returns a new instance of your peer.</target>
        </segment>
      </unit>
      <unit id="224">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Your peer class must derive directly or indirectly from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc>.</source>
          <target xml:space="preserve">Your peer class must derive directly or indirectly from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source xml:space="preserve">For example, the following code declares that the custom control 'NumericUpDown' should use the peer 'NumericUpDownPeer' for UI Automation purposes.</source>
          <target xml:space="preserve">For example, the following code declares that the custom control 'NumericUpDown' should use the peer 'NumericUpDownPeer' for UI Automation purposes.</target>
        </segment>
      </unit>
      <unit id="226">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">OnCreateAutomationPeer</pc></pc> implementation should do nothing more than initialize a new instance of your custom automation peer, passing the calling control as owner, and return that instance.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">OnCreateAutomationPeer</pc></pc> implementation should do nothing more than initialize a new instance of your custom automation peer, passing the calling control as owner, and return that instance.</target>
        </segment>
      </unit>
      <unit id="227">
        <segment state="initial">
          <source xml:space="preserve">Do not attempt additional logic in this method.</source>
          <target xml:space="preserve">Do not attempt additional logic in this method.</target>
        </segment>
      </unit>
      <unit id="228">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In particular, any logic that could potentially lead to destruction of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> within the same call may result in unexpected runtime behavior.</source>
          <target xml:space="preserve">In particular, any logic that could potentially lead to destruction of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> within the same call may result in unexpected runtime behavior.</target>
        </segment>
      </unit>
      <unit id="229">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">*</data>
          <data id="id6">*</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In typical implementations of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnCreateAutomationPeer</pc></pc>, the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">owner</pc> is specified as <pc dataRefEnd="id8" dataRefStart="id7" id="p4">this</pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Me</pc> because the method override is in the same scope as the rest of the control class definition.</source>
          <target xml:space="preserve">In typical implementations of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnCreateAutomationPeer</pc></pc>, the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">owner</pc> is specified as <pc dataRefEnd="id8" dataRefStart="id7" id="p4">this</pc> or <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Me</pc> because the method override is in the same scope as the rest of the control class definition.</target>
        </segment>
      </unit>
      <unit id="230">
        <segment state="initial">
          <source xml:space="preserve">The actual peer class definition can be done in the same code file as the control or in a separate code file.</source>
          <target xml:space="preserve">The actual peer class definition can be done in the same code file as the control or in a separate code file.</target>
        </segment>
      </unit>
      <unit id="231">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242563)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The peer definitions all exist in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Peers</pc></pc> namespace that is a separate namespace from the controls that they provide peers for.</source>
          <target xml:space="preserve">The peer definitions all exist in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Peers</pc></pc> namespace that is a separate namespace from the controls that they provide peers for.</target>
        </segment>
      </unit>
      <unit id="232">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can choose to declare your peers in separate namespaces also, as long as you reference the necessary namespaces for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnCreateAutomationPeer</pc></pc> method call.</source>
          <target xml:space="preserve">You can choose to declare your peers in separate namespaces also, as long as you reference the necessary namespaces for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnCreateAutomationPeer</pc></pc> method call.</target>
        </segment>
      </unit>
      <unit id="233">
        <segment state="initial">
          <source xml:space="preserve">Choosing the correct peer base class</source>
          <target xml:space="preserve">Choosing the correct peer base class</target>
        </segment>
      </unit>
      <unit id="234">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Make sure that your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> is derived from a base class that gives you the best match for the existing peer logic of the control class you are deriving from.</source>
          <target xml:space="preserve">Make sure that your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> is derived from a base class that gives you the best match for the existing peer logic of the control class you are deriving from.</target>
        </segment>
      </unit>
      <unit id="235">
        <originalData>
          <data id="id1">`NumericUpDown`</data>
          <data id="id2">[</data>
          <data id="id3">](https://msdn.microsoft.com/library/windows/apps/BR227863)</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">[</data>
          <data id="id7">](https://msdn.microsoft.com/library/windows/apps/BR242506)</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In the case of the previous example, because <ph dataRef="id1" id="ph1" /> derives from <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">RangeBase</pc></pc>, there is a <pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">RangeBaseAutomationPeer</pc></pc> class available that you should base your peer on.</source>
          <target xml:space="preserve">In the case of the previous example, because <ph dataRef="id1" id="ph1" /> derives from <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">RangeBase</pc></pc>, there is a <pc dataRefEnd="id7" dataRefStart="id6" id="p3"><pc dataRefEnd="id9" dataRefStart="id8" id="p4">RangeBaseAutomationPeer</pc></pc> class available that you should base your peer on.</target>
        </segment>
      </unit>
      <unit id="236">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242590)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">By using the closest matching peer class in parallel to how you derive the control itself, you can avoid overriding at least some of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IRangeValueProvider</pc></pc> functionality because the base peer class already implements it.</source>
          <target xml:space="preserve">By using the closest matching peer class in parallel to how you derive the control itself, you can avoid overriding at least some of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IRangeValueProvider</pc></pc> functionality because the base peer class already implements it.</target>
        </segment>
      </unit>
      <unit id="237">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209390)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The base <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control</pc></pc> class does not have a corresponding peer class.</source>
          <target xml:space="preserve">The base <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control</pc></pc> class does not have a corresponding peer class.</target>
        </segment>
      </unit>
      <unit id="238">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you need a peer class to correspond to a custom control that derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Control</pc>, derive the custom peer class from <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElementAutomationPeer</pc></pc>.</source>
          <target xml:space="preserve">If you need a peer class to correspond to a custom control that derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Control</pc>, derive the custom peer class from <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElementAutomationPeer</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="239">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209365)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911_oncreateautomationpeer)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you derive from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentControl</pc></pc> directly, that class has no default automation peer behavior because there is no <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnCreateAutomationPeer</pc></pc> implementation that references a peer class.</source>
          <target xml:space="preserve">If you derive from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentControl</pc></pc> directly, that class has no default automation peer behavior because there is no <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnCreateAutomationPeer</pc></pc> implementation that references a peer class.</target>
        </segment>
      </unit>
      <unit id="240">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">So make sure either to implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OnCreateAutomationPeer</pc> to use your own peer, or to use <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElementAutomationPeer</pc></pc> as the peer if that level of accessibility support is adequate for your control.</source>
          <target xml:space="preserve">So make sure either to implement <pc dataRefEnd="id2" dataRefStart="id1" id="p1">OnCreateAutomationPeer</pc> to use your own peer, or to use <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElementAutomationPeer</pc></pc> as the peer if that level of accessibility support is adequate for your control.</target>
        </segment>
      </unit>
      <unit id="241">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  You don't typically derive from <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationPeer</pc></pc> rather than <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">FrameworkElementAutomationPeer</pc></pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  You don't typically derive from <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationPeer</pc></pc> rather than <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">FrameworkElementAutomationPeer</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="242">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you did derive directly from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationPeer</pc> you'll need to duplicate a lot of basic accessibility support that would otherwise come from <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElementAutomationPeer</pc>.</source>
          <target xml:space="preserve">If you did derive directly from <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationPeer</pc> you'll need to duplicate a lot of basic accessibility support that would otherwise come from <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElementAutomationPeer</pc>.</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source xml:space="preserve">Initialization of a custom peer class</source>
          <target xml:space="preserve">Initialization of a custom peer class</target>
        </segment>
      </unit>
      <unit id="244">
        <segment state="initial">
          <source xml:space="preserve">The automation peer should define a type-safe constructor that uses an instance of the owner control for base initialization.</source>
          <target xml:space="preserve">The automation peer should define a type-safe constructor that uses an instance of the owner control for base initialization.</target>
        </segment>
      </unit>
      <unit id="245">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242506)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">*</data>
          <data id="id12">*</data>
          <data id="id13">[</data>
          <data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242472_owner)</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In the next example, the implementation passes the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">owner</pc> value on to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">RangeBaseAutomationPeer</pc></pc> base, and ultimately it is the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">FrameworkElementAutomationPeer</pc></pc> that actually uses <pc dataRefEnd="id12" dataRefStart="id11" id="p6">owner</pc> to set <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">FrameworkElementAutomationPeer.Owner</pc></pc>.</source>
          <target xml:space="preserve">In the next example, the implementation passes the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">owner</pc> value on to the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">RangeBaseAutomationPeer</pc></pc> base, and ultimately it is the <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">FrameworkElementAutomationPeer</pc></pc> that actually uses <pc dataRefEnd="id12" dataRefStart="id11" id="p6">owner</pc> to set <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">FrameworkElementAutomationPeer.Owner</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="246">
        <segment state="initial">
          <source xml:space="preserve">Core methods of AutomationPeer</source>
          <target xml:space="preserve">Core methods of AutomationPeer</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source xml:space="preserve">For UWP infrastructure reasons, the overridable methods of an automation peer are part of a pair of methods: the public access method that the UI Automation provider uses as a forwarding point for UI Automation clients, and the protected "Core" customization method that a UWP class can override to influence the behavior.</source>
          <target xml:space="preserve">For UWP infrastructure reasons, the overridable methods of an automation peer are part of a pair of methods: the public access method that the UI Automation provider uses as a forwarding point for UI Automation clients, and the protected "Core" customization method that a UWP class can override to influence the behavior.</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source xml:space="preserve">The method pair is wired together by default in such a way that the call to the access method always invokes the parallel "Core" method that has the provider implementation, or as a fallback, invokes a default implementation from the base classes.</source>
          <target xml:space="preserve">The method pair is wired together by default in such a way that the call to the access method always invokes the parallel "Core" method that has the provider implementation, or as a fallback, invokes a default implementation from the base classes.</target>
        </segment>
      </unit>
      <unit id="249">
        <segment state="initial">
          <source xml:space="preserve">When implementing a peer for a custom control, override any of the "Core" methods from the base automation peer class where you want to expose behavior that is unique to your custom control.</source>
          <target xml:space="preserve">When implementing a peer for a custom control, override any of the "Core" methods from the base automation peer class where you want to expose behavior that is unique to your custom control.</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source xml:space="preserve">UI Automation code gets information about your control by calling public methods of the peer class.</source>
          <target xml:space="preserve">UI Automation code gets information about your control by calling public methods of the peer class.</target>
        </segment>
      </unit>
      <unit id="251">
        <segment state="initial">
          <source xml:space="preserve">To provide information about your control, override each method with a name that ends with "Core" when your control implementation and design creates accessibility scenarios or other UI Automation scenarios that differ from what's supported by the base automation peer class.</source>
          <target xml:space="preserve">To provide information about your control, override each method with a name that ends with "Core" when your control implementation and design creates accessibility scenarios or other UI Automation scenarios that differ from what's supported by the base automation peer class.</target>
        </segment>
      </unit>
      <unit id="252">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getclassnamecore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">At a minimum, whenever you define a new peer class, implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetClassNameCore</pc></pc> method, as shown in the next example.</source>
          <target xml:space="preserve">At a minimum, whenever you define a new peer class, implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetClassNameCore</pc></pc> method, as shown in the next example.</target>
        </segment>
      </unit>
      <unit id="253">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  You might want to store the strings as constants rather than directly in the method body, but that is up to you.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  You might want to store the strings as constants rather than directly in the method body, but that is up to you.</target>
        </segment>
      </unit>
      <unit id="254">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getclassnamecore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetClassNameCore</pc></pc>, you won't need to localize this string.</source>
          <target xml:space="preserve">For <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetClassNameCore</pc></pc>, you won't need to localize this string.</target>
        </segment>
      </unit>
      <unit id="255">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LocalizedControlType</pc> property is used any time a localized string is needed by a UI Automation client, not <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClassName</pc>.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LocalizedControlType</pc> property is used any time a localized string is needed by a UI Automation client, not <pc dataRefEnd="id4" dataRefStart="id3" id="p2">ClassName</pc>.</target>
        </segment>
      </unit>
      <unit id="256">
        <segment state="initial">
          <source xml:space="preserve">GetAutomationControlType</source>
          <target xml:space="preserve">GetAutomationControlType</target>
        </segment>
      </unit>
      <unit id="257">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getautomationcontroltype)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Some assistive technologies use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAutomationControlType</pc></pc> value directly when reporting characteristics of the items in a UI Automation tree, as additional information beyond the UI Automation <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Name</pc>.</source>
          <target xml:space="preserve">Some assistive technologies use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAutomationControlType</pc></pc> value directly when reporting characteristics of the items in a UI Automation tree, as additional information beyond the UI Automation <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Name</pc>.</target>
        </segment>
      </unit>
      <unit id="258">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getautomationcontroltypecore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If your control is significantly different from the control you are deriving from and you want to report a different control type from what is reported by the base peer class used by the control, you must implement a peer and override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAutomationControlTypeCore</pc></pc> in your peer implementation.</source>
          <target xml:space="preserve">If your control is significantly different from the control you are deriving from and you want to report a different control type from what is reported by the base peer class used by the control, you must implement a peer and override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAutomationControlTypeCore</pc></pc> in your peer implementation.</target>
        </segment>
      </unit>
      <unit id="259">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209365)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This is particularly important if you derive from a generalized base class such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ContentControl</pc></pc>, where the base peer doesn't provide precise information about control type.</source>
          <target xml:space="preserve">This is particularly important if you derive from a generalized base class such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ContentControl</pc></pc>, where the base peer doesn't provide precise information about control type.</target>
        </segment>
      </unit>
      <unit id="260">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getautomationcontroltypecore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209182)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Your implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAutomationControlTypeCore</pc></pc> describes your control by returning an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AutomationControlType</pc></pc> value.</source>
          <target xml:space="preserve">Your implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAutomationControlTypeCore</pc></pc> describes your control by returning an <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AutomationControlType</pc></pc> value.</target>
        </segment>
      </unit>
      <unit id="261">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Although you can return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationControlType.Custom</pc>, you should return one of the more specific control types if it accurately describes your control's main scenarios.</source>
          <target xml:space="preserve">Although you can return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationControlType.Custom</pc>, you should return one of the more specific control types if it accurately describes your control's main scenarios.</target>
        </segment>
      </unit>
      <unit id="262">
        <segment state="initial">
          <source xml:space="preserve">Here's an example.</source>
          <target xml:space="preserve">Here's an example.</target>
        </segment>
      </unit>
      <unit id="263">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209182)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR209185_getlocalizedcontroltypecore)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Unless you specify <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationControlType.Custom</pc></pc>, you don't have to implement <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">GetLocalizedControlTypeCore</pc></pc> to provide a <pc dataRefEnd="id12" dataRefStart="id11" id="p6">LocalizedControlType</pc> property value to clients.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Unless you specify <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationControlType.Custom</pc></pc>, you don't have to implement <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">GetLocalizedControlTypeCore</pc></pc> to provide a <pc dataRefEnd="id12" dataRefStart="id11" id="p6">LocalizedControlType</pc> property value to clients.</target>
        </segment>
      </unit>
      <unit id="264">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">UI Automation common infrastructure provides translated strings for every possible <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationControlType</pc> value other than <pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationControlType.Custom</pc>.</source>
          <target xml:space="preserve">UI Automation common infrastructure provides translated strings for every possible <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationControlType</pc> value other than <pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationControlType.Custom</pc>.</target>
        </segment>
      </unit>
      <unit id="265">
        <segment state="initial">
          <source xml:space="preserve">GetPattern and GetPatternCore</source>
          <target xml:space="preserve">GetPattern and GetPatternCore</target>
        </segment>
      </unit>
      <unit id="266">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A peer's implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> returns the object that supports the pattern that is requested in the input parameter.</source>
          <target xml:space="preserve">A peer's implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> returns the object that supports the pattern that is requested in the input parameter.</target>
        </segment>
      </unit>
      <unit id="267">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpattern)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Specifically, a UI Automation client calls a method that is forwarded to the provider's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> method, and specifies a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PatternInterface</pc></pc> enumeration value that names the requested pattern.</source>
          <target xml:space="preserve">Specifically, a UI Automation client calls a method that is forwarded to the provider's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> method, and specifies a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PatternInterface</pc></pc> enumeration value that names the requested pattern.</target>
        </segment>
      </unit>
      <unit id="268">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Your override of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPatternCore</pc> should return the object that implements the specified pattern.</source>
          <target xml:space="preserve">Your override of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPatternCore</pc> should return the object that implements the specified pattern.</target>
        </segment>
      </unit>
      <unit id="269">
        <segment state="initial">
          <source xml:space="preserve">That object is the peer itself, because the peer should implement the corresponding pattern interface any time that it reports that it supports a pattern.</source>
          <target xml:space="preserve">That object is the peer itself, because the peer should implement the corresponding pattern interface any time that it reports that it supports a pattern.</target>
        </segment>
      </unit>
      <unit id="270">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If your peer does not have a custom implementation of a pattern, but you know that the peer's base does implement the pattern, you can call the base type's implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPatternCore</pc> from your <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc>.</source>
          <target xml:space="preserve">If your peer does not have a custom implementation of a pattern, but you know that the peer's base does implement the pattern, you can call the base type's implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPatternCore</pc> from your <pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc>.</target>
        </segment>
      </unit>
      <unit id="271">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A peer's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPatternCore</pc> should return <pc dataRefEnd="id4" dataRefStart="id3" id="p2">null</pc> if a pattern is not supported by the peer.</source>
          <target xml:space="preserve">A peer's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetPatternCore</pc> should return <pc dataRefEnd="id4" dataRefStart="id3" id="p2">null</pc> if a pattern is not supported by the peer.</target>
        </segment>
      </unit>
      <unit id="272">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">However, instead of returning <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> directly from your implementation, you would usually rely on the call to the base implementation to return <pc dataRefEnd="id4" dataRefStart="id3" id="p2">null</pc> for any unsupported pattern.</source>
          <target xml:space="preserve">However, instead of returning <pc dataRefEnd="id2" dataRefStart="id1" id="p1">null</pc> directly from your implementation, you would usually rely on the call to the base implementation to return <pc dataRefEnd="id4" dataRefStart="id3" id="p2">null</pc> for any unsupported pattern.</target>
        </segment>
      </unit>
      <unit id="273">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When a pattern is supported, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> implementation can return <pc dataRefEnd="id6" dataRefStart="id5" id="p3">this</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Me</pc>.</source>
          <target xml:space="preserve">When a pattern is supported, the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> implementation can return <pc dataRefEnd="id6" dataRefStart="id5" id="p3">this</pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Me</pc>.</target>
        </segment>
      </unit>
      <unit id="274">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpattern)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The expectation is that the UI Automation client will cast the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> return value to the requested pattern interface whenever it is not <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.</source>
          <target xml:space="preserve">The expectation is that the UI Automation client will cast the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> return value to the requested pattern interface whenever it is not <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc>.</target>
        </segment>
      </unit>
      <unit id="275">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If a peer class inherits from another peer, and all necessary support and pattern reporting is already handled by the base class, implementing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> isn't necessary.</source>
          <target xml:space="preserve">If a peer class inherits from another peer, and all necessary support and pattern reporting is already handled by the base class, implementing <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> isn't necessary.</target>
        </segment>
      </unit>
      <unit id="276">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227863)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242506)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">[</data>
          <data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242590)</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, if you are implementing a range control that derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RangeBase</pc></pc>, and your peer derives from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RangeBaseAutomationPeer</pc></pc>, that peer returns itself for <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PatternInterface.RangeValue</pc></pc> and has working implementations of the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">IRangeValueProvider</pc></pc> interface that supports the pattern.</source>
          <target xml:space="preserve">For example, if you are implementing a range control that derives from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RangeBase</pc></pc>, and your peer derives from <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RangeBaseAutomationPeer</pc></pc>, that peer returns itself for <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">PatternInterface.RangeValue</pc></pc> and has working implementations of the <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">IRangeValueProvider</pc></pc> interface that supports the pattern.</target>
        </segment>
      </unit>
      <unit id="277">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242506)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Although it is not the literal code, this example approximates the implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> already present in <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RangeBaseAutomationPeer</pc></pc>.</source>
          <target xml:space="preserve">Although it is not the literal code, this example approximates the implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> already present in <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">RangeBaseAutomationPeer</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="278">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you are implementing a peer where you don't have all the support you need from a base peer class, or you want to change or add to the set of base-inherited patterns that your peer can support, then you should override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> to enable UI Automation clients to use the patterns.</source>
          <target xml:space="preserve">If you are implementing a peer where you don't have all the support you need from a base peer class, or you want to change or add to the set of base-inherited patterns that your peer can support, then you should override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> to enable UI Automation clients to use the patterns.</target>
        </segment>
      </unit>
      <unit id="279">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209225)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For a list of the provider patterns that are available in the UWP implementation of UI Automation support, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Provider</pc></pc>.</source>
          <target xml:space="preserve">For a list of the provider patterns that are available in the UWP implementation of UI Automation support, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.UI.Xaml.Automation.Provider</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="280">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpattern)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Each such pattern has a corresponding value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PatternInterface</pc></pc> enumeration, which is how UI Automation clients request the pattern in a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetPattern</pc></pc> call.</source>
          <target xml:space="preserve">Each such pattern has a corresponding value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PatternInterface</pc></pc> enumeration, which is how UI Automation clients request the pattern in a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetPattern</pc></pc> call.</target>
        </segment>
      </unit>
      <unit id="281">
        <segment state="initial">
          <source xml:space="preserve">A peer can report that it supports more than one pattern.</source>
          <target xml:space="preserve">A peer can report that it supports more than one pattern.</target>
        </segment>
      </unit>
      <unit id="282">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If so, the override should include return path logic for each supported <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PatternInterface</pc></pc> value and return the peer in each matching case.</source>
          <target xml:space="preserve">If so, the override should include return path logic for each supported <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PatternInterface</pc></pc> value and return the peer in each matching case.</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source xml:space="preserve">It is expected that the caller will request only one interface at a time, and it is up to the caller to cast to the expected interface.</source>
          <target xml:space="preserve">It is expected that the caller will request only one interface at a time, and it is up to the caller to cast to the expected interface.</target>
        </segment>
      </unit>
      <unit id="284">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Here's an example of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> override for a custom peer.</source>
          <target xml:space="preserve">Here's an example of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> override for a custom peer.</target>
        </segment>
      </unit>
      <unit id="285">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242590)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242653)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">It reports the support for two patterns, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IRangeValueProvider</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IToggleProvider</pc></pc>.</source>
          <target xml:space="preserve">It reports the support for two patterns, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IRangeValueProvider</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IToggleProvider</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="286">
        <segment state="initial">
          <source xml:space="preserve">The control here is a media display control that can display as full-screen (the toggle mode) and that has a progress bar within which users can select a position (the range control).</source>
          <target xml:space="preserve">The control here is a media display control that can display as full-screen (the toggle mode) and that has a progress bar within which users can select a position (the range control).</target>
        </segment>
      </unit>
      <unit id="287">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=238570)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This code came from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML accessibility sample</pc>.</source>
          <target xml:space="preserve">This code came from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML accessibility sample</pc>.</target>
        </segment>
      </unit>
      <unit id="288">
        <segment state="initial">
          <source xml:space="preserve">Forwarding patterns from subelements</source>
          <target xml:space="preserve">Forwarding patterns from subelements</target>
        </segment>
      </unit>
      <unit id="289">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> method implementation can also specify a subelement or part as a pattern provider for its host.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> method implementation can also specify a subelement or part as a pattern provider for its host.</target>
        </segment>
      </unit>
      <unit id="290">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242803)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209527)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This example mimics how <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> transfers scroll-pattern handling to the peer of its internal <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ScrollViewer</pc></pc> control.</source>
          <target xml:space="preserve">This example mimics how <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ItemsControl</pc></pc> transfers scroll-pattern handling to the peer of its internal <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ScrollViewer</pc></pc> control.</target>
        </segment>
      </unit>
      <unit id="291">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242472_createpeerforelement)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To specify a subelement for pattern handling, this code gets the subelement object, creates a peer for the subelement by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.CreatePeerForElement</pc></pc> method, and returns the new peer.</source>
          <target xml:space="preserve">To specify a subelement for pattern handling, this code gets the subelement object, creates a peer for the subelement by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.CreatePeerForElement</pc></pc> method, and returns the new peer.</target>
        </segment>
      </unit>
      <unit id="292">
        <segment state="initial">
          <source xml:space="preserve">Other Core methods</source>
          <target xml:space="preserve">Other Core methods</target>
        </segment>
      </unit>
      <unit id="293">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](keyboard-accessibility.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Your control may need to support keyboard equivalents for primary scenarios; for more info about why this might be necessary, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keyboard accessibility</pc>.</source>
          <target xml:space="preserve">Your control may need to support keyboard equivalents for primary scenarios; for more info about why this might be necessary, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keyboard accessibility</pc>.</target>
        </segment>
      </unit>
      <unit id="294">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getacceleratorkeycore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getaccesskeycore)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Implementing the key support is necessarily part of the control code and not the peer code because that is part of a control's logic, but your peer class should override the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAcceleratorKeyCore</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetAccessKeyCore</pc></pc> methods to report to UI Automation clients which keys are used.</source>
          <target xml:space="preserve">Implementing the key support is necessarily part of the control code and not the peer code because that is part of a control's logic, but your peer class should override the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetAcceleratorKeyCore</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetAccessKeyCore</pc></pc> methods to report to UI Automation clients which keys are used.</target>
        </segment>
      </unit>
      <unit id="295">
        <segment state="initial">
          <source xml:space="preserve">Consider that the strings that report key information might need to be localized, and should therefore come from resources, not hard-coded strings.</source>
          <target xml:space="preserve">Consider that the strings that report key information might need to be localized, and should therefore come from resources, not hard-coded strings.</target>
        </segment>
      </unit>
      <unit id="296">
        <segment state="initial">
          <source xml:space="preserve">If you are providing a peer for a class that supports a collection, it's best to derive from both functional classes and peer classes that already have that kind of collection support.</source>
          <target xml:space="preserve">If you are providing a peer for a class that supports a collection, it's best to derive from both functional classes and peer classes that already have that kind of collection support.</target>
        </segment>
      </unit>
      <unit id="297">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getchildrencore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you can't do so, peers for controls that maintain child collections may have to override the collection-related peer method <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetChildrenCore</pc></pc> to properly report the parent-child relationships to the UI Automation tree.</source>
          <target xml:space="preserve">If you can't do so, peers for controls that maintain child collections may have to override the collection-related peer method <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetChildrenCore</pc></pc> to properly report the parent-child relationships to the UI Automation tree.</target>
        </segment>
      </unit>
      <unit id="298">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_iscontentelementcore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_iscontrolelementcore)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsContentElementCore</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsControlElementCore</pc></pc> methods to indicate whether your control contains data content or fulfills an interactive role in the user interface (or both).</source>
          <target xml:space="preserve">Implement the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsContentElementCore</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsControlElementCore</pc></pc> methods to indicate whether your control contains data content or fulfills an interactive role in the user interface (or both).</target>
        </segment>
      </unit>
      <unit id="299">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">By default, both methods return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc>.</source>
          <target xml:space="preserve">By default, both methods return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc>.</target>
        </segment>
      </unit>
      <unit id="300">
        <segment state="initial">
          <source xml:space="preserve">These settings improve the usability of assistive technologies such as screen readers, which may use these methods to filter the automation tree.</source>
          <target xml:space="preserve">These settings improve the usability of assistive technologies such as screen readers, which may use these methods to filter the automation tree.</target>
        </segment>
      </unit>
      <unit id="301">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpatterncore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> method transfers pattern handling to a subelement peer, the subelement peer's <pc dataRefEnd="id6" dataRefStart="id5" id="p3">IsControlElementCore</pc> method can return <pc dataRefEnd="id8" dataRefStart="id7" id="p4">false</pc> to hide the subelement peer from the automation tree.</source>
          <target xml:space="preserve">If your <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPatternCore</pc></pc> method transfers pattern handling to a subelement peer, the subelement peer's <pc dataRefEnd="id6" dataRefStart="id5" id="p3">IsControlElementCore</pc> method can return <pc dataRefEnd="id8" dataRefStart="id7" id="p4">false</pc> to hide the subelement peer from the automation tree.</target>
        </segment>
      </unit>
      <unit id="302">
        <segment state="initial">
          <source xml:space="preserve">Some controls may support labeling scenarios, where a text label part supplies information for a non-text part, or a control is intended to be in a known labeling relationship with another control in the UI.</source>
          <target xml:space="preserve">Some controls may support labeling scenarios, where a text label part supplies information for a non-text part, or a control is intended to be in a known labeling relationship with another control in the UI.</target>
        </segment>
      </unit>
      <unit id="303">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getlabeledbycore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If it's possible to provide a useful class-based behavior, you can override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetLabeledByCore</pc></pc> to provide this behavior.</source>
          <target xml:space="preserve">If it's possible to provide a useful class-based behavior, you can override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetLabeledByCore</pc></pc> to provide this behavior.</target>
        </segment>
      </unit>
      <unit id="304">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getboundingrectanglecore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getclickablepointcore)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetBoundingRectangleCore</pc>
						</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetClickablePointCore</pc></pc> are used mainly for automated testing scenarios.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetBoundingRectangleCore</pc>
						</pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetClickablePointCore</pc></pc> are used mainly for automated testing scenarios.</target>
        </segment>
      </unit>
      <unit id="305">
        <segment state="initial">
          <source xml:space="preserve">If you want to support automated testing for your control, you might want to override these methods.</source>
          <target xml:space="preserve">If you want to support automated testing for your control, you might want to override these methods.</target>
        </segment>
      </unit>
      <unit id="306">
        <segment state="initial">
          <source xml:space="preserve">This might be desired for range-type controls, where you can't suggest just a single point because where the user clicks in coordinate space has a different effect on a range.</source>
          <target xml:space="preserve">This might be desired for range-type controls, where you can't suggest just a single point because where the user clicks in coordinate space has a different effect on a range.</target>
        </segment>
      </unit>
      <unit id="307">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209745)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR225870)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, the default <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollBar</pc></pc> automation peer overrides <pc dataRefEnd="id6" dataRefStart="id5" id="p3">GetClickablePointCore</pc> to return a "not a number" <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Point</pc></pc> value.</source>
          <target xml:space="preserve">For example, the default <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollBar</pc></pc> automation peer overrides <pc dataRefEnd="id6" dataRefStart="id5" id="p3">GetClickablePointCore</pc> to return a "not a number" <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Point</pc></pc> value.</target>
        </segment>
      </unit>
      <unit id="308">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getlivesettingcore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetLiveSettingCore</pc>
						</pc> influences the control default for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">LiveSetting</pc> value for UI Automation.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetLiveSettingCore</pc>
						</pc> influences the control default for the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">LiveSetting</pc> value for UI Automation.</target>
        </segment>
      </unit>
      <unit id="309">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/JJ191519)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You might want to override this if you want your control to return a value other than <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationLiveSetting.Off</pc></pc>.</source>
          <target xml:space="preserve">You might want to override this if you want your control to return a value other than <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationLiveSetting.Off</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="310">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/JJ191516)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on what <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LiveSetting</pc> represents, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationProperties.LiveSetting</pc></pc>.</source>
          <target xml:space="preserve">For more info on what <pc dataRefEnd="id2" dataRefStart="id1" id="p1">LiveSetting</pc> represents, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationProperties.LiveSetting</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="311">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getorientationcore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209184)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You might override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetOrientationCore</pc></pc> if your control has a settable orientation property that can map to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AutomationOrientation</pc></pc>.</source>
          <target xml:space="preserve">You might override <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetOrientationCore</pc></pc> if your control has a settable orientation property that can map to <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">AutomationOrientation</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="312">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242522)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242546)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollBarAutomationPeer</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SliderAutomationPeer</pc></pc> classes do this.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ScrollBarAutomationPeer</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">SliderAutomationPeer</pc></pc> classes do this.</target>
        </segment>
      </unit>
      <unit id="313">
        <segment state="initial">
          <source xml:space="preserve">Base implementation in FrameworkElementAutomationPeer</source>
          <target xml:space="preserve">Base implementation in FrameworkElementAutomationPeer</target>
        </segment>
      </unit>
      <unit id="314">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The base implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElementAutomationPeer</pc></pc> provides some UI Automation information that can be interpreted from various layout and behavior properties that are defined at the framework level.</source>
          <target xml:space="preserve">The base implementation of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElementAutomationPeer</pc></pc> provides some UI Automation information that can be interpreted from various layout and behavior properties that are defined at the framework level.</target>
        </segment>
      </unit>
      <unit id="315">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getboundingrectanglecore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR225994)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetBoundingRectangleCore</pc>
						</pc>: Returns a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Rect</pc></pc> structure based on the known layout characteristics.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetBoundingRectangleCore</pc>
						</pc>: Returns a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Rect</pc></pc> structure based on the known layout characteristics.</target>
        </segment>
      </unit>
      <unit id="316">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR209185_isoffscreen)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Returns a 0-value <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Rect</pc> if <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IsOffscreen</pc></pc> is <pc dataRefEnd="id8" dataRefStart="id7" id="p4">true</pc>.</source>
          <target xml:space="preserve">Returns a 0-value <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Rect</pc> if <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">IsOffscreen</pc></pc> is <pc dataRefEnd="id8" dataRefStart="id7" id="p4">true</pc>.</target>
        </segment>
      </unit>
      <unit id="317">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getclickablepointcore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR225870)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetClickablePointCore</pc>
						</pc>: Returns a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Point</pc></pc> structure based on the known layout characteristics, as long as there is a nonzero <pc dataRefEnd="id10" dataRefStart="id9" id="p5">BoundingRectangle</pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetClickablePointCore</pc>
						</pc>: Returns a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Point</pc></pc> structure based on the known layout characteristics, as long as there is a nonzero <pc dataRefEnd="id10" dataRefStart="id9" id="p5">BoundingRectangle</pc>.</target>
        </segment>
      </unit>
      <unit id="318">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getnamecore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getnamecore)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetNameCore</pc>
						</pc>: More extensive behavior than can be summarized here; see <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetNameCore</pc></pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetNameCore</pc>
						</pc>: More extensive behavior than can be summarized here; see <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetNameCore</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="319">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209365)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Basically, it attempts a string conversion on any known content of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentControl</pc></pc> or related classes that have content.</source>
          <target xml:space="preserve">Basically, it attempts a string conversion on any known content of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ContentControl</pc></pc> or related classes that have content.</target>
        </segment>
      </unit>
      <unit id="320">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh759769)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Also, if there is a value for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">LabeledBy</pc></pc>, that item's <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Name</pc> value is used as the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Name</pc>.</source>
          <target xml:space="preserve">Also, if there is a value for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">LabeledBy</pc></pc>, that item's <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Name</pc> value is used as the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Name</pc>.</target>
        </segment>
      </unit>
      <unit id="321">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_haskeyboardfocuscore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209390_focusstate)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209390_isenabled)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">HasKeyboardFocusCore</pc>
						</pc>: Evaluated based on the owner's <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FocusState</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IsEnabled</pc></pc> properties.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">HasKeyboardFocusCore</pc>
						</pc>: Evaluated based on the owner's <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FocusState</pc></pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IsEnabled</pc></pc> properties.</target>
        </segment>
      </unit>
      <unit id="322">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Elements that aren't controls always return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">false</pc>.</source>
          <target xml:space="preserve">Elements that aren't controls always return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">false</pc>.</target>
        </segment>
      </unit>
      <unit id="323">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_isenabledcore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209390_isenabled)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209390)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsEnabledCore</pc>
						</pc>: Evaluated based on the owner's <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsEnabled</pc></pc> property if it is a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Control</pc></pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsEnabledCore</pc>
						</pc>: Evaluated based on the owner's <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsEnabled</pc></pc> property if it is a <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Control</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="324">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Elements that aren't controls always return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc>.</source>
          <target xml:space="preserve">Elements that aren't controls always return <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc>.</target>
        </segment>
      </unit>
      <unit id="325">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This doesn't mean that the owner is enabled in the conventional interaction sense; it means that the peer is enabled despite the owner not having an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsEnabled</pc> property.</source>
          <target xml:space="preserve">This doesn't mean that the owner is enabled in the conventional interaction sense; it means that the peer is enabled despite the owner not having an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">IsEnabled</pc> property.</target>
        </segment>
      </unit>
      <unit id="326">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_iskeyboardfocusablecore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/BR209390)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsKeyboardFocusableCore</pc>
						</pc>: Returns <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc> if owner is a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Control</pc></pc>; otherwise it is <pc dataRefEnd="id12" dataRefStart="id11" id="p6">false</pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsKeyboardFocusableCore</pc>
						</pc>: Returns <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc> if owner is a <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Control</pc></pc>; otherwise it is <pc dataRefEnd="id12" dataRefStart="id11" id="p6">false</pc>.</target>
        </segment>
      </unit>
      <unit id="327">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_isoffscreencore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208911_visibility)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR209006)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">**</data>
          <data id="id14">**</data>
          <data id="id15">[</data>
          <data id="id16">](https://msdn.microsoft.com/library/windows/apps/BR209185_isoffscreen)</data>
          <data id="id17">**</data>
          <data id="id18">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsOffscreenCore</pc>
						</pc>: A <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visibility</pc></pc> of <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Hidden</pc></pc> on the owner element or any of its parents equates to a <pc dataRefEnd="id14" dataRefStart="id13" id="p7">true</pc> value for <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">IsOffscreen</pc></pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsOffscreenCore</pc>
						</pc>: A <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visibility</pc></pc> of <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">Hidden</pc></pc> on the owner element or any of its parents equates to a <pc dataRefEnd="id14" dataRefStart="id13" id="p7">true</pc> value for <pc dataRefEnd="id16" dataRefStart="id15" id="p8"><pc dataRefEnd="id18" dataRefStart="id17" id="p9">IsOffscreen</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="328">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227842)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Exception: a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Popup</pc></pc> object can be visible even if its owner's parents are not.</source>
          <target xml:space="preserve">Exception: a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Popup</pc></pc> object can be visible even if its owner's parents are not.</target>
        </segment>
      </unit>
      <unit id="329">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_setfocuscore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209390_focus)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetFocusCore</pc>
						</pc>: Calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Focus</pc></pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">SetFocusCore</pc>
						</pc>: Calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Focus</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="330">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getparent)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208739)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetParent</pc>
						</pc>: Calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement.Parent</pc></pc> from the owner, and looks up the appropriate peer.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetParent</pc>
						</pc>: Calls <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">FrameworkElement.Parent</pc></pc> from the owner, and looks up the appropriate peer.</target>
        </segment>
      </unit>
      <unit id="331">
        <segment state="initial">
          <source xml:space="preserve">This isn't an override pair with a "Core" method, so you can't change this behavior.</source>
          <target xml:space="preserve">This isn't an override pair with a "Core" method, so you can't change this behavior.</target>
        </segment>
      </unit>
      <unit id="332">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Default UWP peers implement a behavior by using internal native code that implements the UWP, not necessarily by using actual UWP code.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Default UWP peers implement a behavior by using internal native code that implements the UWP, not necessarily by using actual UWP code.</target>
        </segment>
      </unit>
      <unit id="333">
        <segment state="initial">
          <source xml:space="preserve">You won't be able to see the code or logic of the implementation through common language runtime (CLR) reflection or other techniques.</source>
          <target xml:space="preserve">You won't be able to see the code or logic of the implementation through common language runtime (CLR) reflection or other techniques.</target>
        </segment>
      </unit>
      <unit id="334">
        <segment state="initial">
          <source xml:space="preserve">You also won't see distinct reference pages for subclass-specific overrides of base peer behavior.</source>
          <target xml:space="preserve">You also won't see distinct reference pages for subclass-specific overrides of base peer behavior.</target>
        </segment>
      </unit>
      <unit id="335">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getnamecore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242550)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, there might be additional behavior for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetNameCore</pc></pc> of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBoxAutomationPeer</pc></pc>, which won't be described on the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">AutomationPeer.GetNameCore</pc> reference page, and there is no reference page for <pc dataRefEnd="id12" dataRefStart="id11" id="p6">TextBoxAutomationPeer.GetNameCore</pc>.</source>
          <target xml:space="preserve">For example, there might be additional behavior for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetNameCore</pc></pc> of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">TextBoxAutomationPeer</pc></pc>, which won't be described on the <pc dataRefEnd="id10" dataRefStart="id9" id="p5">AutomationPeer.GetNameCore</pc> reference page, and there is no reference page for <pc dataRefEnd="id12" dataRefStart="id11" id="p6">TextBoxAutomationPeer.GetNameCore</pc>.</target>
        </segment>
      </unit>
      <unit id="336">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">There isn't even a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TextBoxAutomationPeer.GetNameCore</pc> reference page.</source>
          <target xml:space="preserve">There isn't even a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">TextBoxAutomationPeer.GetNameCore</pc> reference page.</target>
        </segment>
      </unit>
      <unit id="337">
        <segment state="initial">
          <source xml:space="preserve">Instead, read the reference topic for the most immediate peer class, and look for implementation notes in the Remarks section.</source>
          <target xml:space="preserve">Instead, read the reference topic for the most immediate peer class, and look for implementation notes in the Remarks section.</target>
        </segment>
      </unit>
      <unit id="338">
        <segment state="initial">
          <source xml:space="preserve">Peers and AutomationProperties</source>
          <target xml:space="preserve">Peers and AutomationProperties</target>
        </segment>
      </unit>
      <unit id="339">
        <segment state="initial">
          <source xml:space="preserve">Your automation peer should provide appropriate default values for your control's accessibility-related information.</source>
          <target xml:space="preserve">Your automation peer should provide appropriate default values for your control's accessibility-related information.</target>
        </segment>
      </unit>
      <unit id="340">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Note that any app code that uses the control can override some of that behavior by including <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties</pc></pc> attached-property values on control instances.</source>
          <target xml:space="preserve">Note that any app code that uses the control can override some of that behavior by including <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties</pc></pc> attached-property values on control instances.</target>
        </segment>
      </unit>
      <unit id="341">
        <segment state="initial">
          <source xml:space="preserve">Callers can do this either for the default controls or for custom controls.</source>
          <target xml:space="preserve">Callers can do this either for the default controls or for custom controls.</target>
        </segment>
      </unit>
      <unit id="342">
        <originalData>
          <data id="id1">`&lt;Button AutomationProperties.Name="Special"      AutomationProperties.HelpText="This is a special button."/&gt;`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, the following XAML creates a button that has two customized UI Automation properties: <ph dataRef="id1" id="ph1" /></source>
          <target xml:space="preserve">For example, the following XAML creates a button that has two customized UI Automation properties: <ph dataRef="id1" id="ph1" /></target>
        </segment>
      </unit>
      <unit id="343">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](basic-accessibility-information.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info about <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties</pc></pc> attached properties, see <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Basic accessibility information</pc>.</source>
          <target xml:space="preserve">For more info about <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties</pc></pc> attached properties, see <pc dataRefEnd="id6" dataRefStart="id5" id="p3">Basic accessibility information</pc>.</target>
        </segment>
      </unit>
      <unit id="344">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Some of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> methods exist because of the general contract of how UI Automation providers are expected to report information, but these methods are not typically implemented in control peers.</source>
          <target xml:space="preserve">Some of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationPeer</pc></pc> methods exist because of the general contract of how UI Automation providers are expected to report information, but these methods are not typically implemented in control peers.</target>
        </segment>
      </unit>
      <unit id="345">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This is because that info is expected to be provided by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties</pc></pc> values applied to the app code that uses the controls in a specific UI.</source>
          <target xml:space="preserve">This is because that info is expected to be provided by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties</pc></pc> values applied to the app code that uses the controls in a specific UI.</target>
        </segment>
      </unit>
      <unit id="346">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh759769)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, most apps would define the labeling relationship between two different controls in the UI by applying a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.LabeledBy</pc></pc> value.</source>
          <target xml:space="preserve">For example, most apps would define the labeling relationship between two different controls in the UI by applying a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.LabeledBy</pc></pc> value.</target>
        </segment>
      </unit>
      <unit id="347">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getlabeledbycore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">However, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">LabeledByCore</pc></pc> is implemented in certain peers that represent data or item relationships in a control, such as using a header part to label a data-field part, labeling items with their containers, or similar scenarios.</source>
          <target xml:space="preserve">However, <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">LabeledByCore</pc></pc> is implemented in certain peers that represent data or item relationships in a control, such as using a header part to label a data-field part, labeling items with their containers, or similar scenarios.</target>
        </segment>
      </unit>
      <unit id="348">
        <segment state="initial">
          <source xml:space="preserve">Implementing patterns</source>
          <target xml:space="preserve">Implementing patterns</target>
        </segment>
      </unit>
      <unit id="349">
        <segment state="initial">
          <source xml:space="preserve">Let's look at how to write a peer for a control that implements an expand-collapse behavior by implementing the control pattern interface for expand-collapse.</source>
          <target xml:space="preserve">Let's look at how to write a peer for a control that implements an expand-collapse behavior by implementing the control pattern interface for expand-collapse.</target>
        </segment>
      </unit>
      <unit id="350">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getpattern)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The peer should enable the accessibility for the expand-collapse behavior by returning itself whenever <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> is called with a value of <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PatternInterface.ExpandCollapse</pc></pc>.</source>
          <target xml:space="preserve">The peer should enable the accessibility for the expand-collapse behavior by returning itself whenever <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetPattern</pc></pc> is called with a value of <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">PatternInterface.ExpandCollapse</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="351">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671242)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The peer should then inherit the provider interface for that pattern (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IExpandCollapseProvider</pc></pc>) and provide implementations for each of the members of that provider interface.</source>
          <target xml:space="preserve">The peer should then inherit the provider interface for that pattern (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IExpandCollapseProvider</pc></pc>) and provide implementations for each of the members of that provider interface.</target>
        </segment>
      </unit>
      <unit id="352">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242570)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242569)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242570collapsestate)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In this case the interface has three members to override: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Expand</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Collapse</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ExpandCollapseState</pc></pc>.</source>
          <target xml:space="preserve">In this case the interface has three members to override: <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Expand</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Collapse</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ExpandCollapseState</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="353">
        <segment state="initial">
          <source xml:space="preserve">It's helpful to plan ahead for accessibility in the API design of the class itself.</source>
          <target xml:space="preserve">It's helpful to plan ahead for accessibility in the API design of the class itself.</target>
        </segment>
      </unit>
      <unit id="354">
        <segment state="initial">
          <source xml:space="preserve">Whenever you have a behavior that is potentially requested either as a result of typical interactions with a user who is working in the UI or through an automation provider pattern, provide a single method that either the UI response or the automation pattern can call.</source>
          <target xml:space="preserve">Whenever you have a behavior that is potentially requested either as a result of typical interactions with a user who is working in the UI or through an automation provider pattern, provide a single method that either the UI response or the automation pattern can call.</target>
        </segment>
      </unit>
      <unit id="355">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242570)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242569)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/desktop/Ee671242)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, if your control has button parts that have wired event handlers that can expand or collapse the control, and has keyboard equivalents for those actions, have these event handlers call the same method that you call from within the body of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Expand</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Collapse</pc></pc> implementations for <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IExpandCollapseProvider</pc></pc> in the peer.</source>
          <target xml:space="preserve">For example, if your control has button parts that have wired event handlers that can expand or collapse the control, and has keyboard equivalents for those actions, have these event handlers call the same method that you call from within the body of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Expand</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Collapse</pc></pc> implementations for <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">IExpandCollapseProvider</pc></pc> in the peer.</target>
        </segment>
      </unit>
      <unit id="356">
        <segment state="initial">
          <source xml:space="preserve">Using a common logic method can also be a useful way to make sure that your control's visual states are updated to show logical state in a uniform way, regardless of how the behavior was invoked.</source>
          <target xml:space="preserve">Using a common logic method can also be a useful way to make sure that your control's visual states are updated to show logical state in a uniform way, regardless of how the behavior was invoked.</target>
        </segment>
      </unit>
      <unit id="357">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242472_owner)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A typical implementation is that the provider APIs first call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Owner</pc></pc> for access to the control instance at run time.</source>
          <target xml:space="preserve">A typical implementation is that the provider APIs first call <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Owner</pc></pc> for access to the control instance at run time.</target>
        </segment>
      </unit>
      <unit id="358">
        <segment state="initial">
          <source xml:space="preserve">Then the necessary behavior methods can be called on that object.</source>
          <target xml:space="preserve">Then the necessary behavior methods can be called on that object.</target>
        </segment>
      </unit>
      <unit id="359">
        <segment state="initial">
          <source xml:space="preserve">An alternate implementation is that the control itself can reference its peer.</source>
          <target xml:space="preserve">An alternate implementation is that the control itself can reference its peer.</target>
        </segment>
      </unit>
      <unit id="360">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_raiseautomationevent)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This is a common pattern if you are raising automation events from the control, because the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RaiseAutomationEvent</pc></pc> method is a peer method.</source>
          <target xml:space="preserve">This is a common pattern if you are raising automation events from the control, because the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RaiseAutomationEvent</pc></pc> method is a peer method.</target>
        </segment>
      </unit>
      <unit id="361">
        <segment state="initial">
          <source xml:space="preserve">UI Automation events</source>
          <target xml:space="preserve">UI Automation events</target>
        </segment>
      </unit>
      <unit id="362">
        <segment state="initial">
          <source xml:space="preserve">UI Automation events fall into the following categories.</source>
          <target xml:space="preserve">UI Automation events fall into the following categories.</target>
        </segment>
      </unit>
      <unit id="363">
        <segment state="initial">
          <source xml:space="preserve">Event</source>
          <target xml:space="preserve">Event</target>
        </segment>
      </unit>
      <unit id="364">
        <segment state="initial">
          <source xml:space="preserve">Description</source>
          <target xml:space="preserve">Description</target>
        </segment>
      </unit>
      <unit id="365">
        <segment state="initial">
          <source xml:space="preserve">Property change</source>
          <target xml:space="preserve">Property change</target>
        </segment>
      </unit>
      <unit id="366">
        <segment state="initial">
          <source xml:space="preserve">Fires when a property on a UI Automation element or control pattern changes.</source>
          <target xml:space="preserve">Fires when a property on a UI Automation element or control pattern changes.</target>
        </segment>
      </unit>
      <unit id="367">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242653_togglestate)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, if a client needs to monitor an app's check box control, it can register to listen for a property change event on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ToggleState</pc></pc> property.</source>
          <target xml:space="preserve">For example, if a client needs to monitor an app's check box control, it can register to listen for a property change event on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ToggleState</pc></pc> property.</target>
        </segment>
      </unit>
      <unit id="368">
        <segment state="initial">
          <source xml:space="preserve">When the check box control is checked or unchecked, the provider fires the event and the client can act as necessary.</source>
          <target xml:space="preserve">When the check box control is checked or unchecked, the provider fires the event and the client can act as necessary.</target>
        </segment>
      </unit>
      <unit id="369">
        <segment state="initial">
          <source xml:space="preserve">Element action</source>
          <target xml:space="preserve">Element action</target>
        </segment>
      </unit>
      <unit id="370">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Fires when a change in the UI results from user or programmatic activity; for example, when a button is clicked or invoked through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Invoke</pc> pattern.</source>
          <target xml:space="preserve">Fires when a change in the UI results from user or programmatic activity; for example, when a button is clicked or invoked through the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Invoke</pc> pattern.</target>
        </segment>
      </unit>
      <unit id="371">
        <segment state="initial">
          <source xml:space="preserve">Structure change</source>
          <target xml:space="preserve">Structure change</target>
        </segment>
      </unit>
      <unit id="372">
        <segment state="initial">
          <source xml:space="preserve">Fires when the structure of the UI Automation tree changes.</source>
          <target xml:space="preserve">Fires when the structure of the UI Automation tree changes.</target>
        </segment>
      </unit>
      <unit id="373">
        <segment state="initial">
          <source xml:space="preserve">The structure changes when new UI items become visible, hidden, or removed on the desktop.</source>
          <target xml:space="preserve">The structure changes when new UI items become visible, hidden, or removed on the desktop.</target>
        </segment>
      </unit>
      <unit id="374">
        <segment state="initial">
          <source xml:space="preserve">Global change</source>
          <target xml:space="preserve">Global change</target>
        </segment>
      </unit>
      <unit id="375">
        <segment state="initial">
          <source xml:space="preserve">Fires when actions of global interest to the client occur, such as when the focus shifts from one element to another, or when a child window closes.</source>
          <target xml:space="preserve">Fires when actions of global interest to the client occur, such as when the focus shifts from one element to another, or when a child window closes.</target>
        </segment>
      </unit>
      <unit id="376">
        <segment state="initial">
          <source xml:space="preserve">Some events do not necessarily mean that the state of the UI has changed.</source>
          <target xml:space="preserve">Some events do not necessarily mean that the state of the UI has changed.</target>
        </segment>
      </unit>
      <unit id="377">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209683_textchanged)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, if the user tabs to a text-entry field and then clicks a button to update the field, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextChanged</pc></pc> event fires even if the user did not actually change the text.</source>
          <target xml:space="preserve">For example, if the user tabs to a text-entry field and then clicks a button to update the field, a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TextChanged</pc></pc> event fires even if the user did not actually change the text.</target>
        </segment>
      </unit>
      <unit id="378">
        <segment state="initial">
          <source xml:space="preserve">When processing an event, it may be necessary for a client application to check whether anything has actually changed before taking action.</source>
          <target xml:space="preserve">When processing an event, it may be necessary for a client application to check whether anything has actually changed before taking action.</target>
        </segment>
      </unit>
      <unit id="379">
        <segment state="initial">
          <source xml:space="preserve">AutomationEvents identifiers</source>
          <target xml:space="preserve">AutomationEvents identifiers</target>
        </segment>
      </unit>
      <unit id="380">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209183)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">UI Automation events are identified by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationEvents</pc></pc> values.</source>
          <target xml:space="preserve">UI Automation events are identified by <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationEvents</pc></pc> values.</target>
        </segment>
      </unit>
      <unit id="381">
        <segment state="initial">
          <source xml:space="preserve">The values of the enumeration uniquely identify the kind of event.</source>
          <target xml:space="preserve">The values of the enumeration uniquely identify the kind of event.</target>
        </segment>
      </unit>
      <unit id="382">
        <segment state="initial">
          <source xml:space="preserve">Raising events</source>
          <target xml:space="preserve">Raising events</target>
        </segment>
      </unit>
      <unit id="383">
        <segment state="initial">
          <source xml:space="preserve">UI Automation clients can subscribe to automation events.</source>
          <target xml:space="preserve">UI Automation clients can subscribe to automation events.</target>
        </segment>
      </unit>
      <unit id="384">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_raiseautomationevent)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In the automation peer model, peers for custom controls must report changes to control state that are relevant to accessibility by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RaiseAutomationEvent</pc></pc> method.</source>
          <target xml:space="preserve">In the automation peer model, peers for custom controls must report changes to control state that are relevant to accessibility by calling the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RaiseAutomationEvent</pc></pc> method.</target>
        </segment>
      </unit>
      <unit id="385">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_raisepropertychangedevent)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Similarly, when a key UI Automation property value changes, custom control peers should call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RaisePropertyChangedEvent</pc></pc> method.</source>
          <target xml:space="preserve">Similarly, when a key UI Automation property value changes, custom control peers should call the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RaisePropertyChangedEvent</pc></pc> method.</target>
        </segment>
      </unit>
      <unit id="386">
        <segment state="initial">
          <source xml:space="preserve">The next code example shows how to get the peer object from within the control definition code and call a method to fire an event from that peer.</source>
          <target xml:space="preserve">The next code example shows how to get the peer object from within the control definition code and call a method to fire an event from that peer.</target>
        </segment>
      </unit>
      <unit id="387">
        <segment state="initial">
          <source xml:space="preserve">As an optimization, the code determines whether there are any listeners for this event type.</source>
          <target xml:space="preserve">As an optimization, the code determines whether there are any listeners for this event type.</target>
        </segment>
      </unit>
      <unit id="388">
        <segment state="initial">
          <source xml:space="preserve">Firing the event and creating the peer object only when there are listeners avoids unnecessary overhead and helps the control remain responsive.</source>
          <target xml:space="preserve">Firing the event and creating the peer object only when there are listeners avoids unnecessary overhead and helps the control remain responsive.</target>
        </segment>
      </unit>
      <unit id="389">
        <segment state="initial">
          <source xml:space="preserve">Peer navigation</source>
          <target xml:space="preserve">Peer navigation</target>
        </segment>
      </unit>
      <unit id="390">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getchildren)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209185_getparent)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">After locating an automation peer, a UI Automation client can navigate the peer structure of an app by calling the peer object's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetChildren</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetParent</pc></pc> methods.</source>
          <target xml:space="preserve">After locating an automation peer, a UI Automation client can navigate the peer structure of an app by calling the peer object's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetChildren</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GetParent</pc></pc> methods.</target>
        </segment>
      </unit>
      <unit id="391">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209185_getchildrencore)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Navigation among UI elements within a control is supported by the peer's implementation of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetChildrenCore</pc></pc> method.</source>
          <target xml:space="preserve">Navigation among UI elements within a control is supported by the peer's implementation of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GetChildrenCore</pc></pc> method.</target>
        </segment>
      </unit>
      <unit id="392">
        <segment state="initial">
          <source xml:space="preserve">The UI Automation system calls this method to build up a tree of subelements contained within a control; for example, list items in a list box.</source>
          <target xml:space="preserve">The UI Automation system calls this method to build up a tree of subelements contained within a control; for example, list items in a list box.</target>
        </segment>
      </unit>
      <unit id="393">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR242472)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The default <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetChildrenCore</pc> method in <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElementAutomationPeer</pc></pc> traverses the visual tree of elements to build the tree of automation peers.</source>
          <target xml:space="preserve">The default <pc dataRefEnd="id2" dataRefStart="id1" id="p1">GetChildrenCore</pc> method in <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElementAutomationPeer</pc></pc> traverses the visual tree of elements to build the tree of automation peers.</target>
        </segment>
      </unit>
      <unit id="394">
        <segment state="initial">
          <source xml:space="preserve">Custom controls can override this method to expose a different representation of child elements to automation clients, returning the automation peers of elements that convey information or allow user interaction.</source>
          <target xml:space="preserve">Custom controls can override this method to expose a different representation of child elements to automation clients, returning the automation peers of elements that convey information or allow user interaction.</target>
        </segment>
      </unit>
      <unit id="395">
        <segment state="initial">
          <source xml:space="preserve">Native automation support for text patterns</source>
          <target xml:space="preserve">Native automation support for text patterns</target>
        </segment>
      </unit>
      <unit id="396">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242496)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Some of the default UWP app automation peers provide control pattern support for the text pattern (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PatternInterface.Text</pc></pc>).</source>
          <target xml:space="preserve">Some of the default UWP app automation peers provide control pattern support for the text pattern (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">PatternInterface.Text</pc></pc>).</target>
        </segment>
      </unit>
      <unit id="397">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242627)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But they provide this support through native methods, and the peers involved won't note the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ITextProvider</pc></pc> interface in the (managed) inheritance.</source>
          <target xml:space="preserve">But they provide this support through native methods, and the peers involved won't note the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ITextProvider</pc></pc> interface in the (managed) inheritance.</target>
        </segment>
      </unit>
      <unit id="398">
        <segment state="initial">
          <source xml:space="preserve">Still, if a managed or non-managed UI Automation client queries the peer for patterns, it will report support for the text pattern, and provide behavior for parts of the pattern when client APIs are called.</source>
          <target xml:space="preserve">Still, if a managed or non-managed UI Automation client queries the peer for patterns, it will report support for the text pattern, and provide behavior for parts of the pattern when client APIs are called.</target>
        </segment>
      </unit>
      <unit id="399">
        <segment state="initial">
          <source xml:space="preserve">If you intend to derive from one of the UWP app text controls and also create a custom peer that derives from one of the text-related peers, check the Remarks sections for the peer to learn more about any native-level support for patterns.</source>
          <target xml:space="preserve">If you intend to derive from one of the UWP app text controls and also create a custom peer that derives from one of the text-related peers, check the Remarks sections for the peer to learn more about any native-level support for patterns.</target>
        </segment>
      </unit>
      <unit id="400">
        <segment state="initial">
          <source xml:space="preserve">You can access the native base behavior in your custom peer if you call the base implementation from your managed provider interface implementations, but it's difficult to modify what the base implementation does because the native interfaces on both the peer and its owner control aren't exposed.</source>
          <target xml:space="preserve">You can access the native base behavior in your custom peer if you call the base implementation from your managed provider interface implementations, but it's difficult to modify what the base implementation does because the native interfaces on both the peer and its owner control aren't exposed.</target>
        </segment>
      </unit>
      <unit id="401">
        <segment state="initial">
          <source xml:space="preserve">Generally you should either use the base implementations as-is (call base only) or completely replace the functionality with your own managed code and don't call the base implementation.</source>
          <target xml:space="preserve">Generally you should either use the base implementations as-is (call base only) or completely replace the functionality with your own managed code and don't call the base implementation.</target>
        </segment>
      </unit>
      <unit id="402">
        <segment state="initial">
          <source xml:space="preserve">The latter is an advanced scenario, you'll need good familiarity with the text services framework being used by your control in order to support the accessibility requirements when using that framework.</source>
          <target xml:space="preserve">The latter is an advanced scenario, you'll need good familiarity with the text services framework being used by your control in order to support the accessibility requirements when using that framework.</target>
        </segment>
      </unit>
      <unit id="403">
        <segment state="initial">
          <source xml:space="preserve">AutomationProperties.AccessibilityView</source>
          <target xml:space="preserve">AutomationProperties.AccessibilityView</target>
        </segment>
      </unit>
      <unit id="404">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081_accessibilityview)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In addition to providing a custom peer, you can also adjust the tree view representation for any control instance, by setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessibilityView</pc></pc> in XAML.</source>
          <target xml:space="preserve">In addition to providing a custom peer, you can also adjust the tree view representation for any control instance, by setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessibilityView</pc></pc> in XAML.</target>
        </segment>
      </unit>
      <unit id="405">
        <segment state="initial">
          <source xml:space="preserve">This isn't implemented as part of a peer class, but we'll mention it here because it's germane to overall accessibility support either for custom controls or for templates you customize.</source>
          <target xml:space="preserve">This isn't implemented as part of a peer class, but we'll mention it here because it's germane to overall accessibility support either for custom controls or for templates you customize.</target>
        </segment>
      </unit>
      <unit id="406">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081_accessibilityview)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The main scenario for using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessibilityView</pc></pc> is to deliberately omit certain controls in a template from the UI Automation views, because they don't meaningfully contribute to the accessibility view of the entire control.</source>
          <target xml:space="preserve">The main scenario for using <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessibilityView</pc></pc> is to deliberately omit certain controls in a template from the UI Automation views, because they don't meaningfully contribute to the accessibility view of the entire control.</target>
        </segment>
      </unit>
      <unit id="407">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To prevent this, set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationProperties.AccessibilityView</pc> to "Raw".</source>
          <target xml:space="preserve">To prevent this, set <pc dataRefEnd="id2" dataRefStart="id1" id="p1">AutomationProperties.AccessibilityView</pc> to "Raw".</target>
        </segment>
      </unit>
      <unit id="408">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209081_accessibilityview)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessibilityView</pc></pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessibilityView</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="409">
        <segment state="initial">
          <source xml:space="preserve">Throwing exceptions from automation peers</source>
          <target xml:space="preserve">Throwing exceptions from automation peers</target>
        </segment>
      </unit>
      <unit id="410">
        <segment state="initial">
          <source xml:space="preserve">The APIs that you are implementing for your automation peer support are permitted to throw exceptions.</source>
          <target xml:space="preserve">The APIs that you are implementing for your automation peer support are permitted to throw exceptions.</target>
        </segment>
      </unit>
      <unit id="411">
        <segment state="initial">
          <source xml:space="preserve">It's expected any UI Automation clients that are listening are robust enough to continue on after most exceptions are thrown.</source>
          <target xml:space="preserve">It's expected any UI Automation clients that are listening are robust enough to continue on after most exceptions are thrown.</target>
        </segment>
      </unit>
      <unit id="412">
        <segment state="initial">
          <source xml:space="preserve">In all likelihood that listener is looking at an all-up automation tree that includes apps other than your own, and it's an unacceptable client design to bring down the entire client just because one area of the tree threw a peer-based exception when the client called its APIs.</source>
          <target xml:space="preserve">In all likelihood that listener is looking at an all-up automation tree that includes apps other than your own, and it's an unacceptable client design to bring down the entire client just because one area of the tree threw a peer-based exception when the client called its APIs.</target>
        </segment>
      </unit>
      <unit id="413">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](T:System.ArgumentNullException)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For parameters that are passed in to your peer, it's acceptable to validate the input, and for example throw <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ArgumentNullException</pc></pc> if it was passed <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> and that's not a valid value for your implementation.</source>
          <target xml:space="preserve">For parameters that are passed in to your peer, it's acceptable to validate the input, and for example throw <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ArgumentNullException</pc></pc> if it was passed <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> and that's not a valid value for your implementation.</target>
        </segment>
      </unit>
      <unit id="414">
        <segment state="initial">
          <source xml:space="preserve">However, if there are subsequent operations performed by your peer, remember that the peer's interactions with the hosting control have something of an asynchronous character to them.</source>
          <target xml:space="preserve">However, if there are subsequent operations performed by your peer, remember that the peer's interactions with the hosting control have something of an asynchronous character to them.</target>
        </segment>
      </unit>
      <unit id="415">
        <segment state="initial">
          <source xml:space="preserve">Anything a peer does won't necessarily block the UI thread in the control (and it probably shouldn't).</source>
          <target xml:space="preserve">Anything a peer does won't necessarily block the UI thread in the control (and it probably shouldn't).</target>
        </segment>
      </unit>
      <unit id="416">
        <segment state="initial">
          <source xml:space="preserve">So you could have situations where an object was available or had certain properties when the peer was created or when an automation peer method was first called, but in the meantime the control state has changed.</source>
          <target xml:space="preserve">So you could have situations where an object was available or had certain properties when the peer was created or when an automation peer method was first called, but in the meantime the control state has changed.</target>
        </segment>
      </unit>
      <unit id="417">
        <segment state="initial">
          <source xml:space="preserve">For these cases, there are two dedicated exceptions that a provider can throw:</source>
          <target xml:space="preserve">For these cases, there are two dedicated exceptions that a provider can throw:</target>
        </segment>
      </unit>
      <unit id="418">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh673741)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Throw <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ElementNotAvailableException</pc></pc> if you're unable to access either the peer's owner or a related peer element based on the original info your API was passed.</source>
          <target xml:space="preserve">Throw <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ElementNotAvailableException</pc></pc> if you're unable to access either the peer's owner or a related peer element based on the original info your API was passed.</target>
        </segment>
      </unit>
      <unit id="419">
        <segment state="initial">
          <source xml:space="preserve">For example, you might have a peer that's trying to run its methods but the owner has since been removed from the UI, such as a modal dialog that's been closed.</source>
          <target xml:space="preserve">For example, you might have a peer that's trying to run its methods but the owner has since been removed from the UI, such as a modal dialog that's been closed.</target>
        </segment>
      </unit>
      <unit id="420">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671218)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For a non-.NET client, this maps to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIA\_E\_ELEMENTNOTAVAILABLE</pc></pc>.</source>
          <target xml:space="preserve">For a non-.NET client, this maps to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIA\_E\_ELEMENTNOTAVAILABLE</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="421">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh673748)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209390_isenabled)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">`=`</data>
          <data id="id10">**</data>
          <data id="id11">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Throw <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ElementNotEnabledException</pc></pc> if there still is an owner, but that owner is in a mode such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsEnabled</pc></pc><ph dataRef="id9" id="ph1" /><pc dataRefEnd="id11" dataRefStart="id10" id="p5">false</pc> that's blocking some of the specific programmatic changes that your peer is trying to accomplish.</source>
          <target xml:space="preserve">Throw <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ElementNotEnabledException</pc></pc> if there still is an owner, but that owner is in a mode such as <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">IsEnabled</pc></pc><ph dataRef="id9" id="ph1" /><pc dataRefEnd="id11" dataRefStart="id10" id="p5">false</pc> that's blocking some of the specific programmatic changes that your peer is trying to accomplish.</target>
        </segment>
      </unit>
      <unit id="422">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671218)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For a non-.NET client, this maps to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIA\_E\_ELEMENTNOTENABLED</pc></pc>.</source>
          <target xml:space="preserve">For a non-.NET client, this maps to <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIA\_E\_ELEMENTNOTENABLED</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="423">
        <segment state="initial">
          <source xml:space="preserve">Beyond this, peers should be relatively conservative regarding exceptions that they throw from their peer support.</source>
          <target xml:space="preserve">Beyond this, peers should be relatively conservative regarding exceptions that they throw from their peer support.</target>
        </segment>
      </unit>
      <unit id="424">
        <segment state="initial">
          <source xml:space="preserve">Most clients won't be able to handle exceptions from peers and turn these into actionable choices that their users can make when interacting with the client.</source>
          <target xml:space="preserve">Most clients won't be able to handle exceptions from peers and turn these into actionable choices that their users can make when interacting with the client.</target>
        </segment>
      </unit>
      <unit id="425">
        <segment state="initial">
          <source xml:space="preserve">So sometimes a no-op, and catching exceptions without rethrowing within your peer implementations, is a better strategy than is throwing exceptions every time something the peer tries to do doesn't work.</source>
          <target xml:space="preserve">So sometimes a no-op, and catching exceptions without rethrowing within your peer implementations, is a better strategy than is throwing exceptions every time something the peer tries to do doesn't work.</target>
        </segment>
      </unit>
      <unit id="426">
        <segment state="initial">
          <source xml:space="preserve">Consider also that most UI Automation clients aren't written in managed code.</source>
          <target xml:space="preserve">Consider also that most UI Automation clients aren't written in managed code.</target>
        </segment>
      </unit>
      <unit id="427">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Most are written in COM and are just checking for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">S\_OK</pc> in an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HRESULT</pc> whenever they call a UI Automation client method that ends up accessing your peer.</source>
          <target xml:space="preserve">Most are written in COM and are just checking for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">S\_OK</pc> in an <pc dataRefEnd="id4" dataRefStart="id3" id="p2">HRESULT</pc> whenever they call a UI Automation client method that ends up accessing your peer.</target>
        </segment>
      </unit>
      <unit id="428">
        <segment state="initial">
          <source xml:space="preserve">Related topics</source>
          <target xml:space="preserve">Related topics</target>
        </segment>
      </unit>
      <unit id="429">
        <segment state="initial">
          <source xml:space="preserve">Accessibility</source>
          <target xml:space="preserve">Accessibility</target>
        </segment>
      </unit>
      <unit id="430">
        <segment state="initial">
          <source xml:space="preserve">XAML accessibility sample</source>
          <target xml:space="preserve">XAML accessibility sample</target>
        </segment>
      </unit>
      <unit id="431">
        <segment state="initial">
          <source xml:space="preserve">FrameworkElementAutomationPeer</source>
          <target xml:space="preserve">FrameworkElementAutomationPeer</target>
        </segment>
      </unit>
      <unit id="432">
        <segment state="initial">
          <source xml:space="preserve">AutomationPeer</source>
          <target xml:space="preserve">AutomationPeer</target>
        </segment>
      </unit>
      <unit id="433">
        <segment state="initial">
          <source xml:space="preserve">OnCreateAutomationPeer</source>
          <target xml:space="preserve">OnCreateAutomationPeer</target>
        </segment>
      </unit>
      <unit id="434">
        <segment state="initial">
          <source xml:space="preserve">Control patterns and interfaces</source>
          <target xml:space="preserve">Control patterns and interfaces</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>