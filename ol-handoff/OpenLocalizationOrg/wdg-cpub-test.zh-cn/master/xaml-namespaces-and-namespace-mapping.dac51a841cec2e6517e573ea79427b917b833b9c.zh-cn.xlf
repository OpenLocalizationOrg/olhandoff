<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="zh-cn" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">1e9d37634964a2859e6f670b3449acfa84564f9b</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">description: This topic explains the XML/XAML namespace (xmlns) mappings as found in the root element of most XAML files.</source>
          <target xml:space="preserve">description: This topic explains the XML/XAML namespace (xmlns) mappings as found in the root element of most XAML files.</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">It also describes how to produce similar mappings for custom types and assemblies.</source>
          <target xml:space="preserve">It also describes how to produce similar mappings for custom types and assemblies.</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">title: XAML namespaces and namespace mapping</source>
          <target xml:space="preserve">title: XAML namespaces and namespace mapping</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: A19DFF78-E692-47AE-8221-AB5EA9470E8B</source>
          <target xml:space="preserve">ms.assetid: A19DFF78-E692-47AE-8221-AB5EA9470E8B</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">XAML namespaces and namespace mapping</source>
          <target xml:space="preserve">XAML namespaces and namespace mapping</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="107">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles,  see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles,  see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This topic explains the XML/XAML namespace (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc>) mappings as found in the root element of most XAML files.</source>
          <target xml:space="preserve">This topic explains the XML/XAML namespace (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc>) mappings as found in the root element of most XAML files.</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">It also describes how to produce similar mappings for custom types and assemblies.</source>
          <target xml:space="preserve">It also describes how to produce similar mappings for custom types and assemblies.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">How XAML namespaces relate to code definition and type libraries</source>
          <target xml:space="preserve">How XAML namespaces relate to code definition and type libraries</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">Both in its general purpose and for its application to Windows Runtime app programming, XAML is used to declare objects, properties of those objects, and object-property relationships expressed as hierarchies.</source>
          <target xml:space="preserve">Both in its general purpose and for its application to Windows Runtime app programming, XAML is used to declare objects, properties of those objects, and object-property relationships expressed as hierarchies.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">The objects you declare in XAML are backed by type libraries or other representations that are defined by other programming techniques and languages.</source>
          <target xml:space="preserve">The objects you declare in XAML are backed by type libraries or other representations that are defined by other programming techniques and languages.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">These libraries might be:</source>
          <target xml:space="preserve">These libraries might be:</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">The built-in set of objects for the Windows Runtime.</source>
          <target xml:space="preserve">The built-in set of objects for the Windows Runtime.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source xml:space="preserve">This is a fixed set of objects, and accessing these objects from XAML uses internal type-mapping and activation logic.</source>
          <target xml:space="preserve">This is a fixed set of objects, and accessing these objects from XAML uses internal type-mapping and activation logic.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">Distributed libraries that are provided either by Microsoft or by third parties.</source>
          <target xml:space="preserve">Distributed libraries that are provided either by Microsoft or by third parties.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">Libraries that represent the definition of a third-party control that your app incorporates and your package redistributes.</source>
          <target xml:space="preserve">Libraries that represent the definition of a third-party control that your app incorporates and your package redistributes.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">Your own library, which is part of your project and which holds some or all of your user code definitions.</source>
          <target xml:space="preserve">Your own library, which is part of your project and which holds some or all of your user code definitions.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">Backing type info is associated with particular XAML namespace definitions.</source>
          <target xml:space="preserve">Backing type info is associated with particular XAML namespace definitions.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">XAML frameworks such as the Windows Runtime can aggregate multiple assemblies and multiple code namespaces to map to a single XAML namespace.</source>
          <target xml:space="preserve">XAML frameworks such as the Windows Runtime can aggregate multiple assemblies and multiple code namespaces to map to a single XAML namespace.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">This enables the concept of a XAML vocabulary that covers a larger programming framework or technology.</source>
          <target xml:space="preserve">This enables the concept of a XAML vocabulary that covers a larger programming framework or technology.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">A XAML vocabulary can be quite extensive—for example, most of the XAML documented for Windows Runtime apps in this reference constitutes a single XAML vocabulary.</source>
          <target xml:space="preserve">A XAML vocabulary can be quite extensive—for example, most of the XAML documented for Windows Runtime apps in this reference constitutes a single XAML vocabulary.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">A XAML vocabulary is also extensible: you extend it by adding types to the backing code definitions, making sure to include the types in code namespaces that are already used as mapped namespace sources for the XAML vocabulary.</source>
          <target xml:space="preserve">A XAML vocabulary is also extensible: you extend it by adding types to the backing code definitions, making sure to include the types in code namespaces that are already used as mapped namespace sources for the XAML vocabulary.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">A XAML processor can look up types and members from the backing assemblies associated with that XAML namespace when it creates a run-time object representation.</source>
          <target xml:space="preserve">A XAML processor can look up types and members from the backing assemblies associated with that XAML namespace when it creates a run-time object representation.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">This is why XAML is useful as a way to formalize and exchange definitions of object-construction behavior, and why XAML is used as a UI definition technique for a Windows Store app.</source>
          <target xml:space="preserve">This is why XAML is useful as a way to formalize and exchange definitions of object-construction behavior, and why XAML is used as a UI definition technique for a Windows Store app.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source xml:space="preserve">XAML namespaces in typical XAML markup usage</source>
          <target xml:space="preserve">XAML namespaces in typical XAML markup usage</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source xml:space="preserve">A XAML file almost always declares a default XAML namespace in its root element.</source>
          <target xml:space="preserve">A XAML file almost always declares a default XAML namespace in its root element.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">The default XAML namespace defines which elements you can declare without qualifying them by a prefix.</source>
          <target xml:space="preserve">The default XAML namespace defines which elements you can declare without qualifying them by a prefix.</target>
        </segment>
      </unit>
      <unit id="129">
        <originalData>
          <data id="id1">`&lt;Balloon /&gt;`</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, if you declare an element <ph dataRef="id1" id="ph1" />, a XAML parser will expect that an element <pc dataRefEnd="id3" dataRefStart="id2" id="p1">Balloon</pc> exists and is valid in the default XAML namespace.</source>
          <target xml:space="preserve">For example, if you declare an element <ph dataRef="id1" id="ph1" />, a XAML parser will expect that an element <pc dataRefEnd="id3" dataRefStart="id2" id="p1">Balloon</pc> exists and is valid in the default XAML namespace.</target>
        </segment>
      </unit>
      <unit id="130">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">`&lt;party:Balloon /&gt;`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In contrast, if <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Balloon</pc> is not in the defined default XAML namespace, you must instead qualify that element name with a prefix, for example <ph dataRef="id3" id="ph1" />.</source>
          <target xml:space="preserve">In contrast, if <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Balloon</pc> is not in the defined default XAML namespace, you must instead qualify that element name with a prefix, for example <ph dataRef="id3" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="131">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The prefix indicates that the element exists in a different XAML namespace than the default namespace, and you must map a XAML namespace to the prefix <pc dataRefEnd="id2" dataRefStart="id1" id="p1">party</pc> before you can use this element.</source>
          <target xml:space="preserve">The prefix indicates that the element exists in a different XAML namespace than the default namespace, and you must map a XAML namespace to the prefix <pc dataRefEnd="id2" dataRefStart="id1" id="p1">party</pc> before you can use this element.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source xml:space="preserve">XAML namespaces apply to the specific element on which they are declared, and also to any element that is contained by that element in the XAML structure.</source>
          <target xml:space="preserve">XAML namespaces apply to the specific element on which they are declared, and also to any element that is contained by that element in the XAML structure.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">For this reason, XAML namespaces are almost always declared on root elements of a XAML file to take advantage of this inheritance.</source>
          <target xml:space="preserve">For this reason, XAML namespaces are almost always declared on root elements of a XAML file to take advantage of this inheritance.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">The default and XAML language XAML namespace declarations</source>
          <target xml:space="preserve">The default and XAML language XAML namespace declarations</target>
        </segment>
      </unit>
      <unit id="135">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Within the root element of most XAML files, there are two <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> declarations.</source>
          <target xml:space="preserve">Within the root element of most XAML files, there are two <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> declarations.</target>
        </segment>
      </unit>
      <unit id="136">
        <originalData>
          <data id="id1">`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The first declaration maps a XAML namespace as the default: <ph dataRef="id1" id="ph1" /></source>
          <target xml:space="preserve">The first declaration maps a XAML namespace as the default: <ph dataRef="id1" id="ph1" /></target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">This is the same XAML namespace identifier used in several predecessor Microsoft technologies that also use XAML as a UI definition markup format.</source>
          <target xml:space="preserve">This is the same XAML namespace identifier used in several predecessor Microsoft technologies that also use XAML as a UI definition markup format.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source xml:space="preserve">The use of the same identifier is deliberate, and is helpful when you migrate previously defined UI to a Windows Runtime app using C++, C#, or Visual Basic.</source>
          <target xml:space="preserve">The use of the same identifier is deliberate, and is helpful when you migrate previously defined UI to a Windows Runtime app using C++, C#, or Visual Basic.</target>
        </segment>
      </unit>
      <unit id="139">
        <originalData>
          <data id="id1">`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The second declaration maps a separate XAML namespace for the XAML-defined language elements, mapping it (typically) to the "x:" prefix: <ph dataRef="id1" id="ph1" /></source>
          <target xml:space="preserve">The second declaration maps a separate XAML namespace for the XAML-defined language elements, mapping it (typically) to the "x:" prefix: <ph dataRef="id1" id="ph1" /></target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> value, and the "x:" prefix it is mapped to, is also identical to the definitions used in several predecessor Microsoft technologies that use XAML.</source>
          <target xml:space="preserve">This <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> value, and the "x:" prefix it is mapped to, is also identical to the definitions used in several predecessor Microsoft technologies that use XAML.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">The relationship between these declarations is that XAML is a language definition, and the Windows Runtime is one implementation that uses XAML as a language and defines a specific vocabulary where its types are referenced in XAML.</source>
          <target xml:space="preserve">The relationship between these declarations is that XAML is a language definition, and the Windows Runtime is one implementation that uses XAML as a language and defines a specific vocabulary where its types are referenced in XAML.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source xml:space="preserve">The XAML language specifies certain language elements, and each of these should be accessible through XAML processor implementations working against the XAML namespace.</source>
          <target xml:space="preserve">The XAML language specifies certain language elements, and each of these should be accessible through XAML processor implementations working against the XAML namespace.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">The "x:" mapping convention for the XAML language XAML namespace is followed by project templates, sample code, and the documentation for language features.</source>
          <target xml:space="preserve">The "x:" mapping convention for the XAML language XAML namespace is followed by project templates, sample code, and the documentation for language features.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">The XAML language namespace defines several commonly used features that are necessary even for basic Windows Runtime apps using C++, C#, or Visual Basic.</source>
          <target xml:space="preserve">The XAML language namespace defines several commonly used features that are necessary even for basic Windows Runtime apps using C++, C#, or Visual Basic.</target>
        </segment>
      </unit>
      <unit id="145">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](x-class-attribute.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, to join any code-behind to a XAML file through a partial class, you must name that class as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Class attribute</pc> in the root element of the relevant XAML file.</source>
          <target xml:space="preserve">For example, to join any code-behind to a XAML file through a partial class, you must name that class as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Class attribute</pc> in the root element of the relevant XAML file.</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187273)</data>
          <data id="id3">[</data>
          <data id="id4">](x-key-attribute.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Or, any element as defined in a XAML page as a keyed resource in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc> must have the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Key attribute</pc> set on the object element in question.</source>
          <target xml:space="preserve">Or, any element as defined in a XAML page as a keyed resource in a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc> must have the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">x:Key attribute</pc> set on the object element in question.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source xml:space="preserve">Other XAML namespaces</source>
          <target xml:space="preserve">Other XAML namespaces</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source xml:space="preserve">In addition to the default namespace and the XAML language XAML namespace "x:", you may also see other mapped XAML namespaces in the initial default XAML for apps as generated by Microsoft Visual Studio.</source>
          <target xml:space="preserve">In addition to the default namespace and the XAML language XAML namespace "x:", you may also see other mapped XAML namespaces in the initial default XAML for apps as generated by Microsoft Visual Studio.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source xml:space="preserve">d: (http://schemas.microsoft.com/expression/blend/2008)</source>
          <target xml:space="preserve">d: (http://schemas.microsoft.com/expression/blend/2008)</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source xml:space="preserve">The "d:" XAML namespace is intended for designer support, specifically designer support in the XAML design surfaces of Microsoft Visual Studio.</source>
          <target xml:space="preserve">The "d:" XAML namespace is intended for designer support, specifically designer support in the XAML design surfaces of Microsoft Visual Studio.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source xml:space="preserve">The" d:" XAML namespace enables designer or design-time attributes on XAML elements.</source>
          <target xml:space="preserve">The" d:" XAML namespace enables designer or design-time attributes on XAML elements.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source xml:space="preserve">These designer attributes affect only the design aspects of how XAML behaves.</source>
          <target xml:space="preserve">These designer attributes affect only the design aspects of how XAML behaves.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source xml:space="preserve">The designer attributes are ignored when the same XAML is loaded by the Windows Runtime XAML parser when an app runs.</source>
          <target xml:space="preserve">The designer attributes are ignored when the same XAML is loaded by the Windows Runtime XAML parser when an app runs.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">Generally, the designer attributes are valid on any XAML element, but in practice there are only certain scenarios where applying a designer attribute yourself is appropriate.</source>
          <target xml:space="preserve">Generally, the designer attributes are valid on any XAML element, but in practice there are only certain scenarios where applying a designer attribute yourself is appropriate.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">In particular, many of the designer attributes are intended to provide a better experience for interacting with data contexts and data sources while you are developing XAML and code that use data binding.</source>
          <target xml:space="preserve">In particular, many of the designer attributes are intended to provide a better experience for interacting with data contexts and data sources while you are developing XAML and code that use data binding.</target>
        </segment>
      </unit>
      <unit id="156">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignHeight and d:DesignWidth attributes:</pc> These attributes are sometimes applied to the root of a XAML file that Visual Studio or another XAML designer surface creates for you.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignHeight and d:DesignWidth attributes:</pc> These attributes are sometimes applied to the root of a XAML file that Visual Studio or another XAML designer surface creates for you.</target>
        </segment>
      </unit>
      <unit id="157">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227647)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, these attributes are set on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UserControl</pc></pc> root of the XAML that is created if you add a new <pc dataRefEnd="id6" dataRefStart="id5" id="p3">UserControl</pc> to your app project.</source>
          <target xml:space="preserve">For example, these attributes are set on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UserControl</pc></pc> root of the XAML that is created if you add a new <pc dataRefEnd="id6" dataRefStart="id5" id="p3">UserControl</pc> to your app project.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">These attributes make it easier to design the composition of the XAML content, so that you have some anticipation of the layout constraints that might exist once that XAML content is used for a control instance or other part of a larger UI page.</source>
          <target xml:space="preserve">These attributes make it easier to design the composition of the XAML content, so that you have some anticipation of the layout constraints that might exist once that XAML content is used for a control instance or other part of a larger UI page.</target>
        </segment>
      </unit>
      <unit id="159">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you are migrating XAML from Microsoft Silverlight you might have these attributes on root elements that represent an entire UI page.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  If you are migrating XAML from Microsoft Silverlight you might have these attributes on root elements that represent an entire UI page.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source xml:space="preserve">You might want to remove the attributes in this case.</source>
          <target xml:space="preserve">You might want to remove the attributes in this case.</target>
        </segment>
      </unit>
      <unit id="161">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Other features of the XAML designers such as the simulator are probably more useful for designing page layouts that handle scaling and view states well than is a fixed size page layout using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignHeight</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">d:DesignWidth</pc>.</source>
          <target xml:space="preserve">Other features of the XAML designers such as the simulator are probably more useful for designing page layouts that handle scaling and view states well than is a fixed size page layout using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignHeight</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">d:DesignWidth</pc>.</target>
        </segment>
      </unit>
      <unit id="162">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208713)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext attribute:</pc> You can set this attribute on a page root or a control to override any explicit or inherited <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DataContext</pc></pc> that object otherwise has.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext attribute:</pc> You can set this attribute on a page root or a control to override any explicit or inherited <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DataContext</pc></pc> that object otherwise has.</target>
        </segment>
      </unit>
      <unit id="163">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br209833)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/br209835)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignSource attribute:</pc> Specifies a design-time data source for a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">CollectionViewSource</pc></pc>, overriding <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Source</pc></pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignSource attribute:</pc> Specifies a design-time data source for a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">CollectionViewSource</pc></pc>, overriding <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">Source</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="164">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignInstance and d:DesignData markup extensions:</pc> These markup extensions are used to provide the design-time data resources for either <pc dataRefEnd="id4" dataRefStart="id3" id="p2">d:DataContext</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">d:DesignSource</pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignInstance and d:DesignData markup extensions:</pc> These markup extensions are used to provide the design-time data resources for either <pc dataRefEnd="id4" dataRefStart="id3" id="p2">d:DataContext</pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3">d:DesignSource</pc>.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">We won't fully document how to use design-time data resources here.</source>
          <target xml:space="preserve">We won't fully document how to use design-time data resources here.</target>
        </segment>
      </unit>
      <unit id="166">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?LinkId=272504)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Design-Time Attributes</pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Design-Time Attributes</pc>.</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt517866)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For some usage examples, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Sample data on the design surface, and for prototyping</pc>.</source>
          <target xml:space="preserve">For some usage examples, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Sample data on the design surface, and for prototyping</pc>.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source xml:space="preserve">**mc: (http://schemas.openxmlformats.org/markup-compatibility/2006) **</source>
          <target xml:space="preserve">**mc: (http://schemas.openxmlformats.org/markup-compatibility/2006) **</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source xml:space="preserve">" mc:" indicates and supports a markup compatibility mode for reading XAML.</source>
          <target xml:space="preserve">" mc:" indicates and supports a markup compatibility mode for reading XAML.</target>
        </segment>
      </unit>
      <unit id="170">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Typically, the "d:" prefix is associated with the attribute <pc dataRefEnd="id2" dataRefStart="id1" id="p1">mc:Ignorable</pc>.</source>
          <target xml:space="preserve">Typically, the "d:" prefix is associated with the attribute <pc dataRefEnd="id2" dataRefStart="id1" id="p1">mc:Ignorable</pc>.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source xml:space="preserve">This technique enables run-time XAML parsers to ignore the design attributes in "d:".</source>
          <target xml:space="preserve">This technique enables run-time XAML parsers to ignore the design attributes in "d:".</target>
        </segment>
      </unit>
      <unit id="172">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">local:</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">common:</pc></source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">local:</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">common:</pc></target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source xml:space="preserve">"local:" is a prefix that is often mapped for you within the XAML pages for a templated Windows Store app project.</source>
          <target xml:space="preserve">"local:" is a prefix that is often mapped for you within the XAML pages for a templated Windows Store app project.</target>
        </segment>
      </unit>
      <unit id="174">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](x-class-attribute.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">It's mapped to refer to the same namespace that's created to contain the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Class attribute</pc> and code for all the XAML files including app.xaml.</source>
          <target xml:space="preserve">It's mapped to refer to the same namespace that's created to contain the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Class attribute</pc> and code for all the XAML files including app.xaml.</target>
        </segment>
      </unit>
      <unit id="175">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">So long as you define any custom classes you want to use in XAML in this same namespace, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">local:</pc> prefix to refer to your custom types in XAML.</source>
          <target xml:space="preserve">So long as you define any custom classes you want to use in XAML in this same namespace, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">local:</pc> prefix to refer to your custom types in XAML.</target>
        </segment>
      </unit>
      <unit id="176">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A related prefix that comes from a templated Windows Store app project is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">common:</pc>.</source>
          <target xml:space="preserve">A related prefix that comes from a templated Windows Store app project is <pc dataRefEnd="id2" dataRefStart="id1" id="p1">common:</pc>.</target>
        </segment>
      </unit>
      <unit id="177">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This prefix refers to a nested "Common" namespace that contains utility classes such as converters and commands, and you can find the definitions in the Common folder in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Solution Explorer</pc> view.</source>
          <target xml:space="preserve">This prefix refers to a nested "Common" namespace that contains utility classes such as converters and commands, and you can find the definitions in the Common folder in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Solution Explorer</pc> view.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source xml:space="preserve">vsm:</source>
          <target xml:space="preserve">vsm:</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source xml:space="preserve">Do not use.</source>
          <target xml:space="preserve">Do not use.</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source xml:space="preserve">"vsm:" is a prefix that is sometimes seen in older XAML templates imported from other Microsoft technologies.</source>
          <target xml:space="preserve">"vsm:" is a prefix that is sometimes seen in older XAML templates imported from other Microsoft technologies.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">The namespace originally addressed a legacy namespace tooling issue.</source>
          <target xml:space="preserve">The namespace originally addressed a legacy namespace tooling issue.</target>
        </segment>
      </unit>
      <unit id="182">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209007)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209014)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You should delete XAML namespace definitions for "vsm:" in any XAML you use for the Windows Runtime, and change any prefix usages for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualState</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">VisualStateGroup</pc></pc> and related objects to use the default XAML namespace instead.</source>
          <target xml:space="preserve">You should delete XAML namespace definitions for "vsm:" in any XAML you use for the Windows Runtime, and change any prefix usages for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualState</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">VisualStateGroup</pc></pc> and related objects to use the default XAML namespace instead.</target>
        </segment>
      </unit>
      <unit id="183">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br229571)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on XAML migration, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Migrating Silverlight or WPF XAML/code to a Windows Runtime app</pc>.</source>
          <target xml:space="preserve">For more info on XAML migration, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Migrating Silverlight or WPF XAML/code to a Windows Runtime app</pc>.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source xml:space="preserve">Mapping custom types to XAML namespaces and prefixes</source>
          <target xml:space="preserve">Mapping custom types to XAML namespaces and prefixes</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source xml:space="preserve">You can map a XAML namespace so that you can use XAML to access your own custom types.</source>
          <target xml:space="preserve">You can map a XAML namespace so that you can use XAML to access your own custom types.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">In other words, you are mapping a code namespace as it exists in a code representation that defines the custom type, and assigning it a XAML namespace along with a prefix for usage.</source>
          <target xml:space="preserve">In other words, you are mapping a code namespace as it exists in a code representation that defines the custom type, and assigning it a XAML namespace along with a prefix for usage.</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source xml:space="preserve">Custom types for XAML can be defined either in a Microsoft .NET language (C# or Microsoft Visual Basic) or in C++.</source>
          <target xml:space="preserve">Custom types for XAML can be defined either in a Microsoft .NET language (C# or Microsoft Visual Basic) or in C++.</target>
        </segment>
      </unit>
      <unit id="188">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The mapping is made by defining an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> prefix.</source>
          <target xml:space="preserve">The mapping is made by defining an <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> prefix.</target>
        </segment>
      </unit>
      <unit id="189">
        <originalData>
          <data id="id1">`xmlns:myTypes`</data>
          <data id="id2">`myTypes:`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, <ph dataRef="id1" id="ph1" /> defines a new XAML namespace that is accessed by prefixing all usages with the token <ph dataRef="id2" id="ph2" />.</source>
          <target xml:space="preserve">For example, <ph dataRef="id1" id="ph1" /> defines a new XAML namespace that is accessed by prefixing all usages with the token <ph dataRef="id2" id="ph2" />.</target>
        </segment>
      </unit>
      <unit id="190">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">An <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> definition includes a value as well as the prefix naming.</source>
          <target xml:space="preserve">An <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> definition includes a value as well as the prefix naming.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source xml:space="preserve">The value is a string that goes inside quotation marks, following an equal sign.</source>
          <target xml:space="preserve">The value is a string that goes inside quotation marks, following an equal sign.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source xml:space="preserve">A common XML convention is to associate the XML namespace with a Uniform Resource Identifier (URI), so that there is a convention for uniqueness and identification.</source>
          <target xml:space="preserve">A common XML convention is to associate the XML namespace with a Uniform Resource Identifier (URI), so that there is a convention for uniqueness and identification.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source xml:space="preserve">You also see this convention for the default XAML namespace and the XAML language XAML namespace, as well as for some lesser-used XAML namespaces that are used by Windows Runtime XAML.</source>
          <target xml:space="preserve">You also see this convention for the default XAML namespace and the XAML language XAML namespace, as well as for some lesser-used XAML namespaces that are used by Windows Runtime XAML.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source xml:space="preserve">But for a XAML namespace that maps custom types, instead of specifying a URI, you begin the prefix definition with the token "using:".</source>
          <target xml:space="preserve">But for a XAML namespace that maps custom types, instead of specifying a URI, you begin the prefix definition with the token "using:".</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source xml:space="preserve">Following the "using:" token, you then name the code namespace.</source>
          <target xml:space="preserve">Following the "using:" token, you then name the code namespace.</target>
        </segment>
      </unit>
      <unit id="196">
        <originalData>
          <data id="id1">`xmlns:custom1="using:CustomClasses"`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, to map a "custom1" prefix that enables you to reference a "CustomClasses" namespace, and use classes from that namespace or assembly as object elements in XAML, your XAML page should include the following mapping on the root element: <ph dataRef="id1" id="ph1" /></source>
          <target xml:space="preserve">For example, to map a "custom1" prefix that enables you to reference a "CustomClasses" namespace, and use classes from that namespace or assembly as object elements in XAML, your XAML page should include the following mapping on the root element: <ph dataRef="id1" id="ph1" /></target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source xml:space="preserve">Partial classes of the same page scope do not need to be mapped.</source>
          <target xml:space="preserve">Partial classes of the same page scope do not need to be mapped.</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source xml:space="preserve">For example, you don't need prefixes to reference any event handlers that you defined for handling events from the XAML UI definition of your page.</source>
          <target xml:space="preserve">For example, you don't need prefixes to reference any event handlers that you defined for handling events from the XAML UI definition of your page.</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source xml:space="preserve">Also, many of the starting XAML pages from Visual Studio generated projects for a Windows Runtime app using C++, C#, or Visual Basic already map a "local:" prefix, which references the project-specified default namespace and the namespace used by partial class definitions.</source>
          <target xml:space="preserve">Also, many of the starting XAML pages from Visual Studio generated projects for a Windows Runtime app using C++, C#, or Visual Basic already map a "local:" prefix, which references the project-specified default namespace and the namespace used by partial class definitions.</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source xml:space="preserve">CLR language rules</source>
          <target xml:space="preserve">CLR language rules</target>
        </segment>
      </unit>
      <unit id="201">
        <segment state="initial">
          <source xml:space="preserve">If you are writing your backing code in a .NET language (C# or Microsoft Visual Basic), you might be using conventions that use a dot (".") as part of namespace names to create a conceptual hierarchy of code namespaces.</source>
          <target xml:space="preserve">If you are writing your backing code in a .NET language (C# or Microsoft Visual Basic), you might be using conventions that use a dot (".") as part of namespace names to create a conceptual hierarchy of code namespaces.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source xml:space="preserve">If your namespace definition contains a dot, the dot should be part of the value you specify after the "using:" token.</source>
          <target xml:space="preserve">If your namespace definition contains a dot, the dot should be part of the value you specify after the "using:" token.</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source xml:space="preserve">If your code-behind file or code definition file is a C++ file, there are certain conventions that still follow the common language runtime (CLR) language form, so that there is no difference in the XAML syntax.</source>
          <target xml:space="preserve">If your code-behind file or code definition file is a C++ file, there are certain conventions that still follow the common language runtime (CLR) language form, so that there is no difference in the XAML syntax.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source xml:space="preserve">If you declare nested namespaces in C++, the separator between the successive nested namespace strings should be "." rather than "::" when you specify the value that follows the "using:" token.</source>
          <target xml:space="preserve">If you declare nested namespaces in C++, the separator between the successive nested namespace strings should be "." rather than "::" when you specify the value that follows the "using:" token.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source xml:space="preserve">Don't use nested types (such as nesting an enumeration within a class) when you define your code for use with XAML.</source>
          <target xml:space="preserve">Don't use nested types (such as nesting an enumeration within a class) when you define your code for use with XAML.</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source xml:space="preserve">Nested types can't be evaluated.</source>
          <target xml:space="preserve">Nested types can't be evaluated.</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source xml:space="preserve">There's no way for the XAML parser to distinguish that a dot is part of the nested type name rather than part of the namespace name.</source>
          <target xml:space="preserve">There's no way for the XAML parser to distinguish that a dot is part of the nested type name rather than part of the namespace name.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source xml:space="preserve">Custom types and assemblies</source>
          <target xml:space="preserve">Custom types and assemblies</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source xml:space="preserve">The name of the assembly that defines the backing types for a XAML namespace is not specified in the mapping.</source>
          <target xml:space="preserve">The name of the assembly that defines the backing types for a XAML namespace is not specified in the mapping.</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source xml:space="preserve">The logic for which assemblies are available is controlled at the app-definition level and is part of basic app deployment and security principles.</source>
          <target xml:space="preserve">The logic for which assemblies are available is controlled at the app-definition level and is part of basic app deployment and security principles.</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source xml:space="preserve">Declare any assembly that you want included as a code-definition source for XAML as a dependent assembly in project settings.</source>
          <target xml:space="preserve">Declare any assembly that you want included as a code-definition source for XAML as a dependent assembly in project settings.</target>
        </segment>
      </unit>
      <unit id="212">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh441572.aspx)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating Windows Runtime components in C# and Visual Basic</pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Creating Windows Runtime components in C# and Visual Basic</pc>.</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source xml:space="preserve">If you are referencing custom types from the primary app's application definition or page definitions, those types are available without further dependent assembly configuration, but you still must map the code namespace that contains those types.</source>
          <target xml:space="preserve">If you are referencing custom types from the primary app's application definition or page definitions, those types are available without further dependent assembly configuration, but you still must map the code namespace that contains those types.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source xml:space="preserve">A common convention is to map the prefix "local" for the default code namespace of any given XAML page.</source>
          <target xml:space="preserve">A common convention is to map the prefix "local" for the default code namespace of any given XAML page.</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source xml:space="preserve">This convention is often included in starting project templates for XAML projects.</source>
          <target xml:space="preserve">This convention is often included in starting project templates for XAML projects.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source xml:space="preserve">Attached properties</source>
          <target xml:space="preserve">Attached properties</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source xml:space="preserve">If you are referencing attached properties, the owner-type portion of the attached property name must either be in the default XAML namespace or be prefixed.</source>
          <target xml:space="preserve">If you are referencing attached properties, the owner-type portion of the attached property name must either be in the default XAML namespace or be prefixed.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source xml:space="preserve">It's rare to prefix attributes separately from their elements but this is one case where it's sometimes required, particularly for a custom attached property.</source>
          <target xml:space="preserve">It's rare to prefix attributes separately from their elements but this is one case where it's sometimes required, particularly for a custom attached property.</target>
        </segment>
      </unit>
      <unit id="219">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](custom-attached-properties.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom attached properties</pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Custom attached properties</pc>.</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source xml:space="preserve">Related topics</source>
          <target xml:space="preserve">Related topics</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source xml:space="preserve">XAML overview</source>
          <target xml:space="preserve">XAML overview</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source xml:space="preserve">XAML syntax guide</source>
          <target xml:space="preserve">XAML syntax guide</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source xml:space="preserve">Creating Windows Runtime components in C# and Visual Basic</source>
          <target xml:space="preserve">Creating Windows Runtime components in C# and Visual Basic</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source xml:space="preserve">C#, VB, and C++ project templates for Windows Runtime apps</source>
          <target xml:space="preserve">C#, VB, and C++ project templates for Windows Runtime apps</target>
        </segment>
      </unit>
      <unit id="225">
        <segment state="initial">
          <source xml:space="preserve">Migrating Silverlight or WPF XAML/code to a Windows Runtime app</source>
          <target xml:space="preserve">Migrating Silverlight or WPF XAML/code to a Windows Runtime app</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>