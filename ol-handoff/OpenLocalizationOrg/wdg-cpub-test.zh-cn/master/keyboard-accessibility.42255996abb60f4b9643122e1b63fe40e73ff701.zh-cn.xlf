<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="zh-cn" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">3695fe8a5c7f3959986fe70ae1b7c7fcf3781aa0</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">Description: If your app does not provide good keyboard access, users who are blind or have mobility issues can have difficulty using your app or may not be able to use it at all.</source>
          <target xml:space="preserve">Description: If your app does not provide good keyboard access, users who are blind or have mobility issues can have difficulty using your app or may not be able to use it at all.</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">title: Keyboard accessibility</source>
          <target xml:space="preserve">title: Keyboard accessibility</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: DDAE8C4B-7907-49FE-9645-F105F8DFAD8B</source>
          <target xml:space="preserve">ms.assetid: DDAE8C4B-7907-49FE-9645-F105F8DFAD8B</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">label: Keyboard accessibility</source>
          <target xml:space="preserve">label: Keyboard accessibility</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">template: detail.hbs</source>
          <target xml:space="preserve">template: detail.hbs</target>
        </segment>
      </unit>
      <unit id="106">
        <segment state="initial">
          <source xml:space="preserve">Keyboard accessibility</source>
          <target xml:space="preserve">Keyboard accessibility</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">If your app does not provide good keyboard access, users who are blind or have mobility issues can have difficulty using your app or may not be able to use it at all.</source>
          <target xml:space="preserve">If your app does not provide good keyboard access, users who are blind or have mobility issues can have difficulty using your app or may not be able to use it at all.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">Keyboard navigation among UI elements</source>
          <target xml:space="preserve">Keyboard navigation among UI elements</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">To use the keyboard with a control, the control must have focus, and to receive focus (without using a pointer) the control must be accessible in a UI design via tab navigation.</source>
          <target xml:space="preserve">To use the keyboard with a control, the control must have focus, and to receive focus (without using a pointer) the control must be accessible in a UI design via tab navigation.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">By default, the tab order of controls is the same as the order in which they are added to a design surface, listed in XAML, or programmatically added to a container.</source>
          <target xml:space="preserve">By default, the tab order of controls is the same as the order in which they are added to a design surface, listed in XAML, or programmatically added to a container.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">In most cases, the default order based on how you defined controls in XAML is the best order, especially because that is the order in which the controls are read by screen readers.</source>
          <target xml:space="preserve">In most cases, the default order based on how you defined controls in XAML is the best order, especially because that is the order in which the controls are read by screen readers.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">However, the default order does not necessarily correspond to the visual order.</source>
          <target xml:space="preserve">However, the default order does not necessarily correspond to the visual order.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source xml:space="preserve">The actual display position might depend on the parent layout container and certain properties that you can set on the child elements to influence the layout.</source>
          <target xml:space="preserve">The actual display position might depend on the parent layout container and certain properties that you can set on the child elements to influence the layout.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">To be sure your app has a good tab order, test this behavior yourself.</source>
          <target xml:space="preserve">To be sure your app has a good tab order, test this behavior yourself.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">Especially if you have a grid metaphor or table metaphor for your layout, the order in which users might read versus the tab order could end up different.</source>
          <target xml:space="preserve">Especially if you have a grid metaphor or table metaphor for your layout, the order in which users might read versus the tab order could end up different.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">That's not always a problem in and of itself.</source>
          <target xml:space="preserve">That's not always a problem in and of itself.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">But just make sure to test your app's functionality both as a touchable UI and as a keyboard-accessible UI and verify that your UI makes sense either way.</source>
          <target xml:space="preserve">But just make sure to test your app's functionality both as a touchable UI and as a keyboard-accessible UI and verify that your UI makes sense either way.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">You can make the tab order match the visual order by adjusting the XAML.</source>
          <target xml:space="preserve">You can make the tab order match the visual order by adjusting the XAML.</target>
        </segment>
      </unit>
      <unit id="121">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209461)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242704)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Or you can override the default tab order by setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> property, as shown in the following example of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Grid</pc></pc> layout that uses column-first tab navigation.</source>
          <target xml:space="preserve">Or you can override the default tab order by setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> property, as shown in the following example of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Grid</pc></pc> layout that uses column-first tab navigation.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">You may want to exclude a control from the tab order.</source>
          <target xml:space="preserve">You may want to exclude a control from the tab order.</target>
        </segment>
      </unit>
      <unit id="123">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209419)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You typically do this only by making the control noninteractive, for example by setting its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsEnabled</pc></pc> property to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">false</pc>.</source>
          <target xml:space="preserve">You typically do this only by making the control noninteractive, for example by setting its <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsEnabled</pc></pc> property to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">false</pc>.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">A disabled control is automatically excluded from the tab order.</source>
          <target xml:space="preserve">A disabled control is automatically excluded from the tab order.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">But occasionally you might want to exclude a control from the tab order even if it is not disabled.</source>
          <target xml:space="preserve">But occasionally you might want to exclude a control from the tab order even if it is not disabled.</target>
        </segment>
      </unit>
      <unit id="126">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209422)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In this case, you can set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsTabStop</pc></pc> property to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">false</pc>.</source>
          <target xml:space="preserve">In this case, you can set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsTabStop</pc></pc> property to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">false</pc>.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source xml:space="preserve">Any elements that can have focus are usually in the tab order by default.</source>
          <target xml:space="preserve">Any elements that can have focus are usually in the tab order by default.</target>
        </segment>
      </unit>
      <unit id="128">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR227565)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The exception to this is that certain text-display types such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RichTextBlock</pc></pc> can have focus so that they can be accessed by the clipboard for text selection; however, they're not in the tab order because it is not expected for static text elements to be in the tab order.</source>
          <target xml:space="preserve">The exception to this is that certain text-display types such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">RichTextBlock</pc></pc> can have focus so that they can be accessed by the clipboard for text selection; however, they're not in the tab order because it is not expected for static text elements to be in the tab order.</target>
        </segment>
      </unit>
      <unit id="129">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/desktop/Ee671194)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">They're not conventionally interactive (they can't be invoked, and don't require text input, but do support the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Text control pattern</pc> that supports finding and adjusting selection points in text).</source>
          <target xml:space="preserve">They're not conventionally interactive (they can't be invoked, and don't require text input, but do support the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Text control pattern</pc> that supports finding and adjusting selection points in text).</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source xml:space="preserve">Text should not have the connotation that setting focus to it will enable some action that's possible.</source>
          <target xml:space="preserve">Text should not have the connotation that setting focus to it will enable some action that's possible.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source xml:space="preserve">Text elements will still be detected by assistive technologies, and read aloud in screen readers, but that relies on techniques other than finding those elements in the practical tab order.</source>
          <target xml:space="preserve">Text elements will still be detected by assistive technologies, and read aloud in screen readers, but that relies on techniques other than finding those elements in the practical tab order.</target>
        </segment>
      </unit>
      <unit id="132">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209461)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Whether you adjust <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> values or use the default order, these rules apply:</source>
          <target xml:space="preserve">Whether you adjust <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> values or use the default order, these rules apply:</target>
        </segment>
      </unit>
      <unit id="133">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209461)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">UI elements with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> equal to 0 are added to the tab order based on declaration order in XAML or child collections.</source>
          <target xml:space="preserve">UI elements with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> equal to 0 are added to the tab order based on declaration order in XAML or child collections.</target>
        </segment>
      </unit>
      <unit id="134">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209461)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">UI elements with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> greater than 0 are added to the tab order based on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">TabIndex</pc> value.</source>
          <target xml:space="preserve">UI elements with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> greater than 0 are added to the tab order based on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">TabIndex</pc> value.</target>
        </segment>
      </unit>
      <unit id="135">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209461)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">UI elements with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> less than 0 are added to the tab order and appear before any zero value.</source>
          <target xml:space="preserve">UI elements with <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">TabIndex</pc></pc> less than 0 are added to the tab order and appear before any zero value.</target>
        </segment>
      </unit>
      <unit id="136">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This potentially differs from HTML's handling of its <pc dataRefEnd="id2" dataRefStart="id1" id="p1">tabindex</pc> attribute (and negative <pc dataRefEnd="id4" dataRefStart="id3" id="p2">tabindex</pc> was not supported in older HTML specifications).</source>
          <target xml:space="preserve">This potentially differs from HTML's handling of its <pc dataRefEnd="id2" dataRefStart="id1" id="p1">tabindex</pc> attribute (and negative <pc dataRefEnd="id4" dataRefStart="id3" id="p2">tabindex</pc> was not supported in older HTML specifications).</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">Keyboard navigation within a UI element</source>
          <target xml:space="preserve">Keyboard navigation within a UI element</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source xml:space="preserve">For composite elements, it is important to ensure proper inner navigation among the contained elements.</source>
          <target xml:space="preserve">For composite elements, it is important to ensure proper inner navigation among the contained elements.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">A composite element can manage its current active child to reduce the overhead of having all child elements able to have focus.</source>
          <target xml:space="preserve">A composite element can manage its current active child to reduce the overhead of having all child elements able to have focus.</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source xml:space="preserve">Such a composite element is included in the tab order, and it handles keyboard navigation events itself.</source>
          <target xml:space="preserve">Such a composite element is included in the tab order, and it handles keyboard navigation events itself.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">Many of the composite controls already have some inner navigation logic built into the into control's event handling.</source>
          <target xml:space="preserve">Many of the composite controls already have some inner navigation logic built into the into control's event handling.</target>
        </segment>
      </unit>
      <unit id="142">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242878)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR242704view)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">[</data>
          <data id="id10">](https://msdn.microsoft.com/library/windows/apps/BR242868)</data>
          <data id="id11">**</data>
          <data id="id12">**</data>
          <data id="id13">[</data>
          <data id="id14">](https://msdn.microsoft.com/library/windows/apps/BR242678)</data>
          <data id="id15">**</data>
          <data id="id16">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, arrow-key traversal of items is enabled by default on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ListBox</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">FlipView</pc></pc> controls.</source>
          <target xml:space="preserve">For example, arrow-key traversal of items is enabled by default on the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc>, <pc dataRefEnd="id10" dataRefStart="id9" id="p5"><pc dataRefEnd="id12" dataRefStart="id11" id="p6">ListBox</pc></pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="p7"><pc dataRefEnd="id16" dataRefStart="id15" id="p8">FlipView</pc></pc> controls.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">Keyboard alternatives to pointer actions and events for specific control elements</source>
          <target xml:space="preserve">Keyboard alternatives to pointer actions and events for specific control elements</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">Ensure that UI elements that can be clicked can also be invoked by using the keyboard.</source>
          <target xml:space="preserve">Ensure that UI elements that can be clicked can also be invoked by using the keyboard.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source xml:space="preserve">To use the keyboard with a UI element, the element must have focus.</source>
          <target xml:space="preserve">To use the keyboard with a UI element, the element must have focus.</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209390)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Only classes that derive from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control</pc></pc> support focus and tab navigation.</source>
          <target xml:space="preserve">Only classes that derive from <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Control</pc></pc> support focus and tab navigation.</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source xml:space="preserve">For UI elements that can be invoked, implement keyboard event handlers for the Spacebar and Enter keys.</source>
          <target xml:space="preserve">For UI elements that can be invoked, implement keyboard event handlers for the Spacebar and Enter keys.</target>
        </segment>
      </unit>
      <unit id="148">
        <segment state="initial">
          <source xml:space="preserve">This makes the basic keyboard accessibility support complete and enables users to accomplish basic app scenarios by using only the keyboard; that is, users can reach all interactive UI elements and activate the default functionality.</source>
          <target xml:space="preserve">This makes the basic keyboard accessibility support complete and enables users to accomplish basic app scenarios by using only the keyboard; that is, users can reach all interactive UI elements and activate the default functionality.</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source xml:space="preserve">In cases where an element that you want to use in the UI cannot have focus, you could create your own custom control.</source>
          <target xml:space="preserve">In cases where an element that you want to use in the UI cannot have focus, you could create your own custom control.</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209422)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You must set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsTabStop</pc></pc> property to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc> to enable focus and you must provide a visual indication of the focused state by creating a visual state that decorates the UI with a focus indicator.</source>
          <target xml:space="preserve">You must set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">IsTabStop</pc></pc> property to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">true</pc> to enable focus and you must provide a visual indication of the focused state by creating a visual state that decorates the UI with a focus indicator.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source xml:space="preserve">However, it is often easier to use control composition so that the support for tab stops, focus, and Microsoft UI Automation peers and patterns are handled by the control within which you choose to compose your content.</source>
          <target xml:space="preserve">However, it is often easier to use control composition so that the support for tab stops, focus, and Microsoft UI Automation peers and patterns are handled by the control within which you choose to compose your content.</target>
        </segment>
      </unit>
      <unit id="152">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR242752)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209265)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, instead of handling a pointer-pressed event on an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image</pc></pc>, you could wrap that element in a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Button</pc></pc> to get pointer, keyboard, and focus support.</source>
          <target xml:space="preserve">For example, instead of handling a pointer-pressed event on an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Image</pc></pc>, you could wrap that element in a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Button</pc></pc> to get pointer, keyboard, and focus support.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source xml:space="preserve">Keyboard shortcuts</source>
          <target xml:space="preserve">Keyboard shortcuts</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">In addition to implementing keyboard navigation and activation for your app, it is a good practice to implement shortcuts for your app's functionality.</source>
          <target xml:space="preserve">In addition to implementing keyboard navigation and activation for your app, it is a good practice to implement shortcuts for your app's functionality.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">Tab navigation provides a good, basic level of keyboard support, but with complex forms you may want to add support for shortcut keys as well.</source>
          <target xml:space="preserve">Tab navigation provides a good, basic level of keyboard support, but with complex forms you may want to add support for shortcut keys as well.</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source xml:space="preserve">This can make your application more efficient to use, even for people who use both a keyboard and pointing devices.</source>
          <target xml:space="preserve">This can make your application more efficient to use, even for people who use both a keyboard and pointing devices.</target>
        </segment>
      </unit>
      <unit id="157">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">shortcut</pc> is a keyboard combination that enhances productivity by providing an efficient way for the user to access app functionality.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1">shortcut</pc> is a keyboard combination that enhances productivity by providing an efficient way for the user to access app functionality.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">There are two kinds of shortcut:</source>
          <target xml:space="preserve">There are two kinds of shortcut:</target>
        </segment>
      </unit>
      <unit id="159">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">An <pc dataRefEnd="id2" dataRefStart="id1" id="p1">access key</pc> is a shortcut to a piece of UI in your app.</source>
          <target xml:space="preserve">An <pc dataRefEnd="id2" dataRefStart="id1" id="p1">access key</pc> is a shortcut to a piece of UI in your app.</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source xml:space="preserve">Access keys consist of the Alt key plus a letter key.</source>
          <target xml:space="preserve">Access keys consist of the Alt key plus a letter key.</target>
        </segment>
      </unit>
      <unit id="161">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">An <pc dataRefEnd="id2" dataRefStart="id1" id="p1">accelerator key</pc> is a shortcut to an app command.</source>
          <target xml:space="preserve">An <pc dataRefEnd="id2" dataRefStart="id1" id="p1">accelerator key</pc> is a shortcut to an app command.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">Your app may or may not have UI that corresponds exactly to the command.</source>
          <target xml:space="preserve">Your app may or may not have UI that corresponds exactly to the command.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source xml:space="preserve">Accelerator keys consist of the Ctrl key plus a letter key.</source>
          <target xml:space="preserve">Accelerator keys consist of the Ctrl key plus a letter key.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source xml:space="preserve">It is imperative that you provide an easy way for users who rely on screen readers and other assistive technology to discover your app's shortcut keys.</source>
          <target xml:space="preserve">It is imperative that you provide an easy way for users who rely on screen readers and other assistive technology to discover your app's shortcut keys.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">Communicate shortcut keys by using tooltips, accessible names, accessible descriptions, or some other form of on-screen communication.</source>
          <target xml:space="preserve">Communicate shortcut keys by using tooltips, accessible names, accessible descriptions, or some other form of on-screen communication.</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source xml:space="preserve">At a minimum, shortcut keys should be well documented in your app's Help content.</source>
          <target xml:space="preserve">At a minimum, shortcut keys should be well documented in your app's Help content.</target>
        </segment>
      </unit>
      <unit id="167">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh759763)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can document access keys through screen readers by setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessKey</pc></pc> attached property to a string that describes the shortcut key.</source>
          <target xml:space="preserve">You can document access keys through screen readers by setting the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AccessKey</pc></pc> attached property to a string that describes the shortcut key.</target>
        </segment>
      </unit>
      <unit id="168">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh759762)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">There is also an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AcceleratorKey</pc></pc> attached property for documenting non-mnemonic shortcut keys, although screen readers generally treat both properties the same way.</source>
          <target xml:space="preserve">There is also an <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">AutomationProperties.AcceleratorKey</pc></pc> attached property for documenting non-mnemonic shortcut keys, although screen readers generally treat both properties the same way.</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source xml:space="preserve">Try to document shortcut keys in multiple ways, using tooltips, automation properties, and written Help documentation.</source>
          <target xml:space="preserve">Try to document shortcut keys in multiple ways, using tooltips, automation properties, and written Help documentation.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source xml:space="preserve">The following example demonstrates how to document shortcut keys for media play, pause, and stop buttons.</source>
          <target xml:space="preserve">The following example demonstrates how to document shortcut keys for media play, pause, and stop buttons.</target>
        </segment>
      </unit>
      <unit id="171">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/Hh759762)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">[</data>
          <data id="id8">](https://msdn.microsoft.com/library/windows/apps/Hh759763)</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  Setting <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationProperties.AcceleratorKey</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">AutomationProperties.AccessKey</pc></pc> doesn't enable keyboard functionality.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Important</pc>  Setting <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">AutomationProperties.AcceleratorKey</pc></pc> or <pc dataRefEnd="id8" dataRefStart="id7" id="p4"><pc dataRefEnd="id10" dataRefStart="id9" id="p5">AutomationProperties.AccessKey</pc></pc> doesn't enable keyboard functionality.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">It only reports to the UI Automation framework what keys should be used, so that such information can be passed on to users via assistive technologies.</source>
          <target xml:space="preserve">It only reports to the UI Automation framework what keys should be used, so that such information can be passed on to users via assistive technologies.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source xml:space="preserve">The implementation for key handling still needs to be done in code, not XAML.</source>
          <target xml:space="preserve">The implementation for key handling still needs to be done in code, not XAML.</target>
        </segment>
      </unit>
      <unit id="174">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208941)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208942)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You will still need to attach handlers for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc> events on the relevant control in order to actually implement the keyboard shortcut behavior in your app.</source>
          <target xml:space="preserve">You will still need to attach handlers for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">KeyDown</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">KeyUp</pc></pc> events on the relevant control in order to actually implement the keyboard shortcut behavior in your app.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">Also, the underline text decoration for an access key is not provided automatically.</source>
          <target xml:space="preserve">Also, the underline text decoration for an access key is not provided automatically.</target>
        </segment>
      </unit>
      <unit id="176">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209982)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You must explicitly underline the text for the specific key in your mnemonic as inline <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Underline</pc></pc> formatting if you wish to show underlined text in the UI.</source>
          <target xml:space="preserve">You must explicitly underline the text for the specific key in your mnemonic as inline <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Underline</pc></pc> formatting if you wish to show underlined text in the UI.</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source xml:space="preserve">For simplicity, the preceding example omits the use of resources for strings such as "Ctrl+A".</source>
          <target xml:space="preserve">For simplicity, the preceding example omits the use of resources for strings such as "Ctrl+A".</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source xml:space="preserve">However, you must also consider shortcut keys during localization.</source>
          <target xml:space="preserve">However, you must also consider shortcut keys during localization.</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source xml:space="preserve">Localizing shortcut keys is relevant because the choice of key to use as the shortcut key typically depends on the visible text label for the element.</source>
          <target xml:space="preserve">Localizing shortcut keys is relevant because the choice of key to use as the shortcut key typically depends on the visible text label for the element.</target>
        </segment>
      </unit>
      <unit id="180">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=221825)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more guidance about implementing shortcut keys, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Shortcut keys</pc> in the Windows User Experience Interaction Guidelines.</source>
          <target xml:space="preserve">For more guidance about implementing shortcut keys, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Shortcut keys</pc> in the Windows User Experience Interaction Guidelines.</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">Implementing a key event handler</source>
          <target xml:space="preserve">Implementing a key event handler</target>
        </segment>
      </unit>
      <unit id="182">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Input events such as the key events use an event concept called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">routed events</pc>.</source>
          <target xml:space="preserve">Input events such as the key events use an event concept called <pc dataRefEnd="id2" dataRefStart="id1" id="p1">routed events</pc>.</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source xml:space="preserve">A routed event can bubble up through the child elements of a composited control, such that a common control parent can handle events for multiple child elements.</source>
          <target xml:space="preserve">A routed event can bubble up through the child elements of a composited control, such that a common control parent can handle events for multiple child elements.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source xml:space="preserve">This event model is convenient for defining shortcut key actions for a control that contains several composite parts that by design cannot have focus or be part of the tab order.</source>
          <target xml:space="preserve">This event model is convenient for defining shortcut key actions for a control that contains several composite parts that by design cannot have focus or be part of the tab order.</target>
        </segment>
      </unit>
      <unit id="185">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Mt185607)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example code that shows how to write a key event handler that includes checking for modifiers such as the Ctrl key, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keyboard interactions</pc>.</source>
          <target xml:space="preserve">For example code that shows how to write a key event handler that includes checking for modifiers such as the Ctrl key, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Keyboard interactions</pc>.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">Keyboard navigation for custom controls</source>
          <target xml:space="preserve">Keyboard navigation for custom controls</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source xml:space="preserve">We recommend the use of arrow keys as keyboard shortcuts for navigating among child elements, in cases where the child elements have a spacial relationship to each other.</source>
          <target xml:space="preserve">We recommend the use of arrow keys as keyboard shortcuts for navigating among child elements, in cases where the child elements have a spacial relationship to each other.</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source xml:space="preserve">If tree-view nodes have separate sub-elements for handling expand-collapse and node activation, use the left and right arrow keys to provide keyboard expand-collapse functionality.</source>
          <target xml:space="preserve">If tree-view nodes have separate sub-elements for handling expand-collapse and node activation, use the left and right arrow keys to provide keyboard expand-collapse functionality.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source xml:space="preserve">If you have an oriented control that supports directional traversal within the control content, use the appropriate arrow keys.</source>
          <target xml:space="preserve">If you have an oriented control that supports directional traversal within the control content, use the appropriate arrow keys.</target>
        </segment>
      </unit>
      <unit id="190">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209390_onkeydown)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209390_onkeyup)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Generally you implement custom key handling for custom controls by including an override of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnKeyDown</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnKeyUp</pc></pc> methods as part of the class logic.</source>
          <target xml:space="preserve">Generally you implement custom key handling for custom controls by including an override of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">OnKeyDown</pc></pc> and <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">OnKeyUp</pc></pc> methods as part of the class logic.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source xml:space="preserve">An example of a visual state for a focus indicator</source>
          <target xml:space="preserve">An example of a visual state for a focus indicator</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source xml:space="preserve">We mentioned earlier that any custom control that enables the user to focus it should have a visual focus indicator.</source>
          <target xml:space="preserve">We mentioned earlier that any custom control that enables the user to focus it should have a visual focus indicator.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source xml:space="preserve">Usually that focus indicator is as simple as drawing a rectangle shape immediately around the control's normal bounding rectangle.</source>
          <target xml:space="preserve">Usually that focus indicator is as simple as drawing a rectangle shape immediately around the control's normal bounding rectangle.</target>
        </segment>
      </unit>
      <unit id="194">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR243371)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR208992)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Rectangle</pc></pc> for visual focus is a peer element to the rest of the control's composition in a control template, but is initially set with a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visibility</pc></pc> value of <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Collapsed</pc> because the control isn't focused yet.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Rectangle</pc></pc> for visual focus is a peer element to the rest of the control's composition in a control template, but is initially set with a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Visibility</pc></pc> value of <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Collapsed</pc> because the control isn't focused yet.</target>
        </segment>
      </unit>
      <unit id="195">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Then, when the control does get focus, a visual state is invoked that specifically sets the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visibility</pc> of the focus visual to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visible</pc>.</source>
          <target xml:space="preserve">Then, when the control does get focus, a visual state is invoked that specifically sets the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visibility</pc> of the focus visual to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visible</pc>.</target>
        </segment>
      </unit>
      <unit id="196">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Once focus is moved elsewhere, another visual state is called, and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visibility</pc> becomes <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Collapsed</pc>.</source>
          <target xml:space="preserve">Once focus is moved elsewhere, another visual state is called, and the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visibility</pc> becomes <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Collapsed</pc>.</target>
        </segment>
      </unit>
      <unit id="197">
        <segment state="initial">
          <source xml:space="preserve">All of the default XAML controls will display an appropriate visual focus indicator when focused (if they can be focused).</source>
          <target xml:space="preserve">All of the default XAML controls will display an appropriate visual focus indicator when focused (if they can be focused).</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source xml:space="preserve">There are also potentially different looks depending on the user's selected theme (particularly if the user is using a high contrast mode.) If you're using the XAML controls in your UI and not replacing the control templates, you don't need to do anything extra to get visual focus indicators on controls that behave and display correctly.</source>
          <target xml:space="preserve">There are also potentially different looks depending on the user's selected theme (particularly if the user is using a high contrast mode.) If you're using the XAML controls in your UI and not replacing the control templates, you don't need to do anything extra to get visual focus indicators on controls that behave and display correctly.</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source xml:space="preserve">But if you're intending to retemplate a control, or if you're curious about how XAML controls provide their visual focus indicators, the remainder of this section explains how this is done in XAML and in the control logic.</source>
          <target xml:space="preserve">But if you're intending to retemplate a control, or if you're curious about how XAML controls provide their visual focus indicators, the remainder of this section explains how this is done in XAML and in the control logic.</target>
        </segment>
      </unit>
      <unit id="200">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209265)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Here's some example XAML that comes from the default XAML template for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc>.</source>
          <target xml:space="preserve">Here's some example XAML that comes from the default XAML template for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="201">
        <segment state="initial">
          <source xml:space="preserve">So far this is just the composition.</source>
          <target xml:space="preserve">So far this is just the composition.</target>
        </segment>
      </unit>
      <unit id="202">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208992)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To control the focus indicator's visibility, you define visual states that toggle the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visibility</pc></pc> property.</source>
          <target xml:space="preserve">To control the focus indicator's visibility, you define visual states that toggle the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visibility</pc></pc> property.</target>
        </segment>
      </unit>
      <unit id="203">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/Hh738505)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">This is done using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualStateManager.VisualStateGroups</pc></pc> attached property, as applied to the root element that defines the composition.</source>
          <target xml:space="preserve">This is done using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualStateManager.VisualStateGroups</pc></pc> attached property, as applied to the root element that defines the composition.</target>
        </segment>
      </unit>
      <unit id="204">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208992)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Note how only one of the named states adjusts <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visibility</pc></pc> directly whereas the others are seemingly empty.</source>
          <target xml:space="preserve">Note how only one of the named states adjusts <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Visibility</pc></pc> directly whereas the others are seemingly empty.</target>
        </segment>
      </unit>
      <unit id="205">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209014)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The way that visual states work is that as soon as the control uses another state from the same <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualStateGroup</pc></pc>, any animations applied by the previous state are immediately canceled.</source>
          <target xml:space="preserve">The way that visual states work is that as soon as the control uses another state from the same <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">VisualStateGroup</pc></pc>, any animations applied by the previous state are immediately canceled.</target>
        </segment>
      </unit>
      <unit id="206">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Because the default <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visibility</pc> from composition is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Collapsed</pc>, this means the rectangle will not appear.</source>
          <target xml:space="preserve">Because the default <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Visibility</pc> from composition is <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Collapsed</pc>, this means the rectangle will not appear.</target>
        </segment>
      </unit>
      <unit id="207">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208927)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR209025)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The control logic controls this by listening for focus events like <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GotFocus</pc></pc> and changing the states with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GoToState</pc></pc>.</source>
          <target xml:space="preserve">The control logic controls this by listening for focus events like <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">GotFocus</pc></pc> and changing the states with <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GoToState</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source xml:space="preserve">Often this is already handled for you if you are using a default control or customizing based on a control that already has that behavior.</source>
          <target xml:space="preserve">Often this is already handled for you if you are using a default control or customizing based on a control that already has that behavior.</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source xml:space="preserve">Keyboard accessibility and Windows Phone</source>
          <target xml:space="preserve">Keyboard accessibility and Windows Phone</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source xml:space="preserve">A Windows Phone device typically doesn't have a dedicated, hardware keyboard.</source>
          <target xml:space="preserve">A Windows Phone device typically doesn't have a dedicated, hardware keyboard.</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source xml:space="preserve">However, a Soft Input Panel (SIP) can support several keyboard accessibility scenarios.</source>
          <target xml:space="preserve">However, a Soft Input Panel (SIP) can support several keyboard accessibility scenarios.</target>
        </segment>
      </unit>
      <unit id="212">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Screen readers can read text input from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Text</pc> SIP, including announcing deletions.</source>
          <target xml:space="preserve">Screen readers can read text input from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Text</pc> SIP, including announcing deletions.</target>
        </segment>
      </unit>
      <unit id="213">
        <segment state="initial">
          <source xml:space="preserve">Users can discover where their fingers are because the screen reader can detect that the user is scanning keys, and it reads the scanned key name aloud.</source>
          <target xml:space="preserve">Users can discover where their fingers are because the screen reader can detect that the user is scanning keys, and it reads the scanned key name aloud.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source xml:space="preserve">Also, some of the keyboard-oriented accessibility concepts can be mapped to related assistive technology behaviors that don't use a keyboard at all.</source>
          <target xml:space="preserve">Also, some of the keyboard-oriented accessibility concepts can be mapped to related assistive technology behaviors that don't use a keyboard at all.</target>
        </segment>
      </unit>
      <unit id="215">
        <segment state="initial">
          <source xml:space="preserve">For example, even though a SIP won't include a Tab key, Narrator supports a touch gesture that's the equivalent of pressing the Tab key, so having a useful tab order through the controls in a UI is still an important accessibility principle.</source>
          <target xml:space="preserve">For example, even though a SIP won't include a Tab key, Narrator supports a touch gesture that's the equivalent of pressing the Tab key, so having a useful tab order through the controls in a UI is still an important accessibility principle.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source xml:space="preserve">Arrow keys as used for navigating the parts within complex controls are also supported through Narrator touch gestures.</source>
          <target xml:space="preserve">Arrow keys as used for navigating the parts within complex controls are also supported through Narrator touch gestures.</target>
        </segment>
      </unit>
      <unit id="217">
        <segment state="initial">
          <source xml:space="preserve">Once focus has reached a control that's not for text input, Narrator supports a gesture that invokes that control's action.</source>
          <target xml:space="preserve">Once focus has reached a control that's not for text input, Narrator supports a gesture that invokes that control's action.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source xml:space="preserve">Keyboard shortcuts aren't typically relevant for Windows Phone apps, because a SIP won't include Control or Alt keys.</source>
          <target xml:space="preserve">Keyboard shortcuts aren't typically relevant for Windows Phone apps, because a SIP won't include Control or Alt keys.</target>
        </segment>
      </unit>
      <unit id="219">
        <segment state="initial">
          <source xml:space="preserve">Related topics</source>
          <target xml:space="preserve">Related topics</target>
        </segment>
      </unit>
      <unit id="220">
        <segment state="initial">
          <source xml:space="preserve">Accessibility</source>
          <target xml:space="preserve">Accessibility</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source xml:space="preserve">Keyboard interactions</source>
          <target xml:space="preserve">Keyboard interactions</target>
        </segment>
      </unit>
      <unit id="222">
        <segment state="initial">
          <source xml:space="preserve">Input: Touch keyboard sample</source>
          <target xml:space="preserve">Input: Touch keyboard sample</target>
        </segment>
      </unit>
      <unit id="223">
        <segment state="initial">
          <source xml:space="preserve">Responding to the appearance of the on-screen keyboard sample</source>
          <target xml:space="preserve">Responding to the appearance of the on-screen keyboard sample</target>
        </segment>
      </unit>
      <unit id="224">
        <segment state="initial">
          <source xml:space="preserve">XAML accessibility sample</source>
          <target xml:space="preserve">XAML accessibility sample</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>