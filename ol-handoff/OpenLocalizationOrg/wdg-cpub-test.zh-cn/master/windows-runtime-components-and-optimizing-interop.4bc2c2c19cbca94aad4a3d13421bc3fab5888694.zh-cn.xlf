<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="zh-cn" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">faec1058546489c4c8873a13ca46fdb8fcfc2070</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: 9899F6A0-7EDD-4988-A76E-79D7C0C58126</source>
          <target xml:space="preserve">ms.assetid: 9899F6A0-7EDD-4988-A76E-79D7C0C58126</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">title: Universal Windows Platform Components and optimizing interop</source>
          <target xml:space="preserve">title: Universal Windows Platform Components and optimizing interop</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">description: Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.</source>
          <target xml:space="preserve">description: Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">Universal Windows Platform Components and optimizing interop</source>
          <target xml:space="preserve">Universal Windows Platform Components and optimizing interop</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="106">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.</source>
          <target xml:space="preserve">Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source xml:space="preserve">Best practices for interoperability with UWP Components</source>
          <target xml:space="preserve">Best practices for interoperability with UWP Components</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">If you are not careful, using UWP Components can have a large impact on your app performance.</source>
          <target xml:space="preserve">If you are not careful, using UWP Components can have a large impact on your app performance.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">This section discusses how to get good performance when your app uses UWP Components.</source>
          <target xml:space="preserve">This section discusses how to get good performance when your app uses UWP Components.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">Introduction</source>
          <target xml:space="preserve">Introduction</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">Interoperability can have a big impact on performance and you might be using it without even realizing that you are.</source>
          <target xml:space="preserve">Interoperability can have a big impact on performance and you might be using it without even realizing that you are.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">The UWP handles a lot of the interoperability for you so that you can be more productive and reuse code that was written in other languages.</source>
          <target xml:space="preserve">The UWP handles a lot of the interoperability for you so that you can be more productive and reuse code that was written in other languages.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">We encourage you to take advantage of what the UWP does for you, but be aware that it can impact performance.</source>
          <target xml:space="preserve">We encourage you to take advantage of what the UWP does for you, but be aware that it can impact performance.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source xml:space="preserve">This section discusses things you can do to lessen the impact that interoperability has on your app's performance.</source>
          <target xml:space="preserve">This section discusses things you can do to lessen the impact that interoperability has on your app's performance.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">The UWP has a library of types that are accessible from any language that can write a UWP app.</source>
          <target xml:space="preserve">The UWP has a library of types that are accessible from any language that can write a UWP app.</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">You use the UWP types in C# or Microsoft Visual Basic the same way you use .NET objects.</source>
          <target xml:space="preserve">You use the UWP types in C# or Microsoft Visual Basic the same way you use .NET objects.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">You don't need to make platform invoke method calls to access the UWP components.</source>
          <target xml:space="preserve">You don't need to make platform invoke method calls to access the UWP components.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">This makes writing your apps much less complex, but it is important to realize that there might be more interoperability occurring than you expect.</source>
          <target xml:space="preserve">This makes writing your apps much less complex, but it is important to realize that there might be more interoperability occurring than you expect.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">If a UWP component is written in a language other than C# or Visual Basic, you cross interoperability boundaries when you use that component.</source>
          <target xml:space="preserve">If a UWP component is written in a language other than C# or Visual Basic, you cross interoperability boundaries when you use that component.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">Crossing interoperability boundaries can impact the performance of an app.</source>
          <target xml:space="preserve">Crossing interoperability boundaries can impact the performance of an app.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">When you develop a UWP app in C# or Visual Basic, the two most common set of APIs that you use are the UWP APIs and the .NET APIs for UWP apps.</source>
          <target xml:space="preserve">When you develop a UWP app in C# or Visual Basic, the two most common set of APIs that you use are the UWP APIs and the .NET APIs for UWP apps.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">In general, types that are defined in the UWP are in namespaces that begin with "Windows."</source>
          <target xml:space="preserve">In general, types that are defined in the UWP are in namespaces that begin with "Windows."</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">and .NET types are in namespaces that begin with "System."</source>
          <target xml:space="preserve">and .NET types are in namespaces that begin with "System."</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">There are exceptions, though.</source>
          <target xml:space="preserve">There are exceptions, though.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source xml:space="preserve">The types in .NET for UWP apps do not require interoperability when they are used.</source>
          <target xml:space="preserve">The types in .NET for UWP apps do not require interoperability when they are used.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source xml:space="preserve">If you find that you have bad performance in an area that uses UWP, you might be able to use .NET for UWP apps instead to get better performance.</source>
          <target xml:space="preserve">If you find that you have bad performance in an area that uses UWP, you might be able to use .NET for UWP apps instead to get better performance.</target>
        </segment>
      </unit>
      <unit id="128">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>
					</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>
					</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source xml:space="preserve">Most of the UWP components that ship with Windows 10 are implemented in C++ so you cross interoperability boundaries when you use them from C# or Visual Basic.</source>
          <target xml:space="preserve">Most of the UWP components that ship with Windows 10 are implemented in C++ so you cross interoperability boundaries when you use them from C# or Visual Basic.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source xml:space="preserve">As always, make sure to measure your app to see if using UWP components affects your app's performance before you invest in making changes to your code.</source>
          <target xml:space="preserve">As always, make sure to measure your app to see if using UWP components affects your app's performance before you invest in making changes to your code.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source xml:space="preserve">In this topic, when we say "UWP components", we mean components that are written in a language other than C# or Visual Basic.</source>
          <target xml:space="preserve">In this topic, when we say "UWP components", we mean components that are written in a language other than C# or Visual Basic.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source xml:space="preserve">Each time you access a property or call a method on a UWP component, an interoperability cost is incurred.</source>
          <target xml:space="preserve">Each time you access a property or call a method on a UWP component, an interoperability cost is incurred.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">In fact, creating a UWP component is more costly than creating a .NET object.</source>
          <target xml:space="preserve">In fact, creating a UWP component is more costly than creating a .NET object.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">The reasons for this are that the UWP must execute code that transitions from your app's language to the component's language.</source>
          <target xml:space="preserve">The reasons for this are that the UWP must execute code that transitions from your app's language to the component's language.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">Also, if you pass data to the component, the data must be converted between managed and unmanaged types.</source>
          <target xml:space="preserve">Also, if you pass data to the component, the data must be converted between managed and unmanaged types.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source xml:space="preserve">Using UWP Components efficiently</source>
          <target xml:space="preserve">Using UWP Components efficiently</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">If you find that you need to get better performance, you can ensure that your code uses UWP components as efficiently as possible.</source>
          <target xml:space="preserve">If you find that you need to get better performance, you can ensure that your code uses UWP components as efficiently as possible.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source xml:space="preserve">This section discusses some tips for improving performance when you use UWP components.</source>
          <target xml:space="preserve">This section discusses some tips for improving performance when you use UWP components.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">It takes a significant number of calls in a short period of time for the performance impact to be noticeable.</source>
          <target xml:space="preserve">It takes a significant number of calls in a short period of time for the performance impact to be noticeable.</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source xml:space="preserve">A well-designed application that encapsulates calls to UWP components from business logic and other managed code should not incur huge interoperability costs.</source>
          <target xml:space="preserve">A well-designed application that encapsulates calls to UWP components from business logic and other managed code should not incur huge interoperability costs.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">But if your tests indicate that using UWP components is affecting your app's performance, the tips discussed in this section help you improve performance.</source>
          <target xml:space="preserve">But if your tests indicate that using UWP components is affecting your app's performance, the tips discussed in this section help you improve performance.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source xml:space="preserve">Consider using .NET for UWP apps</source>
          <target xml:space="preserve">Consider using .NET for UWP apps</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">There are certain cases where you can accomplish a task by using either UWP or .NET for UWP apps.</source>
          <target xml:space="preserve">There are certain cases where you can accomplish a task by using either UWP or .NET for UWP apps.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">It is a good idea to try to not mix .NET types and UWP types.</source>
          <target xml:space="preserve">It is a good idea to try to not mix .NET types and UWP types.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source xml:space="preserve">Try to stay in one or the other.</source>
          <target xml:space="preserve">Try to stay in one or the other.</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR206173)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.xml.xmlreader.aspx)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, you can parse a stream of xml by using either the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Data.Xml.Dom.XmlDocument</pc></pc> type (a UWP type) or the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">System.Xml.XmlReader</pc></pc> type (a .NET type).</source>
          <target xml:space="preserve">For example, you can parse a stream of xml by using either the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Data.Xml.Dom.XmlDocument</pc></pc> type (a UWP type) or the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">System.Xml.XmlReader</pc></pc> type (a .NET type).</target>
        </segment>
      </unit>
      <unit id="147">
        <segment state="initial">
          <source xml:space="preserve">Use the API that is from the same technology as the stream.</source>
          <target xml:space="preserve">Use the API that is from the same technology as the stream.</target>
        </segment>
      </unit>
      <unit id="148">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.io.memorystream.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, if you read xml from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MemoryStream</pc></pc>, use the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">System.Xml.XmlReader</pc> type, because both types are .NET types.</source>
          <target xml:space="preserve">For example, if you read xml from a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MemoryStream</pc></pc>, use the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">System.Xml.XmlReader</pc> type, because both types are .NET types.</target>
        </segment>
      </unit>
      <unit id="149">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you read from a file, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows.Data.Xml.Dom.XmlDocument</pc> type because the file APIs and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">XmlDocument</pc> are UWP components.</source>
          <target xml:space="preserve">If you read from a file, use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Windows.Data.Xml.Dom.XmlDocument</pc> type because the file APIs and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">XmlDocument</pc> are UWP components.</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source xml:space="preserve">Copy Window Runtime objects to .NET types</source>
          <target xml:space="preserve">Copy Window Runtime objects to .NET types</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source xml:space="preserve">When a UWP component returns a UWP object, it might be beneficial to copy the returned object into a .NET object.</source>
          <target xml:space="preserve">When a UWP component returns a UWP object, it might be beneficial to copy the returned object into a .NET object.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source xml:space="preserve">Two places where this is especially important is when you're working with collections and streams.</source>
          <target xml:space="preserve">Two places where this is especially important is when you're working with collections and streams.</target>
        </segment>
      </unit>
      <unit id="153">
        <segment state="initial">
          <source xml:space="preserve">If you call a UWP API that returns a collection and then you save and access that collection many times, it might be beneficial to copy the collection into a .NET collection and use the .NET version from then on.</source>
          <target xml:space="preserve">If you call a UWP API that returns a collection and then you save and access that collection many times, it might be beneficial to copy the collection into a .NET collection and use the .NET version from then on.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">Cache the results of calls to UWP components for later use</source>
          <target xml:space="preserve">Cache the results of calls to UWP components for later use</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">You might be able to get better performance by saving values into local variables instead of accessing a UWP type multiple times.</source>
          <target xml:space="preserve">You might be able to get better performance by saving values into local variables instead of accessing a UWP type multiple times.</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source xml:space="preserve">This can be especially beneficial if you use a value inside of a loop.</source>
          <target xml:space="preserve">This can be especially beneficial if you use a value inside of a loop.</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source xml:space="preserve">Measure your app to see if using local variables improves your app's performance.</source>
          <target xml:space="preserve">Measure your app to see if using local variables improves your app's performance.</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">Using cached values can increase your app's speed because it will spend less time on interoperability.</source>
          <target xml:space="preserve">Using cached values can increase your app's speed because it will spend less time on interoperability.</target>
        </segment>
      </unit>
      <unit id="159">
        <segment state="initial">
          <source xml:space="preserve">Combine calls to UWP components</source>
          <target xml:space="preserve">Combine calls to UWP components</target>
        </segment>
      </unit>
      <unit id="160">
        <segment state="initial">
          <source xml:space="preserve">Try to complete tasks with the fewest number of calls to UWP objects as possible.</source>
          <target xml:space="preserve">Try to complete tasks with the fewest number of calls to UWP objects as possible.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source xml:space="preserve">For example, it is usually better to read a large amount of data from a stream than to read small amounts at a time.</source>
          <target xml:space="preserve">For example, it is usually better to read a large amount of data from a stream than to read small amounts at a time.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">Use APIs that bundle work in as few calls as possible instead of APIs that do less work and require more calls.</source>
          <target xml:space="preserve">Use APIs that bundle work in as few calls as possible instead of APIs that do less work and require more calls.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source xml:space="preserve">For example, prefer to create an object by calling constructors that initialize multiple properties instead of calling the default constructor and assigning properties one at a time.</source>
          <target xml:space="preserve">For example, prefer to create an object by calling constructors that initialize multiple properties instead of calling the default constructor and assigning properties one at a time.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source xml:space="preserve">Building a UWP components</source>
          <target xml:space="preserve">Building a UWP components</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">If you write a UWP Component that can be used by apps written in C++ or JavaScript, make sure that your component is designed for good performance.</source>
          <target xml:space="preserve">If you write a UWP Component that can be used by apps written in C++ or JavaScript, make sure that your component is designed for good performance.</target>
        </segment>
      </unit>
      <unit id="166">
        <segment state="initial">
          <source xml:space="preserve">All the suggestions for getting good performance in apps apply to getting good performance in components.</source>
          <target xml:space="preserve">All the suggestions for getting good performance in apps apply to getting good performance in components.</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source xml:space="preserve">Measure your component to find out which APIs have high traffic patterns and for those areas, consider providing APIs that enable your users to do work with few calls.</source>
          <target xml:space="preserve">Measure your component to find out which APIs have high traffic patterns and for those areas, consider providing APIs that enable your users to do work with few calls.</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source xml:space="preserve">Keep your app fast when you use interop in managed code</source>
          <target xml:space="preserve">Keep your app fast when you use interop in managed code</target>
        </segment>
      </unit>
      <unit id="169">
        <segment state="initial">
          <source xml:space="preserve">The UWP makes it easy to interoperate between native and managed code, but if you're not careful it can incur performance costs.</source>
          <target xml:space="preserve">The UWP makes it easy to interoperate between native and managed code, but if you're not careful it can incur performance costs.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source xml:space="preserve">Here we show you how to get good performance when you use interop in your managed UWP apps.</source>
          <target xml:space="preserve">Here we show you how to get good performance when you use interop in your managed UWP apps.</target>
        </segment>
      </unit>
      <unit id="171">
        <segment state="initial">
          <source xml:space="preserve">The UWP allows developers to write apps using XAML with their language of choice thanks to the projections of the UWP APIs available in each language.</source>
          <target xml:space="preserve">The UWP allows developers to write apps using XAML with their language of choice thanks to the projections of the UWP APIs available in each language.</target>
        </segment>
      </unit>
      <unit id="172">
        <segment state="initial">
          <source xml:space="preserve">When writing an app in C# or Visual Basic, this convenience comes at an interop cost because the UWP APIs are usually implemented in native code, and any UWP invocation from C# or Visual Basic requires that the CLR transition from a managed to a native stack frame and marshal function parameters to representations accessible by native code.</source>
          <target xml:space="preserve">When writing an app in C# or Visual Basic, this convenience comes at an interop cost because the UWP APIs are usually implemented in native code, and any UWP invocation from C# or Visual Basic requires that the CLR transition from a managed to a native stack frame and marshal function parameters to representations accessible by native code.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source xml:space="preserve">This overhead is negligible for most apps.</source>
          <target xml:space="preserve">This overhead is negligible for most apps.</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source xml:space="preserve">But when you make many calls (hundreds of thousands, to millions) to UWP APIs in the critical path of an app, this cost can become noticeable.</source>
          <target xml:space="preserve">But when you make many calls (hundreds of thousands, to millions) to UWP APIs in the critical path of an app, this cost can become noticeable.</target>
        </segment>
      </unit>
      <unit id="175">
        <segment state="initial">
          <source xml:space="preserve">In general you want to ensure that the time spent in transition between languages is small relative to the execution of the rest of your code.</source>
          <target xml:space="preserve">In general you want to ensure that the time spent in transition between languages is small relative to the execution of the rest of your code.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source xml:space="preserve">This is illustrated by the following diagram.</source>
          <target xml:space="preserve">This is illustrated by the following diagram.</target>
        </segment>
      </unit>
      <unit id="177">
        <originalData>
          <data id="id1">![</data>
          <data id="id2">](images/interop-transitions.png)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<ph dataRef="id1" id="ph1" />Interop transitions should not dominate the program execution time.<ph dataRef="id2" id="ph2" /></source>
          <target xml:space="preserve">
						<ph dataRef="id1" id="ph1" />Interop transitions should not dominate the program execution time.<ph dataRef="id2" id="ph2" /></target>
        </segment>
      </unit>
      <unit id="178">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/br230232.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The types listed at <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">.NET for Windows apps</pc></pc> don't incur this interop cost when used from C# or Visual Basic.</source>
          <target xml:space="preserve">The types listed at <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">.NET for Windows apps</pc></pc> don't incur this interop cost when used from C# or Visual Basic.</target>
        </segment>
      </unit>
      <unit id="179">
        <segment state="initial">
          <source xml:space="preserve">As a rule of thumb, you can assume that types in namespaces which begin with “Windows.”</source>
          <target xml:space="preserve">As a rule of thumb, you can assume that types in namespaces which begin with “Windows.”</target>
        </segment>
      </unit>
      <unit id="180">
        <segment state="initial">
          <source xml:space="preserve">are part of the UWP, and types in namespaces which begin with “System.”</source>
          <target xml:space="preserve">are part of the UWP, and types in namespaces which begin with “System.”</target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">are .NET types.</source>
          <target xml:space="preserve">are .NET types.</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source xml:space="preserve">Keep in mind that even simple usage of UWP types such as allocation or property access incurs an interop cost.</source>
          <target xml:space="preserve">Keep in mind that even simple usage of UWP types such as allocation or property access incurs an interop cost.</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source xml:space="preserve">You should measure your app and determine if interop is taking up a large portion of your apps execution time before optimizing your interop costs.</source>
          <target xml:space="preserve">You should measure your app and determine if interop is taking up a large portion of your apps execution time before optimizing your interop costs.</target>
        </segment>
      </unit>
      <unit id="184">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When analyzing your app’s performance with Visual Studio, you can easily get an upper bound on your interop costs by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Functions</pc> view and looking at inclusive time spent in methods which call into the UWP.</source>
          <target xml:space="preserve">When analyzing your app’s performance with Visual Studio, you can easily get an upper bound on your interop costs by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Functions</pc> view and looking at inclusive time spent in methods which call into the UWP.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source xml:space="preserve">If your app is slow because of interop overhead, you can improve its performance by reducing calls to UWP APIs on hot code paths.</source>
          <target xml:space="preserve">If your app is slow because of interop overhead, you can improve its performance by reducing calls to UWP APIs on hot code paths.</target>
        </segment>
      </unit>
      <unit id="186">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208911)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, a game engine that is doing tons of physics calculations by constantly querying the position and dimensions of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElements</pc></pc> can save a lot of time by storing the necessary info from <pc dataRefEnd="id6" dataRefStart="id5" id="p3">UIElements</pc> to local variables, doing calculations on these cached values, and assigning the end result back to the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">UIElements</pc> after the calculations are done.</source>
          <target xml:space="preserve">For example, a game engine that is doing tons of physics calculations by constantly querying the position and dimensions of <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">UIElements</pc></pc> can save a lot of time by storing the necessary info from <pc dataRefEnd="id6" dataRefStart="id5" id="p3">UIElements</pc> to local variables, doing calculations on these cached values, and assigning the end result back to the <pc dataRefEnd="id8" dataRefStart="id7" id="p4">UIElements</pc> after the calculations are done.</target>
        </segment>
      </unit>
      <unit id="187">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/en-us/library/windows/apps/xaml/system.collections.aspx)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/BR206657)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Another example: if a collection is heavily accessed by C# or Visual Basic code, then it is more efficient to use a collection from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.Collections</pc></pc> namespace, rather than a collection from the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Windows.Foundation.Collections</pc></pc> namespace.</source>
          <target xml:space="preserve">Another example: if a collection is heavily accessed by C# or Visual Basic code, then it is more efficient to use a collection from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">System.Collections</pc></pc> namespace, rather than a collection from the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Windows.Foundation.Collections</pc></pc> namespace.</target>
        </segment>
      </unit>
      <unit id="188">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR207676)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You may also consider combining calls to UWP components; one example where this is possible is by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Storage.BulkAccess</pc></pc> APIs.</source>
          <target xml:space="preserve">You may also consider combining calls to UWP components; one example where this is possible is by using the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Windows.Storage.BulkAccess</pc></pc> APIs.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source xml:space="preserve">Building a UWP component</source>
          <target xml:space="preserve">Building a UWP component</target>
        </segment>
      </unit>
      <unit id="190">
        <segment state="initial">
          <source xml:space="preserve">If you write a UWP component for use in apps written in C++ or JavaScript, make sure that your component is designed for good performance.</source>
          <target xml:space="preserve">If you write a UWP component for use in apps written in C++ or JavaScript, make sure that your component is designed for good performance.</target>
        </segment>
      </unit>
      <unit id="191">
        <segment state="initial">
          <source xml:space="preserve">Your API surface defines your interop boundary and defines the degree to which your users will have to think about the guidance in this topic.</source>
          <target xml:space="preserve">Your API surface defines your interop boundary and defines the degree to which your users will have to think about the guidance in this topic.</target>
        </segment>
      </unit>
      <unit id="192">
        <segment state="initial">
          <source xml:space="preserve">If you are distributing your components to other parties then this becomes especially important.</source>
          <target xml:space="preserve">If you are distributing your components to other parties then this becomes especially important.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source xml:space="preserve">All of the suggestions for getting good performance in apps apply to getting good performance in components.</source>
          <target xml:space="preserve">All of the suggestions for getting good performance in apps apply to getting good performance in components.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source xml:space="preserve">Measure your component to find out which APIs have high traffic patterns, and for those areas, consider providing APIs that enable your users to do work with few calls.</source>
          <target xml:space="preserve">Measure your component to find out which APIs have high traffic patterns, and for those areas, consider providing APIs that enable your users to do work with few calls.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source xml:space="preserve">Significant effort was put into designing the UWP to allow apps to use it without requiring frequent crossing of the interop boundary.</source>
          <target xml:space="preserve">Significant effort was put into designing the UWP to allow apps to use it without requiring frequent crossing of the interop boundary.</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>