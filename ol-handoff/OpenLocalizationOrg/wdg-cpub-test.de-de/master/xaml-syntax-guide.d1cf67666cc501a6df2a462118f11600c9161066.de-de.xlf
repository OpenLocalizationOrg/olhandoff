<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-us" trgLang="de-de" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">0e35a20c8fa071afc349afb023936a5bc027cd03</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <group id="101">
        <unit id="101">
          <segment state="initial" id="101">
            <source xml:space="preserve">XAML syntax guide</source>
            <target xml:space="preserve">XAML syntax guide</target>
          </segment>
        </unit>
        <unit id="102">
          <segment state="initial" id="102">
            <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
            <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
          </segment>
        </unit>
        <unit id="103">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="103">
            <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</source>
            <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</target>
          </segment>
        </unit>
        <unit id="104">
          <segment state="initial" id="104">
            <source xml:space="preserve">We explain XAML syntax rules and the terminology that describes the restrictions or choices available for XAML syntax.</source>
            <target xml:space="preserve">We explain XAML syntax rules and the terminology that describes the restrictions or choices available for XAML syntax.</target>
          </segment>
        </unit>
        <unit id="105">
          <segment state="initial" id="105">
            <source xml:space="preserve">You'll find this topic useful if you are new to using the XAML language, you want a refresher on the terminology or parts of syntax, or you are curious about how the XAML language works and want more background and context.</source>
            <target xml:space="preserve">You'll find this topic useful if you are new to using the XAML language, you want a refresher on the terminology or parts of syntax, or you are curious about how the XAML language works and want more background and context.</target>
          </segment>
        </unit>
        <unit id="106">
          <segment state="initial" id="106">
            <source xml:space="preserve">XAML is XML</source>
            <target xml:space="preserve">XAML is XML</target>
          </segment>
        </unit>
        <unit id="107">
          <segment state="initial" id="107">
            <source xml:space="preserve">Extensible Application Markup Language (XAML) has a basic syntax that builds on XML, and by definition valid XAML must be valid XML.</source>
            <target xml:space="preserve">Extensible Application Markup Language (XAML) has a basic syntax that builds on XML, and by definition valid XAML must be valid XML.</target>
          </segment>
        </unit>
        <unit id="108">
          <segment state="initial" id="108">
            <source xml:space="preserve">But XAML also has its own syntax concepts that extend XML.</source>
            <target xml:space="preserve">But XAML also has its own syntax concepts that extend XML.</target>
          </segment>
        </unit>
        <unit id="109">
          <segment state="initial" id="109">
            <source xml:space="preserve">A given XML entity might be valid in plain XML, but that syntax might have a different and more complete meaning as XAML.</source>
            <target xml:space="preserve">A given XML entity might be valid in plain XML, but that syntax might have a different and more complete meaning as XAML.</target>
          </segment>
        </unit>
        <unit id="110">
          <segment state="initial" id="110">
            <source xml:space="preserve">This topic explains these XAML syntax concepts.</source>
            <target xml:space="preserve">This topic explains these XAML syntax concepts.</target>
          </segment>
        </unit>
        <unit id="111">
          <segment state="initial" id="111">
            <source xml:space="preserve">XAML vocabularies</source>
            <target xml:space="preserve">XAML vocabularies</target>
          </segment>
        </unit>
        <unit id="112">
          <segment state="initial" id="112">
            <source xml:space="preserve">One area where XAML differs from most XML usages is that XAML is not typically enforced with a schema, such as an XSD file.</source>
            <target xml:space="preserve">One area where XAML differs from most XML usages is that XAML is not typically enforced with a schema, such as an XSD file.</target>
          </segment>
        </unit>
        <unit id="113">
          <segment state="initial" id="113">
            <source xml:space="preserve">That's because XAML is intended to be extensible, that's what the "X" in the acronym XAML means.</source>
            <target xml:space="preserve">That's because XAML is intended to be extensible, that's what the "X" in the acronym XAML means.</target>
          </segment>
        </unit>
        <unit id="114">
          <segment state="initial" id="114">
            <source xml:space="preserve">Once XAML is parsed, the elements and attributes you reference in XAML are expected to exist in some backing code representation, either in the core types defined by the Windows Runtime, or in types that extend or are based off the Windows Runtime.</source>
            <target xml:space="preserve">Once XAML is parsed, the elements and attributes you reference in XAML are expected to exist in some backing code representation, either in the core types defined by the Windows Runtime, or in types that extend or are based off the Windows Runtime.</target>
          </segment>
        </unit>
        <unit id="115">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="115">
            <source xml:space="preserve">The SDK documentation sometimes refers to the types that are already built-in to the Windows Runtime and can be used in XAML as being the <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML vocabulary</pc> for the Windows Runtime.</source>
            <target xml:space="preserve">The SDK documentation sometimes refers to the types that are already built-in to the Windows Runtime and can be used in XAML as being the <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML vocabulary</pc> for the Windows Runtime.</target>
          </segment>
        </unit>
        <unit id="116">
          <segment state="initial" id="116">
            <source xml:space="preserve">Microsoft Visual Studio helps you to produce markup that's valid within this XAML vocabulary.</source>
            <target xml:space="preserve">Microsoft Visual Studio helps you to produce markup that's valid within this XAML vocabulary.</target>
          </segment>
        </unit>
        <unit id="117">
          <segment state="initial" id="117">
            <source xml:space="preserve">Visual Studio can also include your custom types for XAML usage so long as the source of those types is referenced correctly in the project.</source>
            <target xml:space="preserve">Visual Studio can also include your custom types for XAML usage so long as the source of those types is referenced correctly in the project.</target>
          </segment>
        </unit>
        <unit id="118">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="118">
            <source xml:space="preserve">For more info about XAML and custom types, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">XAML namespaces and namespace mapping</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For more info about XAML and custom types, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">XAML namespaces and namespace mapping</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="119">
          <segment state="initial" id="119">
            <source xml:space="preserve">Declaring objects</source>
            <target xml:space="preserve">Declaring objects</target>
          </segment>
        </unit>
        <unit id="120">
          <segment state="initial" id="120">
            <source xml:space="preserve">Programmers often think in terms of objects and members, whereas a markup language is conceptualized as elements and attributes.</source>
            <target xml:space="preserve">Programmers often think in terms of objects and members, whereas a markup language is conceptualized as elements and attributes.</target>
          </segment>
        </unit>
        <unit id="121">
          <segment state="initial" id="121">
            <source xml:space="preserve">In the most basic sense, an element that you declare in XAML markup becomes an object in a backing runtime object representation.</source>
            <target xml:space="preserve">In the most basic sense, an element that you declare in XAML markup becomes an object in a backing runtime object representation.</target>
          </segment>
        </unit>
        <unit id="122">
          <segment state="initial" id="122">
            <source xml:space="preserve">To create a run-time object for your app, you declare a XAML element in the XAML markup.</source>
            <target xml:space="preserve">To create a run-time object for your app, you declare a XAML element in the XAML markup.</target>
          </segment>
        </unit>
        <unit id="123">
          <segment state="initial" id="123">
            <source xml:space="preserve">The object is created when the Windows Runtime loads your XAML.</source>
            <target xml:space="preserve">The object is created when the Windows Runtime loads your XAML.</target>
          </segment>
        </unit>
        <unit id="124">
          <segment state="initial" id="124">
            <source xml:space="preserve">A XAML file always has exactly one element serving as its root, which declares an object that will be the conceptual root of some programming structure such as a page, or the object graph of the entire run-time definition of an application.</source>
            <target xml:space="preserve">A XAML file always has exactly one element serving as its root, which declares an object that will be the conceptual root of some programming structure such as a page, or the object graph of the entire run-time definition of an application.</target>
          </segment>
        </unit>
        <unit id="125">
          <segment state="initial" id="125">
            <source xml:space="preserve">In terms of XAML syntax, there are three ways to declare objects in XAML:</source>
            <target xml:space="preserve">In terms of XAML syntax, there are three ways to declare objects in XAML:</target>
          </segment>
        </unit>
        <unit id="126">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="126">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Directly, using object element syntax:</pc> This uses opening and closing tags to instantiate an object as an XML-form element.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Directly, using object element syntax:</pc> This uses opening and closing tags to instantiate an object as an XML-form element.</target>
          </segment>
        </unit>
        <unit id="127">
          <segment state="initial" id="127">
            <source xml:space="preserve">You can use this syntax to declare root objects or to create nested objects that set property values.</source>
            <target xml:space="preserve">You can use this syntax to declare root objects or to create nested objects that set property values.</target>
          </segment>
        </unit>
        <unit id="128">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="128">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Indirectly, using attribute syntax:</pc> This uses an inline string value that has instructions for how to create an object.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Indirectly, using attribute syntax:</pc> This uses an inline string value that has instructions for how to create an object.</target>
          </segment>
        </unit>
        <unit id="129">
          <segment state="initial" id="129">
            <source xml:space="preserve">The XAML parser uses this string to set the value of a property to a newly created reference value.</source>
            <target xml:space="preserve">The XAML parser uses this string to set the value of a property to a newly created reference value.</target>
          </segment>
        </unit>
        <unit id="130">
          <segment state="initial" id="130">
            <source xml:space="preserve">Support for it is limited to certain common objects and properties.</source>
            <target xml:space="preserve">Support for it is limited to certain common objects and properties.</target>
          </segment>
        </unit>
        <unit id="131">
          <segment state="initial" id="131">
            <source xml:space="preserve">Using a markup extension.</source>
            <target xml:space="preserve">Using a markup extension.</target>
          </segment>
        </unit>
        <unit id="132">
          <segment state="initial" id="132">
            <source xml:space="preserve">This does not mean that you always have the choice of any syntax for object creation in a XAML vocabulary.</source>
            <target xml:space="preserve">This does not mean that you always have the choice of any syntax for object creation in a XAML vocabulary.</target>
          </segment>
        </unit>
        <unit id="133">
          <segment state="initial" id="133">
            <source xml:space="preserve">Some objects can be created only by using object element syntax.</source>
            <target xml:space="preserve">Some objects can be created only by using object element syntax.</target>
          </segment>
        </unit>
        <unit id="134">
          <segment state="initial" id="134">
            <source xml:space="preserve">Some objects can be created only by being initially set in an attribute.</source>
            <target xml:space="preserve">Some objects can be created only by being initially set in an attribute.</target>
          </segment>
        </unit>
        <unit id="135">
          <segment state="initial" id="135">
            <source xml:space="preserve">In fact, objects that can be created with either object element or attribute syntax are comparatively rare in XAML vocabularies.</source>
            <target xml:space="preserve">In fact, objects that can be created with either object element or attribute syntax are comparatively rare in XAML vocabularies.</target>
          </segment>
        </unit>
        <unit id="136">
          <segment state="initial" id="136">
            <source xml:space="preserve">Even if both syntax forms are possible, one of the syntaxes will be more common as a matter of style.</source>
            <target xml:space="preserve">Even if both syntax forms are possible, one of the syntaxes will be more common as a matter of style.</target>
          </segment>
        </unit>
        <unit id="137">
          <segment state="initial" id="137">
            <source xml:space="preserve">There are also techniques you can use in XAML to reference existing objects rather than creating new values.</source>
            <target xml:space="preserve">There are also techniques you can use in XAML to reference existing objects rather than creating new values.</target>
          </segment>
        </unit>
        <unit id="138">
          <segment state="initial" id="138">
            <source xml:space="preserve">The existing objects might be defined either in other areas of XAML, or might exist implicitly through some behavior of the platform and its application or programming models.</source>
            <target xml:space="preserve">The existing objects might be defined either in other areas of XAML, or might exist implicitly through some behavior of the platform and its application or programming models.</target>
          </segment>
        </unit>
        <unit id="139">
          <segment state="initial" id="139">
            <source xml:space="preserve">Declaring an object by using object element syntax</source>
            <target xml:space="preserve">Declaring an object by using object element syntax</target>
          </segment>
        </unit>
        <unit id="140">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="140">
            <source xml:space="preserve">To declare an object with object element syntax, you write tags like this: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;objectName&gt;  &lt;/objectName&gt;</pc>, where <pc dataRefEnd="id4" dataRefStart="id3" id="4">objectName</pc> is the type name for the object you want to instantiate.</source>
            <target xml:space="preserve">To declare an object with object element syntax, you write tags like this: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;objectName&gt;  &lt;/objectName&gt;</pc>, where <pc dataRefEnd="id4" dataRefStart="id3" id="4">objectName</pc> is the type name for the object you want to instantiate.</target>
          </segment>
        </unit>
        <unit id="141">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="141">
            <source xml:space="preserve">Here's object element usage to declare a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> object:</source>
            <target xml:space="preserve">Here's object element usage to declare a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> object:</target>
          </segment>
        </unit>
        <unit id="142">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="142">
            <source xml:space="preserve">If the object does not contain other objects, you can declare the object element by using one self-closing tag instead of an opening/closing pair: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Canvas /&gt;</pc></source>
            <target xml:space="preserve">If the object does not contain other objects, you can declare the object element by using one self-closing tag instead of an opening/closing pair: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Canvas /&gt;</pc></target>
          </segment>
        </unit>
        <unit id="143">
          <segment state="initial" id="143">
            <source xml:space="preserve">Containers</source>
            <target xml:space="preserve">Containers</target>
          </segment>
        </unit>
        <unit id="144">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="144">
            <source xml:space="preserve">Many objects used as UI elements, such as <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, can contain other objects.</source>
            <target xml:space="preserve">Many objects used as UI elements, such as <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, can contain other objects.</target>
          </segment>
        </unit>
        <unit id="145">
          <segment state="initial" id="145">
            <source xml:space="preserve">These are sometimes referred to as containers.</source>
            <target xml:space="preserve">These are sometimes referred to as containers.</target>
          </segment>
        </unit>
        <unit id="146">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="146">
            <source xml:space="preserve">The following example shows a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> container that contains one element, a <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Rectangle**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">The following example shows a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Canvas</pc> container that contains one element, a <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Rectangle**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="147">
          <segment state="initial" id="147">
            <source xml:space="preserve">Declaring an object by using attribute syntax</source>
            <target xml:space="preserve">Declaring an object by using attribute syntax</target>
          </segment>
        </unit>
        <unit id="148">
          <segment state="initial" id="148">
            <source xml:space="preserve">Because this behavior is tied to property setting, we'll talk about this more in upcoming sections.</source>
            <target xml:space="preserve">Because this behavior is tied to property setting, we'll talk about this more in upcoming sections.</target>
          </segment>
        </unit>
        <unit id="149">
          <segment state="initial" id="149">
            <source xml:space="preserve">Initialization text</source>
            <target xml:space="preserve">Initialization text</target>
          </segment>
        </unit>
        <unit id="150">
          <segment state="initial" id="150">
            <source xml:space="preserve">For some objects you can declare new values using inner text that's used as initialization values for construction.</source>
            <target xml:space="preserve">For some objects you can declare new values using inner text that's used as initialization values for construction.</target>
          </segment>
        </unit>
        <unit id="151">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="151">
            <source xml:space="preserve">In XAML, this technique and syntax is called <pc dataRefEnd="id2" dataRefStart="id1" id="2">initialization text</pc>.</source>
            <target xml:space="preserve">In XAML, this technique and syntax is called <pc dataRefEnd="id2" dataRefStart="id1" id="2">initialization text</pc>.</target>
          </segment>
        </unit>
        <unit id="152">
          <segment state="initial" id="152">
            <source xml:space="preserve">Conceptually, initialization text is similar to calling a constructor that has parameters.</source>
            <target xml:space="preserve">Conceptually, initialization text is similar to calling a constructor that has parameters.</target>
          </segment>
        </unit>
        <unit id="153">
          <segment state="initial" id="153">
            <source xml:space="preserve">Initialization text is useful for setting initial values of certain structures.</source>
            <target xml:space="preserve">Initialization text is useful for setting initial values of certain structures.</target>
          </segment>
        </unit>
        <unit id="154">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="154">
            <source xml:space="preserve">You often use an object element syntax with initialization text if you want a structure value with an <pc dataRefEnd="id2" dataRefStart="id1" id="2">x:Key</pc>, so it can exist in a <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**ResourceDictionary**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">You often use an object element syntax with initialization text if you want a structure value with an <pc dataRefEnd="id2" dataRefStart="id1" id="2">x:Key</pc>, so it can exist in a <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**ResourceDictionary**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="155">
          <segment state="initial" id="155">
            <source xml:space="preserve">You might do this if you share that structure value among multiple target properties.</source>
            <target xml:space="preserve">You might do this if you share that structure value among multiple target properties.</target>
          </segment>
        </unit>
        <unit id="156">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id19">&lt;link&gt;</data>
            <data id="id20">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="156">
            <source xml:space="preserve">For some structures, you can't use attribute syntax to set the structure's values: initialization text is the only way to produce a useful and shareable <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CornerRadius**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Thickness**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**GridLength**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> or <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**Color**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc> resource.</source>
            <target xml:space="preserve">For some structures, you can't use attribute syntax to set the structure's values: initialization text is the only way to produce a useful and shareable <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**CornerRadius**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Thickness**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**GridLength**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> or <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**Color**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc> resource.</target>
          </segment>
        </unit>
        <unit id="157">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;strong&gt;</data>
            <data id="id8">&lt;/strong&gt;</data>
            <data id="id9">&lt;strong&gt;</data>
            <data id="id10">&lt;/strong&gt;</data>
            <data id="id11">&lt;strong&gt;</data>
            <data id="id12">&lt;/strong&gt;</data>
            <data id="id13">&lt;strong&gt;</data>
            <data id="id14">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="157">
            <source xml:space="preserve">This abbreviated example uses initialization text to specify values for a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Thickness**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, in this case specifying values that set both <pc dataRefEnd="id8" dataRefStart="id7" id="4">Left</pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="6">Right</pc> to 20, and both <pc dataRefEnd="id12" dataRefStart="id11" id="8">Top</pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="10">Bottom</pc> to 10.</source>
            <target xml:space="preserve">This abbreviated example uses initialization text to specify values for a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Thickness**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, in this case specifying values that set both <pc dataRefEnd="id8" dataRefStart="id7" id="4">Left</pc> and <pc dataRefEnd="id10" dataRefStart="id9" id="6">Right</pc> to 20, and both <pc dataRefEnd="id12" dataRefStart="id11" id="8">Top</pc> and <pc dataRefEnd="id14" dataRefStart="id13" id="10">Bottom</pc> to 10.</target>
          </segment>
        </unit>
        <unit id="158">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="158">
            <source xml:space="preserve">This example shows the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Thickness</pc> created as a keyed resource, and then the reference to that resource.</source>
            <target xml:space="preserve">This example shows the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Thickness</pc> created as a keyed resource, and then the reference to that resource.</target>
          </segment>
        </unit>
        <unit id="159">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="159">
            <source xml:space="preserve">For more info on <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Thickness**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> initialization text, see <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Thickness**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For more info on <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Thickness**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> initialization text, see <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Thickness**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="160">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="160">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  Some structures can't be declared as object elements.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  Some structures can't be declared as object elements.</target>
          </segment>
        </unit>
        <unit id="161">
          <segment state="initial" id="161">
            <source xml:space="preserve">Initialization text isn't supported and they can't be used as resources.</source>
            <target xml:space="preserve">Initialization text isn't supported and they can't be used as resources.</target>
          </segment>
        </unit>
        <unit id="162">
          <segment state="initial" id="162">
            <source xml:space="preserve">You must use an attribute syntax in order to set properties to these values in XAML.</source>
            <target xml:space="preserve">You must use an attribute syntax in order to set properties to these values in XAML.</target>
          </segment>
        </unit>
        <unit id="163">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id19">&lt;link&gt;</data>
            <data id="id20">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id25">&lt;link&gt;</data>
            <data id="id26">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="163">
            <source xml:space="preserve">These types are: <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Duration**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**RepeatBehavior**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Point**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>, <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**Rect**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc> and <pc dataRefEnd="id26" dataRefStart="id25" id="10CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="10CapsExtId2">**Size**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="10CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">These types are: <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Duration**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**RepeatBehavior**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Point**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>, <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**Rect**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc> and <pc dataRefEnd="id26" dataRefStart="id25" id="10CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="10CapsExtId2">**Size**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="10CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="164">
          <segment state="initial" id="164">
            <source xml:space="preserve">Setting properties</source>
            <target xml:space="preserve">Setting properties</target>
          </segment>
        </unit>
        <unit id="165">
          <segment state="initial" id="165">
            <source xml:space="preserve">You can set properties on objects that you declared by using object element syntax.</source>
            <target xml:space="preserve">You can set properties on objects that you declared by using object element syntax.</target>
          </segment>
        </unit>
        <unit id="166">
          <segment state="initial" id="166">
            <source xml:space="preserve">There are multiple ways to set properties in XAML:</source>
            <target xml:space="preserve">There are multiple ways to set properties in XAML:</target>
          </segment>
        </unit>
        <unit id="167">
          <segment state="initial" id="167">
            <source xml:space="preserve">By using attribute syntax.</source>
            <target xml:space="preserve">By using attribute syntax.</target>
          </segment>
        </unit>
        <unit id="168">
          <segment state="initial" id="168">
            <source xml:space="preserve">By using property element syntax.</source>
            <target xml:space="preserve">By using property element syntax.</target>
          </segment>
        </unit>
        <unit id="169">
          <segment state="initial" id="169">
            <source xml:space="preserve">By using element syntax where the content (inner text or child elements) is setting the XAML content property of an object.</source>
            <target xml:space="preserve">By using element syntax where the content (inner text or child elements) is setting the XAML content property of an object.</target>
          </segment>
        </unit>
        <unit id="170">
          <segment state="initial" id="170">
            <source xml:space="preserve">By using a collection syntax (which is usually the implicit collection syntax).</source>
            <target xml:space="preserve">By using a collection syntax (which is usually the implicit collection syntax).</target>
          </segment>
        </unit>
        <unit id="171">
          <segment state="initial" id="171">
            <source xml:space="preserve">As with object declaration, this list doesn't imply that any property could be set with each of the techniques.</source>
            <target xml:space="preserve">As with object declaration, this list doesn't imply that any property could be set with each of the techniques.</target>
          </segment>
        </unit>
        <unit id="172">
          <segment state="initial" id="172">
            <source xml:space="preserve">Some properties support only one of the techniques.</source>
            <target xml:space="preserve">Some properties support only one of the techniques.</target>
          </segment>
        </unit>
        <unit id="173">
          <segment state="initial" id="173">
            <source xml:space="preserve">Some properties support more than one form; for example, there are properties that can use property element syntax, or attribute syntax.</source>
            <target xml:space="preserve">Some properties support more than one form; for example, there are properties that can use property element syntax, or attribute syntax.</target>
          </segment>
        </unit>
        <unit id="174">
          <segment state="initial" id="174">
            <source xml:space="preserve">What's possible depends both on the property and on the object type that the property uses.</source>
            <target xml:space="preserve">What's possible depends both on the property and on the object type that the property uses.</target>
          </segment>
        </unit>
        <unit id="175">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="175">
            <source xml:space="preserve">In the Windows Runtime API reference, you'll see the XAML usages you can use in the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Syntax</pc> section.</source>
            <target xml:space="preserve">In the Windows Runtime API reference, you'll see the XAML usages you can use in the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Syntax</pc> section.</target>
          </segment>
        </unit>
        <unit id="176">
          <segment state="initial" id="176">
            <source xml:space="preserve">Sometimes there is an alternative usage that would work but would be more verbose.</source>
            <target xml:space="preserve">Sometimes there is an alternative usage that would work but would be more verbose.</target>
          </segment>
        </unit>
        <unit id="177">
          <segment state="initial" id="177">
            <source xml:space="preserve">Those verbose usages aren't always shown because we are trying to show you the best practices or the real world scenarios for using that property in XAML.</source>
            <target xml:space="preserve">Those verbose usages aren't always shown because we are trying to show you the best practices or the real world scenarios for using that property in XAML.</target>
          </segment>
        </unit>
        <unit id="178">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="178">
            <source xml:space="preserve">Guidance for XAML syntax is provided in the <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML Usage</pc> sections of reference pages for properties that can be set in XAML.</source>
            <target xml:space="preserve">Guidance for XAML syntax is provided in the <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML Usage</pc> sections of reference pages for properties that can be set in XAML.</target>
          </segment>
        </unit>
        <unit id="179">
          <segment state="initial" id="179">
            <source xml:space="preserve">Some properties on objects that cannot be set in XAML by any means, and can only be set using code.</source>
            <target xml:space="preserve">Some properties on objects that cannot be set in XAML by any means, and can only be set using code.</target>
          </segment>
        </unit>
        <unit id="180">
          <segment state="initial" id="180">
            <source xml:space="preserve">Usually these are properties that are more appropriate to work with in the code-behind, not in XAML.</source>
            <target xml:space="preserve">Usually these are properties that are more appropriate to work with in the code-behind, not in XAML.</target>
          </segment>
        </unit>
        <unit id="181">
          <segment state="initial" id="181">
            <source xml:space="preserve">A read-only property cannot be set in XAML.</source>
            <target xml:space="preserve">A read-only property cannot be set in XAML.</target>
          </segment>
        </unit>
        <unit id="182">
          <segment state="initial" id="182">
            <source xml:space="preserve">Even in code, the owning type would have to support some other way to set it, like a constructor overload, helper method, or calculated property support.</source>
            <target xml:space="preserve">Even in code, the owning type would have to support some other way to set it, like a constructor overload, helper method, or calculated property support.</target>
          </segment>
        </unit>
        <unit id="183">
          <segment state="initial" id="183">
            <source xml:space="preserve">A calculated property relies on the values of other settable properties plus sometimes an event with built-in handling; these features are available in the dependency property system.</source>
            <target xml:space="preserve">A calculated property relies on the values of other settable properties plus sometimes an event with built-in handling; these features are available in the dependency property system.</target>
          </segment>
        </unit>
        <unit id="184">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="184">
            <source xml:space="preserve">For more info on how dependency properties are useful for calculated property support, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Dependency properties overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For more info on how dependency properties are useful for calculated property support, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Dependency properties overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="185">
          <segment state="initial" id="185">
            <source xml:space="preserve">Collection syntax in XAML gives an appearance that you are setting a read-only property, but in fact you are not.</source>
            <target xml:space="preserve">Collection syntax in XAML gives an appearance that you are setting a read-only property, but in fact you are not.</target>
          </segment>
        </unit>
        <unit id="186">
          <segment state="initial" id="186">
            <source xml:space="preserve">See "Setting a Property by Using a Collection Syntax" section later in this topic.</source>
            <target xml:space="preserve">See "Setting a Property by Using a Collection Syntax" section later in this topic.</target>
          </segment>
        </unit>
        <unit id="187">
          <segment state="initial" id="187">
            <source xml:space="preserve">Setting a property by using attribute syntax</source>
            <target xml:space="preserve">Setting a property by using attribute syntax</target>
          </segment>
        </unit>
        <unit id="188">
          <segment state="initial" id="188">
            <source xml:space="preserve">Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</source>
            <target xml:space="preserve">Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</target>
          </segment>
        </unit>
        <unit id="189">
          <segment state="initial" id="189">
            <source xml:space="preserve">Setting XAML attributes is similar to how you set attribute values in XML.</source>
            <target xml:space="preserve">Setting XAML attributes is similar to how you set attribute values in XML.</target>
          </segment>
        </unit>
        <unit id="190">
          <segment state="initial" id="190">
            <source xml:space="preserve">The attribute name is specified at any point within the tags following the element name, separated from element name by at least one whitespace.</source>
            <target xml:space="preserve">The attribute name is specified at any point within the tags following the element name, separated from element name by at least one whitespace.</target>
          </segment>
        </unit>
        <unit id="191">
          <segment state="initial" id="191">
            <source xml:space="preserve">The attribute name is followed by an equals sign.</source>
            <target xml:space="preserve">The attribute name is followed by an equals sign.</target>
          </segment>
        </unit>
        <unit id="192">
          <segment state="initial" id="192">
            <source xml:space="preserve">The attribute value is contained within a pair of quotes.</source>
            <target xml:space="preserve">The attribute value is contained within a pair of quotes.</target>
          </segment>
        </unit>
        <unit id="193">
          <segment state="initial" id="193">
            <source xml:space="preserve">The quotes can be either double quotes or single quotes so long as they match and enclose the value.</source>
            <target xml:space="preserve">The quotes can be either double quotes or single quotes so long as they match and enclose the value.</target>
          </segment>
        </unit>
        <unit id="194">
          <segment state="initial" id="194">
            <source xml:space="preserve">The attribute value itself must be expressible as a string.</source>
            <target xml:space="preserve">The attribute value itself must be expressible as a string.</target>
          </segment>
        </unit>
        <unit id="195">
          <segment state="initial" id="195">
            <source xml:space="preserve">The string often contains numerals, but to XAML, all attribute values are string values until the XAML parser gets involved and does some basic value conversion.</source>
            <target xml:space="preserve">The string often contains numerals, but to XAML, all attribute values are string values until the XAML parser gets involved and does some basic value conversion.</target>
          </segment>
        </unit>
        <unit id="196">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id19">&lt;link&gt;</data>
            <data id="id20">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id25">&lt;link&gt;</data>
            <data id="id26">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="196">
            <source xml:space="preserve">This example uses attribute syntax for four attributes to set the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Name**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Width**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Height**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>, and <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**Fill**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc> properties of a <pc dataRefEnd="id26" dataRefStart="id25" id="10CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="10CapsExtId2">**Rectangle**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="10CapsExtId3"></pc></pc> object.</source>
            <target xml:space="preserve">This example uses attribute syntax for four attributes to set the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Name**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Width**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Height**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>, and <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**Fill**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc> properties of a <pc dataRefEnd="id26" dataRefStart="id25" id="10CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="10CapsExtId2">**Rectangle**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="10CapsExtId3"></pc></pc> object.</target>
          </segment>
        </unit>
        <unit id="197">
          <segment state="initial" id="197">
            <source xml:space="preserve">Setting a property by using property element syntax</source>
            <target xml:space="preserve">Setting a property by using property element syntax</target>
          </segment>
        </unit>
        <unit id="198">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;code&gt;</data>
            <data id="id6">&lt;/code&gt;</data>
            <data id="id7">&lt;em&gt;</data>
            <data id="id8">&lt;/em&gt;</data>
            <data id="id9">&lt;code&gt;</data>
            <data id="id10">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="198">
            <source xml:space="preserve">Many properties of an object can be set by using property element syntax. A property element looks like this: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;</pc><pc dataRefEnd="id4" dataRefStart="id3" id="3">object</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4">.</pc><pc dataRefEnd="id8" dataRefStart="id7" id="5">property</pc><pc dataRefEnd="id10" dataRefStart="id9" id="6">&gt;</pc>.</source>
            <target xml:space="preserve">Many properties of an object can be set by using property element syntax. A property element looks like this: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;</pc><pc dataRefEnd="id4" dataRefStart="id3" id="3">object</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4">.</pc><pc dataRefEnd="id8" dataRefStart="id7" id="5">property</pc><pc dataRefEnd="id10" dataRefStart="id9" id="6">&gt;</pc>.</target>
          </segment>
        </unit>
        <unit id="199">
          <segment state="initial" id="199">
            <source xml:space="preserve">To use property element syntax, you create XAML property elements for the property that you want to set.</source>
            <target xml:space="preserve">To use property element syntax, you create XAML property elements for the property that you want to set.</target>
          </segment>
        </unit>
        <unit id="200">
          <segment state="initial" id="200">
            <source xml:space="preserve">In standard XML, this element would just be considered an element that has a dot in its name.</source>
            <target xml:space="preserve">In standard XML, this element would just be considered an element that has a dot in its name.</target>
          </segment>
        </unit>
        <unit id="201">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="201">
            <source xml:space="preserve">However, in XAML, the dot in the element name identifies the element as a property element, with <pc dataRefEnd="id2" dataRefStart="id1" id="2">property</pc> expected to a member of <pc dataRefEnd="id4" dataRefStart="id3" id="4">object</pc> in a backing object model implementation.</source>
            <target xml:space="preserve">However, in XAML, the dot in the element name identifies the element as a property element, with <pc dataRefEnd="id2" dataRefStart="id1" id="2">property</pc> expected to a member of <pc dataRefEnd="id4" dataRefStart="id3" id="4">object</pc> in a backing object model implementation.</target>
          </segment>
        </unit>
        <unit id="202">
          <segment state="initial" id="202">
            <source xml:space="preserve">To use property element syntax, it must be possible to specify an object element in order to "fill" the property element tags.</source>
            <target xml:space="preserve">To use property element syntax, it must be possible to specify an object element in order to "fill" the property element tags.</target>
          </segment>
        </unit>
        <unit id="203">
          <segment state="initial" id="203">
            <source xml:space="preserve">A property element will always have some content (single element, multiple elements, or inner text); there's no point in having a self-closing property element.</source>
            <target xml:space="preserve">A property element will always have some content (single element, multiple elements, or inner text); there's no point in having a self-closing property element.</target>
          </segment>
        </unit>
        <unit id="204">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="204">
            <source xml:space="preserve">In the following grammar, <pc dataRefEnd="id2" dataRefStart="id1" id="2">property</pc> is the name of the property that you want to set and <pc dataRefEnd="id4" dataRefStart="id3" id="4">propertyValueAsObjectElement</pc> is a single object element, that's expected to satisfy the value type requirements of the property.</source>
            <target xml:space="preserve">In the following grammar, <pc dataRefEnd="id2" dataRefStart="id1" id="2">property</pc> is the name of the property that you want to set and <pc dataRefEnd="id4" dataRefStart="id3" id="4">propertyValueAsObjectElement</pc> is a single object element, that's expected to satisfy the value type requirements of the property.</target>
          </segment>
        </unit>
        <unit id="205">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;code&gt;</data>
            <data id="id6">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="205">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">&lt;</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">object</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3">&gt;</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">&lt;</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">object</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3">&gt;</pc>
						</target>
          </segment>
        </unit>
        <unit id="206">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;code&gt;</data>
            <data id="id6">&lt;/code&gt;</data>
            <data id="id7">&lt;em&gt;</data>
            <data id="id8">&lt;/em&gt;</data>
            <data id="id9">&lt;code&gt;</data>
            <data id="id10">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="206">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">&lt;</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">object</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3">.</pc>
							<pc dataRefEnd="id8" dataRefStart="id7" id="4">property</pc>
							<pc dataRefEnd="id10" dataRefStart="id9" id="5">&gt;</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">&lt;</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">object</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3">.</pc>
							<pc dataRefEnd="id8" dataRefStart="id7" id="4">property</pc>
							<pc dataRefEnd="id10" dataRefStart="id9" id="5">&gt;</pc>
						</target>
          </segment>
        </unit>
        <unit id="207">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="207">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">propertyValueAsObjectElement</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">propertyValueAsObjectElement</pc>
						</target>
          </segment>
        </unit>
        <unit id="208">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;code&gt;</data>
            <data id="id6">&lt;/code&gt;</data>
            <data id="id7">&lt;em&gt;</data>
            <data id="id8">&lt;/em&gt;</data>
            <data id="id9">&lt;code&gt;</data>
            <data id="id10">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="208">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">&lt;/</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">object</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3">.</pc>
							<pc dataRefEnd="id8" dataRefStart="id7" id="4">property</pc>
							<pc dataRefEnd="id10" dataRefStart="id9" id="5">&gt;</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">&lt;/</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">object</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3">.</pc>
							<pc dataRefEnd="id8" dataRefStart="id7" id="4">property</pc>
							<pc dataRefEnd="id10" dataRefStart="id9" id="5">&gt;</pc>
						</target>
          </segment>
        </unit>
        <unit id="209">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;code&gt;</data>
            <data id="id6">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="209">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">&lt;/</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">object</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3">&gt;</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">&lt;/</pc>
							<pc dataRefEnd="id4" dataRefStart="id3" id="2">object</pc>
							<pc dataRefEnd="id6" dataRefStart="id5" id="3">&gt;</pc>
						</target>
          </segment>
        </unit>
        <unit id="210">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="210">
            <source xml:space="preserve">The following example uses property element syntax to set the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Fill**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> of a <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Rectangle**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> with a <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**SolidColorBrush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> object element.</source>
            <target xml:space="preserve">The following example uses property element syntax to set the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Fill**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> of a <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Rectangle**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> with a <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**SolidColorBrush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> object element.</target>
          </segment>
        </unit>
        <unit id="211">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="211">
            <source xml:space="preserve">(Within the <pc dataRefEnd="id2" dataRefStart="id1" id="2">SolidColorBrush</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Color**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> is set as an attribute.)</source>
            <target xml:space="preserve">(Within the <pc dataRefEnd="id2" dataRefStart="id1" id="2">SolidColorBrush</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Color**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> is set as an attribute.)</target>
          </segment>
        </unit>
        <unit id="212">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="212">
            <source xml:space="preserve">The parsed result of this XAML is identical to the previous XAML example that set <pc dataRefEnd="id2" dataRefStart="id1" id="2">Fill</pc> using attribute syntax.</source>
            <target xml:space="preserve">The parsed result of this XAML is identical to the previous XAML example that set <pc dataRefEnd="id2" dataRefStart="id1" id="2">Fill</pc> using attribute syntax.</target>
          </segment>
        </unit>
        <unit id="213">
          <segment state="initial" id="213">
            <source xml:space="preserve">XAML vocabularies and object-oriented programming</source>
            <target xml:space="preserve">XAML vocabularies and object-oriented programming</target>
          </segment>
        </unit>
        <unit id="214">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id9">&lt;link&gt;</data>
            <data id="id10">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id15">&lt;strong&gt;</data>
            <data id="id16">&lt;/strong&gt;</data>
            <data id="id17">&lt;link&gt;</data>
            <data id="id18">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id23">&lt;strong&gt;</data>
            <data id="id24">&lt;/strong&gt;</data>
            <data id="id25">&lt;link&gt;</data>
            <data id="id26">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id31">&lt;link&gt;</data>
            <data id="id32">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id37">&lt;link&gt;</data>
            <data id="id38">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id43">&lt;link&gt;</data>
            <data id="id44">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id49">&lt;link&gt;</data>
            <data id="id50">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id55">&lt;strong&gt;</data>
            <data id="id56">&lt;/strong&gt;</data>
            <data id="id57">&lt;link&gt;</data>
            <data id="id58">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="214">
            <source xml:space="preserve">Properties and events as they appear as XAML members of a Windows Runtime XAML type are often inherited from base types. Consider this example: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Button Background="Blue" .../&gt;</pc>. The <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Background**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> property is not an immediately declared property on the <pc dataRefEnd="id10" dataRefStart="id9" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Button**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> class. Instead, <pc dataRefEnd="id16" dataRefStart="id15" id="8">Background</pc> is inherited from the base <pc dataRefEnd="id18" dataRefStart="id17" id="10CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="10CapsExtId2">**Control**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="10CapsExtId3"></pc></pc> class. In fact, if you look at the reference topic for <pc dataRefEnd="id24" dataRefStart="id23" id="12">Button</pc> you'll see that the members lists contain at least one inherited member from each of a chain of successive base classes: <pc dataRefEnd="id26" dataRefStart="id25" id="14CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="14CapsExtId2">**ButtonBase**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="14CapsExtId3"></pc></pc>, <pc dataRefEnd="id32" dataRefStart="id31" id="16CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="16CapsExtId2">**Control**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="16CapsExtId3"></pc></pc>, <pc dataRefEnd="id38" dataRefStart="id37" id="18CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="18CapsExtId2">**FrameworkElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="18CapsExtId3"></pc></pc>, <pc dataRefEnd="id44" dataRefStart="id43" id="20CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="20CapsExtId2">**UIElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="20CapsExtId3"></pc></pc>, <pc dataRefEnd="id50" dataRefStart="id49" id="22CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="22CapsExtId2">**DependencyObject**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="22CapsExtId3"></pc></pc>. In the <pc dataRefEnd="id56" dataRefStart="id55" id="24">Properties</pc> list, all the read-write properties and collection properties are inherited in a XAML vocabulary sense. Events (like the various <pc dataRefEnd="id58" dataRefStart="id57" id="26CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="26CapsExtId2">**UIElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="26CapsExtId3"></pc></pc> events) are inherited too.</source>
            <target xml:space="preserve">Properties and events as they appear as XAML members of a Windows Runtime XAML type are often inherited from base types. Consider this example: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Button Background="Blue" .../&gt;</pc>. The <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Background**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> property is not an immediately declared property on the <pc dataRefEnd="id10" dataRefStart="id9" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Button**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> class. Instead, <pc dataRefEnd="id16" dataRefStart="id15" id="8">Background</pc> is inherited from the base <pc dataRefEnd="id18" dataRefStart="id17" id="10CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="10CapsExtId2">**Control**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="10CapsExtId3"></pc></pc> class. In fact, if you look at the reference topic for <pc dataRefEnd="id24" dataRefStart="id23" id="12">Button</pc> you'll see that the members lists contain at least one inherited member from each of a chain of successive base classes: <pc dataRefEnd="id26" dataRefStart="id25" id="14CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="14CapsExtId2">**ButtonBase**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="14CapsExtId3"></pc></pc>, <pc dataRefEnd="id32" dataRefStart="id31" id="16CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="16CapsExtId2">**Control**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="16CapsExtId3"></pc></pc>, <pc dataRefEnd="id38" dataRefStart="id37" id="18CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="18CapsExtId2">**FrameworkElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="18CapsExtId3"></pc></pc>, <pc dataRefEnd="id44" dataRefStart="id43" id="20CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="20CapsExtId2">**UIElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="20CapsExtId3"></pc></pc>, <pc dataRefEnd="id50" dataRefStart="id49" id="22CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="22CapsExtId2">**DependencyObject**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="22CapsExtId3"></pc></pc>. In the <pc dataRefEnd="id56" dataRefStart="id55" id="24">Properties</pc> list, all the read-write properties and collection properties are inherited in a XAML vocabulary sense. Events (like the various <pc dataRefEnd="id58" dataRefStart="id57" id="26CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="26CapsExtId2">**UIElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="26CapsExtId3"></pc></pc> events) are inherited too.</target>
          </segment>
        </unit>
        <unit id="215">
          <segment state="initial" id="215">
            <source xml:space="preserve">If you use the Windows Runtime reference for XAML guidance, the element name that's shown in a syntax or even in example code is sometimes for the type that originally defines the property, because that reference topic is shared by all the possible types that inherit it from a base class.</source>
            <target xml:space="preserve">If you use the Windows Runtime reference for XAML guidance, the element name that's shown in a syntax or even in example code is sometimes for the type that originally defines the property, because that reference topic is shared by all the possible types that inherit it from a base class.</target>
          </segment>
        </unit>
        <unit id="216">
          <segment state="initial" id="216">
            <source xml:space="preserve">If you use Visual Studio's IntelliSense for XAML in the XML editor, the IntelliSense and its drop-downs do a great job of coalescing the inheritance and providing an accurate list of attributes that are available for setting once you've started with an object element for a class instance.</source>
            <target xml:space="preserve">If you use Visual Studio's IntelliSense for XAML in the XML editor, the IntelliSense and its drop-downs do a great job of coalescing the inheritance and providing an accurate list of attributes that are available for setting once you've started with an object element for a class instance.</target>
          </segment>
        </unit>
        <unit id="217">
          <segment state="initial" id="217">
            <source xml:space="preserve">XAML content properties</source>
            <target xml:space="preserve">XAML content properties</target>
          </segment>
        </unit>
        <unit id="218">
          <segment state="initial" id="218">
            <source xml:space="preserve">Some types define one of their properties such that the property enables a XAML content syntax.</source>
            <target xml:space="preserve">Some types define one of their properties such that the property enables a XAML content syntax.</target>
          </segment>
        </unit>
        <unit id="219">
          <segment state="initial" id="219">
            <source xml:space="preserve">For the XAML content property of a type, you can omit the property element for that property when specifying it in XAML.</source>
            <target xml:space="preserve">For the XAML content property of a type, you can omit the property element for that property when specifying it in XAML.</target>
          </segment>
        </unit>
        <unit id="220">
          <segment state="initial" id="220">
            <source xml:space="preserve">Or, you can set the property to an inner text value by providing that inner text directly within the owning type's object element tags.</source>
            <target xml:space="preserve">Or, you can set the property to an inner text value by providing that inner text directly within the owning type's object element tags.</target>
          </segment>
        </unit>
        <unit id="221">
          <segment state="initial" id="221">
            <source xml:space="preserve">XAML content properties support straightforward markup syntax for that property and makes the XAML more human-readable by reducing the nesting.</source>
            <target xml:space="preserve">XAML content properties support straightforward markup syntax for that property and makes the XAML more human-readable by reducing the nesting.</target>
          </segment>
        </unit>
        <unit id="222">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="222">
            <source xml:space="preserve">If a XAML content syntax is available, that syntax will be shown in the "XAML" sections of <pc dataRefEnd="id2" dataRefStart="id1" id="2">Syntax</pc> for that property in the Windows Runtime reference documentation.</source>
            <target xml:space="preserve">If a XAML content syntax is available, that syntax will be shown in the "XAML" sections of <pc dataRefEnd="id2" dataRefStart="id1" id="2">Syntax</pc> for that property in the Windows Runtime reference documentation.</target>
          </segment>
        </unit>
        <unit id="223">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;strong&gt;</data>
            <data id="id14">&lt;/strong&gt;</data>
            <data id="id15">&lt;strong&gt;</data>
            <data id="id16">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="223">
            <source xml:space="preserve">For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Child**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> property page for <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Border**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> shows XAML content syntax instead of property element syntax to set the single-object <pc dataRefEnd="id14" dataRefStart="id13" id="6">Border.Child</pc> value of a <pc dataRefEnd="id16" dataRefStart="id15" id="8">Border</pc>, like this:</source>
            <target xml:space="preserve">For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Child**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> property page for <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Border**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> shows XAML content syntax instead of property element syntax to set the single-object <pc dataRefEnd="id14" dataRefStart="id13" id="6">Border.Child</pc> value of a <pc dataRefEnd="id16" dataRefStart="id15" id="8">Border</pc>, like this:</target>
          </segment>
        </unit>
        <unit id="224">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="224">
            <source xml:space="preserve">If the property that is declared as the XAML content property is the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc> type, or is type <pc dataRefEnd="id4" dataRefStart="id3" id="4">String</pc>, then the XAML content syntax supports what's basically inner text in the XML document model: a string between the opening and closing object tags.</source>
            <target xml:space="preserve">If the property that is declared as the XAML content property is the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Object</pc> type, or is type <pc dataRefEnd="id4" dataRefStart="id3" id="4">String</pc>, then the XAML content syntax supports what's basically inner text in the XML document model: a string between the opening and closing object tags.</target>
          </segment>
        </unit>
        <unit id="225">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;strong&gt;</data>
            <data id="id14">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="225">
            <source xml:space="preserve">For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Text**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> property page for <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**TextBlock**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> shows XAML content syntax that has an inner text value to set <pc dataRefEnd="id14" dataRefStart="id13" id="6">Text</pc>, but the string "Text" never appears in the markup.</source>
            <target xml:space="preserve">For example, the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Text**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> property page for <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**TextBlock**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> shows XAML content syntax that has an inner text value to set <pc dataRefEnd="id14" dataRefStart="id13" id="6">Text</pc>, but the string "Text" never appears in the markup.</target>
          </segment>
        </unit>
        <unit id="226">
          <segment state="initial" id="226">
            <source xml:space="preserve">Here's an example usage:</source>
            <target xml:space="preserve">Here's an example usage:</target>
          </segment>
        </unit>
        <unit id="227">
          <segment state="initial" id="227">
            <source xml:space="preserve">If a XAML content property exists for a class, that's indicated in the reference topic for the class, in the "Attributes" section.</source>
            <target xml:space="preserve">If a XAML content property exists for a class, that's indicated in the reference topic for the class, in the "Attributes" section.</target>
          </segment>
        </unit>
        <unit id="228">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="228">
            <source xml:space="preserve">Look for the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ContentPropertyAttribute**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Look for the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ContentPropertyAttribute**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="229">
          <segment state="initial" id="229">
            <source xml:space="preserve">This attribute uses a named field "Name".</source>
            <target xml:space="preserve">This attribute uses a named field "Name".</target>
          </segment>
        </unit>
        <unit id="230">
          <segment state="initial" id="230">
            <source xml:space="preserve">The value of "Name" is the name of the property of that class that is the XAML content property.</source>
            <target xml:space="preserve">The value of "Name" is the name of the property of that class that is the XAML content property.</target>
          </segment>
        </unit>
        <unit id="231">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="231">
            <source xml:space="preserve">For example, on the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Border**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> reference page, you'll see this: ContentProperty("Name=Child").</source>
            <target xml:space="preserve">For example, on the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Border**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> reference page, you'll see this: ContentProperty("Name=Child").</target>
          </segment>
        </unit>
        <unit id="232">
          <segment state="initial" id="232">
            <source xml:space="preserve">One important XAML syntax rule we should mention is that you can't intermix the XAML content property and other property elements you set on the element.</source>
            <target xml:space="preserve">One important XAML syntax rule we should mention is that you can't intermix the XAML content property and other property elements you set on the element.</target>
          </segment>
        </unit>
        <unit id="233">
          <segment state="initial" id="233">
            <source xml:space="preserve">The XAML content property must be set entirely before any property elements, or entirely after.</source>
            <target xml:space="preserve">The XAML content property must be set entirely before any property elements, or entirely after.</target>
          </segment>
        </unit>
        <unit id="234">
          <segment state="initial" id="234">
            <source xml:space="preserve">For example this is invalid XAML:</source>
            <target xml:space="preserve">For example this is invalid XAML:</target>
          </segment>
        </unit>
        <unit id="235">
          <segment state="initial" id="235">
            <source xml:space="preserve">Collection syntax</source>
            <target xml:space="preserve">Collection syntax</target>
          </segment>
        </unit>
        <unit id="236">
          <segment state="initial" id="236">
            <source xml:space="preserve">All of the syntaxes shown thus far are setting properties to single objects.</source>
            <target xml:space="preserve">All of the syntaxes shown thus far are setting properties to single objects.</target>
          </segment>
        </unit>
        <unit id="237">
          <segment state="initial" id="237">
            <source xml:space="preserve">But many UI scenarios require that a given parent element can have multiple child elements.</source>
            <target xml:space="preserve">But many UI scenarios require that a given parent element can have multiple child elements.</target>
          </segment>
        </unit>
        <unit id="238">
          <segment state="initial" id="238">
            <source xml:space="preserve">For example, a UI for an input form needs several text box elements, some labels, and perhaps a "Submit" button.</source>
            <target xml:space="preserve">For example, a UI for an input form needs several text box elements, some labels, and perhaps a "Submit" button.</target>
          </segment>
        </unit>
        <unit id="239">
          <segment state="initial" id="239">
            <source xml:space="preserve">Still, if you were to use a programming object model to access these multiple elements, they would typically be items in a single collection property, rather than each item being the value of different properties.</source>
            <target xml:space="preserve">Still, if you were to use a programming object model to access these multiple elements, they would typically be items in a single collection property, rather than each item being the value of different properties.</target>
          </segment>
        </unit>
        <unit id="240">
          <segment state="initial" id="240">
            <source xml:space="preserve">XAML supports multiple child elements as well as supporting a typical backing collection model by treating properties that use a collection type as implicit, and performing special handling for any child elements of a collection type.</source>
            <target xml:space="preserve">XAML supports multiple child elements as well as supporting a typical backing collection model by treating properties that use a collection type as implicit, and performing special handling for any child elements of a collection type.</target>
          </segment>
        </unit>
        <unit id="241">
          <segment state="initial" id="241">
            <source xml:space="preserve">Many collection properties are also identified as the XAML content property for the class.</source>
            <target xml:space="preserve">Many collection properties are also identified as the XAML content property for the class.</target>
          </segment>
        </unit>
        <unit id="242">
          <segment state="initial" id="242">
            <source xml:space="preserve">The combination of implicit collection processing and XAML content syntax is frequently seen in types used for control compositing, such as panels, views, or items controls.</source>
            <target xml:space="preserve">The combination of implicit collection processing and XAML content syntax is frequently seen in types used for control compositing, such as panels, views, or items controls.</target>
          </segment>
        </unit>
        <unit id="243">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="243">
            <source xml:space="preserve">For example, the following examples show the simplest possible XAML for compositing two peer UI elements within a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**StackPanel**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For example, the following examples show the simplest possible XAML for compositing two peer UI elements within a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**StackPanel**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="244">
          <segment state="initial" id="244">
            <source xml:space="preserve">The mechanism of XAML collection syntax</source>
            <target xml:space="preserve">The mechanism of XAML collection syntax</target>
          </segment>
        </unit>
        <unit id="245">
          <segment state="initial" id="245">
            <source xml:space="preserve">It might at first appear that XAML is enabling a "set" of the read-only collection property.</source>
            <target xml:space="preserve">It might at first appear that XAML is enabling a "set" of the read-only collection property.</target>
          </segment>
        </unit>
        <unit id="246">
          <segment state="initial" id="246">
            <source xml:space="preserve">In reality, what XAML enables here is adding items to an existing collection.</source>
            <target xml:space="preserve">In reality, what XAML enables here is adding items to an existing collection.</target>
          </segment>
        </unit>
        <unit id="247">
          <segment state="initial" id="247">
            <source xml:space="preserve">The XAML language and XAML processors implementing XAML support rely on a convention in backing collection types to enable this syntax.</source>
            <target xml:space="preserve">The XAML language and XAML processors implementing XAML support rely on a convention in backing collection types to enable this syntax.</target>
          </segment>
        </unit>
        <unit id="248">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="248">
            <source xml:space="preserve">Typically there is a backing property such as an indexer or <pc dataRefEnd="id2" dataRefStart="id1" id="2">Items</pc> property that refers to specific items of the collection.</source>
            <target xml:space="preserve">Typically there is a backing property such as an indexer or <pc dataRefEnd="id2" dataRefStart="id1" id="2">Items</pc> property that refers to specific items of the collection.</target>
          </segment>
        </unit>
        <unit id="249">
          <segment state="initial" id="249">
            <source xml:space="preserve">Generally, that property is not explicit in the XAML syntax.</source>
            <target xml:space="preserve">Generally, that property is not explicit in the XAML syntax.</target>
          </segment>
        </unit>
        <unit id="250">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="250">
            <source xml:space="preserve">For collections, the underlying mechanism for XAML parsing is not a property, but a method: specifically, the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Add</pc> method in most cases.</source>
            <target xml:space="preserve">For collections, the underlying mechanism for XAML parsing is not a property, but a method: specifically, the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Add</pc> method in most cases.</target>
          </segment>
        </unit>
        <unit id="251">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="251">
            <source xml:space="preserve">When the XAML processor encounters one or more object elements within a XAML collection syntax, each such object is first created from an element, then each new object is added in order to the containing collection by calling the collection's <pc dataRefEnd="id2" dataRefStart="id1" id="2">Add</pc> method.</source>
            <target xml:space="preserve">When the XAML processor encounters one or more object elements within a XAML collection syntax, each such object is first created from an element, then each new object is added in order to the containing collection by calling the collection's <pc dataRefEnd="id2" dataRefStart="id1" id="2">Add</pc> method.</target>
          </segment>
        </unit>
        <unit id="252">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="252">
            <source xml:space="preserve">When a XAML parser adds items to a collection, it is the logic of the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Add</pc> method that determines whether a given XAML element is a permissible item child of the collection object.</source>
            <target xml:space="preserve">When a XAML parser adds items to a collection, it is the logic of the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Add</pc> method that determines whether a given XAML element is a permissible item child of the collection object.</target>
          </segment>
        </unit>
        <unit id="253">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="253">
            <source xml:space="preserve">Many collection types are strongly typed by the backing implementation, meaning that the input parameter of <pc dataRefEnd="id2" dataRefStart="id1" id="2">Add</pc> expects that whatever is passed must be a type match with the <pc dataRefEnd="id4" dataRefStart="id3" id="4">Add</pc> parameter type.</source>
            <target xml:space="preserve">Many collection types are strongly typed by the backing implementation, meaning that the input parameter of <pc dataRefEnd="id2" dataRefStart="id1" id="2">Add</pc> expects that whatever is passed must be a type match with the <pc dataRefEnd="id4" dataRefStart="id3" id="4">Add</pc> parameter type.</target>
          </segment>
        </unit>
        <unit id="254">
          <segment state="initial" id="254">
            <source xml:space="preserve">For collection properties, be careful about when you try to specify the collection explicitly as an object element.</source>
            <target xml:space="preserve">For collection properties, be careful about when you try to specify the collection explicitly as an object element.</target>
          </segment>
        </unit>
        <unit id="255">
          <segment state="initial" id="255">
            <source xml:space="preserve">A XAML parser will create a new object whenever it encounters an object element.</source>
            <target xml:space="preserve">A XAML parser will create a new object whenever it encounters an object element.</target>
          </segment>
        </unit>
        <unit id="256">
          <segment state="initial" id="256">
            <source xml:space="preserve">If the collection property you're trying to use is read-only, this can throw a XAML parse exception.</source>
            <target xml:space="preserve">If the collection property you're trying to use is read-only, this can throw a XAML parse exception.</target>
          </segment>
        </unit>
        <unit id="257">
          <segment state="initial" id="257">
            <source xml:space="preserve">Just use the implicit collection syntax, and you won't see that exception.</source>
            <target xml:space="preserve">Just use the implicit collection syntax, and you won't see that exception.</target>
          </segment>
        </unit>
        <unit id="258">
          <segment state="initial" id="258">
            <source xml:space="preserve">When to use attribute or property element syntax</source>
            <target xml:space="preserve">When to use attribute or property element syntax</target>
          </segment>
        </unit>
        <unit id="259">
          <segment state="initial" id="259">
            <source xml:space="preserve">All properties that support being set in XAML will support attribute or property element syntax for direct value setting, but potentially will not support either syntax interchangeably.</source>
            <target xml:space="preserve">All properties that support being set in XAML will support attribute or property element syntax for direct value setting, but potentially will not support either syntax interchangeably.</target>
          </segment>
        </unit>
        <unit id="260">
          <segment state="initial" id="260">
            <source xml:space="preserve">Some properties do support either syntax, and some properties support additional syntax options like a XAML content property.</source>
            <target xml:space="preserve">Some properties do support either syntax, and some properties support additional syntax options like a XAML content property.</target>
          </segment>
        </unit>
        <unit id="261">
          <segment state="initial" id="261">
            <source xml:space="preserve">The type of XAML syntax supported by a property depends on the type of object that the property uses as its property type.</source>
            <target xml:space="preserve">The type of XAML syntax supported by a property depends on the type of object that the property uses as its property type.</target>
          </segment>
        </unit>
        <unit id="262">
          <segment state="initial" id="262">
            <source xml:space="preserve">If the property type is a primitive type, such as a double (float or decimal), integer, Boolean, or string, the property always supports attribute syntax.</source>
            <target xml:space="preserve">If the property type is a primitive type, such as a double (float or decimal), integer, Boolean, or string, the property always supports attribute syntax.</target>
          </segment>
        </unit>
        <unit id="263">
          <segment state="initial" id="263">
            <source xml:space="preserve">You can also use attribute syntax to set a property if the object type you use to set that property can be created by processing a string.</source>
            <target xml:space="preserve">You can also use attribute syntax to set a property if the object type you use to set that property can be created by processing a string.</target>
          </segment>
        </unit>
        <unit id="264">
          <segment state="initial" id="264">
            <source xml:space="preserve">For primitives, this is always the case, the type conversion is built in to the parser.</source>
            <target xml:space="preserve">For primitives, this is always the case, the type conversion is built in to the parser.</target>
          </segment>
        </unit>
        <unit id="265">
          <segment state="initial" id="265">
            <source xml:space="preserve">However, certain other object types can also be created by using a string specified as an attribute value, rather than an object element within a property element.</source>
            <target xml:space="preserve">However, certain other object types can also be created by using a string specified as an attribute value, rather than an object element within a property element.</target>
          </segment>
        </unit>
        <unit id="266">
          <segment state="initial" id="266">
            <source xml:space="preserve">For this to work, there has to be an underlying type conversion, supported either by that particular property or supported generally for all values that use that property type.</source>
            <target xml:space="preserve">For this to work, there has to be an underlying type conversion, supported either by that particular property or supported generally for all values that use that property type.</target>
          </segment>
        </unit>
        <unit id="267">
          <segment state="initial" id="267">
            <source xml:space="preserve">The string value of the attribute is used to set properties that are important for the initialization of the new object value.</source>
            <target xml:space="preserve">The string value of the attribute is used to set properties that are important for the initialization of the new object value.</target>
          </segment>
        </unit>
        <unit id="268">
          <segment state="initial" id="268">
            <source xml:space="preserve">Potentially, a specific type converter can also create different subclasses of a common property type, depending on how it uniquely processes information in the string.</source>
            <target xml:space="preserve">Potentially, a specific type converter can also create different subclasses of a common property type, depending on how it uniquely processes information in the string.</target>
          </segment>
        </unit>
        <unit id="269">
          <segment state="initial" id="269">
            <source xml:space="preserve">Object types that support this behavior will have a special grammar listed in the syntax section of the reference documentation.</source>
            <target xml:space="preserve">Object types that support this behavior will have a special grammar listed in the syntax section of the reference documentation.</target>
          </segment>
        </unit>
        <unit id="270">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;strong&gt;</data>
            <data id="id14">&lt;/strong&gt;</data>
            <data id="id15">&lt;strong&gt;</data>
            <data id="id16">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="270">
            <source xml:space="preserve">As an example, the XAML syntax for <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Brush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> shows how an attribute syntax can be used to create a new <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**SolidColorBrush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> value for any property of type <pc dataRefEnd="id14" dataRefStart="id13" id="6">Brush</pc> (and there are many <pc dataRefEnd="id16" dataRefStart="id15" id="8">Brush</pc> properties in Windows Runtime XAML).</source>
            <target xml:space="preserve">As an example, the XAML syntax for <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Brush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> shows how an attribute syntax can be used to create a new <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**SolidColorBrush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> value for any property of type <pc dataRefEnd="id14" dataRefStart="id13" id="6">Brush</pc> (and there are many <pc dataRefEnd="id16" dataRefStart="id15" id="8">Brush</pc> properties in Windows Runtime XAML).</target>
          </segment>
        </unit>
        <unit id="271">
          <segment state="initial" id="271">
            <source xml:space="preserve">XAML parsing logic and rules</source>
            <target xml:space="preserve">XAML parsing logic and rules</target>
          </segment>
        </unit>
        <unit id="272">
          <segment state="initial" id="272">
            <source xml:space="preserve">Sometime's it's informative to read the XAML in a similar way to how a XAML parser must read it: as a set of string tokens encountered in a linear order.</source>
            <target xml:space="preserve">Sometime's it's informative to read the XAML in a similar way to how a XAML parser must read it: as a set of string tokens encountered in a linear order.</target>
          </segment>
        </unit>
        <unit id="273">
          <segment state="initial" id="273">
            <source xml:space="preserve">A XAML parser must interpret these tokens under a set of rules that are part of the definition of how XAML works.</source>
            <target xml:space="preserve">A XAML parser must interpret these tokens under a set of rules that are part of the definition of how XAML works.</target>
          </segment>
        </unit>
        <unit id="274">
          <segment state="initial" id="274">
            <source xml:space="preserve">Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</source>
            <target xml:space="preserve">Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</target>
          </segment>
        </unit>
        <unit id="275">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;em&gt;</data>
            <data id="id6">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="275">
            <source xml:space="preserve">In the following syntax, <pc dataRefEnd="id2" dataRefStart="id1" id="2">objectName</pc> is the object you want to instantiate, <pc dataRefEnd="id4" dataRefStart="id3" id="4">propertyName</pc> is the name of the property that you want to set on that object, and <pc dataRefEnd="id6" dataRefStart="id5" id="6">propertyValue</pc> is the value to set.</source>
            <target xml:space="preserve">In the following syntax, <pc dataRefEnd="id2" dataRefStart="id1" id="2">objectName</pc> is the object you want to instantiate, <pc dataRefEnd="id4" dataRefStart="id3" id="4">propertyName</pc> is the name of the property that you want to set on that object, and <pc dataRefEnd="id6" dataRefStart="id5" id="6">propertyValue</pc> is the value to set.</target>
          </segment>
        </unit>
        <unit id="276">
          <segment state="initial" id="276">
            <source xml:space="preserve">Either syntax enables you to declare an object and set a property on that object.</source>
            <target xml:space="preserve">Either syntax enables you to declare an object and set a property on that object.</target>
          </segment>
        </unit>
        <unit id="277">
          <segment state="initial" id="277">
            <source xml:space="preserve">Although the first example is a single element in markup, there are actually discrete steps here with regard to how a XAML processor parses this markup.</source>
            <target xml:space="preserve">Although the first example is a single element in markup, there are actually discrete steps here with regard to how a XAML processor parses this markup.</target>
          </segment>
        </unit>
        <unit id="278">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="278">
            <source xml:space="preserve">First, the presence of the object element indicates that a new <pc dataRefEnd="id2" dataRefStart="id1" id="2">objectName</pc> object must be instantiated.</source>
            <target xml:space="preserve">First, the presence of the object element indicates that a new <pc dataRefEnd="id2" dataRefStart="id1" id="2">objectName</pc> object must be instantiated.</target>
          </segment>
        </unit>
        <unit id="279">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="279">
            <source xml:space="preserve">Only after such an instance exists can the instance property <pc dataRefEnd="id2" dataRefStart="id1" id="2">propertyName</pc> can be set on it.</source>
            <target xml:space="preserve">Only after such an instance exists can the instance property <pc dataRefEnd="id2" dataRefStart="id1" id="2">propertyName</pc> can be set on it.</target>
          </segment>
        </unit>
        <unit id="280">
          <segment state="initial" id="280">
            <source xml:space="preserve">Another rule of XAML is that attributes of an element must be able to be set in any order.</source>
            <target xml:space="preserve">Another rule of XAML is that attributes of an element must be able to be set in any order.</target>
          </segment>
        </unit>
        <unit id="281">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
            <data id="id3">&lt;code&gt;</data>
            <data id="id4">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="281">
            <source xml:space="preserve">For example, there's no difference between <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Rectangle Height="50" Width="100" /&gt;</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="4">&lt;Rectangle Width="100"  Height="50" /&gt;</pc>.</source>
            <target xml:space="preserve">For example, there's no difference between <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Rectangle Height="50" Width="100" /&gt;</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="4">&lt;Rectangle Width="100"  Height="50" /&gt;</pc>.</target>
          </segment>
        </unit>
        <unit id="282">
          <segment state="initial" id="282">
            <source xml:space="preserve">Which order you use is a matter of style.</source>
            <target xml:space="preserve">Which order you use is a matter of style.</target>
          </segment>
        </unit>
        <unit id="283">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="283">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  XAML designers often promote ordering conventions if you use design surfaces other than the XML editor, but you can freely edit that XAML later, to reorder the attributes or introduce new ones.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  XAML designers often promote ordering conventions if you use design surfaces other than the XML editor, but you can freely edit that XAML later, to reorder the attributes or introduce new ones.</target>
          </segment>
        </unit>
        <unit id="284">
          <segment state="initial" id="284">
            <source xml:space="preserve">Attached properties</source>
            <target xml:space="preserve">Attached properties</target>
          </segment>
        </unit>
        <unit id="285">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="285">
            <source xml:space="preserve">XAML extends XML by adding a syntax element known as an <pc dataRefEnd="id2" dataRefStart="id1" id="2">attached property</pc>.</source>
            <target xml:space="preserve">XAML extends XML by adding a syntax element known as an <pc dataRefEnd="id2" dataRefStart="id1" id="2">attached property</pc>.</target>
          </segment>
        </unit>
        <unit id="286">
          <segment state="initial" id="286">
            <source xml:space="preserve">Similar to the property element syntax, the attached property syntax contains a dot, and the dot holds special meaning to XAML parsing.</source>
            <target xml:space="preserve">Similar to the property element syntax, the attached property syntax contains a dot, and the dot holds special meaning to XAML parsing.</target>
          </segment>
        </unit>
        <unit id="287">
          <segment state="initial" id="287">
            <source xml:space="preserve">Specifically, the dot separates the owner provider of the attached property, and the property name.</source>
            <target xml:space="preserve">Specifically, the dot separates the owner provider of the attached property, and the property name.</target>
          </segment>
        </unit>
        <unit id="288">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;link&gt;</data>
            <data id="id6">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="288">
            <source xml:space="preserve">In XAML, you set attached properties by using the syntax <pc dataRefEnd="id2" dataRefStart="id1" id="2">AttachedPropertyProvider</pc>.<pc dataRefEnd="id4" dataRefStart="id3" id="4">PropertyName</pc> Here is an example of how you can set the attached property <pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Canvas.Left**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> in XAML:</source>
            <target xml:space="preserve">In XAML, you set attached properties by using the syntax <pc dataRefEnd="id2" dataRefStart="id1" id="2">AttachedPropertyProvider</pc>.<pc dataRefEnd="id4" dataRefStart="id3" id="4">PropertyName</pc> Here is an example of how you can set the attached property <pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Canvas.Left**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> in XAML:</target>
          </segment>
        </unit>
        <unit id="289">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="289">
            <source xml:space="preserve">You can set the attached property on elements that don't have a property of that name in the backing type, and in that way they function somewhat like a global property, or an attribute defined by a different XML namespace like the <pc dataRefEnd="id2" dataRefStart="id1" id="2">xml:space</pc> attribute.</source>
            <target xml:space="preserve">You can set the attached property on elements that don't have a property of that name in the backing type, and in that way they function somewhat like a global property, or an attribute defined by a different XML namespace like the <pc dataRefEnd="id2" dataRefStart="id1" id="2">xml:space</pc> attribute.</target>
          </segment>
        </unit>
        <unit id="290">
          <segment state="initial" id="290">
            <source xml:space="preserve">In Windows Runtime XAML you'll see attached properties that support these scenarios:</source>
            <target xml:space="preserve">In Windows Runtime XAML you'll see attached properties that support these scenarios:</target>
          </segment>
        </unit>
        <unit id="291">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="291">
            <source xml:space="preserve">Child elements can inform parent container panels how they should behave in layout: <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Grid**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**VariableSizedWrapGrid**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Child elements can inform parent container panels how they should behave in layout: <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Canvas**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Grid**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**VariableSizedWrapGrid**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="292">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="292">
            <source xml:space="preserve">Control usages can influence behavior of an important control part that comes from the control template: <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ScrollViewer**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**VirtualizingStackPanel**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Control usages can influence behavior of an important control part that comes from the control template: <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ScrollViewer**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**VirtualizingStackPanel**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="293">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id19">&lt;link&gt;</data>
            <data id="id20">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="293">
            <source xml:space="preserve">Using a service that's available in a related class, where the service and the class that uses it don't share inheritance: <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Typography**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**VisualStateManager**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**AutomationProperties**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>, <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**ToolTipService**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Using a service that's available in a related class, where the service and the class that uses it don't share inheritance: <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Typography**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**VisualStateManager**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**AutomationProperties**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>, <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**ToolTipService**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="294">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="294">
            <source xml:space="preserve">Animation targeting: <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Storyboard**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Animation targeting: <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Storyboard**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="295">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="295">
            <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Attached properties overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Attached properties overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="296">
          <segment state="initial" id="296">
            <source xml:space="preserve">Literal "{" values</source>
            <target xml:space="preserve">Literal "{" values</target>
          </segment>
        </unit>
        <unit id="297">
          <segment state="initial" id="297">
            <source xml:space="preserve">Because the opening brace symbol \{ is the opening of the markup extension sequence, you use an escape sequence to specify a literal string value that starts with "\{".</source>
            <target xml:space="preserve">Because the opening brace symbol \{ is the opening of the markup extension sequence, you use an escape sequence to specify a literal string value that starts with "\{".</target>
          </segment>
        </unit>
        <unit id="298">
          <segment state="initial" id="298">
            <source xml:space="preserve">The escape sequence is "\{\}".</source>
            <target xml:space="preserve">The escape sequence is "\{\}".</target>
          </segment>
        </unit>
        <unit id="299">
          <segment state="initial" id="299">
            <source xml:space="preserve">For example, to specify a string value that is a single opening brace, specify the attribute value as "\{\}\{".</source>
            <target xml:space="preserve">For example, to specify a string value that is a single opening brace, specify the attribute value as "\{\}\{".</target>
          </segment>
        </unit>
        <unit id="300">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="300">
            <source xml:space="preserve">You can also use the alternative quotation marks (for example, a <pc dataRefEnd="id2" dataRefStart="id1" id="2">'</pc> within an attribute value delimited by <pc dataRefEnd="id4" dataRefStart="id3" id="4">""</pc>) to provide a "\{" value as a string.</source>
            <target xml:space="preserve">You can also use the alternative quotation marks (for example, a <pc dataRefEnd="id2" dataRefStart="id1" id="2">'</pc> within an attribute value delimited by <pc dataRefEnd="id4" dataRefStart="id3" id="4">""</pc>) to provide a "\{" value as a string.</target>
          </segment>
        </unit>
        <unit id="301">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="301">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  "\\}" also works if it's inside a quoted attribute.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  "\\}" also works if it's inside a quoted attribute.</target>
          </segment>
        </unit>
        <unit id="302">
          <segment state="initial" id="302">
            <source xml:space="preserve">Enumeration values</source>
            <target xml:space="preserve">Enumeration values</target>
          </segment>
        </unit>
        <unit id="303">
          <segment state="initial" id="303">
            <source xml:space="preserve">Many properties in the Windows Runtime API use enumerations as values.</source>
            <target xml:space="preserve">Many properties in the Windows Runtime API use enumerations as values.</target>
          </segment>
        </unit>
        <unit id="304">
          <segment state="initial" id="304">
            <source xml:space="preserve">If the member is a read-write property you can set such a property by providing an attribute value.</source>
            <target xml:space="preserve">If the member is a read-write property you can set such a property by providing an attribute value.</target>
          </segment>
        </unit>
        <unit id="305">
          <segment state="initial" id="305">
            <source xml:space="preserve">You identify which enumeration value to use as the value of the property by using the unqualified name of the constant name .</source>
            <target xml:space="preserve">You identify which enumeration value to use as the value of the property by using the unqualified name of the constant name .</target>
          </segment>
        </unit>
        <unit id="306">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;code&gt;</data>
            <data id="id8">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="306">
            <source xml:space="preserve">For example here's how to set <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**UIElement.Visibility**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> in XAML: <pc dataRefEnd="id8" dataRefStart="id7" id="4">&lt;Button Visibility="Visible"/&gt;</pc>.</source>
            <target xml:space="preserve">For example here's how to set <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**UIElement.Visibility**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> in XAML: <pc dataRefEnd="id8" dataRefStart="id7" id="4">&lt;Button Visibility="Visible"/&gt;</pc>.</target>
          </segment>
        </unit>
        <unit id="307">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;strong&gt;</data>
            <data id="id8">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="307">
            <source xml:space="preserve">Here the "Visible" as a string is directly mapped to a named constant of the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Visibility**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> enumeration, <pc dataRefEnd="id8" dataRefStart="id7" id="4">Visible</pc>.</source>
            <target xml:space="preserve">Here the "Visible" as a string is directly mapped to a named constant of the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Visibility**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> enumeration, <pc dataRefEnd="id8" dataRefStart="id7" id="4">Visible</pc>.</target>
          </segment>
        </unit>
        <unit id="308">
          <segment state="initial" id="308">
            <source xml:space="preserve">Don't use a qualified form, it won't work.</source>
            <target xml:space="preserve">Don't use a qualified form, it won't work.</target>
          </segment>
        </unit>
        <unit id="309">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="309">
            <source xml:space="preserve">For example, this is invalid XAML: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Button Visibility="Visibility.Visible"/&gt;</pc>.</source>
            <target xml:space="preserve">For example, this is invalid XAML: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Button Visibility="Visibility.Visible"/&gt;</pc>.</target>
          </segment>
        </unit>
        <unit id="310">
          <segment state="initial" id="310">
            <source xml:space="preserve">Don't use the value of the constant.</source>
            <target xml:space="preserve">Don't use the value of the constant.</target>
          </segment>
        </unit>
        <unit id="311">
          <segment state="initial" id="311">
            <source xml:space="preserve">In other words, don't rely on the integer value of the enumeration that's there explicitly or implicitly depending on how the enumeration was defined.</source>
            <target xml:space="preserve">In other words, don't rely on the integer value of the enumeration that's there explicitly or implicitly depending on how the enumeration was defined.</target>
          </segment>
        </unit>
        <unit id="312">
          <segment state="initial" id="312">
            <source xml:space="preserve">Although it might appear to work, it's a bad practice either in XAML or in code because you're relying on what could be a transient implementation detail.</source>
            <target xml:space="preserve">Although it might appear to work, it's a bad practice either in XAML or in code because you're relying on what could be a transient implementation detail.</target>
          </segment>
        </unit>
        <unit id="313">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="313">
            <source xml:space="preserve">For example, don't do this: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Button Visibility="1"/&gt;</pc>.</source>
            <target xml:space="preserve">For example, don't do this: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Button Visibility="1"/&gt;</pc>.</target>
          </segment>
        </unit>
        <unit id="314">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
            <data id="id5">&lt;strong&gt;</data>
            <data id="id6">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="314">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  In reference topics for APIs that use XAML and use enumerations, click the link to the enumeration type in the <pc dataRefEnd="id4" dataRefStart="id3" id="3">Property value</pc> section of <pc dataRefEnd="id6" dataRefStart="id5" id="5">Syntax</pc>.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  In reference topics for APIs that use XAML and use enumerations, click the link to the enumeration type in the <pc dataRefEnd="id4" dataRefStart="id3" id="3">Property value</pc> section of <pc dataRefEnd="id6" dataRefStart="id5" id="5">Syntax</pc>.</target>
          </segment>
        </unit>
        <unit id="315">
          <segment state="initial" id="315">
            <source xml:space="preserve">This links to the enumeration page where you can discover the named constants for that enumeration.</source>
            <target xml:space="preserve">This links to the enumeration page where you can discover the named constants for that enumeration.</target>
          </segment>
        </unit>
        <unit id="316">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="316">
            <source xml:space="preserve">Enumerations can be flagwise, meaning that they are attributed with <pc dataRefEnd="id2" dataRefStart="id1" id="2">FlagsAttribute</pc>.</source>
            <target xml:space="preserve">Enumerations can be flagwise, meaning that they are attributed with <pc dataRefEnd="id2" dataRefStart="id1" id="2">FlagsAttribute</pc>.</target>
          </segment>
        </unit>
        <unit id="317">
          <segment state="initial" id="317">
            <source xml:space="preserve">If you need to specify a combination of values for a flagwise enumeration as a XAML attribute value, use the name of each enumeration constant, with a comma (,) between each name, and no intervening space characters.</source>
            <target xml:space="preserve">If you need to specify a combination of values for a flagwise enumeration as a XAML attribute value, use the name of each enumeration constant, with a comma (,) between each name, and no intervening space characters.</target>
          </segment>
        </unit>
        <unit id="318">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="318">
            <source xml:space="preserve">Flagwise attributes aren't common in the Windows Runtime XAML vocabulary, but <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ManipulationModes**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> is an example where setting a flagwise enumeration value in XAML is supported.</source>
            <target xml:space="preserve">Flagwise attributes aren't common in the Windows Runtime XAML vocabulary, but <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ManipulationModes**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> is an example where setting a flagwise enumeration value in XAML is supported.</target>
          </segment>
        </unit>
        <unit id="319">
          <segment state="initial" id="319">
            <source xml:space="preserve">Interfaces in XAML</source>
            <target xml:space="preserve">Interfaces in XAML</target>
          </segment>
        </unit>
        <unit id="320">
          <segment state="initial" id="320">
            <source xml:space="preserve">In rare cases you'll see a XAML syntax where the type of a property is an interface.</source>
            <target xml:space="preserve">In rare cases you'll see a XAML syntax where the type of a property is an interface.</target>
          </segment>
        </unit>
        <unit id="321">
          <segment state="initial" id="321">
            <source xml:space="preserve">In the XAML type system, a type that implements that interface is acceptable as a value when parsed.</source>
            <target xml:space="preserve">In the XAML type system, a type that implements that interface is acceptable as a value when parsed.</target>
          </segment>
        </unit>
        <unit id="322">
          <segment state="initial" id="322">
            <source xml:space="preserve">There must be a created instance of such a type available to serve as the value.</source>
            <target xml:space="preserve">There must be a created instance of such a type available to serve as the value.</target>
          </segment>
        </unit>
        <unit id="323">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="323">
            <source xml:space="preserve">You'll see an interface used as a type in the XAML syntax for <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Command**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**CommandParameter**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> properties of <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**ButtonBase**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">You'll see an interface used as a type in the XAML syntax for <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Command**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**CommandParameter**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> properties of <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**ButtonBase**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="324">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="324">
            <source xml:space="preserve">These properties support Model-View-ViewModel (MVVM) design patterns where the <pc dataRefEnd="id2" dataRefStart="id1" id="2">ICommand</pc> interface is the contract for how the views and models interact.</source>
            <target xml:space="preserve">These properties support Model-View-ViewModel (MVVM) design patterns where the <pc dataRefEnd="id2" dataRefStart="id1" id="2">ICommand</pc> interface is the contract for how the views and models interact.</target>
          </segment>
        </unit>
        <unit id="325">
          <segment state="initial" id="325">
            <source xml:space="preserve">XAML placeholder conventions in Windows Runtime reference</source>
            <target xml:space="preserve">XAML placeholder conventions in Windows Runtime reference</target>
          </segment>
        </unit>
        <unit id="326">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="326">
            <source xml:space="preserve">If you've examined any of the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Syntax</pc> section of reference topics for Windows Runtime APIs that can use XAML, you've probably seen that the syntax includes quite a few placeholders.</source>
            <target xml:space="preserve">If you've examined any of the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Syntax</pc> section of reference topics for Windows Runtime APIs that can use XAML, you've probably seen that the syntax includes quite a few placeholders.</target>
          </segment>
        </unit>
        <unit id="327">
          <segment state="initial" id="327">
            <source xml:space="preserve">XAML syntax is different than the C\#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) syntax because the XAML syntax is a usage syntax.</source>
            <target xml:space="preserve">XAML syntax is different than the C\#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) syntax because the XAML syntax is a usage syntax.</target>
          </segment>
        </unit>
        <unit id="328">
          <segment state="initial" id="328">
            <source xml:space="preserve">It's hinting at your eventual usage in your own XAML files, but without being over-prescriptive about the values you can use.</source>
            <target xml:space="preserve">It's hinting at your eventual usage in your own XAML files, but without being over-prescriptive about the values you can use.</target>
          </segment>
        </unit>
        <unit id="329">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="329">
            <source xml:space="preserve">So usually the usage describes a type of grammar that mixes literals and placeholders, and defines some of the placeholders in the <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML Values</pc> section.</source>
            <target xml:space="preserve">So usually the usage describes a type of grammar that mixes literals and placeholders, and defines some of the placeholders in the <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML Values</pc> section.</target>
          </segment>
        </unit>
        <unit id="330">
          <segment state="initial" id="330">
            <source xml:space="preserve">When you see type names / element names in a XAML syntax for a property, the name that's shown is for the type that originally defines the property.</source>
            <target xml:space="preserve">When you see type names / element names in a XAML syntax for a property, the name that's shown is for the type that originally defines the property.</target>
          </segment>
        </unit>
        <unit id="331">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="331">
            <source xml:space="preserve">But Windows Runtime XAML supports a class inheritance model for the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**DependencyObject**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>-based classes.</source>
            <target xml:space="preserve">But Windows Runtime XAML supports a class inheritance model for the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**DependencyObject**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>-based classes.</target>
          </segment>
        </unit>
        <unit id="332">
          <segment state="initial" id="332">
            <source xml:space="preserve">So you can often use an attribute on a class that's not literally the defining class, but instead derives from a class that first defined the property/attribute.</source>
            <target xml:space="preserve">So you can often use an attribute on a class that's not literally the defining class, but instead derives from a class that first defined the property/attribute.</target>
          </segment>
        </unit>
        <unit id="333">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="333">
            <source xml:space="preserve">For example, you can set <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Visibility**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> as an attribute on any <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**UIElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> derived class using a deep inheritance.</source>
            <target xml:space="preserve">For example, you can set <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Visibility**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> as an attribute on any <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**UIElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> derived class using a deep inheritance.</target>
          </segment>
        </unit>
        <unit id="334">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="334">
            <source xml:space="preserve">For example: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Button Visibility="Visible" /&gt;</pc>.</source>
            <target xml:space="preserve">For example: <pc dataRefEnd="id2" dataRefStart="id1" id="2">&lt;Button Visibility="Visible" /&gt;</pc>.</target>
          </segment>
        </unit>
        <unit id="335">
          <segment state="initial" id="335">
            <source xml:space="preserve">So don't take the element name shown in any XAML usage syntax too literally; the syntax may be viable for elements representing that class, and also elements that represent a derived class.</source>
            <target xml:space="preserve">So don't take the element name shown in any XAML usage syntax too literally; the syntax may be viable for elements representing that class, and also elements that represent a derived class.</target>
          </segment>
        </unit>
        <unit id="336">
          <segment state="initial" id="336">
            <source xml:space="preserve">In cases where it's rare or impossible for the type shown as the defining element to be in a real-world usage, that type name is deliberately lowercased in the syntax.</source>
            <target xml:space="preserve">In cases where it's rare or impossible for the type shown as the defining element to be in a real-world usage, that type name is deliberately lowercased in the syntax.</target>
          </segment>
        </unit>
        <unit id="337">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="337">
            <source xml:space="preserve">For example, the syntax you see for <pc dataRefEnd="id2" dataRefStart="id1" id="2">UIElement.Visibility</pc> is :</source>
            <target xml:space="preserve">For example, the syntax you see for <pc dataRefEnd="id2" dataRefStart="id1" id="2">UIElement.Visibility</pc> is :</target>
          </segment>
        </unit>
        <unit id="338">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="338">
            <source xml:space="preserve">Many XAML syntax sections include placeholders in the "Usage" that are then defined in a <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML Values</pc> section that's directly under the <pc dataRefEnd="id4" dataRefStart="id3" id="4">Syntax</pc> section.</source>
            <target xml:space="preserve">Many XAML syntax sections include placeholders in the "Usage" that are then defined in a <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML Values</pc> section that's directly under the <pc dataRefEnd="id4" dataRefStart="id3" id="4">Syntax</pc> section.</target>
          </segment>
        </unit>
        <unit id="339">
          <segment state="initial" id="339">
            <source xml:space="preserve">XAML usage sections also use various generalized placeholders.</source>
            <target xml:space="preserve">XAML usage sections also use various generalized placeholders.</target>
          </segment>
        </unit>
        <unit id="340">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="340">
            <source xml:space="preserve">These placeholders aren't redefined every time in <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML Values</pc>, because you'll guess or eventually learn what they represent.</source>
            <target xml:space="preserve">These placeholders aren't redefined every time in <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML Values</pc>, because you'll guess or eventually learn what they represent.</target>
          </segment>
        </unit>
        <unit id="341">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="341">
            <source xml:space="preserve">We think most readers would get tired of seeing them in <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML Values</pc> again and again so we left them out of the definitions.</source>
            <target xml:space="preserve">We think most readers would get tired of seeing them in <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML Values</pc> again and again so we left them out of the definitions.</target>
          </segment>
        </unit>
        <unit id="342">
          <segment state="initial" id="342">
            <source xml:space="preserve">For reference, here's a list of some of these placeholders and what they mean in a general sense:</source>
            <target xml:space="preserve">For reference, here's a list of some of these placeholders and what they mean in a general sense:</target>
          </segment>
        </unit>
        <unit id="343">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="343">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">object</pc>: theoretically any object value, but often practically limited to certain types of objects such as a string-or-object choice, and you should check the Remarks on the reference page for more info.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">object</pc>: theoretically any object value, but often practically limited to certain types of objects such as a string-or-object choice, and you should check the Remarks on the reference page for more info.</target>
          </segment>
        </unit>
        <unit id="344">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;em&gt;</data>
            <data id="id6">&lt;/em&gt;</data>
            <data id="id7">&lt;em&gt;</data>
            <data id="id8">&lt;/em&gt;</data>
            <data id="id9">&lt;strong&gt;</data>
            <data id="id10">&lt;/strong&gt;</data>
            <data id="id11">&lt;link&gt;</data>
            <data id="id12">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id17">&lt;html&gt;</data>
            <data id="id18">&lt;/html&gt;</data>
          </originalData>
          <segment state="initial" id="344">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">object</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="3">property</pc>: <pc dataRefEnd="id6" dataRefStart="id5" id="5">object</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="7">property</pc> in combination is used for cases where the syntax being shown is the syntax for a type that can be used as an attribute value for many properties. For example, the <pc dataRefEnd="id10" dataRefStart="id9" id="9">Xaml Attribute Usage</pc> shown for <pc dataRefEnd="id12" dataRefStart="id11" id="11CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="11CapsExtId2">**Brush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="11CapsExtId3"></pc></pc> includes: <pc dataRefEnd="id18" dataRefStart="id17" id="13"></pc></source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">object</pc> <pc dataRefEnd="id4" dataRefStart="id3" id="3">property</pc>: <pc dataRefEnd="id6" dataRefStart="id5" id="5">object</pc> <pc dataRefEnd="id8" dataRefStart="id7" id="7">property</pc> in combination is used for cases where the syntax being shown is the syntax for a type that can be used as an attribute value for many properties. For example, the <pc dataRefEnd="id10" dataRefStart="id9" id="9">Xaml Attribute Usage</pc> shown for <pc dataRefEnd="id12" dataRefStart="id11" id="11CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="11CapsExtId2">**Brush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="11CapsExtId3"></pc></pc> includes: <pc dataRefEnd="id18" dataRefStart="id17" id="13"></pc></target>
          </segment>
        </unit>
        <unit id="345">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="345">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">eventhandler</pc>: This appears as the attribute value for every XAML syntax shown for an event attribute.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">eventhandler</pc>: This appears as the attribute value for every XAML syntax shown for an event attribute.</target>
          </segment>
        </unit>
        <unit id="346">
          <segment state="initial" id="346">
            <source xml:space="preserve">What you're supplying here is the function name for an event handler function.</source>
            <target xml:space="preserve">What you're supplying here is the function name for an event handler function.</target>
          </segment>
        </unit>
        <unit id="347">
          <segment state="initial" id="347">
            <source xml:space="preserve">That function must be defined in the code-behind for the XAML page.</source>
            <target xml:space="preserve">That function must be defined in the code-behind for the XAML page.</target>
          </segment>
        </unit>
        <unit id="348">
          <segment state="initial" id="348">
            <source xml:space="preserve">At the programming level, that function must match the delegate signature of the event that you're handling, or your app code won't compile.</source>
            <target xml:space="preserve">At the programming level, that function must match the delegate signature of the event that you're handling, or your app code won't compile.</target>
          </segment>
        </unit>
        <unit id="349">
          <segment state="initial" id="349">
            <source xml:space="preserve">But that's really a programming consideration, not a XAML consideration, so we don't try to hint anything about the delegate type in the XAML syntax.</source>
            <target xml:space="preserve">But that's really a programming consideration, not a XAML consideration, so we don't try to hint anything about the delegate type in the XAML syntax.</target>
          </segment>
        </unit>
        <unit id="350">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="350">
            <source xml:space="preserve">If you want to know which delegate you should be implementing for an event, that's in the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Event information</pc> section of the reference topic for the event, in a table row that's labeled <pc dataRefEnd="id4" dataRefStart="id3" id="4">Delegate</pc>.</source>
            <target xml:space="preserve">If you want to know which delegate you should be implementing for an event, that's in the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Event information</pc> section of the reference topic for the event, in a table row that's labeled <pc dataRefEnd="id4" dataRefStart="id3" id="4">Delegate</pc>.</target>
          </segment>
        </unit>
        <unit id="351">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id9">&lt;html&gt;</data>
            <data id="id10">&lt;/html&gt;</data>
            <data id="id11">&lt;strong&gt;</data>
            <data id="id12">&lt;/strong&gt;</data>
            <data id="id13">&lt;strong&gt;</data>
            <data id="id14">&lt;/strong&gt;</data>
            <data id="id15">&lt;strong&gt;</data>
            <data id="id16">&lt;/strong&gt;</data>
            <data id="id17">&lt;strong&gt;</data>
            <data id="id18">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="351">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">enumMemberName</pc>: shown in attribute syntax for all enumerations. There's a similar placeholder for properties that use an enumeration value, but it usually prefixes the placeholder with a hint of the enumeration's name. For example, the syntax shown for <pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId2">**FrameworkElement.FlowDirection**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="3CapsExtId3"></pc></pc> is <pc dataRefEnd="id10" dataRefStart="id9" id="5"></pc>. If you're on one of those property reference pages, click the link to the enumeration type that appears in the <pc dataRefEnd="id12" dataRefStart="id11" id="7">Property Value</pc> section, next to the text <pc dataRefEnd="id14" dataRefStart="id13" id="9">Type:</pc>. For the attribute value of a property that uses that enumeration, you can use any string that is listed in the <pc dataRefEnd="id16" dataRefStart="id15" id="11">Member</pc> column of the <pc dataRefEnd="id18" dataRefStart="id17" id="13">Members</pc> list.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">enumMemberName</pc>: shown in attribute syntax for all enumerations. There's a similar placeholder for properties that use an enumeration value, but it usually prefixes the placeholder with a hint of the enumeration's name. For example, the syntax shown for <pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="3CapsExtId2">**FrameworkElement.FlowDirection**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="3CapsExtId3"></pc></pc> is <pc dataRefEnd="id10" dataRefStart="id9" id="5"></pc>. If you're on one of those property reference pages, click the link to the enumeration type that appears in the <pc dataRefEnd="id12" dataRefStart="id11" id="7">Property Value</pc> section, next to the text <pc dataRefEnd="id14" dataRefStart="id13" id="9">Type:</pc>. For the attribute value of a property that uses that enumeration, you can use any string that is listed in the <pc dataRefEnd="id16" dataRefStart="id15" id="11">Member</pc> column of the <pc dataRefEnd="id18" dataRefStart="id17" id="13">Members</pc> list.</target>
          </segment>
        </unit>
        <unit id="352">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
            <data id="id3">&lt;em&gt;</data>
            <data id="id4">&lt;/em&gt;</data>
            <data id="id5">&lt;em&gt;</data>
            <data id="id6">&lt;/em&gt;</data>
            <data id="id7">&lt;em&gt;</data>
            <data id="id8">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="352">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">double</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="3">int</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="5">string</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="7">bool</pc>: These are primitive types known to the XAML language.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">double</pc>, <pc dataRefEnd="id4" dataRefStart="id3" id="3">int</pc>, <pc dataRefEnd="id6" dataRefStart="id5" id="5">string</pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="7">bool</pc>: These are primitive types known to the XAML language.</target>
          </segment>
        </unit>
        <unit id="353">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id13">&lt;link&gt;</data>
            <data id="id14">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id19">&lt;link&gt;</data>
            <data id="id20">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="353">
            <source xml:space="preserve">If you're programming using C\# or Visual Basic, these types are projected to Microsoft .NET equivalent types such as <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Double**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Int32**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**String**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> and <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**Boolean**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc>, and you can use any members on those .NET types when you work with your XAML-defined values in .NET code-behind.</source>
            <target xml:space="preserve">If you're programming using C\# or Visual Basic, these types are projected to Microsoft .NET equivalent types such as <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Double**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Int32**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>, <pc dataRefEnd="id14" dataRefStart="id13" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**String**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> and <pc dataRefEnd="id20" dataRefStart="id19" id="8CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="8CapsExtId2">**Boolean**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="8CapsExtId3"></pc></pc>, and you can use any members on those .NET types when you work with your XAML-defined values in .NET code-behind.</target>
          </segment>
        </unit>
        <unit id="354">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="354">
            <source xml:space="preserve">If you're programming using C++/CX, you'll use the C++ primitive types but you can also consider these equivalent to types defined by the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Platform**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> namespace, for example <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Platform::String**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">If you're programming using C++/CX, you'll use the C++ primitive types but you can also consider these equivalent to types defined by the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Platform**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> namespace, for example <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Platform::String**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="355">
          <segment state="initial" id="355">
            <source xml:space="preserve">There will sometimes be additional value restrictions for particular properties.</source>
            <target xml:space="preserve">There will sometimes be additional value restrictions for particular properties.</target>
          </segment>
        </unit>
        <unit id="356">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="356">
            <source xml:space="preserve">But you'll usually see these noted in a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Property value</pc> section or Remarks section and not in a XAML section, because any such restrictions apply both to code usages and XAML usages.</source>
            <target xml:space="preserve">But you'll usually see these noted in a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Property value</pc> section or Remarks section and not in a XAML section, because any such restrictions apply both to code usages and XAML usages.</target>
          </segment>
        </unit>
        <unit id="357">
          <segment state="initial" id="357">
            <source xml:space="preserve">Tips and tricks, notes on style</source>
            <target xml:space="preserve">Tips and tricks, notes on style</target>
          </segment>
        </unit>
        <unit id="358">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="358">
            <source xml:space="preserve">Markup extensions in general are described in the main <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">XAML overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Markup extensions in general are described in the main <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">XAML overview</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="359">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="359">
            <source xml:space="preserve">But the markup extension that most impacts the guidance given in this topic is the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">StaticResource</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> markup extension (and related <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">ThemeResource</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">But the markup extension that most impacts the guidance given in this topic is the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">StaticResource</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> markup extension (and related <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">ThemeResource</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="360">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="360">
            <source xml:space="preserve">The function of the StaticResource markup extension is to enable factoring your XAML into reusable resources that come from a XAML <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ResourceDictionary**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">The function of the StaticResource markup extension is to enable factoring your XAML into reusable resources that come from a XAML <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**ResourceDictionary**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="361">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="361">
            <source xml:space="preserve">You almost always define control templates and related styles in a <pc dataRefEnd="id2" dataRefStart="id1" id="2">ResourceDictionary</pc>.</source>
            <target xml:space="preserve">You almost always define control templates and related styles in a <pc dataRefEnd="id2" dataRefStart="id1" id="2">ResourceDictionary</pc>.</target>
          </segment>
        </unit>
        <unit id="362">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="362">
            <source xml:space="preserve">You often define the smaller parts of a control template definition or app-specific style in a <pc dataRefEnd="id2" dataRefStart="id1" id="2">ResourceDictionary</pc> too, for example a <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**SolidColorBrush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> for a color that your app uses more than once for different parts of UI.</source>
            <target xml:space="preserve">You often define the smaller parts of a control template definition or app-specific style in a <pc dataRefEnd="id2" dataRefStart="id1" id="2">ResourceDictionary</pc> too, for example a <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**SolidColorBrush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> for a color that your app uses more than once for different parts of UI.</target>
          </segment>
        </unit>
        <unit id="363">
          <segment state="initial" id="363">
            <source xml:space="preserve">By using a StaticResource, any property that would otherwise require a property element usage to set can now be set in attribute syntax.</source>
            <target xml:space="preserve">By using a StaticResource, any property that would otherwise require a property element usage to set can now be set in attribute syntax.</target>
          </segment>
        </unit>
        <unit id="364">
          <segment state="initial" id="364">
            <source xml:space="preserve">But the benefits of factoring XAML for reuse go beyond just simplifying the page-level syntax.</source>
            <target xml:space="preserve">But the benefits of factoring XAML for reuse go beyond just simplifying the page-level syntax.</target>
          </segment>
        </unit>
        <unit id="365">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="365">
            <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">ResourceDictionary and XAML resource references</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">ResourceDictionary and XAML resource references</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="366">
          <segment state="initial" id="366">
            <source xml:space="preserve">You'll see several different conventions for how white space and line feeds are applied in XAML examples.</source>
            <target xml:space="preserve">You'll see several different conventions for how white space and line feeds are applied in XAML examples.</target>
          </segment>
        </unit>
        <unit id="367">
          <segment state="initial" id="367">
            <source xml:space="preserve">In particular, there are different conventions for how to break up object elements that have a lot of different attributes set.</source>
            <target xml:space="preserve">In particular, there are different conventions for how to break up object elements that have a lot of different attributes set.</target>
          </segment>
        </unit>
        <unit id="368">
          <segment state="initial" id="368">
            <source xml:space="preserve">That's just a matter of style.</source>
            <target xml:space="preserve">That's just a matter of style.</target>
          </segment>
        </unit>
        <unit id="369">
          <segment state="initial" id="369">
            <source xml:space="preserve">The Visual Studio XML editor applies some default style rules when you edit XAML, but you can change these in the settings.</source>
            <target xml:space="preserve">The Visual Studio XML editor applies some default style rules when you edit XAML, but you can change these in the settings.</target>
          </segment>
        </unit>
        <unit id="370">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="370">
            <source xml:space="preserve">There are a small number of cases where the white space in a XAML file is considered significant; for more info see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">XAML and whitespace</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">There are a small number of cases where the white space in a XAML file is considered significant; for more info see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">XAML and whitespace</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="371">
          <segment state="initial" id="371">
            <source xml:space="preserve">Related topics</source>
            <target xml:space="preserve">Related topics</target>
          </segment>
        </unit>
        <unit id="372">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="372">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">XAML overview</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">XAML overview</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
        <unit id="373">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="373">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">XAML namespaces and namespace mapping</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">XAML namespaces and namespace mapping</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
        <unit id="374">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="374">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">ResourceDictionary and XAML resource references</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">ResourceDictionary and XAML resource references</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
      </group>
    </group>
  </file>
</xliff>