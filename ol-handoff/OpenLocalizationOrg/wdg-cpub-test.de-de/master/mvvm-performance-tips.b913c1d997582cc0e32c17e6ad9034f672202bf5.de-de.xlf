<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-us" trgLang="de-de" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">d7ec7fb242eaddc508823a67716860807c7a2ec3</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <group id="101">
        <unit id="101">
          <segment state="initial" id="101">
            <source xml:space="preserve">MVVM and language performance tips</source>
            <target xml:space="preserve">MVVM and language performance tips</target>
          </segment>
        </unit>
        <unit id="102">
          <segment state="initial" id="102">
            <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
            <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
          </segment>
        </unit>
        <unit id="103">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="103">
            <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</source>
            <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</target>
          </segment>
        </unit>
        <unit id="104">
          <segment state="initial" id="104">
            <source xml:space="preserve">This topic discusses some performance considerations related to your choice of software design patterns, and programming language.</source>
            <target xml:space="preserve">This topic discusses some performance considerations related to your choice of software design patterns, and programming language.</target>
          </segment>
        </unit>
        <unit id="105">
          <segment state="initial" id="105">
            <source xml:space="preserve">The Model-View-ViewModel (MVVM) pattern</source>
            <target xml:space="preserve">The Model-View-ViewModel (MVVM) pattern</target>
          </segment>
        </unit>
        <unit id="106">
          <segment state="initial" id="106">
            <source xml:space="preserve">The Model-View-ViewModel (MVVM) pattern is common in a lot of XAML apps.</source>
            <target xml:space="preserve">The Model-View-ViewModel (MVVM) pattern is common in a lot of XAML apps.</target>
          </segment>
        </unit>
        <unit id="107">
          <segment state="initial" id="107">
            <source xml:space="preserve">(MVVM is very similar to Fowler’s description of the Model-View-Presenter pattern, but it is tailored to XAML).</source>
            <target xml:space="preserve">(MVVM is very similar to Fowler’s description of the Model-View-Presenter pattern, but it is tailored to XAML).</target>
          </segment>
        </unit>
        <unit id="108">
          <segment state="initial" id="108">
            <source xml:space="preserve">The issue with the MVVM pattern is that it can inadvertently lead to apps that have too many layers and too many allocations.</source>
            <target xml:space="preserve">The issue with the MVVM pattern is that it can inadvertently lead to apps that have too many layers and too many allocations.</target>
          </segment>
        </unit>
        <unit id="109">
          <segment state="initial" id="109">
            <source xml:space="preserve">The motivations for MVVM are these.</source>
            <target xml:space="preserve">The motivations for MVVM are these.</target>
          </segment>
        </unit>
        <unit id="110">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="110">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Separation of concerns</pc>.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Separation of concerns</pc>.</target>
          </segment>
        </unit>
        <unit id="111">
          <segment state="initial" id="111">
            <source xml:space="preserve">It’s always helpful to divide a problem into smaller pieces, and a pattern like MVVM or MVC is a way to divide an app (or even a single control) into smaller pieces: the actual view, a logical model of the view (view-model), and the view-independent app logic (the model).</source>
            <target xml:space="preserve">It’s always helpful to divide a problem into smaller pieces, and a pattern like MVVM or MVC is a way to divide an app (or even a single control) into smaller pieces: the actual view, a logical model of the view (view-model), and the view-independent app logic (the model).</target>
          </segment>
        </unit>
        <unit id="112">
          <segment state="initial" id="112">
            <source xml:space="preserve">In particular, it’s a popular workflow to have designers own the view using one tool, developers own the model using another tool, and design integrators own the view-model using both tools.</source>
            <target xml:space="preserve">In particular, it’s a popular workflow to have designers own the view using one tool, developers own the model using another tool, and design integrators own the view-model using both tools.</target>
          </segment>
        </unit>
        <unit id="113">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="113">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Unit testing</pc>.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Unit testing</pc>.</target>
          </segment>
        </unit>
        <unit id="114">
          <segment state="initial" id="114">
            <source xml:space="preserve">You can unit test the view-model (and consequently the model) independent of the view, thereby not relying on creating windows, driving input, and so on.</source>
            <target xml:space="preserve">You can unit test the view-model (and consequently the model) independent of the view, thereby not relying on creating windows, driving input, and so on.</target>
          </segment>
        </unit>
        <unit id="115">
          <segment state="initial" id="115">
            <source xml:space="preserve">By keeping the view small, you can test a large portion of your app without ever having to create a window.</source>
            <target xml:space="preserve">By keeping the view small, you can test a large portion of your app without ever having to create a window.</target>
          </segment>
        </unit>
        <unit id="116">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="116">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Agility to user experience changes</pc>.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Agility to user experience changes</pc>.</target>
          </segment>
        </unit>
        <unit id="117">
          <segment state="initial" id="117">
            <source xml:space="preserve">The view tends to see the most frequent changes, and the most late changes, as the user experience is tweaked based on end-user feedback.</source>
            <target xml:space="preserve">The view tends to see the most frequent changes, and the most late changes, as the user experience is tweaked based on end-user feedback.</target>
          </segment>
        </unit>
        <unit id="118">
          <segment state="initial" id="118">
            <source xml:space="preserve">By keeping the view separate, these changes can be accommodated more quickly and with less churn to the app.</source>
            <target xml:space="preserve">By keeping the view separate, these changes can be accommodated more quickly and with less churn to the app.</target>
          </segment>
        </unit>
        <unit id="119">
          <segment state="initial" id="119">
            <source xml:space="preserve">There are multiple concrete definitions of the MVVM pattern, and 3rd party frameworks that help implement it.</source>
            <target xml:space="preserve">There are multiple concrete definitions of the MVVM pattern, and 3rd party frameworks that help implement it.</target>
          </segment>
        </unit>
        <unit id="120">
          <segment state="initial" id="120">
            <source xml:space="preserve">But strict adherence to any variation of the pattern can lead to apps with a lot more overhead than can be justified.</source>
            <target xml:space="preserve">But strict adherence to any variation of the pattern can lead to apps with a lot more overhead than can be justified.</target>
          </segment>
        </unit>
        <unit id="121">
          <segment state="initial" id="121">
            <source xml:space="preserve">XAML data binding (the {Binding} markup extension) was designed in part to enable model/view patterns.</source>
            <target xml:space="preserve">XAML data binding (the {Binding} markup extension) was designed in part to enable model/view patterns.</target>
          </segment>
        </unit>
        <unit id="122">
          <segment state="initial" id="122">
            <source xml:space="preserve">But {Binding} brings with it non-trivial working set and CPU overhead.</source>
            <target xml:space="preserve">But {Binding} brings with it non-trivial working set and CPU overhead.</target>
          </segment>
        </unit>
        <unit id="123">
          <segment state="initial" id="123">
            <source xml:space="preserve">Creating a {Binding} causes a series of allocations, and updating a binding target can cause reflection and boxing.</source>
            <target xml:space="preserve">Creating a {Binding} causes a series of allocations, and updating a binding target can cause reflection and boxing.</target>
          </segment>
        </unit>
        <unit id="124">
          <segment state="initial" id="124">
            <source xml:space="preserve">These problems are being addressed with the {x:Bind} markup extension, which compiles the bindings at build time.</source>
            <target xml:space="preserve">These problems are being addressed with the {x:Bind} markup extension, which compiles the bindings at build time.</target>
          </segment>
        </unit>
        <unit id="125">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="125">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Recommendation:</pc> use {x:Bind}.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Recommendation:</pc> use {x:Bind}.</target>
          </segment>
        </unit>
        <unit id="126">
          <segment state="initial" id="126">
            <source xml:space="preserve">It’s popular in MVVM to connect Button.Click to the view-model using an ICommand, such as the common DelegateCommand or RelayCommand helpers.</source>
            <target xml:space="preserve">It’s popular in MVVM to connect Button.Click to the view-model using an ICommand, such as the common DelegateCommand or RelayCommand helpers.</target>
          </segment>
        </unit>
        <unit id="127">
          <segment state="initial" id="127">
            <source xml:space="preserve">Those commands are extra allocations, though, including the CanExecuteChanged event listener, adding to the working set, and adding to the startup/navigation time for the page.</source>
            <target xml:space="preserve">Those commands are extra allocations, though, including the CanExecuteChanged event listener, adding to the working set, and adding to the startup/navigation time for the page.</target>
          </segment>
        </unit>
        <unit id="128">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="128">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Recommendation:</pc> As an alternative to using the convenient ICommand interface, consider putting event handlers in your code-behind and attaching them to the view events and call a command on your view-model when those events are raised.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Recommendation:</pc> As an alternative to using the convenient ICommand interface, consider putting event handlers in your code-behind and attaching them to the view events and call a command on your view-model when those events are raised.</target>
          </segment>
        </unit>
        <unit id="129">
          <segment state="initial" id="129">
            <source xml:space="preserve">You'll also need to add extra code to disable the Button when the command is unavailable.</source>
            <target xml:space="preserve">You'll also need to add extra code to disable the Button when the command is unavailable.</target>
          </segment>
        </unit>
        <unit id="130">
          <segment state="initial" id="130">
            <source xml:space="preserve">It’s popular in MVVM to create a Page with all possible configurations of the UI, then collapse parts of the tree by binding the Visibility property to properties in the VM.</source>
            <target xml:space="preserve">It’s popular in MVVM to create a Page with all possible configurations of the UI, then collapse parts of the tree by binding the Visibility property to properties in the VM.</target>
          </segment>
        </unit>
        <unit id="131">
          <segment state="initial" id="131">
            <source xml:space="preserve">This adds unnecessarily to startup time and possibly to working set (because some parts of the tree may never become visible).</source>
            <target xml:space="preserve">This adds unnecessarily to startup time and possibly to working set (because some parts of the tree may never become visible).</target>
          </segment>
        </unit>
        <unit id="132">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="132">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Recommendations:</pc> Use the x:DeferLoadStrategy feature to defer unnecessary portions of the tree out of startup.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Recommendations:</pc> Use the x:DeferLoadStrategy feature to defer unnecessary portions of the tree out of startup.</target>
          </segment>
        </unit>
        <unit id="133">
          <segment state="initial" id="133">
            <source xml:space="preserve">Also, create separate user controls for the different modes of the page and use code-behind to keep only the necessary controls loaded.</source>
            <target xml:space="preserve">Also, create separate user controls for the different modes of the page and use code-behind to keep only the necessary controls loaded.</target>
          </segment>
        </unit>
        <unit id="134">
          <segment state="initial" id="134">
            <source xml:space="preserve">C++/CX recommendations</source>
            <target xml:space="preserve">C++/CX recommendations</target>
          </segment>
        </unit>
        <unit id="135">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="135">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Use the latest version</pc>.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Use the latest version</pc>.</target>
          </segment>
        </unit>
        <unit id="136">
          <segment state="initial" id="136">
            <source xml:space="preserve">There are continual performance improvements made to the C++/CX compiler.</source>
            <target xml:space="preserve">There are continual performance improvements made to the C++/CX compiler.</target>
          </segment>
        </unit>
        <unit id="137">
          <segment state="initial" id="137">
            <source xml:space="preserve">Ensure your app is building using the latest toolset.</source>
            <target xml:space="preserve">Ensure your app is building using the latest toolset.</target>
          </segment>
        </unit>
        <unit id="138">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="138">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Disable RTTI (/GR-)</pc>.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Disable RTTI (/GR-)</pc>.</target>
          </segment>
        </unit>
        <unit id="139">
          <segment state="initial" id="139">
            <source xml:space="preserve">RTTI is on by default in the compiler so, unless your build environment switches it off, you’re probably using it.</source>
            <target xml:space="preserve">RTTI is on by default in the compiler so, unless your build environment switches it off, you’re probably using it.</target>
          </segment>
        </unit>
        <unit id="140">
          <segment state="initial" id="140">
            <source xml:space="preserve">RTTI has significant overhead, and unless your code has a deep dependency on it, you should turn it off.</source>
            <target xml:space="preserve">RTTI has significant overhead, and unless your code has a deep dependency on it, you should turn it off.</target>
          </segment>
        </unit>
        <unit id="141">
          <segment state="initial" id="141">
            <source xml:space="preserve">The XAML framework has no requirement that your code use RTTI.</source>
            <target xml:space="preserve">The XAML framework has no requirement that your code use RTTI.</target>
          </segment>
        </unit>
        <unit id="142">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="142">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Avoid heavy use of ppltasks</pc>.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Avoid heavy use of ppltasks</pc>.</target>
          </segment>
        </unit>
        <unit id="143">
          <segment state="initial" id="143">
            <source xml:space="preserve">Ppltasks are very convenient when calling async WinRT APIs, but they come with significant code size overhead.</source>
            <target xml:space="preserve">Ppltasks are very convenient when calling async WinRT APIs, but they come with significant code size overhead.</target>
          </segment>
        </unit>
        <unit id="144">
          <segment state="initial" id="144">
            <source xml:space="preserve">The C++/CX team is working on a language feature – await – that will provide much better performance.</source>
            <target xml:space="preserve">The C++/CX team is working on a language feature – await – that will provide much better performance.</target>
          </segment>
        </unit>
        <unit id="145">
          <segment state="initial" id="145">
            <source xml:space="preserve">In the meantime, balance your use of ppltasks in the hot paths of your code.</source>
            <target xml:space="preserve">In the meantime, balance your use of ppltasks in the hot paths of your code.</target>
          </segment>
        </unit>
        <unit id="146">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="146">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Avoid use of C++/CX in the “business logic” of your app</pc>.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Avoid use of C++/CX in the “business logic” of your app</pc>.</target>
          </segment>
        </unit>
        <unit id="147">
          <segment state="initial" id="147">
            <source xml:space="preserve">C++/CX is designed to be a convenient way to access WinRT APIs from C++ apps.</source>
            <target xml:space="preserve">C++/CX is designed to be a convenient way to access WinRT APIs from C++ apps.</target>
          </segment>
        </unit>
        <unit id="148">
          <segment state="initial" id="148">
            <source xml:space="preserve">It makes use of wrappers that have overhead.</source>
            <target xml:space="preserve">It makes use of wrappers that have overhead.</target>
          </segment>
        </unit>
        <unit id="149">
          <segment state="initial" id="149">
            <source xml:space="preserve">You should avoid C++/CX inside the business logic/model of your class, and reserve it for use at the boundaries between your code and WinRT.</source>
            <target xml:space="preserve">You should avoid C++/CX inside the business logic/model of your class, and reserve it for use at the boundaries between your code and WinRT.</target>
          </segment>
        </unit>
      </group>
    </group>
  </file>
</xliff>