<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-us" trgLang="de-de" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">67beb04cc87765a4c2edb249a61ba300cd9a7544</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <group id="101">
        <unit id="101">
          <segment state="initial" id="101">
            <source xml:space="preserve">XAML namescopes</source>
            <target xml:space="preserve">XAML namescopes</target>
          </segment>
        </unit>
        <unit id="102">
          <segment state="initial" id="102">
            <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
            <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
          </segment>
        </unit>
        <unit id="103">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="103">
            <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</source>
            <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</target>
          </segment>
        </unit>
        <unit id="104">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="104">
            <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML namescope</pc> stores relationships between the XAML-defined names of objects and their instance equivalents.</source>
            <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="2">XAML namescope</pc> stores relationships between the XAML-defined names of objects and their instance equivalents.</target>
          </segment>
        </unit>
        <unit id="105">
          <originalData>
            <data id="id1">&lt;em&gt;</data>
            <data id="id2">&lt;/em&gt;</data>
          </originalData>
          <segment state="initial" id="105">
            <source xml:space="preserve">This concept is similar to the wider meaning of the term <pc dataRefEnd="id2" dataRefStart="id1" id="2">namescope</pc> in other programming languages and technologies.</source>
            <target xml:space="preserve">This concept is similar to the wider meaning of the term <pc dataRefEnd="id2" dataRefStart="id1" id="2">namescope</pc> in other programming languages and technologies.</target>
          </segment>
        </unit>
        <unit id="106">
          <segment state="initial" id="106">
            <source xml:space="preserve">How XAML namescopes are defined</source>
            <target xml:space="preserve">How XAML namescopes are defined</target>
          </segment>
        </unit>
        <unit id="107">
          <segment state="initial" id="107">
            <source xml:space="preserve">Names in XAML namescopes enable user code to reference the objects that were initially declared in XAML.</source>
            <target xml:space="preserve">Names in XAML namescopes enable user code to reference the objects that were initially declared in XAML.</target>
          </segment>
        </unit>
        <unit id="108">
          <segment state="initial" id="108">
            <source xml:space="preserve">The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations.</source>
            <target xml:space="preserve">The internal result of parsing XAML is that the runtime creates a set of objects that retain some or all of the relationships these objects had in the XAML declarations.</target>
          </segment>
        </unit>
        <unit id="109">
          <segment state="initial" id="109">
            <source xml:space="preserve">These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.</source>
            <target xml:space="preserve">These relationships are maintained as specific object properties of the created objects, or are exposed to utility methods in the programming model APIs.</target>
          </segment>
        </unit>
        <unit id="110">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="110">
            <source xml:space="preserve">The most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated <pc dataRefEnd="id2" dataRefStart="id1" id="2">InitializeComponent</pc> method in the partial class templates.</source>
            <target xml:space="preserve">The most typical use of a name in a XAML namescope is as a direct reference to an object instance, which is enabled by the markup compile pass as a project build action, combined with a generated <pc dataRefEnd="id2" dataRefStart="id1" id="2">InitializeComponent</pc> method in the partial class templates.</target>
          </segment>
        </unit>
        <unit id="111">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="111">
            <source xml:space="preserve">You can also use the utility method <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> yourself at run time to return a reference to objects that were defined with a name in the XAML markup.</source>
            <target xml:space="preserve">You can also use the utility method <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> yourself at run time to return a reference to objects that were defined with a name in the XAML markup.</target>
          </segment>
        </unit>
        <unit id="112">
          <segment state="initial" id="112">
            <source xml:space="preserve">More about build actions and XAML</source>
            <target xml:space="preserve">More about build actions and XAML</target>
          </segment>
        </unit>
        <unit id="113">
          <segment state="initial" id="113">
            <source xml:space="preserve">What happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together.</source>
            <target xml:space="preserve">What happens technically is that the XAML itself undergoes a markup compiler pass at the same time that the XAML and the partial class it defines for code-behind are compiled together.</target>
          </segment>
        </unit>
        <unit id="114">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="114">
            <source xml:space="preserve">Each object element with a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Name</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">x:Name attribute</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> defined in the markup generates an internal field with a name that matches the XAML name.</source>
            <target xml:space="preserve">Each object element with a <pc dataRefEnd="id2" dataRefStart="id1" id="2">Name</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">x:Name attribute</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> defined in the markup generates an internal field with a name that matches the XAML name.</target>
          </segment>
        </unit>
        <unit id="115">
          <segment state="initial" id="115">
            <source xml:space="preserve">This field is initially empty.</source>
            <target xml:space="preserve">This field is initially empty.</target>
          </segment>
        </unit>
        <unit id="116">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="116">
            <source xml:space="preserve">Then the class generates an <pc dataRefEnd="id2" dataRefStart="id1" id="2">InitializeComponent</pc> method that is called only after all the XAML is loaded.</source>
            <target xml:space="preserve">Then the class generates an <pc dataRefEnd="id2" dataRefStart="id1" id="2">InitializeComponent</pc> method that is called only after all the XAML is loaded.</target>
          </segment>
        </unit>
        <unit id="117">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="117">
            <source xml:space="preserve">Within the <pc dataRefEnd="id2" dataRefStart="id1" id="2">InitializeComponent</pc> logic, each internal field is then populated with the <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> return value for the equivalent name string.</source>
            <target xml:space="preserve">Within the <pc dataRefEnd="id2" dataRefStart="id1" id="2">InitializeComponent</pc> logic, each internal field is then populated with the <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> return value for the equivalent name string.</target>
          </segment>
        </unit>
        <unit id="118">
          <segment state="initial" id="118">
            <source xml:space="preserve">You can observe this infrastructure for yourself by looking at the ".g" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation.</source>
            <target xml:space="preserve">You can observe this infrastructure for yourself by looking at the ".g" (generated) files that are created for each XAML page in the /obj subfolder of a Windows Runtime app project after compilation.</target>
          </segment>
        </unit>
        <unit id="119">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="119">
            <source xml:space="preserve">You can also see the fields and <pc dataRefEnd="id2" dataRefStart="id1" id="2">InitializeComponent</pc> method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.</source>
            <target xml:space="preserve">You can also see the fields and <pc dataRefEnd="id2" dataRefStart="id1" id="2">InitializeComponent</pc> method as members of your resulting assemblies if you reflect over them or otherwise examine their interface language contents.</target>
          </segment>
        </unit>
        <unit id="120">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="120">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  Specifically for Visual C++ component extensions (C++/CX) apps, a backing field for an <pc dataRefEnd="id4" dataRefStart="id3" id="3">x:Name</pc> reference is not created for the root element of a XAML file.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  Specifically for Visual C++ component extensions (C++/CX) apps, a backing field for an <pc dataRefEnd="id4" dataRefStart="id3" id="3">x:Name</pc> reference is not created for the root element of a XAML file.</target>
          </segment>
        </unit>
        <unit id="121">
          <segment state="initial" id="121">
            <source xml:space="preserve">If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal.</source>
            <target xml:space="preserve">If you need to reference the root object from C++/CX code-behind, use other APIs or tree traversal.</target>
          </segment>
        </unit>
        <unit id="122">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="122">
            <source xml:space="preserve">For example you can call <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> for a known named child element and then call <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Parent**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For example you can call <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> for a known named child element and then call <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Parent**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="123">
          <segment state="initial" id="123">
            <source xml:space="preserve">Creating objects at run time with XamlReader.Load</source>
            <target xml:space="preserve">Creating objects at run time with XamlReader.Load</target>
          </segment>
        </unit>
        <unit id="124">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="124">
            <source xml:space="preserve">XAML can be also be used as the string input for the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**XamlReader.Load**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method, which acts analogously to the initial XAML source parse operation.</source>
            <target xml:space="preserve">XAML can be also be used as the string input for the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**XamlReader.Load**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method, which acts analogously to the initial XAML source parse operation.</target>
          </segment>
        </unit>
        <unit id="125">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="125">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">XamlReader.Load</pc> creates a new disconnected tree of objects at run time.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">XamlReader.Load</pc> creates a new disconnected tree of objects at run time.</target>
          </segment>
        </unit>
        <unit id="126">
          <segment state="initial" id="126">
            <source xml:space="preserve">The disconnected tree can then be attached to some point on the main object tree.</source>
            <target xml:space="preserve">The disconnected tree can then be attached to some point on the main object tree.</target>
          </segment>
        </unit>
        <unit id="127">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;link&gt;</data>
            <data id="id4">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id9">&lt;link&gt;</data>
            <data id="id10">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="127">
            <source xml:space="preserve">You must explicitly connect your created object tree, either by adding it to a content property collection such as <pc dataRefEnd="id2" dataRefStart="id1" id="2">Children</pc>, or by setting some other property that takes an object value (for example, loading a new <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**ImageBrush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> for a <pc dataRefEnd="id10" dataRefStart="id9" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Fill**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> property value).</source>
            <target xml:space="preserve">You must explicitly connect your created object tree, either by adding it to a content property collection such as <pc dataRefEnd="id2" dataRefStart="id1" id="2">Children</pc>, or by setting some other property that takes an object value (for example, loading a new <pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**ImageBrush**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> for a <pc dataRefEnd="id10" dataRefStart="id9" id="6CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="6CapsExtId2">**Fill**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="6CapsExtId3"></pc></pc> property value).</target>
          </segment>
        </unit>
        <unit id="128">
          <segment state="initial" id="128">
            <source xml:space="preserve">XAML namescope implications of XamlReader.Load</source>
            <target xml:space="preserve">XAML namescope implications of XamlReader.Load</target>
          </segment>
        </unit>
        <unit id="129">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="129">
            <source xml:space="preserve">The preliminary XAML namescope defined by the new object tree created by <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**XamlReader.Load**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> evaluates any defined names in the provided XAML for uniqueness.</source>
            <target xml:space="preserve">The preliminary XAML namescope defined by the new object tree created by <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**XamlReader.Load**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> evaluates any defined names in the provided XAML for uniqueness.</target>
          </segment>
        </unit>
        <unit id="130">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="130">
            <source xml:space="preserve">If names in the provided XAML are not internally unique at this point, <pc dataRefEnd="id2" dataRefStart="id1" id="2">XamlReader.Load</pc> throws an exception.</source>
            <target xml:space="preserve">If names in the provided XAML are not internally unique at this point, <pc dataRefEnd="id2" dataRefStart="id1" id="2">XamlReader.Load</pc> throws an exception.</target>
          </segment>
        </unit>
        <unit id="131">
          <segment state="initial" id="131">
            <source xml:space="preserve">The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree.</source>
            <target xml:space="preserve">The disconnected object tree does not attempt to merge its XAML namescope with the main application XAML namescope, if or when it is connected to the main application object tree.</target>
          </segment>
        </unit>
        <unit id="132">
          <segment state="initial" id="132">
            <source xml:space="preserve">After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it.</source>
            <target xml:space="preserve">After you connect the trees, your app has a unified object tree, but that tree has discrete XAML namescopes within it.</target>
          </segment>
        </unit>
        <unit id="133">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="133">
            <source xml:space="preserve">The divisions occur at the connection points between objects, where you set some property to be the value returned from a <pc dataRefEnd="id2" dataRefStart="id1" id="2">XamlReader.Load</pc> call.</source>
            <target xml:space="preserve">The divisions occur at the connection points between objects, where you set some property to be the value returned from a <pc dataRefEnd="id2" dataRefStart="id1" id="2">XamlReader.Load</pc> call.</target>
          </segment>
        </unit>
        <unit id="134">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="134">
            <source xml:space="preserve">The complication of having discrete and disconnected XAML namescopes is that calls to the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method as well as direct managed object references no longer operate against a unified XAML namescope.</source>
            <target xml:space="preserve">The complication of having discrete and disconnected XAML namescopes is that calls to the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> method as well as direct managed object references no longer operate against a unified XAML namescope.</target>
          </segment>
        </unit>
        <unit id="135">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="135">
            <source xml:space="preserve">Instead, the particular object that <pc dataRefEnd="id2" dataRefStart="id1" id="2">FindName</pc> is called on implies the scope, with the scope being the XAML namescope that the calling object is within.</source>
            <target xml:space="preserve">Instead, the particular object that <pc dataRefEnd="id2" dataRefStart="id1" id="2">FindName</pc> is called on implies the scope, with the scope being the XAML namescope that the calling object is within.</target>
          </segment>
        </unit>
        <unit id="136">
          <segment state="initial" id="136">
            <source xml:space="preserve">In the direct managed object reference case, the scope is implied by the class where the code exists.</source>
            <target xml:space="preserve">In the direct managed object reference case, the scope is implied by the class where the code exists.</target>
          </segment>
        </unit>
        <unit id="137">
          <segment state="initial" id="137">
            <source xml:space="preserve">Typically, the code-behind for run-time interaction of a "page" of app content exists in the partial class that backs the root "page", and therefore the XAML namescope is the root XAML namescope.</source>
            <target xml:space="preserve">Typically, the code-behind for run-time interaction of a "page" of app content exists in the partial class that backs the root "page", and therefore the XAML namescope is the root XAML namescope.</target>
          </segment>
        </unit>
        <unit id="138">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="138">
            <source xml:space="preserve">If you call <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**XamlReader.Load**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">If you call <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> to get a named object in the root XAML namescope, the method will not find the objects from a discrete XAML namescope created by <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**XamlReader.Load**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="139">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="139">
            <source xml:space="preserve">Conversely, if you call <pc dataRefEnd="id2" dataRefStart="id1" id="2">FindName</pc> from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.</source>
            <target xml:space="preserve">Conversely, if you call <pc dataRefEnd="id2" dataRefStart="id1" id="2">FindName</pc> from an object obtained from out of the discrete XAML namescope, the method will not find named objects in the root XAML namescope.</target>
          </segment>
        </unit>
        <unit id="140">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="140">
            <source xml:space="preserve">This discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> call.</source>
            <target xml:space="preserve">This discrete XAML namescope issue only affects finding objects by name in XAML namescopes when using the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> call.</target>
          </segment>
        </unit>
        <unit id="141">
          <segment state="initial" id="141">
            <source xml:space="preserve">To get references to objects that are defined in a different XAML namescope, you can use several techniques:</source>
            <target xml:space="preserve">To get references to objects that are defined in a different XAML namescope, you can use several techniques:</target>
          </segment>
        </unit>
        <unit id="142">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="142">
            <source xml:space="preserve">Walk the entire tree in discrete steps with <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Parent**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and/or collection properties that are known to exist in your object tree structure (such as the collection returned by <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Panel.Children**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Walk the entire tree in discrete steps with <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Parent**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and/or collection properties that are known to exist in your object tree structure (such as the collection returned by <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Panel.Children**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="143">
          <segment state="initial" id="143">
            <source xml:space="preserve">If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed.</source>
            <target xml:space="preserve">If you are calling from a discrete XAML namescope and want the root XAML namescope, it is always easy to get a reference to the main window currently displayed.</target>
          </segment>
        </unit>
        <unit id="144">
          <originalData>
            <data id="id1">&lt;code&gt;</data>
            <data id="id2">&lt;/code&gt;</data>
          </originalData>
          <segment state="initial" id="144">
            <source xml:space="preserve">You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call <pc dataRefEnd="id2" dataRefStart="id1" id="2">Window.Current.Content</pc>.</source>
            <target xml:space="preserve">You can get the visual root (the root XAML element, also known as the content source) from the current application window in one line of code with the call <pc dataRefEnd="id2" dataRefStart="id1" id="2">Window.Current.Content</pc>.</target>
          </segment>
        </unit>
        <unit id="145">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="145">
            <source xml:space="preserve">You can then cast to <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FrameworkElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and call <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> from this scope.</source>
            <target xml:space="preserve">You can then cast to <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FrameworkElement**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and call <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> from this scope.</target>
          </segment>
        </unit>
        <unit id="146">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="146">
            <source xml:space="preserve">If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**XamlReader.Load**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and then added to the main object tree.</source>
            <target xml:space="preserve">If you are calling from the root XAML namescope and want an object within a discrete XAML namescope, the best thing to do is to plan ahead in your code and retain a reference to the object that was returned by <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**XamlReader.Load**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> and then added to the main object tree.</target>
          </segment>
        </unit>
        <unit id="147">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="147">
            <source xml:space="preserve">This object is now a valid object for calling <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> within the discrete XAML namescope.</source>
            <target xml:space="preserve">This object is now a valid object for calling <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> within the discrete XAML namescope.</target>
          </segment>
        </unit>
        <unit id="148">
          <segment state="initial" id="148">
            <source xml:space="preserve">You could keep this object available as a global variable or otherwise pass it by using method parameters.</source>
            <target xml:space="preserve">You could keep this object available as a global variable or otherwise pass it by using method parameters.</target>
          </segment>
        </unit>
        <unit id="149">
          <segment state="initial" id="149">
            <source xml:space="preserve">You can avoid names and XAML namescope considerations entirely by examining the visual tree.</source>
            <target xml:space="preserve">You can avoid names and XAML namescope considerations entirely by examining the visual tree.</target>
          </segment>
        </unit>
        <unit id="150">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="150">
            <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**VisualTreeHelper**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.</source>
            <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**VisualTreeHelper**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> API enables you to traverse the visual tree in terms of parent objects and child collections, based purely on position and index.</target>
          </segment>
        </unit>
        <unit id="151">
          <segment state="initial" id="151">
            <source xml:space="preserve">XAML namescopes in templates</source>
            <target xml:space="preserve">XAML namescopes in templates</target>
          </segment>
        </unit>
        <unit id="152">
          <segment state="initial" id="152">
            <source xml:space="preserve">Templates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level.</source>
            <target xml:space="preserve">Templates in XAML provide the ability to reuse and reapply content in a straightforward way, but templates might also include elements with names defined at the template level.</target>
          </segment>
        </unit>
        <unit id="153">
          <segment state="initial" id="153">
            <source xml:space="preserve">That same template might be used multiple times in a page.</source>
            <target xml:space="preserve">That same template might be used multiple times in a page.</target>
          </segment>
        </unit>
        <unit id="154">
          <segment state="initial" id="154">
            <source xml:space="preserve">For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied.</source>
            <target xml:space="preserve">For this reason, templates define their own XAML namescopes, independent of the containing page where the style or template is applied.</target>
          </segment>
        </unit>
        <unit id="155">
          <segment state="initial" id="155">
            <source xml:space="preserve">Consider this example:</source>
            <target xml:space="preserve">Consider this example:</target>
          </segment>
        </unit>
        <unit id="156">
          <segment state="initial" id="156">
            <source xml:space="preserve">Here, the same template is applied to two different controls.</source>
            <target xml:space="preserve">Here, the same template is applied to two different controls.</target>
          </segment>
        </unit>
        <unit id="157">
          <segment state="initial" id="157">
            <source xml:space="preserve">If templates did not have discrete XAML namescopes, the "MyTextBlock" name used in the template would cause a name collision.</source>
            <target xml:space="preserve">If templates did not have discrete XAML namescopes, the "MyTextBlock" name used in the template would cause a name collision.</target>
          </segment>
        </unit>
        <unit id="158">
          <segment state="initial" id="158">
            <source xml:space="preserve">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</source>
            <target xml:space="preserve">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</target>
          </segment>
        </unit>
        <unit id="159">
          <segment state="initial" id="159">
            <source xml:space="preserve">However, the root XAML namescope does not contain the name from either template.</source>
            <target xml:space="preserve">However, the root XAML namescope does not contain the name from either template.</target>
          </segment>
        </unit>
        <unit id="160">
          <segment state="initial" id="160">
            <source xml:space="preserve">Because of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique.</source>
            <target xml:space="preserve">Because of the separate XAML namescopes, finding named elements within a template from the scope of the page where the template is applied requires a different technique.</target>
          </segment>
        </unit>
        <unit id="161">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="161">
            <source xml:space="preserve">Rather than calling <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> on some object in the object tree, you first obtain the object that has the template applied, and then call <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**GetTemplateChild**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">Rather than calling <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**FindName**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> on some object in the object tree, you first obtain the object that has the template applied, and then call <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**GetTemplateChild**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="162">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="162">
            <source xml:space="preserve">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="2">GetTemplateChild</pc> method from your control implementation code.</source>
            <target xml:space="preserve">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <pc dataRefEnd="id2" dataRefStart="id1" id="2">GetTemplateChild</pc> method from your control implementation code.</target>
          </segment>
        </unit>
        <unit id="163">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="163">
            <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">GetTemplateChild</pc> method is protected, so only the control author has access to it.</source>
            <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2">GetTemplateChild</pc> method is protected, so only the control author has access to it.</target>
          </segment>
        </unit>
        <unit id="164">
          <segment state="initial" id="164">
            <source xml:space="preserve">Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class.</source>
            <target xml:space="preserve">Also, there are conventions that control authors should follow in order to name parts and template parts and report these as attribute values applied to the control class.</target>
          </segment>
        </unit>
        <unit id="165">
          <segment state="initial" id="165">
            <source xml:space="preserve">This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.</source>
            <target xml:space="preserve">This technique makes the names of important parts discoverable to control users who might wish to apply a different template, which would need to replace the named parts in order to maintain control functionality.</target>
          </segment>
        </unit>
        <unit id="166">
          <segment state="initial" id="166">
            <source xml:space="preserve">Related topics</source>
            <target xml:space="preserve">Related topics</target>
          </segment>
        </unit>
        <unit id="167">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="167">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">XAML overview</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">XAML overview</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
        <unit id="168">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="168">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">x:Name attribute</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">x:Name attribute</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
        <unit id="169">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="169">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">Quickstart: Control templates</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">Quickstart: Control templates</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
        <unit id="170">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="170">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">**XamlReader.Load**</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">**XamlReader.Load**</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
        <unit id="171">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="171">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">**FindName**</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1CapsExtId1">
								<pc dataRefEnd="id4" dataRefStart="id3" id="1CapsExtId2">**FindName**</pc>
								<pc dataRefEnd="id6" dataRefStart="id5" id="1CapsExtId3"></pc>
							</pc>
						</target>
          </segment>
        </unit>
      </group>
    </group>
  </file>
</xliff>