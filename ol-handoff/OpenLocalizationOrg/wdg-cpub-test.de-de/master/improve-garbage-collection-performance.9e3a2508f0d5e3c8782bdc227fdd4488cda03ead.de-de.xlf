<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-us" trgLang="de-de" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">048a75c84f26aa5538b036d1f5a8649f92aed5cb</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <group id="101">
        <unit id="101">
          <segment state="initial" id="101">
            <source xml:space="preserve">Improve garbage collection performance</source>
            <target xml:space="preserve">Improve garbage collection performance</target>
          </segment>
        </unit>
        <unit id="102">
          <segment state="initial" id="102">
            <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
            <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
          </segment>
        </unit>
        <unit id="103">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="103">
            <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</source>
            <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</target>
          </segment>
        </unit>
        <unit id="104">
          <segment state="initial" id="104">
            <source xml:space="preserve">Universal Windows Platform (UWP) apps written in C\# and Visual Basic get automatic memory management from the .NET garbage collector.</source>
            <target xml:space="preserve">Universal Windows Platform (UWP) apps written in C\# and Visual Basic get automatic memory management from the .NET garbage collector.</target>
          </segment>
        </unit>
        <unit id="105">
          <segment state="initial" id="105">
            <source xml:space="preserve">This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</source>
            <target xml:space="preserve">This section summarizes the behavior and performance best practices for the .NET garbage collector in UWP apps.</target>
          </segment>
        </unit>
        <unit id="106">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="106">
            <source xml:space="preserve">For more info on how the .NET garbage collector works and tools for debugging and analyzing garbage collector performance, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Garbage collection</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For more info on how the .NET garbage collector works and tools for debugging and analyzing garbage collector performance, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Garbage collection</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="107">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="107">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  Needing to intervene in the default behavior of the garbage collector is strongly indicative of general memory issues with your app.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  Needing to intervene in the default behavior of the garbage collector is strongly indicative of general memory issues with your app.</target>
          </segment>
        </unit>
        <unit id="108">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="108">
            <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Memory Usage Tool while debugging in Visual Studio 2015</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Memory Usage Tool while debugging in Visual Studio 2015</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="109">
          <segment state="initial" id="109">
            <source xml:space="preserve">This topic applies to C\# and Visual Basic only.</source>
            <target xml:space="preserve">This topic applies to C\# and Visual Basic only.</target>
          </segment>
        </unit>
        <unit id="110">
          <segment state="initial" id="110">
            <source xml:space="preserve">The garbage collector determines when to run by balancing the memory consumption of the managed heap with the amount of work a garbage collection needs to do.</source>
            <target xml:space="preserve">The garbage collector determines when to run by balancing the memory consumption of the managed heap with the amount of work a garbage collection needs to do.</target>
          </segment>
        </unit>
        <unit id="111">
          <segment state="initial" id="111">
            <source xml:space="preserve">One of the ways the garbage collector does this is by dividing the heap into generations and collecting only part of the heap most of the time.</source>
            <target xml:space="preserve">One of the ways the garbage collector does this is by dividing the heap into generations and collecting only part of the heap most of the time.</target>
          </segment>
        </unit>
        <unit id="112">
          <segment state="initial" id="112">
            <source xml:space="preserve">There are three generations in the managed heap:</source>
            <target xml:space="preserve">There are three generations in the managed heap:</target>
          </segment>
        </unit>
        <unit id="113">
          <segment state="initial" id="113">
            <source xml:space="preserve">Generation 0.</source>
            <target xml:space="preserve">Generation 0.</target>
          </segment>
        </unit>
        <unit id="114">
          <segment state="initial" id="114">
            <source xml:space="preserve">This generation contains newly allocated objects unless they are 85KB or larger, in which case they are part of the large object heap.</source>
            <target xml:space="preserve">This generation contains newly allocated objects unless they are 85KB or larger, in which case they are part of the large object heap.</target>
          </segment>
        </unit>
        <unit id="115">
          <segment state="initial" id="115">
            <source xml:space="preserve">The large object heap is collected with generation 2 collections.</source>
            <target xml:space="preserve">The large object heap is collected with generation 2 collections.</target>
          </segment>
        </unit>
        <unit id="116">
          <segment state="initial" id="116">
            <source xml:space="preserve">Generation 0 collections are the most frequently occurring type of collection and clean up short-lived objects such as local variables.</source>
            <target xml:space="preserve">Generation 0 collections are the most frequently occurring type of collection and clean up short-lived objects such as local variables.</target>
          </segment>
        </unit>
        <unit id="117">
          <segment state="initial" id="117">
            <source xml:space="preserve">Generation 1.</source>
            <target xml:space="preserve">Generation 1.</target>
          </segment>
        </unit>
        <unit id="118">
          <segment state="initial" id="118">
            <source xml:space="preserve">This generation contains objects that have survived generation 0 collections.</source>
            <target xml:space="preserve">This generation contains objects that have survived generation 0 collections.</target>
          </segment>
        </unit>
        <unit id="119">
          <segment state="initial" id="119">
            <source xml:space="preserve">It serves as a buffer between generation 0 and generation 2.</source>
            <target xml:space="preserve">It serves as a buffer between generation 0 and generation 2.</target>
          </segment>
        </unit>
        <unit id="120">
          <segment state="initial" id="120">
            <source xml:space="preserve">Generation 1 collections occur less frequently than generation 0 collections and clean up temporary objects that were active during previous generation 0 collections.</source>
            <target xml:space="preserve">Generation 1 collections occur less frequently than generation 0 collections and clean up temporary objects that were active during previous generation 0 collections.</target>
          </segment>
        </unit>
        <unit id="121">
          <segment state="initial" id="121">
            <source xml:space="preserve">A generation 1 collection also collects generation 0.</source>
            <target xml:space="preserve">A generation 1 collection also collects generation 0.</target>
          </segment>
        </unit>
        <unit id="122">
          <segment state="initial" id="122">
            <source xml:space="preserve">Generation 2.</source>
            <target xml:space="preserve">Generation 2.</target>
          </segment>
        </unit>
        <unit id="123">
          <segment state="initial" id="123">
            <source xml:space="preserve">This generation contains long-lived objects that have survived generation 0 and generation 1 collections.</source>
            <target xml:space="preserve">This generation contains long-lived objects that have survived generation 0 and generation 1 collections.</target>
          </segment>
        </unit>
        <unit id="124">
          <segment state="initial" id="124">
            <source xml:space="preserve">Generation 2 collections are the least frequent and collect the entire managed heap, including the large object heap which contains objects that are 85KB or larger.</source>
            <target xml:space="preserve">Generation 2 collections are the least frequent and collect the entire managed heap, including the large object heap which contains objects that are 85KB or larger.</target>
          </segment>
        </unit>
        <unit id="125">
          <segment state="initial" id="125">
            <source xml:space="preserve">You can measure the performance of the garbage collector in 2 aspects: the time it takes to do the garbage collection, and the memory consumption of the managed heap.</source>
            <target xml:space="preserve">You can measure the performance of the garbage collector in 2 aspects: the time it takes to do the garbage collection, and the memory consumption of the managed heap.</target>
          </segment>
        </unit>
        <unit id="126">
          <segment state="initial" id="126">
            <source xml:space="preserve">If you have a small app with a heap size less than 100MB then focus on reducing memory consumption.</source>
            <target xml:space="preserve">If you have a small app with a heap size less than 100MB then focus on reducing memory consumption.</target>
          </segment>
        </unit>
        <unit id="127">
          <segment state="initial" id="127">
            <source xml:space="preserve">If you have an app with a managed heap larger than 100MB then focus on reducing the garbage collection time only.</source>
            <target xml:space="preserve">If you have an app with a managed heap larger than 100MB then focus on reducing the garbage collection time only.</target>
          </segment>
        </unit>
        <unit id="128">
          <segment state="initial" id="128">
            <source xml:space="preserve">Here's how you can help the .NET garbage collector achieve better performance.</source>
            <target xml:space="preserve">Here's how you can help the .NET garbage collector achieve better performance.</target>
          </segment>
        </unit>
        <unit id="129">
          <segment state="initial" id="129">
            <source xml:space="preserve">Reduce memory consumption</source>
            <target xml:space="preserve">Reduce memory consumption</target>
          </segment>
        </unit>
        <unit id="130">
          <segment state="initial" id="130">
            <source xml:space="preserve">Release references</source>
            <target xml:space="preserve">Release references</target>
          </segment>
        </unit>
        <unit id="131">
          <segment state="initial" id="131">
            <source xml:space="preserve">A reference to an object in your app prevents that object, and all of the objects it references, from being collected.</source>
            <target xml:space="preserve">A reference to an object in your app prevents that object, and all of the objects it references, from being collected.</target>
          </segment>
        </unit>
        <unit id="132">
          <segment state="initial" id="132">
            <source xml:space="preserve">The .NET compiler does a good job of detecting when a variable is no longer in use so objects held onto by that variable will be eligible for collection.</source>
            <target xml:space="preserve">The .NET compiler does a good job of detecting when a variable is no longer in use so objects held onto by that variable will be eligible for collection.</target>
          </segment>
        </unit>
        <unit id="133">
          <segment state="initial" id="133">
            <source xml:space="preserve">But in some cases it may not be obvious that some objects have a reference to other objects because part of the object graph might be owned by libraries your app uses.</source>
            <target xml:space="preserve">But in some cases it may not be obvious that some objects have a reference to other objects because part of the object graph might be owned by libraries your app uses.</target>
          </segment>
        </unit>
        <unit id="134">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="134">
            <source xml:space="preserve">To learn about the tools and techniques to find out which objects survive a garbage collection, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Garbage collection and performance</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">To learn about the tools and techniques to find out which objects survive a garbage collection, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Garbage collection and performance</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="135">
          <segment state="initial" id="135">
            <source xml:space="preserve">Induce a garbage collection if it’s useful</source>
            <target xml:space="preserve">Induce a garbage collection if it’s useful</target>
          </segment>
        </unit>
        <unit id="136">
          <segment state="initial" id="136">
            <source xml:space="preserve">Induce a garbage collection only after you have measured your app's performance and have determined that inducing a collection will improve its performance.</source>
            <target xml:space="preserve">Induce a garbage collection only after you have measured your app's performance and have determined that inducing a collection will improve its performance.</target>
          </segment>
        </unit>
        <unit id="137">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="137">
            <source xml:space="preserve">You can induce a garbage collection of a generation by calling [<pc dataRefEnd="id2" dataRefStart="id1" id="2">GC.Collect(n)</pc>]https://msdn.microsoft.com/en-us/library/windows/apps/xaml/y46kxc5e.aspx), where n is the generation you want to collect (0, 1, or 2).</source>
            <target xml:space="preserve">You can induce a garbage collection of a generation by calling [<pc dataRefEnd="id2" dataRefStart="id1" id="2">GC.Collect(n)</pc>]https://msdn.microsoft.com/en-us/library/windows/apps/xaml/y46kxc5e.aspx), where n is the generation you want to collect (0, 1, or 2).</target>
          </segment>
        </unit>
        <unit id="138">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="138">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  We recommend that you don't force a garbage collection in your app because the garbage collector uses many heuristics to determine the best time to perform a collection, and forcing a collection is in many cases an unnecessary use of the CPU.</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>  We recommend that you don't force a garbage collection in your app because the garbage collector uses many heuristics to determine the best time to perform a collection, and forcing a collection is in many cases an unnecessary use of the CPU.</target>
          </segment>
        </unit>
        <unit id="139">
          <segment state="initial" id="139">
            <source xml:space="preserve">But if you know that you have a large number of objects in your app that are no longer used and you want to return this memory to the system, then it may be appropriate to force a garbage collection.</source>
            <target xml:space="preserve">But if you know that you have a large number of objects in your app that are no longer used and you want to return this memory to the system, then it may be appropriate to force a garbage collection.</target>
          </segment>
        </unit>
        <unit id="140">
          <segment state="initial" id="140">
            <source xml:space="preserve">For example, you can induce a collection at the end of a loading sequence in a game to free up memory before gameplay starts.</source>
            <target xml:space="preserve">For example, you can induce a collection at the end of a loading sequence in a game to free up memory before gameplay starts.</target>
          </segment>
        </unit>
        <unit id="141">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;strong&gt;</data>
            <data id="id8">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="141">
            <source xml:space="preserve">To avoid inadvertently inducing too many garbage collections, you can set the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**GCCollectionMode**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> to <pc dataRefEnd="id8" dataRefStart="id7" id="4">Optimized</pc>.</source>
            <target xml:space="preserve">To avoid inadvertently inducing too many garbage collections, you can set the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**GCCollectionMode**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> to <pc dataRefEnd="id8" dataRefStart="id7" id="4">Optimized</pc>.</target>
          </segment>
        </unit>
        <unit id="142">
          <segment state="initial" id="142">
            <source xml:space="preserve">This instructs the garbage collector to start a collection only if it determines that the collection would be productive enough to be justified.</source>
            <target xml:space="preserve">This instructs the garbage collector to start a collection only if it determines that the collection would be productive enough to be justified.</target>
          </segment>
        </unit>
        <unit id="143">
          <segment state="initial" id="143">
            <source xml:space="preserve">Reduce garbage collection time</source>
            <target xml:space="preserve">Reduce garbage collection time</target>
          </segment>
        </unit>
        <unit id="144">
          <segment state="initial" id="144">
            <source xml:space="preserve">This section applies if you've analyzed your app and observed large garbage collection times.</source>
            <target xml:space="preserve">This section applies if you've analyzed your app and observed large garbage collection times.</target>
          </segment>
        </unit>
        <unit id="145">
          <segment state="initial" id="145">
            <source xml:space="preserve">Garbage collection-related pause times include: the time it takes to run a single garbage collection pass; and the total time your app spends doing garbage collections.</source>
            <target xml:space="preserve">Garbage collection-related pause times include: the time it takes to run a single garbage collection pass; and the total time your app spends doing garbage collections.</target>
          </segment>
        </unit>
        <unit id="146">
          <segment state="initial" id="146">
            <source xml:space="preserve">The amount of time it takes to do a collection depends on how much live data the collector has to analyze.</source>
            <target xml:space="preserve">The amount of time it takes to do a collection depends on how much live data the collector has to analyze.</target>
          </segment>
        </unit>
        <unit id="147">
          <segment state="initial" id="147">
            <source xml:space="preserve">Generation 0 and generation 1 are bounded in size, but generation 2 continues to grow as more long-lived objects are active in your app.</source>
            <target xml:space="preserve">Generation 0 and generation 1 are bounded in size, but generation 2 continues to grow as more long-lived objects are active in your app.</target>
          </segment>
        </unit>
        <unit id="148">
          <segment state="initial" id="148">
            <source xml:space="preserve">This means that the collection times for generation 0 and generation 1 are bounded, while generation 2 collections can take longer.</source>
            <target xml:space="preserve">This means that the collection times for generation 0 and generation 1 are bounded, while generation 2 collections can take longer.</target>
          </segment>
        </unit>
        <unit id="149">
          <segment state="initial" id="149">
            <source xml:space="preserve">How often garbage collections run depends mostly on how much memory you allocate, because a garbage collection frees up memory to satisfy allocation requests.</source>
            <target xml:space="preserve">How often garbage collections run depends mostly on how much memory you allocate, because a garbage collection frees up memory to satisfy allocation requests.</target>
          </segment>
        </unit>
        <unit id="150">
          <segment state="initial" id="150">
            <source xml:space="preserve">The garbage collector occasionally pauses your app to perform work, but doesn't necessarily pause your app the entire time it is doing a collection.</source>
            <target xml:space="preserve">The garbage collector occasionally pauses your app to perform work, but doesn't necessarily pause your app the entire time it is doing a collection.</target>
          </segment>
        </unit>
        <unit id="151">
          <segment state="initial" id="151">
            <source xml:space="preserve">Pause times are usually not user-perceivable in your app, especially for generation 0 and generation 1 collections.</source>
            <target xml:space="preserve">Pause times are usually not user-perceivable in your app, especially for generation 0 and generation 1 collections.</target>
          </segment>
        </unit>
        <unit id="152">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="152">
            <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Background garbage collection</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> feature of the .NET garbage collector allows Generation 2 collections to be performed concurrently while your app is running and will only pause your app for short periods of time.</source>
            <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">Background garbage collection</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> feature of the .NET garbage collector allows Generation 2 collections to be performed concurrently while your app is running and will only pause your app for short periods of time.</target>
          </segment>
        </unit>
        <unit id="153">
          <segment state="initial" id="153">
            <source xml:space="preserve">But it is not always possible to do a Generation 2 collection as a background collection.</source>
            <target xml:space="preserve">But it is not always possible to do a Generation 2 collection as a background collection.</target>
          </segment>
        </unit>
        <unit id="154">
          <segment state="initial" id="154">
            <source xml:space="preserve">In that case, the pause can be user-perceivable if you have a large enough heap (more than 100MB).</source>
            <target xml:space="preserve">In that case, the pause can be user-perceivable if you have a large enough heap (more than 100MB).</target>
          </segment>
        </unit>
        <unit id="155">
          <segment state="initial" id="155">
            <source xml:space="preserve">Frequent garbage collections can contribute to increased CPU (and therefore power) consumption, longer loading times, or decreased frame rates in your application.</source>
            <target xml:space="preserve">Frequent garbage collections can contribute to increased CPU (and therefore power) consumption, longer loading times, or decreased frame rates in your application.</target>
          </segment>
        </unit>
        <unit id="156">
          <segment state="initial" id="156">
            <source xml:space="preserve">Below are some techniques you can use to reduce garbage collection time and collection-related pauses in your managed UWP app.</source>
            <target xml:space="preserve">Below are some techniques you can use to reduce garbage collection time and collection-related pauses in your managed UWP app.</target>
          </segment>
        </unit>
        <unit id="157">
          <segment state="initial" id="157">
            <source xml:space="preserve">Reduce memory allocations</source>
            <target xml:space="preserve">Reduce memory allocations</target>
          </segment>
        </unit>
        <unit id="158">
          <segment state="initial" id="158">
            <source xml:space="preserve">If you don’t allocate any objects then the garbage collector doesn’t run unless there is a low memory condition in the system.</source>
            <target xml:space="preserve">If you don’t allocate any objects then the garbage collector doesn’t run unless there is a low memory condition in the system.</target>
          </segment>
        </unit>
        <unit id="159">
          <segment state="initial" id="159">
            <source xml:space="preserve">Reducing the amount of memory you allocate directly translates to less frequent garbage collections.</source>
            <target xml:space="preserve">Reducing the amount of memory you allocate directly translates to less frequent garbage collections.</target>
          </segment>
        </unit>
        <unit id="160">
          <segment state="initial" id="160">
            <source xml:space="preserve">If in some sections of your app pauses are completely undesirable, then you can pre-allocate the necessary objects beforehand during a less performance-critical time.</source>
            <target xml:space="preserve">If in some sections of your app pauses are completely undesirable, then you can pre-allocate the necessary objects beforehand during a less performance-critical time.</target>
          </segment>
        </unit>
        <unit id="161">
          <segment state="initial" id="161">
            <source xml:space="preserve">For example, a game might allocate all of the objects needed for gameplay during the loading screen of a level and not make any allocations during gameplay.</source>
            <target xml:space="preserve">For example, a game might allocate all of the objects needed for gameplay during the loading screen of a level and not make any allocations during gameplay.</target>
          </segment>
        </unit>
        <unit id="162">
          <segment state="initial" id="162">
            <source xml:space="preserve">This avoids pauses while the user is playing the game and can result in a higher and more consistent frame rate.</source>
            <target xml:space="preserve">This avoids pauses while the user is playing the game and can result in a higher and more consistent frame rate.</target>
          </segment>
        </unit>
        <unit id="163">
          <segment state="initial" id="163">
            <source xml:space="preserve">Reduce generation 2 collections by avoiding objects with a medium-length lifetime</source>
            <target xml:space="preserve">Reduce generation 2 collections by avoiding objects with a medium-length lifetime</target>
          </segment>
        </unit>
        <unit id="164">
          <segment state="initial" id="164">
            <source xml:space="preserve">Generational garbage collections perform best when you have really short-lived and/or really long-lived objects in your app.</source>
            <target xml:space="preserve">Generational garbage collections perform best when you have really short-lived and/or really long-lived objects in your app.</target>
          </segment>
        </unit>
        <unit id="165">
          <segment state="initial" id="165">
            <source xml:space="preserve">Short lived objects are collected in the cheaper generation 0 and generation 1 collections, and objects that are long-lived get promoted to generation 2, which is collected infrequently.</source>
            <target xml:space="preserve">Short lived objects are collected in the cheaper generation 0 and generation 1 collections, and objects that are long-lived get promoted to generation 2, which is collected infrequently.</target>
          </segment>
        </unit>
        <unit id="166">
          <segment state="initial" id="166">
            <source xml:space="preserve">Long-lived objects are those that are in use for the entire duration of your app, or during a significant period of your app, such as during a specific page or game level.</source>
            <target xml:space="preserve">Long-lived objects are those that are in use for the entire duration of your app, or during a significant period of your app, such as during a specific page or game level.</target>
          </segment>
        </unit>
        <unit id="167">
          <segment state="initial" id="167">
            <source xml:space="preserve">If you frequently create objects that have a temporary lifetime but live long enough to be promoted to generation 2, then more of the expensive generation 2 collections happen.</source>
            <target xml:space="preserve">If you frequently create objects that have a temporary lifetime but live long enough to be promoted to generation 2, then more of the expensive generation 2 collections happen.</target>
          </segment>
        </unit>
        <unit id="168">
          <segment state="initial" id="168">
            <source xml:space="preserve">You may be able to reduce generation 2 collections by recycling existing objects or releasing objects more quickly.</source>
            <target xml:space="preserve">You may be able to reduce generation 2 collections by recycling existing objects or releasing objects more quickly.</target>
          </segment>
        </unit>
        <unit id="169">
          <segment state="initial" id="169">
            <source xml:space="preserve">A common example of objects with medium-term lifetime is objects that are used for displaying items in a list that a user scrolls through.</source>
            <target xml:space="preserve">A common example of objects with medium-term lifetime is objects that are used for displaying items in a list that a user scrolls through.</target>
          </segment>
        </unit>
        <unit id="170">
          <segment state="initial" id="170">
            <source xml:space="preserve">If objects are created when items in the list are scrolled into view, and are no longer referenced as items in the list are scrolled out of view, then your app typically has a large number of generation 2 collections.</source>
            <target xml:space="preserve">If objects are created when items in the list are scrolled into view, and are no longer referenced as items in the list are scrolled out of view, then your app typically has a large number of generation 2 collections.</target>
          </segment>
        </unit>
        <unit id="171">
          <segment state="initial" id="171">
            <source xml:space="preserve">In situations like this you can pre-allocate and reuse a set of objects for the data that is actively shown to the user, and use short-lived objects to load info as items in the list come into view.</source>
            <target xml:space="preserve">In situations like this you can pre-allocate and reuse a set of objects for the data that is actively shown to the user, and use short-lived objects to load info as items in the list come into view.</target>
          </segment>
        </unit>
        <unit id="172">
          <segment state="initial" id="172">
            <source xml:space="preserve">Reduce generation 2 collections by avoiding large-sized objects with short lifetimes</source>
            <target xml:space="preserve">Reduce generation 2 collections by avoiding large-sized objects with short lifetimes</target>
          </segment>
        </unit>
        <unit id="173">
          <segment state="initial" id="173">
            <source xml:space="preserve">Any object that is 85KB or larger is allocated on the large object heap (LOH) and gets collected as part of generation 2.</source>
            <target xml:space="preserve">Any object that is 85KB or larger is allocated on the large object heap (LOH) and gets collected as part of generation 2.</target>
          </segment>
        </unit>
        <unit id="174">
          <segment state="initial" id="174">
            <source xml:space="preserve">If you have temporary variables, such as buffers, that are greater than 85KB, then a generation 2 collection cleans them up.</source>
            <target xml:space="preserve">If you have temporary variables, such as buffers, that are greater than 85KB, then a generation 2 collection cleans them up.</target>
          </segment>
        </unit>
        <unit id="175">
          <segment state="initial" id="175">
            <source xml:space="preserve">Limiting temporary variables to less than 85KB reduces the number of generation 2 collections in your app.</source>
            <target xml:space="preserve">Limiting temporary variables to less than 85KB reduces the number of generation 2 collections in your app.</target>
          </segment>
        </unit>
        <unit id="176">
          <segment state="initial" id="176">
            <source xml:space="preserve">One common technique is to create a buffer pool and reuse objects from the pool to avoid large temporary allocations.</source>
            <target xml:space="preserve">One common technique is to create a buffer pool and reuse objects from the pool to avoid large temporary allocations.</target>
          </segment>
        </unit>
        <unit id="177">
          <segment state="initial" id="177">
            <source xml:space="preserve">Avoid reference-rich objects</source>
            <target xml:space="preserve">Avoid reference-rich objects</target>
          </segment>
        </unit>
        <unit id="178">
          <segment state="initial" id="178">
            <source xml:space="preserve">The garbage collector determines which objects are live by following references between objects, starting from roots in your app.</source>
            <target xml:space="preserve">The garbage collector determines which objects are live by following references between objects, starting from roots in your app.</target>
          </segment>
        </unit>
        <unit id="179">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="179">
            <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">What happens during a garbage collection</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</source>
            <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">What happens during a garbage collection</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>.</target>
          </segment>
        </unit>
        <unit id="180">
          <segment state="initial" id="180">
            <source xml:space="preserve">If an object contains many references, then there is more work for the garbage collector to do.</source>
            <target xml:space="preserve">If an object contains many references, then there is more work for the garbage collector to do.</target>
          </segment>
        </unit>
        <unit id="181">
          <segment state="initial" id="181">
            <source xml:space="preserve">A common technique (especially with large objects) is to convert reference rich objects into objects with no references (e.g., instead of storing a reference, store an index).</source>
            <target xml:space="preserve">A common technique (especially with large objects) is to convert reference rich objects into objects with no references (e.g., instead of storing a reference, store an index).</target>
          </segment>
        </unit>
        <unit id="182">
          <segment state="initial" id="182">
            <source xml:space="preserve">Of course this technique works only when it is logically possible to do so.</source>
            <target xml:space="preserve">Of course this technique works only when it is logically possible to do so.</target>
          </segment>
        </unit>
        <unit id="183">
          <segment state="initial" id="183">
            <source xml:space="preserve">Replacing object references with indexes can be a disruptive and complicated change to your app and is most effective for large objects with a large number of references.</source>
            <target xml:space="preserve">Replacing object references with indexes can be a disruptive and complicated change to your app and is most effective for large objects with a large number of references.</target>
          </segment>
        </unit>
        <unit id="184">
          <segment state="initial" id="184">
            <source xml:space="preserve">Do this only if you are noticing large garbage collection times in your app related to reference-heavy objects.</source>
            <target xml:space="preserve">Do this only if you are noticing large garbage collection times in your app related to reference-heavy objects.</target>
          </segment>
        </unit>
      </group>
    </group>
  </file>
</xliff>