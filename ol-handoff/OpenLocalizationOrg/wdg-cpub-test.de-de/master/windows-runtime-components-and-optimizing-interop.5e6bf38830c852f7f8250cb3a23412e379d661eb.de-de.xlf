<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-us" trgLang="de-de" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">57cb81d8450d3d71b421ae77536872d244b3e509</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <group id="101">
        <unit id="101">
          <segment state="initial" id="101">
            <source xml:space="preserve">Universal Windows Platform Components and optimizing interop</source>
            <target xml:space="preserve">Universal Windows Platform Components and optimizing interop</target>
          </segment>
        </unit>
        <unit id="102">
          <segment state="initial" id="102">
            <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
            <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
          </segment>
        </unit>
        <unit id="103">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="103">
            <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</source>
            <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">archive</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> \]</target>
          </segment>
        </unit>
        <unit id="104">
          <segment state="initial" id="104">
            <source xml:space="preserve">Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.</source>
            <target xml:space="preserve">Create Universal Windows Platform (UWP) apps that use UWP Components and interop between native and managed types while avoiding interop performance issues.</target>
          </segment>
        </unit>
        <unit id="105">
          <segment state="initial" id="105">
            <source xml:space="preserve">Best practices for interoperability with UWP Components</source>
            <target xml:space="preserve">Best practices for interoperability with UWP Components</target>
          </segment>
        </unit>
        <unit id="106">
          <segment state="initial" id="106">
            <source xml:space="preserve">If you are not careful, using UWP Components can have a large impact on your app performance.</source>
            <target xml:space="preserve">If you are not careful, using UWP Components can have a large impact on your app performance.</target>
          </segment>
        </unit>
        <unit id="107">
          <segment state="initial" id="107">
            <source xml:space="preserve">This section discusses how to get good performance when your app uses UWP Components.</source>
            <target xml:space="preserve">This section discusses how to get good performance when your app uses UWP Components.</target>
          </segment>
        </unit>
        <unit id="108">
          <segment state="initial" id="108">
            <source xml:space="preserve">Introduction</source>
            <target xml:space="preserve">Introduction</target>
          </segment>
        </unit>
        <unit id="109">
          <segment state="initial" id="109">
            <source xml:space="preserve">Interoperability can have a big impact on performance and you might be using it without even realizing that you are.</source>
            <target xml:space="preserve">Interoperability can have a big impact on performance and you might be using it without even realizing that you are.</target>
          </segment>
        </unit>
        <unit id="110">
          <segment state="initial" id="110">
            <source xml:space="preserve">The UWP handles a lot of the interoperability for you so that you can be more productive and reuse code that was written in other languages.</source>
            <target xml:space="preserve">The UWP handles a lot of the interoperability for you so that you can be more productive and reuse code that was written in other languages.</target>
          </segment>
        </unit>
        <unit id="111">
          <segment state="initial" id="111">
            <source xml:space="preserve">We encourage you to take advantage of what the UWP does for you, but be aware that it can impact performance.</source>
            <target xml:space="preserve">We encourage you to take advantage of what the UWP does for you, but be aware that it can impact performance.</target>
          </segment>
        </unit>
        <unit id="112">
          <segment state="initial" id="112">
            <source xml:space="preserve">This section discusses things you can do to lessen the impact that interoperability has on your app's performance.</source>
            <target xml:space="preserve">This section discusses things you can do to lessen the impact that interoperability has on your app's performance.</target>
          </segment>
        </unit>
        <unit id="113">
          <segment state="initial" id="113">
            <source xml:space="preserve">The UWP has a library of types that are accessible from any language that can write a UWP app.</source>
            <target xml:space="preserve">The UWP has a library of types that are accessible from any language that can write a UWP app.</target>
          </segment>
        </unit>
        <unit id="114">
          <segment state="initial" id="114">
            <source xml:space="preserve">You use the UWP types in C\# or Microsoft Visual Basic the same way you use .NET objects.</source>
            <target xml:space="preserve">You use the UWP types in C\# or Microsoft Visual Basic the same way you use .NET objects.</target>
          </segment>
        </unit>
        <unit id="115">
          <segment state="initial" id="115">
            <source xml:space="preserve">You don't need to make platform invoke method calls to access the UWP components.</source>
            <target xml:space="preserve">You don't need to make platform invoke method calls to access the UWP components.</target>
          </segment>
        </unit>
        <unit id="116">
          <segment state="initial" id="116">
            <source xml:space="preserve">This makes writing your apps much less complex, but it is important to realize that there might be more interoperability occurring than you expect.</source>
            <target xml:space="preserve">This makes writing your apps much less complex, but it is important to realize that there might be more interoperability occurring than you expect.</target>
          </segment>
        </unit>
        <unit id="117">
          <segment state="initial" id="117">
            <source xml:space="preserve">If a UWP component is written in a language other than C\# or Visual Basic, you cross interoperability boundaries when you use that component.</source>
            <target xml:space="preserve">If a UWP component is written in a language other than C\# or Visual Basic, you cross interoperability boundaries when you use that component.</target>
          </segment>
        </unit>
        <unit id="118">
          <segment state="initial" id="118">
            <source xml:space="preserve">Crossing interoperability boundaries can impact the performance of an app.</source>
            <target xml:space="preserve">Crossing interoperability boundaries can impact the performance of an app.</target>
          </segment>
        </unit>
        <unit id="119">
          <segment state="initial" id="119">
            <source xml:space="preserve">When you develop a UWP app in C\# or Visual Basic, the two most common set of APIs that you use are the UWP APIs and the .NET APIs for UWP apps.</source>
            <target xml:space="preserve">When you develop a UWP app in C\# or Visual Basic, the two most common set of APIs that you use are the UWP APIs and the .NET APIs for UWP apps.</target>
          </segment>
        </unit>
        <unit id="120">
          <segment state="initial" id="120">
            <source xml:space="preserve">In general, types that are defined in the UWP are in namespaces that begin with "Windows."</source>
            <target xml:space="preserve">In general, types that are defined in the UWP are in namespaces that begin with "Windows."</target>
          </segment>
        </unit>
        <unit id="121">
          <segment state="initial" id="121">
            <source xml:space="preserve">and .NET types are in namespaces that begin with "System."</source>
            <target xml:space="preserve">and .NET types are in namespaces that begin with "System."</target>
          </segment>
        </unit>
        <unit id="122">
          <segment state="initial" id="122">
            <source xml:space="preserve">There are exceptions, though.</source>
            <target xml:space="preserve">There are exceptions, though.</target>
          </segment>
        </unit>
        <unit id="123">
          <segment state="initial" id="123">
            <source xml:space="preserve">The types in .NET for UWP apps do not require interoperability when they are used.</source>
            <target xml:space="preserve">The types in .NET for UWP apps do not require interoperability when they are used.</target>
          </segment>
        </unit>
        <unit id="124">
          <segment state="initial" id="124">
            <source xml:space="preserve">If you find that you have bad performance in an area that uses UWP, you might be able to use .NET for UWP apps instead to get better performance.</source>
            <target xml:space="preserve">If you find that you have bad performance in an area that uses UWP, you might be able to use .NET for UWP apps instead to get better performance.</target>
          </segment>
        </unit>
        <unit id="125">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="125">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Note</pc>
						</target>
          </segment>
        </unit>
        <unit id="126">
          <segment state="initial" id="126">
            <source xml:space="preserve">Most of the UWP components that ship with Windows 10 are implemented in C++ so you cross interoperability boundaries when you use them from C\# or Visual Basic.</source>
            <target xml:space="preserve">Most of the UWP components that ship with Windows 10 are implemented in C++ so you cross interoperability boundaries when you use them from C\# or Visual Basic.</target>
          </segment>
        </unit>
        <unit id="127">
          <segment state="initial" id="127">
            <source xml:space="preserve">As always, make sure to measure your app to see if using UWP components affects your app's performance before you invest in making changes to your code.</source>
            <target xml:space="preserve">As always, make sure to measure your app to see if using UWP components affects your app's performance before you invest in making changes to your code.</target>
          </segment>
        </unit>
        <unit id="128">
          <segment state="initial" id="128">
            <source xml:space="preserve">In this topic, when we say "UWP components", we mean components that are written in a language other than C\# or Visual Basic.</source>
            <target xml:space="preserve">In this topic, when we say "UWP components", we mean components that are written in a language other than C\# or Visual Basic.</target>
          </segment>
        </unit>
        <unit id="129">
          <segment state="initial" id="129">
            <source xml:space="preserve">Each time you access a property or call a method on a UWP component, an interoperability cost is incurred.</source>
            <target xml:space="preserve">Each time you access a property or call a method on a UWP component, an interoperability cost is incurred.</target>
          </segment>
        </unit>
        <unit id="130">
          <segment state="initial" id="130">
            <source xml:space="preserve">In fact, creating a UWP component is more costly than creating a .NET object.</source>
            <target xml:space="preserve">In fact, creating a UWP component is more costly than creating a .NET object.</target>
          </segment>
        </unit>
        <unit id="131">
          <segment state="initial" id="131">
            <source xml:space="preserve">The reasons for this are that the UWP must execute code that transitions from your app's language to the component's language.</source>
            <target xml:space="preserve">The reasons for this are that the UWP must execute code that transitions from your app's language to the component's language.</target>
          </segment>
        </unit>
        <unit id="132">
          <segment state="initial" id="132">
            <source xml:space="preserve">Also, if you pass data to the component, the data must be converted between managed and unmanaged types.</source>
            <target xml:space="preserve">Also, if you pass data to the component, the data must be converted between managed and unmanaged types.</target>
          </segment>
        </unit>
        <unit id="133">
          <segment state="initial" id="133">
            <source xml:space="preserve">Using UWP Components efficiently</source>
            <target xml:space="preserve">Using UWP Components efficiently</target>
          </segment>
        </unit>
        <unit id="134">
          <segment state="initial" id="134">
            <source xml:space="preserve">If you find that you need to get better performance, you can ensure that your code uses UWP components as efficiently as possible.</source>
            <target xml:space="preserve">If you find that you need to get better performance, you can ensure that your code uses UWP components as efficiently as possible.</target>
          </segment>
        </unit>
        <unit id="135">
          <segment state="initial" id="135">
            <source xml:space="preserve">This section discusses some tips for improving performance when you use UWP components.</source>
            <target xml:space="preserve">This section discusses some tips for improving performance when you use UWP components.</target>
          </segment>
        </unit>
        <unit id="136">
          <segment state="initial" id="136">
            <source xml:space="preserve">It takes a significant number of calls in a short period of time for the performance impact to be noticeable.</source>
            <target xml:space="preserve">It takes a significant number of calls in a short period of time for the performance impact to be noticeable.</target>
          </segment>
        </unit>
        <unit id="137">
          <segment state="initial" id="137">
            <source xml:space="preserve">A well-designed application that encapsulates calls to UWP components from business logic and other managed code should not incur huge interoperability costs.</source>
            <target xml:space="preserve">A well-designed application that encapsulates calls to UWP components from business logic and other managed code should not incur huge interoperability costs.</target>
          </segment>
        </unit>
        <unit id="138">
          <segment state="initial" id="138">
            <source xml:space="preserve">But if your tests indicate that using UWP components is affecting your app's performance, the tips discussed in this section help you improve performance.</source>
            <target xml:space="preserve">But if your tests indicate that using UWP components is affecting your app's performance, the tips discussed in this section help you improve performance.</target>
          </segment>
        </unit>
        <unit id="139">
          <segment state="initial" id="139">
            <source xml:space="preserve">Consider using .NET for UWP apps</source>
            <target xml:space="preserve">Consider using .NET for UWP apps</target>
          </segment>
        </unit>
        <unit id="140">
          <segment state="initial" id="140">
            <source xml:space="preserve">There are certain cases where you can accomplish a task by using either UWP or .NET for UWP apps.</source>
            <target xml:space="preserve">There are certain cases where you can accomplish a task by using either UWP or .NET for UWP apps.</target>
          </segment>
        </unit>
        <unit id="141">
          <segment state="initial" id="141">
            <source xml:space="preserve">It is a good idea to try to not mix .NET types and UWP types.</source>
            <target xml:space="preserve">It is a good idea to try to not mix .NET types and UWP types.</target>
          </segment>
        </unit>
        <unit id="142">
          <segment state="initial" id="142">
            <source xml:space="preserve">Try to stay in one or the other.</source>
            <target xml:space="preserve">Try to stay in one or the other.</target>
          </segment>
        </unit>
        <unit id="143">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="143">
            <source xml:space="preserve">For example, you can parse a stream of xml by using either the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Windows.Data.Xml.Dom.XmlDocument**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> type (a UWP type) or the <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**System.Xml.XmlReader**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> type (a .NET type).</source>
            <target xml:space="preserve">For example, you can parse a stream of xml by using either the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Windows.Data.Xml.Dom.XmlDocument**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> type (a UWP type) or the <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**System.Xml.XmlReader**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> type (a .NET type).</target>
          </segment>
        </unit>
        <unit id="144">
          <segment state="initial" id="144">
            <source xml:space="preserve">Use the API that is from the same technology as the stream.</source>
            <target xml:space="preserve">Use the API that is from the same technology as the stream.</target>
          </segment>
        </unit>
        <unit id="145">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;strong&gt;</data>
            <data id="id8">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="145">
            <source xml:space="preserve">For example, if you read xml from a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**MemoryStream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, use the <pc dataRefEnd="id8" dataRefStart="id7" id="4">System.Xml.XmlReader</pc> type, because both types are .NET types.</source>
            <target xml:space="preserve">For example, if you read xml from a <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**MemoryStream**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc>, use the <pc dataRefEnd="id8" dataRefStart="id7" id="4">System.Xml.XmlReader</pc> type, because both types are .NET types.</target>
          </segment>
        </unit>
        <unit id="146">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
            <data id="id3">&lt;strong&gt;</data>
            <data id="id4">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="146">
            <source xml:space="preserve">If you read from a file, use the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Windows.Data.Xml.Dom.XmlDocument</pc> type because the file APIs and <pc dataRefEnd="id4" dataRefStart="id3" id="4">XmlDocument</pc> are UWP components.</source>
            <target xml:space="preserve">If you read from a file, use the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Windows.Data.Xml.Dom.XmlDocument</pc> type because the file APIs and <pc dataRefEnd="id4" dataRefStart="id3" id="4">XmlDocument</pc> are UWP components.</target>
          </segment>
        </unit>
        <unit id="147">
          <segment state="initial" id="147">
            <source xml:space="preserve">Copy Window Runtime objects to .NET types</source>
            <target xml:space="preserve">Copy Window Runtime objects to .NET types</target>
          </segment>
        </unit>
        <unit id="148">
          <segment state="initial" id="148">
            <source xml:space="preserve">When a UWP component returns a UWP object, it might be beneficial to copy the returned object into a .NET object.</source>
            <target xml:space="preserve">When a UWP component returns a UWP object, it might be beneficial to copy the returned object into a .NET object.</target>
          </segment>
        </unit>
        <unit id="149">
          <segment state="initial" id="149">
            <source xml:space="preserve">Two places where this is especially important is when you're working with collections and streams.</source>
            <target xml:space="preserve">Two places where this is especially important is when you're working with collections and streams.</target>
          </segment>
        </unit>
        <unit id="150">
          <segment state="initial" id="150">
            <source xml:space="preserve">If you call a UWP API that returns a collection and then you save and access that collection many times, it might be beneficial to copy the collection into a .NET collection and use the .NET version from then on.</source>
            <target xml:space="preserve">If you call a UWP API that returns a collection and then you save and access that collection many times, it might be beneficial to copy the collection into a .NET collection and use the .NET version from then on.</target>
          </segment>
        </unit>
        <unit id="151">
          <segment state="initial" id="151">
            <source xml:space="preserve">Cache the results of calls to UWP components for later use</source>
            <target xml:space="preserve">Cache the results of calls to UWP components for later use</target>
          </segment>
        </unit>
        <unit id="152">
          <segment state="initial" id="152">
            <source xml:space="preserve">You might be able to get better performance by saving values into local variables instead of accessing a UWP type multiple times.</source>
            <target xml:space="preserve">You might be able to get better performance by saving values into local variables instead of accessing a UWP type multiple times.</target>
          </segment>
        </unit>
        <unit id="153">
          <segment state="initial" id="153">
            <source xml:space="preserve">This can be especially beneficial if you use a value inside of a loop.</source>
            <target xml:space="preserve">This can be especially beneficial if you use a value inside of a loop.</target>
          </segment>
        </unit>
        <unit id="154">
          <segment state="initial" id="154">
            <source xml:space="preserve">Measure your app to see if using local variables improves your app's performance.</source>
            <target xml:space="preserve">Measure your app to see if using local variables improves your app's performance.</target>
          </segment>
        </unit>
        <unit id="155">
          <segment state="initial" id="155">
            <source xml:space="preserve">Using cached values can increase your app's speed because it will spend less time on interoperability.</source>
            <target xml:space="preserve">Using cached values can increase your app's speed because it will spend less time on interoperability.</target>
          </segment>
        </unit>
        <unit id="156">
          <segment state="initial" id="156">
            <source xml:space="preserve">Combine calls to UWP components</source>
            <target xml:space="preserve">Combine calls to UWP components</target>
          </segment>
        </unit>
        <unit id="157">
          <segment state="initial" id="157">
            <source xml:space="preserve">Try to complete tasks with the fewest number of calls to UWP objects as possible.</source>
            <target xml:space="preserve">Try to complete tasks with the fewest number of calls to UWP objects as possible.</target>
          </segment>
        </unit>
        <unit id="158">
          <segment state="initial" id="158">
            <source xml:space="preserve">For example, it is usually better to read a large amount of data from a stream than to read small amounts at a time.</source>
            <target xml:space="preserve">For example, it is usually better to read a large amount of data from a stream than to read small amounts at a time.</target>
          </segment>
        </unit>
        <unit id="159">
          <segment state="initial" id="159">
            <source xml:space="preserve">Use APIs that bundle work in as few calls as possible instead of APIs that do less work and require more calls.</source>
            <target xml:space="preserve">Use APIs that bundle work in as few calls as possible instead of APIs that do less work and require more calls.</target>
          </segment>
        </unit>
        <unit id="160">
          <segment state="initial" id="160">
            <source xml:space="preserve">For example, prefer to create an object by calling constructors that initialize multiple properties instead of calling the default constructor and assigning properties one at a time.</source>
            <target xml:space="preserve">For example, prefer to create an object by calling constructors that initialize multiple properties instead of calling the default constructor and assigning properties one at a time.</target>
          </segment>
        </unit>
        <unit id="161">
          <segment state="initial" id="161">
            <source xml:space="preserve">Building a UWP components</source>
            <target xml:space="preserve">Building a UWP components</target>
          </segment>
        </unit>
        <unit id="162">
          <segment state="initial" id="162">
            <source xml:space="preserve">If you write a UWP Component that can be used by apps written in C++ or JavaScript, make sure that your component is designed for good performance.</source>
            <target xml:space="preserve">If you write a UWP Component that can be used by apps written in C++ or JavaScript, make sure that your component is designed for good performance.</target>
          </segment>
        </unit>
        <unit id="163">
          <segment state="initial" id="163">
            <source xml:space="preserve">All the suggestions for getting good performance in apps apply to getting good performance in components.</source>
            <target xml:space="preserve">All the suggestions for getting good performance in apps apply to getting good performance in components.</target>
          </segment>
        </unit>
        <unit id="164">
          <segment state="initial" id="164">
            <source xml:space="preserve">Measure your component to find out which APIs have high traffic patterns and for those areas, consider providing APIs that enable your users to do work with few calls.</source>
            <target xml:space="preserve">Measure your component to find out which APIs have high traffic patterns and for those areas, consider providing APIs that enable your users to do work with few calls.</target>
          </segment>
        </unit>
        <unit id="165">
          <segment state="initial" id="165">
            <source xml:space="preserve">Keep your app fast when you use interop in managed code</source>
            <target xml:space="preserve">Keep your app fast when you use interop in managed code</target>
          </segment>
        </unit>
        <unit id="166">
          <segment state="initial" id="166">
            <source xml:space="preserve">The UWP makes it easy to interoperate between native and managed code, but if you're not careful it can incur performance costs.</source>
            <target xml:space="preserve">The UWP makes it easy to interoperate between native and managed code, but if you're not careful it can incur performance costs.</target>
          </segment>
        </unit>
        <unit id="167">
          <segment state="initial" id="167">
            <source xml:space="preserve">Here we show you how to get good performance when you use interop in your managed UWP apps.</source>
            <target xml:space="preserve">Here we show you how to get good performance when you use interop in your managed UWP apps.</target>
          </segment>
        </unit>
        <unit id="168">
          <segment state="initial" id="168">
            <source xml:space="preserve">The UWP allows developers to write apps using XAML with their language of choice thanks to the projections of the UWP APIs available in each language.</source>
            <target xml:space="preserve">The UWP allows developers to write apps using XAML with their language of choice thanks to the projections of the UWP APIs available in each language.</target>
          </segment>
        </unit>
        <unit id="169">
          <segment state="initial" id="169">
            <source xml:space="preserve">When writing an app in C\# or Visual Basic, this convenience comes at an interop cost because the UWP APIs are usually implemented in native code, and any UWP invocation from C\# or Visual Basic requires that the CLR transition from a managed to a native stack frame and marshal function parameters to representations accessible by native code.</source>
            <target xml:space="preserve">When writing an app in C\# or Visual Basic, this convenience comes at an interop cost because the UWP APIs are usually implemented in native code, and any UWP invocation from C\# or Visual Basic requires that the CLR transition from a managed to a native stack frame and marshal function parameters to representations accessible by native code.</target>
          </segment>
        </unit>
        <unit id="170">
          <segment state="initial" id="170">
            <source xml:space="preserve">This overhead is negligible for most apps.</source>
            <target xml:space="preserve">This overhead is negligible for most apps.</target>
          </segment>
        </unit>
        <unit id="171">
          <segment state="initial" id="171">
            <source xml:space="preserve">But when you make many calls (hundreds of thousands, to millions) to UWP APIs in the critical path of an app, this cost can become noticeable.</source>
            <target xml:space="preserve">But when you make many calls (hundreds of thousands, to millions) to UWP APIs in the critical path of an app, this cost can become noticeable.</target>
          </segment>
        </unit>
        <unit id="172">
          <segment state="initial" id="172">
            <source xml:space="preserve">In general you want to ensure that the time spent in transition between languages is small relative to the execution of the rest of your code.</source>
            <target xml:space="preserve">In general you want to ensure that the time spent in transition between languages is small relative to the execution of the rest of your code.</target>
          </segment>
        </unit>
        <unit id="173">
          <segment state="initial" id="173">
            <source xml:space="preserve">This is illustrated by the following diagram.</source>
            <target xml:space="preserve">This is illustrated by the following diagram.</target>
          </segment>
        </unit>
        <unit id="174">
          <originalData>
            <data id="id1">&lt;linkText&gt;</data>
            <data id="id2">&lt;/linkText&gt;</data>
          </originalData>
          <segment state="initial" id="174">
            <source xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Interop transitions should not dominate the program execution time.</pc>
						</source>
            <target xml:space="preserve">
							<pc dataRefEnd="id2" dataRefStart="id1" id="1">Interop transitions should not dominate the program execution time.</pc>
						</target>
          </segment>
        </unit>
        <unit id="175">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="175">
            <source xml:space="preserve">The types listed at <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**.NET for Windows apps**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> don't incur this interop cost when used from C\# or Visual Basic.</source>
            <target xml:space="preserve">The types listed at <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**.NET for Windows apps**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> don't incur this interop cost when used from C\# or Visual Basic.</target>
          </segment>
        </unit>
        <unit id="176">
          <segment state="initial" id="176">
            <source xml:space="preserve">As a rule of thumb, you can assume that types in namespaces which begin with “Windows.”</source>
            <target xml:space="preserve">As a rule of thumb, you can assume that types in namespaces which begin with “Windows.”</target>
          </segment>
        </unit>
        <unit id="177">
          <segment state="initial" id="177">
            <source xml:space="preserve">are part of the UWP, and types in namespaces which begin with “System.”</source>
            <target xml:space="preserve">are part of the UWP, and types in namespaces which begin with “System.”</target>
          </segment>
        </unit>
        <unit id="178">
          <segment state="initial" id="178">
            <source xml:space="preserve">are .NET types.</source>
            <target xml:space="preserve">are .NET types.</target>
          </segment>
        </unit>
        <unit id="179">
          <segment state="initial" id="179">
            <source xml:space="preserve">Keep in mind that even simple usage of UWP types such as allocation or property access incurs an interop cost.</source>
            <target xml:space="preserve">Keep in mind that even simple usage of UWP types such as allocation or property access incurs an interop cost.</target>
          </segment>
        </unit>
        <unit id="180">
          <segment state="initial" id="180">
            <source xml:space="preserve">You should measure your app and determine if interop is taking up a large portion of your apps execution time before optimizing your interop costs.</source>
            <target xml:space="preserve">You should measure your app and determine if interop is taking up a large portion of your apps execution time before optimizing your interop costs.</target>
          </segment>
        </unit>
        <unit id="181">
          <originalData>
            <data id="id1">&lt;strong&gt;</data>
            <data id="id2">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="181">
            <source xml:space="preserve">When analyzing your app’s performance with Visual Studio, you can easily get an upper bound on your interop costs by using the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Functions</pc> view and looking at inclusive time spent in methods which call into the UWP.</source>
            <target xml:space="preserve">When analyzing your app’s performance with Visual Studio, you can easily get an upper bound on your interop costs by using the <pc dataRefEnd="id2" dataRefStart="id1" id="2">Functions</pc> view and looking at inclusive time spent in methods which call into the UWP.</target>
          </segment>
        </unit>
        <unit id="182">
          <segment state="initial" id="182">
            <source xml:space="preserve">If your app is slow because of interop overhead, you can improve its performance by reducing calls to UWP APIs on hot code paths.</source>
            <target xml:space="preserve">If your app is slow because of interop overhead, you can improve its performance by reducing calls to UWP APIs on hot code paths.</target>
          </segment>
        </unit>
        <unit id="183">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;strong&gt;</data>
            <data id="id8">&lt;/strong&gt;</data>
            <data id="id9">&lt;strong&gt;</data>
            <data id="id10">&lt;/strong&gt;</data>
          </originalData>
          <segment state="initial" id="183">
            <source xml:space="preserve">For example, a game engine that is doing tons of physics calculations by constantly querying the position and dimensions of <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**UIElements**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> can save a lot of time by storing the necessary info from <pc dataRefEnd="id8" dataRefStart="id7" id="4">UIElements</pc> to local variables, doing calculations on these cached values, and assigning the end result back to the <pc dataRefEnd="id10" dataRefStart="id9" id="6">UIElements</pc> after the calculations are done.</source>
            <target xml:space="preserve">For example, a game engine that is doing tons of physics calculations by constantly querying the position and dimensions of <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**UIElements**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> can save a lot of time by storing the necessary info from <pc dataRefEnd="id8" dataRefStart="id7" id="4">UIElements</pc> to local variables, doing calculations on these cached values, and assigning the end result back to the <pc dataRefEnd="id10" dataRefStart="id9" id="6">UIElements</pc> after the calculations are done.</target>
          </segment>
        </unit>
        <unit id="184">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
            <data id="id7">&lt;link&gt;</data>
            <data id="id8">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="184">
            <source xml:space="preserve">Another example: if a collection is heavily accessed by C\# or Visual Basic code, then it is more efficient to use a collection from the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**System.Collections**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> namespace, rather than a collection from the <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Windows.Foundation.Collections**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> namespace.</source>
            <target xml:space="preserve">Another example: if a collection is heavily accessed by C\# or Visual Basic code, then it is more efficient to use a collection from the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**System.Collections**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> namespace, rather than a collection from the <pc dataRefEnd="id8" dataRefStart="id7" id="4CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="4CapsExtId2">**Windows.Foundation.Collections**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="4CapsExtId3"></pc></pc> namespace.</target>
          </segment>
        </unit>
        <unit id="185">
          <originalData>
            <data id="id1">&lt;link&gt;</data>
            <data id="id2">&lt;/link&gt;</data>
            <data id="id3">&lt;linkText&gt;</data>
            <data id="id4">&lt;/linkText&gt;</data>
            <data id="id5">&lt;title&gt;</data>
            <data id="id6">&lt;/title&gt;</data>
          </originalData>
          <segment state="initial" id="185">
            <source xml:space="preserve">You may also consider combining calls to UWP components; one example where this is possible is by using the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Windows.Storage.BulkAccess**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> APIs.</source>
            <target xml:space="preserve">You may also consider combining calls to UWP components; one example where this is possible is by using the <pc dataRefEnd="id2" dataRefStart="id1" id="2CapsExtId1"><pc dataRefEnd="id4" dataRefStart="id3" id="2CapsExtId2">**Windows.Storage.BulkAccess**</pc><pc dataRefEnd="id6" dataRefStart="id5" id="2CapsExtId3"></pc></pc> APIs.</target>
          </segment>
        </unit>
        <unit id="186">
          <segment state="initial" id="186">
            <source xml:space="preserve">Building a UWP component</source>
            <target xml:space="preserve">Building a UWP component</target>
          </segment>
        </unit>
        <unit id="187">
          <segment state="initial" id="187">
            <source xml:space="preserve">If you write a UWP component for use in apps written in C++ or JavaScript, make sure that your component is designed for good performance.</source>
            <target xml:space="preserve">If you write a UWP component for use in apps written in C++ or JavaScript, make sure that your component is designed for good performance.</target>
          </segment>
        </unit>
        <unit id="188">
          <segment state="initial" id="188">
            <source xml:space="preserve">Your API surface defines your interop boundary and defines the degree to which your users will have to think about the guidance in this topic.</source>
            <target xml:space="preserve">Your API surface defines your interop boundary and defines the degree to which your users will have to think about the guidance in this topic.</target>
          </segment>
        </unit>
        <unit id="189">
          <segment state="initial" id="189">
            <source xml:space="preserve">If you are distributing your components to other parties then this becomes especially important.</source>
            <target xml:space="preserve">If you are distributing your components to other parties then this becomes especially important.</target>
          </segment>
        </unit>
        <unit id="190">
          <segment state="initial" id="190">
            <source xml:space="preserve">All of the suggestions for getting good performance in apps apply to getting good performance in components.</source>
            <target xml:space="preserve">All of the suggestions for getting good performance in apps apply to getting good performance in components.</target>
          </segment>
        </unit>
        <unit id="191">
          <segment state="initial" id="191">
            <source xml:space="preserve">Measure your component to find out which APIs have high traffic patterns, and for those areas, consider providing APIs that enable your users to do work with few calls.</source>
            <target xml:space="preserve">Measure your component to find out which APIs have high traffic patterns, and for those areas, consider providing APIs that enable your users to do work with few calls.</target>
          </segment>
        </unit>
        <unit id="192">
          <segment state="initial" id="192">
            <source xml:space="preserve">Significant effort was put into designing the UWP to allow apps to use it without requiring frequent crossing of the interop boundary.</source>
            <target xml:space="preserve">Significant effort was put into designing the UWP to allow apps to use it without requiring frequent crossing of the interop boundary.</target>
          </segment>
        </unit>
      </group>
    </group>
  </file>
</xliff>