<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en-US" target-language="fr-fr">
    <body>
      <group id="main" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Monitor your APIs with Azure API Management, Event Hubs and Runscope</source>
          <target state="new">Monitor your APIs with Azure API Management, Event Hubs and Runscope</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Sample application demonstrating the log-to-eventhub policy by connecting Azure API Management, Azure Event Hubs and Runscope for HTTP  logging and monitoring</source>
          <target state="new">Sample application demonstrating the log-to-eventhub policy by connecting Azure API Management, Azure Event Hubs and Runscope for HTTP  logging and monitoring</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Monitor your APIs with Azure API Management, Event Hubs and Runscope</source>
          <target state="new">Monitor your APIs with Azure API Management, Event Hubs and Runscope</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>API Management service<ept id="p1">](api-management-key-concepts.md)</ept><ph id="ph2" /> provides many capabilities to enhance the processing of HTTP requests sent to your HTTP API.</source>
          <target state="new">The <bpt id="p1">[</bpt>API Management service<ept id="p1">](api-management-key-concepts.md)</ept><ph id="ph2" /> provides many capabilities to enhance the processing of HTTP requests sent to your HTTP API.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>However, the existence of the requests and responses are transient.</source>
          <target state="new">However, the existence of the requests and responses are transient.</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>The request is made and it flows through the API Management service to your backend API.</source>
          <target state="new">The request is made and it flows through the API Management service to your backend API.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Your API processes the request and a response flows back through to the API consumer.</source>
          <target state="new">Your API processes the request and a response flows back through to the API consumer.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>The API Management service keeps some important statistics about the APIs for display in the Publisher portal dashboard, but beyond that, the details are gone.</source>
          <target state="new">The API Management service keeps some important statistics about the APIs for display in the Publisher portal dashboard, but beyond that, the details are gone.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>By using the <bpt id="p2">[</bpt>log-to-eventhub<ept id="p2">](https://msdn.microsoft.com/library/azure/dn894085.aspx#log-to-eventhub)</ept> <bpt id="p3">[</bpt>policy<ept id="p3">](api-management-howto-policies.md)</ept><ph id="ph3" /> in the API Management service you can send any details from the request and response to an <bpt id="p4">[</bpt>Azure Event Hub<ept id="p4">](../event-hubs/event-hubs-what-is-event-hubs.md)</ept>.</source>
          <target state="new">By using the <bpt id="p2">[</bpt>log-to-eventhub<ept id="p2">](https://msdn.microsoft.com/library/azure/dn894085.aspx#log-to-eventhub)</ept> <bpt id="p3">[</bpt>policy<ept id="p3">](api-management-howto-policies.md)</ept><ph id="ph3" /> in the API Management service you can send any details from the request and response to an <bpt id="p4">[</bpt>Azure Event Hub<ept id="p4">](../event-hubs/event-hubs-what-is-event-hubs.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>There are a variety of reasons why you may want to generate events from HTTP messages being sent to your APIs.</source>
          <target state="new">There are a variety of reasons why you may want to generate events from HTTP messages being sent to your APIs.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Some examples include audit trail of updates, usage analytics, exception alerting and 3rd party integrations.</source>
          <target state="new">Some examples include audit trail of updates, usage analytics, exception alerting and 3rd party integrations.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This article demonstrates how to capture the entire HTTP request and response message, send it to an Event Hub and then relay that message to a third party service that provides HTTP logging and monitoring services.</source>
          <target state="new">This article demonstrates how to capture the entire HTTP request and response message, send it to an Event Hub and then relay that message to a third party service that provides HTTP logging and monitoring services.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Why Send From API Management Service?</source>
          <target state="new">Why Send From API Management Service?</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>It is possible to write HTTP middleware that can plug into HTTP API frameworks to capture HTTP requests and responses and feed them into logging and monitoring systems.</source>
          <target state="new">It is possible to write HTTP middleware that can plug into HTTP API frameworks to capture HTTP requests and responses and feed them into logging and monitoring systems.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>The downside to this approach is the HTTP middleware needs to be integrated into the backend API and must match the platform of the API.</source>
          <target state="new">The downside to this approach is the HTTP middleware needs to be integrated into the backend API and must match the platform of the API.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>If there are multiple APIs then each one must deploy the middleware.</source>
          <target state="new">If there are multiple APIs then each one must deploy the middleware.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Often there are reasons why backend APIs cannot be updated.</source>
          <target state="new">Often there are reasons why backend APIs cannot be updated.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Using the Azure API Management service to integrate with logging infrastructure provides a centralized and platform-independent solution.</source>
          <target state="new">Using the Azure API Management service to integrate with logging infrastructure provides a centralized and platform-independent solution.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>It is also scalable, in part due to the <bpt id="p5">[</bpt>geo-replication<ept id="p5">](api-management-howto-deploy-multi-region.md)</ept><ph id="ph4" /> capabilities of Azure API Management.</source>
          <target state="new">It is also scalable, in part due to the <bpt id="p5">[</bpt>geo-replication<ept id="p5">](api-management-howto-deploy-multi-region.md)</ept><ph id="ph4" /> capabilities of Azure API Management.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Why send to an Azure Event Hub?</source>
          <target state="new">Why send to an Azure Event Hub?</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>It is a reasonable to ask, why create a policy that is specific to Azure Event Hubs?</source>
          <target state="new">It is a reasonable to ask, why create a policy that is specific to Azure Event Hubs?</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>There are many different places where I might want to log my requests.</source>
          <target state="new">There are many different places where I might want to log my requests.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Why not just send the requests directly to the final destination?</source>
          <target state="new">Why not just send the requests directly to the final destination?</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>That is an option.</source>
          <target state="new">That is an option.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>However, when making logging requests from an API management service, it is necessary to consider how logging messages will impact the performance of the API.</source>
          <target state="new">However, when making logging requests from an API management service, it is necessary to consider how logging messages will impact the performance of the API.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Gradual increases in load can be handled by increasing available instances of system components or by taking advantage of geo-replication.</source>
          <target state="new">Gradual increases in load can be handled by increasing available instances of system components or by taking advantage of geo-replication.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>However, short spikes in traffic can cause requests to be significantly delayed if requests to logging infrastructure start to slow under load.</source>
          <target state="new">However, short spikes in traffic can cause requests to be significantly delayed if requests to logging infrastructure start to slow under load.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>The Azure Event Hubs is designed to ingress huge volumes of data, with capacity for dealing with a far higher number of events than the number of HTTP requests most APIs process.</source>
          <target state="new">The Azure Event Hubs is designed to ingress huge volumes of data, with capacity for dealing with a far higher number of events than the number of HTTP requests most APIs process.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The Event Hub acts as a kind of sophisticated buffer between your API management service and the infrastructure that will store and process the messages.</source>
          <target state="new">The Event Hub acts as a kind of sophisticated buffer between your API management service and the infrastructure that will store and process the messages.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>This ensures that your API performance will not suffer due to the logging infrastructure.</source>
          <target state="new">This ensures that your API performance will not suffer due to the logging infrastructure.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Once the data has been passed to an Event Hub it is persisted and will wait for Event Hub consumers to process it.</source>
          <target state="new">Once the data has been passed to an Event Hub it is persisted and will wait for Event Hub consumers to process it.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The Event Hub does not care how it will be processed, it just cares about making sure the message will be successfully delivered.</source>
          <target state="new">The Event Hub does not care how it will be processed, it just cares about making sure the message will be successfully delivered.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Event Hubs have the ability to stream events to multiple consumer groups.</source>
          <target state="new">Event Hubs have the ability to stream events to multiple consumer groups.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This allows events to be processed by completely different systems.</source>
          <target state="new">This allows events to be processed by completely different systems.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This enables supporting many integration scenarios without putting addition delays on the processing of the API request within the API Management service as only one event needs to be generated.</source>
          <target state="new">This enables supporting many integration scenarios without putting addition delays on the processing of the API request within the API Management service as only one event needs to be generated.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>A policy to send application/http messages</source>
          <target state="new">A policy to send application/http messages</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>An Event Hub accepts event data as a simple string.</source>
          <target state="new">An Event Hub accepts event data as a simple string.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>The contents of that string are completely up to you.</source>
          <target state="new">The contents of that string are completely up to you.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>To be able to package up an HTTP request and send it off to Event Hubs we need to format the string with the request or response information.</source>
          <target state="new">To be able to package up an HTTP request and send it off to Event Hubs we need to format the string with the request or response information.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In situations like this, if there is an existing format we can reuse, then we may not have to write our own parsing code.</source>
          <target state="new">In situations like this, if there is an existing format we can reuse, then we may not have to write our own parsing code.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Initially I considered using the <bpt id="p6">[</bpt>HAR<ept id="p6">](http://www.softwareishard.com/blog/har-12-spec/)</ept><ph id="ph5" /> for sending HTTP requests and responses.</source>
          <target state="new">Initially I considered using the <bpt id="p6">[</bpt>HAR<ept id="p6">](http://www.softwareishard.com/blog/har-12-spec/)</ept><ph id="ph5" /> for sending HTTP requests and responses.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>However, this format is optimized for storing a sequence of HTTP requests in a JSON based format.</source>
          <target state="new">However, this format is optimized for storing a sequence of HTTP requests in a JSON based format.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>It contained a number of mandatory elements that added unnecessary complexity for the scenario of passing the HTTP message over the wire.</source>
          <target state="new">It contained a number of mandatory elements that added unnecessary complexity for the scenario of passing the HTTP message over the wire.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>An alternative option was to use the <ph id="ph6">`application/http`</ph><ph id="ph7" /> media type as described in the HTTP specification <bpt id="p7">[</bpt>RFC 7230<ept id="p7">](http://tools.ietf.org/html/rfc7230)</ept>.</source>
          <target state="new">An alternative option was to use the <ph id="ph6">`application/http`</ph><ph id="ph7" /> media type as described in the HTTP specification <bpt id="p7">[</bpt>RFC 7230<ept id="p7">](http://tools.ietf.org/html/rfc7230)</ept>.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>This media type uses the exact same format that is used to actually send HTTP messages over the wire, but the entire message can be put in the body of another HTTP request.</source>
          <target state="new">This media type uses the exact same format that is used to actually send HTTP messages over the wire, but the entire message can be put in the body of another HTTP request.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In our case we are just going to use the body as our message to send to Event Hubs.</source>
          <target state="new">In our case we are just going to use the body as our message to send to Event Hubs.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Conveniently, there is a parser that exists in <bpt id="p8">[</bpt>Microsoft ASP.NET Web API 2.2 Client<ept id="p8">](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/)</ept><ph id="ph8" /> libraries that can parse this format and convert it into the native <ph id="ph9">`HttpRequestMessage`</ph><ph id="ph10" /> and <ph id="ph11">`HttpResponseMessage`</ph><ph id="ph12" /> objects.</source>
          <target state="new">Conveniently, there is a parser that exists in <bpt id="p8">[</bpt>Microsoft ASP.NET Web API 2.2 Client<ept id="p8">](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/)</ept><ph id="ph8" /> libraries that can parse this format and convert it into the native <ph id="ph9">`HttpRequestMessage`</ph><ph id="ph10" /> and <ph id="ph11">`HttpResponseMessage`</ph><ph id="ph12" /> objects.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>To be able to create this message we need to take advantage of C# based <bpt id="p9">[</bpt>Policy expressions<ept id="p9">](https://msdn.microsoft.com/library/azure/dn910913.aspx)</ept><ph id="ph13" /> in Azure API Management.</source>
          <target state="new">To be able to create this message we need to take advantage of C# based <bpt id="p9">[</bpt>Policy expressions<ept id="p9">](https://msdn.microsoft.com/library/azure/dn910913.aspx)</ept><ph id="ph13" /> in Azure API Management.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Here is the policy which sends a HTTP request message to Azure Event Hubs.</source>
          <target state="new">Here is the policy which sends a HTTP request message to Azure Event Hubs.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Policy declaration</source>
          <target state="new">Policy declaration</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>There a few particular things worth mentioning about this policy expression.</source>
          <target state="new">There a few particular things worth mentioning about this policy expression.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The log-to-eventhub policy has an attribute called logger-id which refers to the name of logger that has been created within the API Management service.</source>
          <target state="new">The log-to-eventhub policy has an attribute called logger-id which refers to the name of logger that has been created within the API Management service.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The details of how to setup an Event Hub logger in the API Management service can be found in the document <bpt id="p10">[</bpt>How to log events to Azure Event Hubs in Azure API Management<ept id="p10">](api-management-howto-log-event-hubs.md)</ept>.</source>
          <target state="new">The details of how to setup an Event Hub logger in the API Management service can be found in the document <bpt id="p10">[</bpt>How to log events to Azure Event Hubs in Azure API Management<ept id="p10">](api-management-howto-log-event-hubs.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>The second attribute is an optional parameter that instructs Event Hubs which partition to store the message in.</source>
          <target state="new">The second attribute is an optional parameter that instructs Event Hubs which partition to store the message in.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Event Hubs use partitions to enable scalabilty and require a minimum of two.</source>
          <target state="new">Event Hubs use partitions to enable scalabilty and require a minimum of two.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The ordered delivery of messages is only guaranteed within a partition.</source>
          <target state="new">The ordered delivery of messages is only guaranteed within a partition.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>If we do not instruct Event Hub in which partition to place the message, it will use a round-robin algorithm to distribute the load.</source>
          <target state="new">If we do not instruct Event Hub in which partition to place the message, it will use a round-robin algorithm to distribute the load.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>However, that may cause some of our messages to be processed out of order.</source>
          <target state="new">However, that may cause some of our messages to be processed out of order.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Partitions</source>
          <target state="new">Partitions</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>To ensure our messages are delivered to consumers in order and take advantage of the load distribution capability of partitions, I chose to send HTTP request messages to one partition and HTTP response messages to a second partition.</source>
          <target state="new">To ensure our messages are delivered to consumers in order and take advantage of the load distribution capability of partitions, I chose to send HTTP request messages to one partition and HTTP response messages to a second partition.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>This will ensure an even load distribution and we can guarantee that all requests will be consumed in order and all responses will be consumed in order.</source>
          <target state="new">This will ensure an even load distribution and we can guarantee that all requests will be consumed in order and all responses will be consumed in order.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>It is possible for a response to be consumed before the corresponding request, but as that is not a problem as we have a different mechanism for correlating requests to responses and we know that requests always come before responses.</source>
          <target state="new">It is possible for a response to be consumed before the corresponding request, but as that is not a problem as we have a different mechanism for correlating requests to responses and we know that requests always come before responses.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>HTTP payloads</source>
          <target state="new">HTTP payloads</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>After building the <ph id="ph14">`requestLine`</ph><ph id="ph15" /> we check to see if the request body should be truncated.</source>
          <target state="new">After building the <ph id="ph14">`requestLine`</ph><ph id="ph15" /> we check to see if the request body should be truncated.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The request body is truncated to only 1024.</source>
          <target state="new">The request body is truncated to only 1024.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This could be increased, however individual Event Hub messages are limited to 256KB, so it is likely that some HTTP message bodies will not fit in a single message.</source>
          <target state="new">This could be increased, however individual Event Hub messages are limited to 256KB, so it is likely that some HTTP message bodies will not fit in a single message.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>When doing logging and analytics a significant amount of information can be derived from just the HTTP request line and headers.</source>
          <target state="new">When doing logging and analytics a significant amount of information can be derived from just the HTTP request line and headers.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Also, many API requests only return small bodies and so the loss of information value by truncating large bodies is fairly minimal in comparison to the reduction in transfer, processing and storage costs to keep all body contents.</source>
          <target state="new">Also, many API requests only return small bodies and so the loss of information value by truncating large bodies is fairly minimal in comparison to the reduction in transfer, processing and storage costs to keep all body contents.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>One final note about processing the body is that we need to pass <ph id="ph16">`true`</ph><ph id="ph17" /> to the As<ph id="ph18">&lt;string&gt;</ph>() method because we are reading the body contents, but was also want the backend API to be able to read the body.</source>
          <target state="new">One final note about processing the body is that we need to pass <ph id="ph16">`true`</ph><ph id="ph17" /> to the As<ph id="ph18">&lt;string&gt;</ph>() method because we are reading the body contents, but was also want the backend API to be able to read the body.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>By passing true to this method we cause the body to be buffered so that it can be read a second time.</source>
          <target state="new">By passing true to this method we cause the body to be buffered so that it can be read a second time.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>This is important to be aware of if you have an API that does uploading of very large files or uses long polling.</source>
          <target state="new">This is important to be aware of if you have an API that does uploading of very large files or uses long polling.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>In these cases it would be best to avoid reading the body at all.</source>
          <target state="new">In these cases it would be best to avoid reading the body at all.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>HTTP headers</source>
          <target state="new">HTTP headers</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>HTTP Headers can be simply transferred over into the message format in a simple key/value pair format.</source>
          <target state="new">HTTP Headers can be simply transferred over into the message format in a simple key/value pair format.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>We have chosen to strip out certain security sensitive fields, to avoid unnecessarily leaking credential information.</source>
          <target state="new">We have chosen to strip out certain security sensitive fields, to avoid unnecessarily leaking credential information.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>It is unlikely that API keys and other credentials would be used for analytics purposes.</source>
          <target state="new">It is unlikely that API keys and other credentials would be used for analytics purposes.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>If we wish to do analysis on the user and the particular product they are using then we could get that from the <ph id="ph19">`context`</ph><ph id="ph20" /> object and add that to the message.</source>
          <target state="new">If we wish to do analysis on the user and the particular product they are using then we could get that from the <ph id="ph19">`context`</ph><ph id="ph20" /> object and add that to the message.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Message Metadata</source>
          <target state="new">Message Metadata</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>When building the complete message to send to the event hub, the first line is not actually part of the <ph id="ph21">`application/http`</ph><ph id="ph22" /> message.</source>
          <target state="new">When building the complete message to send to the event hub, the first line is not actually part of the <ph id="ph21">`application/http`</ph><ph id="ph22" /> message.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>The first line is additional metadata consisting of whether the message is a request or response message and a message id which is used to correlate requests to responses.</source>
          <target state="new">The first line is additional metadata consisting of whether the message is a request or response message and a message id which is used to correlate requests to responses.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>The message id is created by using another policy that looks like this:</source>
          <target state="new">The message id is created by using another policy that looks like this:</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>We could have created the request message, stored that in a variable until the response was returned and then simply sent the request and response as a single message.</source>
          <target state="new">We could have created the request message, stored that in a variable until the response was returned and then simply sent the request and response as a single message.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>However, by sending the request and response independently and using a message id to correlate the two, we get a bit more flexibility in the message size, the ability to take advantage of multiple partitions whilst maintaining message order and the request will appear in our logging dashboard sooner.</source>
          <target state="new">However, by sending the request and response independently and using a message id to correlate the two, we get a bit more flexibility in the message size, the ability to take advantage of multiple partitions whilst maintaining message order and the request will appear in our logging dashboard sooner.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>There also may be some scenarios where a valid response is never sent to the event hub, possibly due to a fatal request error in the API Management service, but we still will have a record of the request.</source>
          <target state="new">There also may be some scenarios where a valid response is never sent to the event hub, possibly due to a fatal request error in the API Management service, but we still will have a record of the request.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>The policy to send the response HTTP message looks very similar to the request and so the complete policy configuration looks like this:</source>
          <target state="new">The policy to send the response HTTP message looks very similar to the request and so the complete policy configuration looks like this:</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>The <ph id="ph23">`set-variable`</ph><ph id="ph24" /> policy creates a value that is accessible by both the <ph id="ph25">`log-to-eventhub`</ph><ph id="ph26" /> policy in the <ph id="ph27">`&lt;inbound&gt;`</ph><ph id="ph28" /> section and the <ph id="ph29">`&lt;outbound&gt;`</ph><ph id="ph30" /> section.</source>
          <target state="new">The <ph id="ph23">`set-variable`</ph><ph id="ph24" /> policy creates a value that is accessible by both the <ph id="ph25">`log-to-eventhub`</ph><ph id="ph26" /> policy in the <ph id="ph27">`&lt;inbound&gt;`</ph><ph id="ph28" /> section and the <ph id="ph29">`&lt;outbound&gt;`</ph><ph id="ph30" /> section.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Receiving events from Event Hubs</source>
          <target state="new">Receiving events from Event Hubs</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Events from Azure Event Hub are received using the <bpt id="p11">[</bpt>AMQP protocol<ept id="p11">](http://www.amqp.org/)</ept>.</source>
          <target state="new">Events from Azure Event Hub are received using the <bpt id="p11">[</bpt>AMQP protocol<ept id="p11">](http://www.amqp.org/)</ept>.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>The Microsoft Service Bus team have made client libraries available to make the consuming events easier.</source>
          <target state="new">The Microsoft Service Bus team have made client libraries available to make the consuming events easier.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>There are two different approaches supported, one is being a <bpt id="p12">*</bpt>Direct Consumer<ept id="p12">*</ept><ph id="ph31" /> and the other is using the <ph id="ph32">`EventProcessorHost`</ph><ph id="ph33" /> class.</source>
          <target state="new">There are two different approaches supported, one is being a <bpt id="p12">*</bpt>Direct Consumer<ept id="p12">*</ept><ph id="ph31" /> and the other is using the <ph id="ph32">`EventProcessorHost`</ph><ph id="ph33" /> class.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Examples of these two approaches can be found in the <bpt id="p13">[</bpt>Event Hubs Programming Guide<ept id="p13">](../event-hubs/event-hubs-programming-guide.md)</ept>.</source>
          <target state="new">Examples of these two approaches can be found in the <bpt id="p13">[</bpt>Event Hubs Programming Guide<ept id="p13">](../event-hubs/event-hubs-programming-guide.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The short version of the differences is, <ph id="ph34">`Direct Consumer`</ph><ph id="ph35" /> gives you complete control and the <ph id="ph36">`EventProcessorHost`</ph><ph id="ph37" /> does some of the plumbing work for you but makes certain assumptions about how you will process those events.</source>
          <target state="new">The short version of the differences is, <ph id="ph34">`Direct Consumer`</ph><ph id="ph35" /> gives you complete control and the <ph id="ph36">`EventProcessorHost`</ph><ph id="ph37" /> does some of the plumbing work for you but makes certain assumptions about how you will process those events.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>EventProcessorHost</source>
          <target state="new">EventProcessorHost</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>In this sample, we will use the <ph id="ph38">`EventProcessorHost`</ph><ph id="ph39" /> for simplicity, however it may not the best choice for this particular scenario.</source>
          <target state="new">In this sample, we will use the <ph id="ph38">`EventProcessorHost`</ph><ph id="ph39" /> for simplicity, however it may not the best choice for this particular scenario.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source><ph id="ph40">`EventProcessorHost`</ph><ph id="ph41" /> does the hard work of making sure you don't have to worry about threading issues within a particular event processor class.</source>
          <target state="new"><ph id="ph40">`EventProcessorHost`</ph><ph id="ph41" /> does the hard work of making sure you don't have to worry about threading issues within a particular event processor class.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>However, in our scenario, we are simply converting the message to another format and passing it along to another service using an async method.</source>
          <target state="new">However, in our scenario, we are simply converting the message to another format and passing it along to another service using an async method.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>There is no need for updating shared state and therefore no risk of threading issues.</source>
          <target state="new">There is no need for updating shared state and therefore no risk of threading issues.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>For most scenarios, <ph id="ph42">`EventProcessorHost`</ph><ph id="ph43" /> is probably the best choice and it is certainly the easier option.</source>
          <target state="new">For most scenarios, <ph id="ph42">`EventProcessorHost`</ph><ph id="ph43" /> is probably the best choice and it is certainly the easier option.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>IEventProcessor</source>
          <target state="new">IEventProcessor</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The central concept when using <ph id="ph44">`EventProcessorHost`</ph><ph id="ph45" /> is to create a an implementation of the <ph id="ph46">`IEventProcessor`</ph><ph id="ph47" /> interface which contains the method <ph id="ph48">`ProcessEventAsync`</ph>.</source>
          <target state="new">The central concept when using <ph id="ph44">`EventProcessorHost`</ph><ph id="ph45" /> is to create a an implementation of the <ph id="ph46">`IEventProcessor`</ph><ph id="ph47" /> interface which contains the method <ph id="ph48">`ProcessEventAsync`</ph>.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>The essence of that method is shown here:</source>
          <target state="new">The essence of that method is shown here:</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>async Task IEventProcessor.ProcessEventsAsync(PartitionContext context, IEnumerable<ph id="ph49">&lt;EventData&gt;</ph><ph id="ph50" /> messages)
      <ph id="ph51" />{</source>
          <target state="new">async Task IEventProcessor.ProcessEventsAsync(PartitionContext context, IEnumerable<ph id="ph49">&lt;EventData&gt;</ph><ph id="ph50" /> messages)
      <ph id="ph51" />{</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>A list of EventData objects are passed into the method and we iterate over that list.</source>
          <target state="new">A list of EventData objects are passed into the method and we iterate over that list.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>The bytes of each method are parsed into a HttpMessage object and that object is passed to an instance of IHttpMessageProcessor.</source>
          <target state="new">The bytes of each method are parsed into a HttpMessage object and that object is passed to an instance of IHttpMessageProcessor.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>HttpMessage</source>
          <target state="new">HttpMessage</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The <ph id="ph52">`HttpMessage`</ph><ph id="ph53" /> instance contains three pieces of data:</source>
          <target state="new">The <ph id="ph52">`HttpMessage`</ph><ph id="ph53" /> instance contains three pieces of data:</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The <ph id="ph54">`HttpMessage`</ph><ph id="ph55" /> instance contains a <ph id="ph56">`MessageId`</ph><ph id="ph57" /> GUID that allows us to connect the HTTP request to the corresponding HTTP response and a boolean value that identifies if the object contains an instance of a HttpRequestMessage and HttpResponseMessage.</source>
          <target state="new">The <ph id="ph54">`HttpMessage`</ph><ph id="ph55" /> instance contains a <ph id="ph56">`MessageId`</ph><ph id="ph57" /> GUID that allows us to connect the HTTP request to the corresponding HTTP response and a boolean value that identifies if the object contains an instance of a HttpRequestMessage and HttpResponseMessage.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>By using the built in HTTP classes from <ph id="ph58">`System.Net.Http`</ph>, I was able to take advantage of the <ph id="ph59">`application/http`</ph><ph id="ph60" /> parsing code that is included in <ph id="ph61">`System.Net.Http.Formatting`</ph>.</source>
          <target state="new">By using the built in HTTP classes from <ph id="ph58">`System.Net.Http`</ph>, I was able to take advantage of the <ph id="ph59">`application/http`</ph><ph id="ph60" /> parsing code that is included in <ph id="ph61">`System.Net.Http.Formatting`</ph>.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>IHttpMessageProcessor</source>
          <target state="new">IHttpMessageProcessor</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>The <ph id="ph62">`HttpMessage`</ph><ph id="ph63" /> instance is then forwarded to implementation of <ph id="ph64">`IHttpMessageProcessor`</ph><ph id="ph65" /> which is an interface I created to decouple the receiving and interpretation of the event from Azure Event Hub and the actual processing of it.</source>
          <target state="new">The <ph id="ph62">`HttpMessage`</ph><ph id="ph63" /> instance is then forwarded to implementation of <ph id="ph64">`IHttpMessageProcessor`</ph><ph id="ph65" /> which is an interface I created to decouple the receiving and interpretation of the event from Azure Event Hub and the actual processing of it.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Forwarding the HTTP message</source>
          <target state="new">Forwarding the HTTP message</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>For this sample, I decided it would be interesting to push the HTTP Request over to <bpt id="p14">[</bpt>Runscope<ept id="p14">](http://www.runscope.com)</ept>.</source>
          <target state="new">For this sample, I decided it would be interesting to push the HTTP Request over to <bpt id="p14">[</bpt>Runscope<ept id="p14">](http://www.runscope.com)</ept>.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Runscope is a cloud based service that specializes in HTTP debugging, logging and monitoring.</source>
          <target state="new">Runscope is a cloud based service that specializes in HTTP debugging, logging and monitoring.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>They have a free tier, so it is easy to try and it allows us to see the HTTP requests in real-time flowing through our API Management service.</source>
          <target state="new">They have a free tier, so it is easy to try and it allows us to see the HTTP requests in real-time flowing through our API Management service.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The <ph id="ph66">`IHttpMessageProcessor`</ph><ph id="ph67" /> implementation looks like this,</source>
          <target state="new">The <ph id="ph66">`IHttpMessageProcessor`</ph><ph id="ph67" /> implementation looks like this,</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>I was able to take advantage of an <bpt id="p15">[</bpt>existing client library for Runscope<ept id="p15">](http://www.nuget.org/packages/Runscope.net.hapikit/0.9.0-alpha)</ept><ph id="ph68" /> that makes it easy to push <ph id="ph69">`HttpRequestMessage`</ph><ph id="ph70" /> and <ph id="ph71">`HttpResponseMessage`</ph><ph id="ph72" /> instances up into their service.</source>
          <target state="new">I was able to take advantage of an <bpt id="p15">[</bpt>existing client library for Runscope<ept id="p15">](http://www.nuget.org/packages/Runscope.net.hapikit/0.9.0-alpha)</ept><ph id="ph68" /> that makes it easy to push <ph id="ph69">`HttpRequestMessage`</ph><ph id="ph70" /> and <ph id="ph71">`HttpResponseMessage`</ph><ph id="ph72" /> instances up into their service.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>In order to access the Runscope API you will need an account and an API Key.</source>
          <target state="new">In order to access the Runscope API you will need an account and an API Key.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Instructions for getting an API key can be found in the <bpt id="p16">[</bpt>Creating Applications to Access Runscope API<ept id="p16">](http://blog.runscope.com/posts/creating-applications-to-access-the-runscope-api)</ept><ph id="ph73" /> screencast.</source>
          <target state="new">Instructions for getting an API key can be found in the <bpt id="p16">[</bpt>Creating Applications to Access Runscope API<ept id="p16">](http://blog.runscope.com/posts/creating-applications-to-access-the-runscope-api)</ept><ph id="ph73" /> screencast.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Complete sample</source>
          <target state="new">Complete sample</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The <bpt id="p17">[</bpt>source code<ept id="p17">](https://github.com/darrelmiller/ApimEventProcessor)</ept><ph id="ph74" /> and tests for the sample are on Github.</source>
          <target state="new">The <bpt id="p17">[</bpt>source code<ept id="p17">](https://github.com/darrelmiller/ApimEventProcessor)</ept><ph id="ph74" /> and tests for the sample are on Github.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>You will need an <bpt id="p18">[</bpt>API Management Service<ept id="p18">](api-management-get-started.md)</ept>, <bpt id="p19">[</bpt>a connected Event Hub<ept id="p19">](api-management-howto-log-event-hubs.md)</ept>, and a <bpt id="p20">[</bpt>Storage Account<ept id="p20">](../storage/storage-create-storage-account.md)</ept><ph id="ph75" /> to run the sample for yourself.</source>
          <target state="new">You will need an <bpt id="p18">[</bpt>API Management Service<ept id="p18">](api-management-get-started.md)</ept>, <bpt id="p19">[</bpt>a connected Event Hub<ept id="p19">](api-management-howto-log-event-hubs.md)</ept>, and a <bpt id="p20">[</bpt>Storage Account<ept id="p20">](../storage/storage-create-storage-account.md)</ept><ph id="ph75" /> to run the sample for yourself.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The sample is just a simple Console application that listens for events coming from Event Hub, converts them into a <ph id="ph76">`HttpRequestMessage`</ph><ph id="ph77" /> and <ph id="ph78">`HttpResponseMessage`</ph><ph id="ph79" /> objects and then forwards them on to the Runscope API.</source>
          <target state="new">The sample is just a simple Console application that listens for events coming from Event Hub, converts them into a <ph id="ph76">`HttpRequestMessage`</ph><ph id="ph77" /> and <ph id="ph78">`HttpResponseMessage`</ph><ph id="ph79" /> objects and then forwards them on to the Runscope API.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>In the following animated image, you can see a request being made to an API in the Developer Portal, the Console application showing the message being received, processed and forwarded and then the request and response showing up in the Runscope Traffic inspector.</source>
          <target state="new">In the following animated image, you can see a request being made to an API in the Developer Portal, the Console application showing the message being received, processed and forwarded and then the request and response showing up in the Runscope Traffic inspector.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source><ph id="ph80">![</ph>Demonstration of request being forwarded to Runscope<ph id="ph81">](./media/api-management-log-to-eventhub-sample/apim-eventhub-runscope.gif)</ph></source>
          <target state="new"><ph id="ph80">![</ph>Demonstration of request being forwarded to Runscope<ph id="ph81">](./media/api-management-log-to-eventhub-sample/apim-eventhub-runscope.gif)</ph></target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="new">Summary</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Azure API Management service provides an ideal place to capture the HTTP traffic travelling to and from your APIs.</source>
          <target state="new">Azure API Management service provides an ideal place to capture the HTTP traffic travelling to and from your APIs.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Azure Event Hubs is a highly scalable, low cost solution for capturing that traffic and feeding it into secondary processing systems for logging, monitoring and other sophisticated analytics.</source>
          <target state="new">Azure Event Hubs is a highly scalable, low cost solution for capturing that traffic and feeding it into secondary processing systems for logging, monitoring and other sophisticated analytics.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Connecting to 3rd party traffic monitoring systems like Runscope is a simple as a few dozen lines of code.</source>
          <target state="new">Connecting to 3rd party traffic monitoring systems like Runscope is a simple as a few dozen lines of code.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>Learn more about Azure Event Hubs</source>
          <target state="new">Learn more about Azure Event Hubs</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source><bpt id="p21">[</bpt>Get started with Azure Event Hubs<ept id="p21">](../event-hubs/event-hubs-csharp-ephcs-getstarted.md)</ept></source>
          <target state="new"><bpt id="p21">[</bpt>Get started with Azure Event Hubs<ept id="p21">](../event-hubs/event-hubs-csharp-ephcs-getstarted.md)</ept></target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source><bpt id="p22">[</bpt>Receive messages with EventProcessorHost<ept id="p22">](../event-hubs/event-hubs-csharp-ephcs-getstarted.md#receive-messages-with-eventprocessorhost)</ept></source>
          <target state="new"><bpt id="p22">[</bpt>Receive messages with EventProcessorHost<ept id="p22">](../event-hubs/event-hubs-csharp-ephcs-getstarted.md#receive-messages-with-eventprocessorhost)</ept></target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source><bpt id="p23">[</bpt>Event Hubs programming guide<ept id="p23">](../event-hubs/event-hubs-programming-guide.md)</ept></source>
          <target state="new"><bpt id="p23">[</bpt>Event Hubs programming guide<ept id="p23">](../event-hubs/event-hubs-programming-guide.md)</ept></target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Learn more about API Management and Event Hubs integration</source>
          <target state="new">Learn more about API Management and Event Hubs integration</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source><bpt id="p24">[</bpt>How to log events to Azure Event Hubs in Azure API Management<ept id="p24">](api-management-howto-log-event-hubs.md)</ept></source>
          <target state="new"><bpt id="p24">[</bpt>How to log events to Azure Event Hubs in Azure API Management<ept id="p24">](api-management-howto-log-event-hubs.md)</ept></target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source><bpt id="p25">[</bpt>Logger entity reference<ept id="p25">](https://msdn.microsoft.com/library/azure/mt592020.aspx)</ept></source>
          <target state="new"><bpt id="p25">[</bpt>Logger entity reference<ept id="p25">](https://msdn.microsoft.com/library/azure/mt592020.aspx)</ept></target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source><bpt id="p26">[</bpt>log-to-eventhub policy reference<ept id="p26">](https://msdn.microsoft.com/library/azure/dn894085.aspx#log-to-eventhub)</ept></source>
          <target state="new"><bpt id="p26">[</bpt>log-to-eventhub policy reference<ept id="p26">](https://msdn.microsoft.com/library/azure/dn894085.aspx#log-to-eventhub)</ept></target>
        </trans-unit>
      </group>
    </body>
  </file>
  <header xmlns="">
    <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">416593880813dcc52784b18e36d1d6f4a65320e2</xliffext:olfilehash>
  </header>
</xliff>