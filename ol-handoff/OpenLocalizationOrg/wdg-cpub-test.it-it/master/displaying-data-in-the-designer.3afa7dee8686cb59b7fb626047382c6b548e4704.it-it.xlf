<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="it-it" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">f9a087407671e3d81447777a52531e0663e01d4d</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: 089660A2-7CAE-4911-9994-F619C5D22287</source>
          <target xml:space="preserve">ms.assetid: 089660A2-7CAE-4911-9994-F619C5D22287</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">title: Sample data on the design surface, and for prototyping</source>
          <target xml:space="preserve">title: Sample data on the design surface, and for prototyping</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">description: It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.</source>
          <target xml:space="preserve">description: It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">Sample data on the design surface, and for prototyping</source>
          <target xml:space="preserve">Sample data on the design surface, and for prototyping</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="106">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="107">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/Mt204782)</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/Mt204783)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The degree to which you need sample data—and how much it will help you—depends on whether your bindings use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding} markup extension</pc> or the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{x:Bind} markup extension</pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  The degree to which you need sample data—and how much it will help you—depends on whether your bindings use the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding} markup extension</pc> or the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{x:Bind} markup extension</pc>.</target>
        </segment>
      </unit>
      <unit id="108">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208713)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The techniques described in this topic are based on the use of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc>, so they're only appropriate for <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{Binding}</pc>.</source>
          <target xml:space="preserve">The techniques described in this topic are based on the use of a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc>, so they're only appropriate for <pc dataRefEnd="id6" dataRefStart="id5" id="p3">{Binding}</pc>.</target>
        </segment>
      </unit>
      <unit id="109">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But if you're using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> then your bindings at least show placeholder values on the design surface (even for items controls), so you don't have quite the same need for sample data.</source>
          <target xml:space="preserve">But if you're using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Bind}</pc> then your bindings at least show placeholder values on the design surface (even for items controls), so you don't have quite the same need for sample data.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.</source>
          <target xml:space="preserve">It may be impossible or undesirable (perhaps for reasons of privacy or performance) for your app to display live data on the design surface in Microsoft Visual Studio or Blend for Visual Studio.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">In order to have your controls populated with data (so that you can work on your app's layout, templates, and other visual properties), there are various ways in which you can use design-time sample data.</source>
          <target xml:space="preserve">In order to have your controls populated with data (so that you can work on your app's layout, templates, and other visual properties), there are various ways in which you can use design-time sample data.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">Sample data can also be really useful and time-saving if you're building a sketch (or prototype) app.</source>
          <target xml:space="preserve">Sample data can also be really useful and time-saving if you're building a sketch (or prototype) app.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">You can use sample data in your sketch or prototype at run-time to illustrate your ideas without going as far as connecting to real, live data.</source>
          <target xml:space="preserve">You can use sample data in your sketch or prototype at run-time to illustrate your ideas without going as far as connecting to real, live data.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">Setting DataContext in markup</source>
          <target xml:space="preserve">Setting DataContext in markup</target>
        </segment>
      </unit>
      <unit id="115">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR208713)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">It's a fairly common developer practice to use imperative code (in code-behind) to set a page or user control's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc> to a view model instance.</source>
          <target xml:space="preserve">It's a fairly common developer practice to use imperative code (in code-behind) to set a page or user control's <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc></pc> to a view model instance.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">But if you do that then your page isn't as "designable" as it could be.</source>
          <target xml:space="preserve">But if you do that then your page isn't as "designable" as it could be.</target>
        </segment>
      </unit>
      <unit id="117">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The reason is that when your XAML page is opened in Visual Studio or Blend for Visual Studio, the imperative code that assigns the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> value is never run (in fact, none of your code-behind is executed).</source>
          <target xml:space="preserve">The reason is that when your XAML page is opened in Visual Studio or Blend for Visual Studio, the imperative code that assigns the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> value is never run (in fact, none of your code-behind is executed).</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">The XAML tools do of course parse your markup and instantiate any objects declared in it, but they don't actually instantiate your page's type itself.</source>
          <target xml:space="preserve">The XAML tools do of course parse your markup and instantiate any objects declared in it, but they don't actually instantiate your page's type itself.</target>
        </segment>
      </unit>
      <unit id="119">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The result is that you won't see any data in your controls or in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create Data Binding</pc> dialog, and your page will be more challenging to style and to lay out.</source>
          <target xml:space="preserve">The result is that you won't see any data in your controls or in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create Data Binding</pc> dialog, and your page will be more challenging to style and to lay out.</target>
        </segment>
      </unit>
      <unit id="120">
        <segment state="initial">
          <source xml:space="preserve">Sparse design UI.</source>
          <target xml:space="preserve">Sparse design UI.</target>
        </segment>
      </unit>
      <unit id="121">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The first remedy to try is to comment out that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> assignment and set the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> in your page markup instead.</source>
          <target xml:space="preserve">The first remedy to try is to comment out that <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> assignment and set the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> in your page markup instead.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">That way, your live data shows up at design-time as well as at run-time.</source>
          <target xml:space="preserve">That way, your live data shows up at design-time as well as at run-time.</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">To do this, first open your XAML page.</source>
          <target xml:space="preserve">To do this, first open your XAML page.</target>
        </segment>
      </unit>
      <unit id="124">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Then, in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Document Outline</pc> window, click the root designable element (usually with the label <pc dataRefEnd="id4" dataRefStart="id3" id="p2">\[Page\]</pc>) to select it.</source>
          <target xml:space="preserve">Then, in the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Document Outline</pc> window, click the root designable element (usually with the label <pc dataRefEnd="id4" dataRefStart="id3" id="p2">\[Page\]</pc>) to select it.</target>
        </segment>
      </unit>
      <unit id="125">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Properties</pc> window, find the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> property (inside the Common category), and then click <pc dataRefEnd="id6" dataRefStart="id5" id="p3">New</pc>.</source>
          <target xml:space="preserve">In the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Properties</pc> window, find the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> property (inside the Common category), and then click <pc dataRefEnd="id6" dataRefStart="id5" id="p3">New</pc>.</target>
        </segment>
      </unit>
      <unit id="126">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Click your view model type from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Select Object</pc> dialog box, and then click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">OK</pc>.</source>
          <target xml:space="preserve">Click your view model type from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Select Object</pc> dialog box, and then click <pc dataRefEnd="id4" dataRefStart="id3" id="p2">OK</pc>.</target>
        </segment>
      </unit>
      <unit id="127">
        <segment state="initial">
          <source xml:space="preserve">UI for setting DataContext.</source>
          <target xml:space="preserve">UI for setting DataContext.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">Here's what the resulting markup looks like.</source>
          <target xml:space="preserve">Here's what the resulting markup looks like.</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source xml:space="preserve">And here’s what the design surface looks like now that your bindings can resolve.</source>
          <target xml:space="preserve">And here’s what the design surface looks like now that your bindings can resolve.</target>
        </segment>
      </unit>
      <unit id="130">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Notice that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Path</pc> picker in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Create Data Binding</pc> dialog is now populated, based on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DataContext</pc> type and the properties that you can bind to.</source>
          <target xml:space="preserve">Notice that the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Path</pc> picker in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Create Data Binding</pc> dialog is now populated, based on the <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DataContext</pc> type and the properties that you can bind to.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source xml:space="preserve">Designable UI.</source>
          <target xml:space="preserve">Designable UI.</target>
        </segment>
      </unit>
      <unit id="132">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create Data Binding</pc> dialog only needs a type to work from, but the bindings need the properties to be initialized with values.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create Data Binding</pc> dialog only needs a type to work from, but the bindings need the properties to be initialized with values.</target>
        </segment>
      </unit>
      <unit id="133">
        <segment state="initial">
          <source xml:space="preserve">If you don't want to reach out to your cloud service at design-time (due to performance, paying for data transfer, privacy issues, that kind of thing) then your initialization code can check to see whether your app is running in a design tool (such as Visual Studio or Blend for Visual Studio) and in that case load sample data for use at design-time only.</source>
          <target xml:space="preserve">If you don't want to reach out to your cloud service at design-time (due to performance, paying for data transfer, privacy issues, that kind of thing) then your initialization code can check to see whether your app is running in a design tool (such as Visual Studio or Blend for Visual Studio) and in that case load sample data for use at design-time only.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">You could use a view model locator if you need to pass parameters to your initialization code.</source>
          <target xml:space="preserve">You could use a view model locator if you need to pass parameters to your initialization code.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">A view model locator is a class that you can put into app resources.</source>
          <target xml:space="preserve">A view model locator is a class that you can put into app resources.</target>
        </segment>
      </unit>
      <unit id="136">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">It has a property that exposes the view model, and your page's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> binds to that property.</source>
          <target xml:space="preserve">It has a property that exposes the view model, and your page's <pc dataRefEnd="id2" dataRefStart="id1" id="p1">DataContext</pc> binds to that property.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">Another pattern that the locator or the view model can use is dependency injection, which can construct a design-time or a run-time data provider (each of which implements a common interface), as applicable.</source>
          <target xml:space="preserve">Another pattern that the locator or the view model can use is dependency injection, which can construct a design-time or a run-time data provider (each of which implements a common interface), as applicable.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source xml:space="preserve">"Sample data from class", and design-time attributes</source>
          <target xml:space="preserve">"Sample data from class", and design-time attributes</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">If for whatever reason none of the options in the previous section work for you then you still have plenty of design-time data options available via XAML tools features and design-time attributes.</source>
          <target xml:space="preserve">If for whatever reason none of the options in the previous section work for you then you still have plenty of design-time data options available via XAML tools features and design-time attributes.</target>
        </segment>
      </unit>
      <unit id="140">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">One good option is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create Sample Data from Class</pc> feature in Blend for Visual Studio.</source>
          <target xml:space="preserve">One good option is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Create Sample Data from Class</pc> feature in Blend for Visual Studio.</target>
        </segment>
      </unit>
      <unit id="141">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can find that command on one of the buttons at the top of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data</pc> panel.</source>
          <target xml:space="preserve">You can find that command on one of the buttons at the top of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data</pc> panel.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source xml:space="preserve">All you need to do is to specify a class for the command to use.</source>
          <target xml:space="preserve">All you need to do is to specify a class for the command to use.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">The command then does two important things for you.</source>
          <target xml:space="preserve">The command then does two important things for you.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">First, it generates a XAML file that contains sample data suitable for hydrating an instance of your chosen class and all of its members, recursively (in fact, the tooling works equally well with XAML or JSON files).</source>
          <target xml:space="preserve">First, it generates a XAML file that contains sample data suitable for hydrating an instance of your chosen class and all of its members, recursively (in fact, the tooling works equally well with XAML or JSON files).</target>
        </segment>
      </unit>
      <unit id="145">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Second, it populates the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data</pc> panel with the schema of your chosen class.</source>
          <target xml:space="preserve">Second, it populates the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data</pc> panel with the schema of your chosen class.</target>
        </segment>
      </unit>
      <unit id="146">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can then drag members from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data</pc> panel onto the design surface to perform various tasks.</source>
          <target xml:space="preserve">You can then drag members from the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Data</pc> panel onto the design surface to perform various tasks.</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Depending on what you drag and where you drop it, you can add bindings to existing controls (using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc>), or create new controls and bind them at the same time.</source>
          <target xml:space="preserve">Depending on what you drag and where you drop it, you can add bindings to existing controls (using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc>), or create new controls and bind them at the same time.</target>
        </segment>
      </unit>
      <unit id="148">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In either case, the operation also sets a design-time data context (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext</pc>) for you (if one is not already set) on the layout root of your page.</source>
          <target xml:space="preserve">In either case, the operation also sets a design-time data context (<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext</pc>) for you (if one is not already set) on the layout root of your page.</target>
        </segment>
      </unit>
      <unit id="149">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">That design-time data context uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignData</pc> attribute to get its sample data from the XAML file that was generated (which, by the way, you are free to find in your project and edit so that it contains the sample data you want).</source>
          <target xml:space="preserve">That design-time data context uses the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignData</pc> attribute to get its sample data from the XAML file that was generated (which, by the way, you are free to find in your project and edit so that it contains the sample data you want).</target>
        </segment>
      </unit>
      <unit id="150">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The various xmlns declarations mean that attributes with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:</pc> prefix are interpreted only at design-time and are ignored at run-time.</source>
          <target xml:space="preserve">The various xmlns declarations mean that attributes with the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:</pc> prefix are interpreted only at design-time and are ignored at run-time.</target>
        </segment>
      </unit>
      <unit id="151">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/BR208713)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">So the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext</pc> attribute only affects the value of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DataContext</pc></pc> property at design-time; it has no effect at run-time.</source>
          <target xml:space="preserve">So the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext</pc> attribute only affects the value of the <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">DataContext</pc></pc> property at design-time; it has no effect at run-time.</target>
        </segment>
      </unit>
      <unit id="152">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can even set both <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> in markup if you like.</source>
          <target xml:space="preserve">You can even set both <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext</pc> and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> in markup if you like.</target>
        </segment>
      </unit>
      <unit id="153">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext</pc> will override at design-time, and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> will override at run-time.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext</pc> will override at design-time, and <pc dataRefEnd="id4" dataRefStart="id3" id="p2">DataContext</pc> will override at run-time.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">These same override rules apply to all design-time and run-time attributes.</source>
          <target xml:space="preserve">These same override rules apply to all design-time and run-time attributes.</target>
        </segment>
      </unit>
      <unit id="155">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](http://go.microsoft.com/fwlink/p/?LinkId=272504)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext</pc> attribute, and all other design-time attributes, are documented in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Design-Time Attributes</pc> topic, which is still valid for Universal Windows Platform (UWP) apps.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DataContext</pc> attribute, and all other design-time attributes, are documented in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Design-Time Attributes</pc> topic, which is still valid for Universal Windows Platform (UWP) apps.</target>
        </segment>
      </unit>
      <unit id="156">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/BR209833)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">CollectionViewSource</pc>
						</pc> doesn't have a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DataContext</pc> property, but it does have a <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Source</pc> property.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">CollectionViewSource</pc>
						</pc> doesn't have a <pc dataRefEnd="id6" dataRefStart="id5" id="p3">DataContext</pc> property, but it does have a <pc dataRefEnd="id8" dataRefStart="id7" id="p4">Source</pc> property.</target>
        </segment>
      </unit>
      <unit id="157">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Consequently, there's a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:Source</pc> property that you can use to set design-time-only sample data on a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CollectionViewSource</pc>.</source>
          <target xml:space="preserve">Consequently, there's a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:Source</pc> property that you can use to set design-time-only sample data on a <pc dataRefEnd="id4" dataRefStart="id3" id="p2">CollectionViewSource</pc>.</target>
        </segment>
      </unit>
      <unit id="158">
        <originalData>
          <data id="id1">`Recordings : ObservableCollection&lt;Recording&gt;`</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For this to work, you would have a class named <ph dataRef="id1" id="ph1" />, and you would edit the sample data XAML file so that it contains only a <pc dataRefEnd="id3" dataRefStart="id2" id="p1">Recordings</pc> object (with <pc dataRefEnd="id5" dataRefStart="id4" id="p2">Recording</pc> objects inside that), as shown here.</source>
          <target xml:space="preserve">For this to work, you would have a class named <ph dataRef="id1" id="ph1" />, and you would edit the sample data XAML file so that it contains only a <pc dataRefEnd="id3" dataRefStart="id2" id="p1">Recordings</pc> object (with <pc dataRefEnd="id5" dataRefStart="id4" id="p2">Recording</pc> objects inside that), as shown here.</target>
        </segment>
      </unit>
      <unit id="159">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you use a JSON sample data file instead of XAML, you must set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type</pc> property.</source>
          <target xml:space="preserve">If you use a JSON sample data file instead of XAML, you must set the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Type</pc> property.</target>
        </segment>
      </unit>
      <unit id="160">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">So far, we've been using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignData</pc> to load design-time sample data from a XAML or JSON file.</source>
          <target xml:space="preserve">So far, we've been using <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignData</pc> to load design-time sample data from a XAML or JSON file.</target>
        </segment>
      </unit>
      <unit id="161">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">An alternative to that is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignInstance</pc> markup extension, which indicates that the design-time source is based on the class specified by the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Type</pc> property.</source>
          <target xml:space="preserve">An alternative to that is the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">d:DesignInstance</pc> markup extension, which indicates that the design-time source is based on the class specified by the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Type</pc> property.</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">Here's an example.</source>
          <target xml:space="preserve">Here's an example.</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>