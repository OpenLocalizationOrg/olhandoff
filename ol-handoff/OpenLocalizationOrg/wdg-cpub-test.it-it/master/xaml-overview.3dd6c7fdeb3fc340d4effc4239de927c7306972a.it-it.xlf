<?xml version="1.0" encoding="utf-8"?>
<xliff srcLang="en-US" trgLang="it-it" version="2.0" xmlns="urn:oasis:names:tc:xliff:document:2.0" xmlns:mda="urn:oasis:names:tc:xliff:metadata:2.0">
  <file id="1">
    <mda:metadata>
      <mda:metaGroup>
        <mda:meta type="olfilehash">0650191324964593b8b3fc54b757648253b95caa</mda:meta>
      </mda:metaGroup>
    </mda:metadata>
    <group id="content">
      <unit id="101">
        <segment state="initial">
          <source xml:space="preserve">description: We introduce the XAML language and XAML concepts to the Windows Runtime app developer audience, and describe the different ways to declare objects and set attributes in XAML as it is used for creating a Windows Runtime app.</source>
          <target xml:space="preserve">description: We introduce the XAML language and XAML concepts to the Windows Runtime app developer audience, and describe the different ways to declare objects and set attributes in XAML as it is used for creating a Windows Runtime app.</target>
        </segment>
      </unit>
      <unit id="102">
        <segment state="initial">
          <source xml:space="preserve">title: XAML overview</source>
          <target xml:space="preserve">title: XAML overview</target>
        </segment>
      </unit>
      <unit id="103">
        <segment state="initial">
          <source xml:space="preserve">ms.assetid: 48041B37-F1A8-44A4-BB8E-1D4DE30E7823</source>
          <target xml:space="preserve">ms.assetid: 48041B37-F1A8-44A4-BB8E-1D4DE30E7823</target>
        </segment>
      </unit>
      <unit id="104">
        <segment state="initial">
          <source xml:space="preserve">XAML overview</source>
          <target xml:space="preserve">XAML overview</target>
        </segment>
      </unit>
      <unit id="105">
        <segment state="initial">
          <source xml:space="preserve">\[ Updated for UWP apps on Windows 10.</source>
          <target xml:space="preserve">\[ Updated for UWP apps on Windows 10.</target>
        </segment>
      </unit>
      <unit id="106">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](http://go.microsoft.com/fwlink/p/?linkid=619132)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</source>
          <target xml:space="preserve">For Windows 8.x articles, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">archive</pc> \]</target>
        </segment>
      </unit>
      <unit id="107">
        <segment state="initial">
          <source xml:space="preserve">We introduce the XAML language and XAML concepts to the Windows Runtime app developer audience, and describe the different ways to declare objects and set attributes in XAML as it is used for creating a Windows Runtime app.</source>
          <target xml:space="preserve">We introduce the XAML language and XAML concepts to the Windows Runtime app developer audience, and describe the different ways to declare objects and set attributes in XAML as it is used for creating a Windows Runtime app.</target>
        </segment>
      </unit>
      <unit id="108">
        <segment state="initial">
          <source xml:space="preserve">What is XAML?</source>
          <target xml:space="preserve">What is XAML?</target>
        </segment>
      </unit>
      <unit id="109">
        <segment state="initial">
          <source xml:space="preserve">Extensible Application Markup Language (XAML) is a declarative language.</source>
          <target xml:space="preserve">Extensible Application Markup Language (XAML) is a declarative language.</target>
        </segment>
      </unit>
      <unit id="110">
        <segment state="initial">
          <source xml:space="preserve">Specifically, XAML can initialize objects and set properties of objects, using a language structure that shows hierarchical relationships between multiple objects, and using a backing type convention that supports extension of types.</source>
          <target xml:space="preserve">Specifically, XAML can initialize objects and set properties of objects, using a language structure that shows hierarchical relationships between multiple objects, and using a backing type convention that supports extension of types.</target>
        </segment>
      </unit>
      <unit id="111">
        <segment state="initial">
          <source xml:space="preserve">You can create visible UI elements in the declarative XAML markup.</source>
          <target xml:space="preserve">You can create visible UI elements in the declarative XAML markup.</target>
        </segment>
      </unit>
      <unit id="112">
        <segment state="initial">
          <source xml:space="preserve">You can then associate a separate code-behind file for each XAML file that can respond to events and manipulate the objects that you originally declare in XAML.</source>
          <target xml:space="preserve">You can then associate a separate code-behind file for each XAML file that can respond to events and manipulate the objects that you originally declare in XAML.</target>
        </segment>
      </unit>
      <unit id="113">
        <segment state="initial">
          <source xml:space="preserve">The XAML language supports interchange of sources between different tools and roles in the development process, such as exchanging XAML sources between design tools and an IDE, or between primary developers and localization developers.</source>
          <target xml:space="preserve">The XAML language supports interchange of sources between different tools and roles in the development process, such as exchanging XAML sources between design tools and an IDE, or between primary developers and localization developers.</target>
        </segment>
      </unit>
      <unit id="114">
        <segment state="initial">
          <source xml:space="preserve">By using XAML as the interchange format, designer roles and developer roles can be kept separate or brought together, and designers and developers can iterate during the production of an app.</source>
          <target xml:space="preserve">By using XAML as the interchange format, designer roles and developer roles can be kept separate or brought together, and designers and developers can iterate during the production of an app.</target>
        </segment>
      </unit>
      <unit id="115">
        <segment state="initial">
          <source xml:space="preserve">When you see them as part of your Windows Runtime app projects, XAML files are XML files with the .xaml file name extension.</source>
          <target xml:space="preserve">When you see them as part of your Windows Runtime app projects, XAML files are XML files with the .xaml file name extension.</target>
        </segment>
      </unit>
      <unit id="116">
        <segment state="initial">
          <source xml:space="preserve">Basic XAML syntax</source>
          <target xml:space="preserve">Basic XAML syntax</target>
        </segment>
      </unit>
      <unit id="117">
        <segment state="initial">
          <source xml:space="preserve">XAML has a basic syntax that builds on XML.</source>
          <target xml:space="preserve">XAML has a basic syntax that builds on XML.</target>
        </segment>
      </unit>
      <unit id="118">
        <segment state="initial">
          <source xml:space="preserve">By definition, valid XAML must also be valid XML.</source>
          <target xml:space="preserve">By definition, valid XAML must also be valid XML.</target>
        </segment>
      </unit>
      <unit id="119">
        <segment state="initial">
          <source xml:space="preserve">But XAML also has syntax concepts that are assigned a different and more complete meaning, while still being valid in XML per the XML 1.0 specification.</source>
          <target xml:space="preserve">But XAML also has syntax concepts that are assigned a different and more complete meaning, while still being valid in XML per the XML 1.0 specification.</target>
        </segment>
      </unit>
      <unit id="120">
        <originalData>
          <data id="id1">*</data>
          <data id="id2">*</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, XAML supports <pc dataRefEnd="id2" dataRefStart="id1" id="p1">property element syntax</pc>, where property values can be set within elements rather than as string values in attributes or as content.</source>
          <target xml:space="preserve">For example, XAML supports <pc dataRefEnd="id2" dataRefStart="id1" id="p1">property element syntax</pc>, where property values can be set within elements rather than as string values in attributes or as content.</target>
        </segment>
      </unit>
      <unit id="121">
        <segment state="initial">
          <source xml:space="preserve">To regular XML, a XAML property element is an element with a dot in its name, so it's valid to plain XML but doesn't have the same meaning.</source>
          <target xml:space="preserve">To regular XML, a XAML property element is an element with a dot in its name, so it's valid to plain XML but doesn't have the same meaning.</target>
        </segment>
      </unit>
      <unit id="122">
        <segment state="initial">
          <source xml:space="preserve">XAML and Microsoft Visual Studio</source>
          <target xml:space="preserve">XAML and Microsoft Visual Studio</target>
        </segment>
      </unit>
      <unit id="123">
        <segment state="initial">
          <source xml:space="preserve">Microsoft Visual Studio helps you to produce valid XAML syntax, both in the XAML text editor and in the more graphically oriented XAML design surface.</source>
          <target xml:space="preserve">Microsoft Visual Studio helps you to produce valid XAML syntax, both in the XAML text editor and in the more graphically oriented XAML design surface.</target>
        </segment>
      </unit>
      <unit id="124">
        <segment state="initial">
          <source xml:space="preserve">So when you write XAML for your app using Visual Studio, don't worry too much about the syntax with each keystroke.</source>
          <target xml:space="preserve">So when you write XAML for your app using Visual Studio, don't worry too much about the syntax with each keystroke.</target>
        </segment>
      </unit>
      <unit id="125">
        <segment state="initial">
          <source xml:space="preserve">The IDE encourages valid XAML syntax by providing autocompletion hints, showing suggestions in Microsoft IntelliSense lists and dropdowns, showing UI element libraries in the toolbox, or other techniques.</source>
          <target xml:space="preserve">The IDE encourages valid XAML syntax by providing autocompletion hints, showing suggestions in Microsoft IntelliSense lists and dropdowns, showing UI element libraries in the toolbox, or other techniques.</target>
        </segment>
      </unit>
      <unit id="126">
        <segment state="initial">
          <source xml:space="preserve">If this is your first experience with XAML, it might still be useful to know the syntax rules and particularly the terminology that is sometimes used to describe the restrictions or choices when we describe XAML syntax in reference or other topics.</source>
          <target xml:space="preserve">If this is your first experience with XAML, it might still be useful to know the syntax rules and particularly the terminology that is sometimes used to describe the restrictions or choices when we describe XAML syntax in reference or other topics.</target>
        </segment>
      </unit>
      <unit id="127">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](xaml-syntax-guide.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">We cover these fine points of XAML syntax in a separate topic, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML syntax guide</pc>.</source>
          <target xml:space="preserve">We cover these fine points of XAML syntax in a separate topic, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML syntax guide</pc>.</target>
        </segment>
      </unit>
      <unit id="128">
        <segment state="initial">
          <source xml:space="preserve">XAML namespaces</source>
          <target xml:space="preserve">XAML namespaces</target>
        </segment>
      </unit>
      <unit id="129">
        <segment state="initial">
          <source xml:space="preserve">In general programming, a namespace is an organizing concept that determines how identifiers for programming entities are interpreted.</source>
          <target xml:space="preserve">In general programming, a namespace is an organizing concept that determines how identifiers for programming entities are interpreted.</target>
        </segment>
      </unit>
      <unit id="130">
        <segment state="initial">
          <source xml:space="preserve">By using namespaces, a programming framework can separate user-declared identifiers from framework-declared identifiers, disambiguate identifiers through namespace qualifications, enforce rules for scoping names, and so on.</source>
          <target xml:space="preserve">By using namespaces, a programming framework can separate user-declared identifiers from framework-declared identifiers, disambiguate identifiers through namespace qualifications, enforce rules for scoping names, and so on.</target>
        </segment>
      </unit>
      <unit id="131">
        <segment state="initial">
          <source xml:space="preserve">XAML has its own XAML namespace concept that serves this purpose for the XAML language.</source>
          <target xml:space="preserve">XAML has its own XAML namespace concept that serves this purpose for the XAML language.</target>
        </segment>
      </unit>
      <unit id="132">
        <segment state="initial">
          <source xml:space="preserve">Here's how XAML applies and extends the XML language namespace concepts:</source>
          <target xml:space="preserve">Here's how XAML applies and extends the XML language namespace concepts:</target>
        </segment>
      </unit>
      <unit id="133">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">XAML uses the reserved XML attribute <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> for namespace declarations.</source>
          <target xml:space="preserve">XAML uses the reserved XML attribute <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> for namespace declarations.</target>
        </segment>
      </unit>
      <unit id="134">
        <segment state="initial">
          <source xml:space="preserve">The value of the attribute is typically a Uniform Resource Identifier (URI), which is a convention inherited from XML.</source>
          <target xml:space="preserve">The value of the attribute is typically a Uniform Resource Identifier (URI), which is a convention inherited from XML.</target>
        </segment>
      </unit>
      <unit id="135">
        <segment state="initial">
          <source xml:space="preserve">XAML uses prefixes in declarations to declare non-default namespaces, and prefix usages in elements and attributes reference that namespace.</source>
          <target xml:space="preserve">XAML uses prefixes in declarations to declare non-default namespaces, and prefix usages in elements and attributes reference that namespace.</target>
        </segment>
      </unit>
      <unit id="136">
        <segment state="initial">
          <source xml:space="preserve">XAML has a concept of a default namespace, which is the namespace used when no prefix exists in a usage or declaration.</source>
          <target xml:space="preserve">XAML has a concept of a default namespace, which is the namespace used when no prefix exists in a usage or declaration.</target>
        </segment>
      </unit>
      <unit id="137">
        <segment state="initial">
          <source xml:space="preserve">The default namespace can be defined differently for each XAML programming framework.</source>
          <target xml:space="preserve">The default namespace can be defined differently for each XAML programming framework.</target>
        </segment>
      </unit>
      <unit id="138">
        <segment state="initial">
          <source xml:space="preserve">Namespace definitions inherit in a XAML file or construct, from parent element to child element.</source>
          <target xml:space="preserve">Namespace definitions inherit in a XAML file or construct, from parent element to child element.</target>
        </segment>
      </unit>
      <unit id="139">
        <segment state="initial">
          <source xml:space="preserve">For example if you define a namespace in the root element of a XAML file, all elements within that file inherit that namespace definition.</source>
          <target xml:space="preserve">For example if you define a namespace in the root element of a XAML file, all elements within that file inherit that namespace definition.</target>
        </segment>
      </unit>
      <unit id="140">
        <segment state="initial">
          <source xml:space="preserve">If an element further into the page redefines the namespace, that element's descendants inherit the new definition.</source>
          <target xml:space="preserve">If an element further into the page redefines the namespace, that element's descendants inherit the new definition.</target>
        </segment>
      </unit>
      <unit id="141">
        <segment state="initial">
          <source xml:space="preserve">Attributes of an element inherit the element's namespaces.</source>
          <target xml:space="preserve">Attributes of an element inherit the element's namespaces.</target>
        </segment>
      </unit>
      <unit id="142">
        <segment state="initial">
          <source xml:space="preserve">It's fairly uncommon to see prefixes on XAML attributes.</source>
          <target xml:space="preserve">It's fairly uncommon to see prefixes on XAML attributes.</target>
        </segment>
      </unit>
      <unit id="143">
        <segment state="initial">
          <source xml:space="preserve">A XAML file almost always declares a default XAML namespace in its root element.</source>
          <target xml:space="preserve">A XAML file almost always declares a default XAML namespace in its root element.</target>
        </segment>
      </unit>
      <unit id="144">
        <segment state="initial">
          <source xml:space="preserve">The default XAML namespace defines which elements you can declare without qualifying them by a prefix.</source>
          <target xml:space="preserve">The default XAML namespace defines which elements you can declare without qualifying them by a prefix.</target>
        </segment>
      </unit>
      <unit id="145">
        <segment state="initial">
          <source xml:space="preserve">For typical Windows Runtime app projects, this default namespace contains all the built-in XAML vocabulary for the Windows Runtime that's used for UI definitions: the default controls, text elements, XAML graphics and animations, databinding and styling support types, and so on.</source>
          <target xml:space="preserve">For typical Windows Runtime app projects, this default namespace contains all the built-in XAML vocabulary for the Windows Runtime that's used for UI definitions: the default controls, text elements, XAML graphics and animations, databinding and styling support types, and so on.</target>
        </segment>
      </unit>
      <unit id="146">
        <segment state="initial">
          <source xml:space="preserve">Most of the XAML you'll write for Windows Runtime apps will thus be able to avoid using XAML namespaces and prefixes when referring to common UI elements.</source>
          <target xml:space="preserve">Most of the XAML you'll write for Windows Runtime apps will thus be able to avoid using XAML namespaces and prefixes when referring to common UI elements.</target>
        </segment>
      </unit>
      <unit id="147">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227503)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Here's a snippet showing a template-created <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Page</pc></pc> root of the initial page for an app (showing the opening tag only, and simplified).</source>
          <target xml:space="preserve">Here's a snippet showing a template-created <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Page</pc></pc> root of the initial page for an app (showing the opening tag only, and simplified).</target>
        </segment>
      </unit>
      <unit id="148">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">It declares the default namespace and also the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x</pc> namespace (which we'll explain next).</source>
          <target xml:space="preserve">It declares the default namespace and also the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x</pc> namespace (which we'll explain next).</target>
        </segment>
      </unit>
      <unit id="149">
        <segment state="initial">
          <source xml:space="preserve">The XAML-language XAML namespace</source>
          <target xml:space="preserve">The XAML-language XAML namespace</target>
        </segment>
      </unit>
      <unit id="150">
        <segment state="initial">
          <source xml:space="preserve">One particular XAML namespace that is declared in nearly every Windows Runtime XAML file is the XAML-language namespace.</source>
          <target xml:space="preserve">One particular XAML namespace that is declared in nearly every Windows Runtime XAML file is the XAML-language namespace.</target>
        </segment>
      </unit>
      <unit id="151">
        <segment state="initial">
          <source xml:space="preserve">This namespace includes elements and concepts that are defined by the XAML language, by its language specification.</source>
          <target xml:space="preserve">This namespace includes elements and concepts that are defined by the XAML language, by its language specification.</target>
        </segment>
      </unit>
      <unit id="152">
        <segment state="initial">
          <source xml:space="preserve">By convention, the XAML-language XAML namespace is mapped to the prefix "x".</source>
          <target xml:space="preserve">By convention, the XAML-language XAML namespace is mapped to the prefix "x".</target>
        </segment>
      </unit>
      <unit id="153">
        <originalData>
          <data id="id1">`xmlns=`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The default project and file templates for Windows Runtime app projects always define both the default XAML namespace (no prefix, just <ph dataRef="id1" id="ph1" />) and the XAML-language XAML namespace (prefix "x") as part of the root element.</source>
          <target xml:space="preserve">The default project and file templates for Windows Runtime app projects always define both the default XAML namespace (no prefix, just <ph dataRef="id1" id="ph1" />) and the XAML-language XAML namespace (prefix "x") as part of the root element.</target>
        </segment>
      </unit>
      <unit id="154">
        <segment state="initial">
          <source xml:space="preserve">The "x" prefix/XAML-language XAML namespace contains several programming constructs that you use often in your XAML.</source>
          <target xml:space="preserve">The "x" prefix/XAML-language XAML namespace contains several programming constructs that you use often in your XAML.</target>
        </segment>
      </unit>
      <unit id="155">
        <segment state="initial">
          <source xml:space="preserve">Here are the most common ones:</source>
          <target xml:space="preserve">Here are the most common ones:</target>
        </segment>
      </unit>
      <unit id="156">
        <segment state="initial">
          <source xml:space="preserve">Term</source>
          <target xml:space="preserve">Term</target>
        </segment>
      </unit>
      <unit id="157">
        <segment state="initial">
          <source xml:space="preserve">Description</source>
          <target xml:space="preserve">Description</target>
        </segment>
      </unit>
      <unit id="158">
        <segment state="initial">
          <source xml:space="preserve">x:Key</source>
          <target xml:space="preserve">x:Key</target>
        </segment>
      </unit>
      <unit id="159">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Sets a unique user-defined key for each resource in a XAML <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>.</source>
          <target xml:space="preserve">Sets a unique user-defined key for each resource in a XAML <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="160">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The key's token string is the argument for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc> markup extension, and you use this key later to retrieve the XAML resource from another XAML usage elsewhere in your app's XAML.</source>
          <target xml:space="preserve">The key's token string is the argument for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc> markup extension, and you use this key later to retrieve the XAML resource from another XAML usage elsewhere in your app's XAML.</target>
        </segment>
      </unit>
      <unit id="161">
        <segment state="initial">
          <source xml:space="preserve">x:Class</source>
          <target xml:space="preserve">x:Class</target>
        </segment>
      </unit>
      <unit id="162">
        <segment state="initial">
          <source xml:space="preserve">Specifies the code namespace and code class name for the class that provides code-behind for a XAML page.</source>
          <target xml:space="preserve">Specifies the code namespace and code class name for the class that provides code-behind for a XAML page.</target>
        </segment>
      </unit>
      <unit id="163">
        <segment state="initial">
          <source xml:space="preserve">This names the class that is created or joined by the build actions when you build your app.</source>
          <target xml:space="preserve">This names the class that is created or joined by the build actions when you build your app.</target>
        </segment>
      </unit>
      <unit id="164">
        <segment state="initial">
          <source xml:space="preserve">These build actions support the XAML markup compiler and combine your markup and code-behind when the app is compiled.</source>
          <target xml:space="preserve">These build actions support the XAML markup compiler and combine your markup and code-behind when the app is compiled.</target>
        </segment>
      </unit>
      <unit id="165">
        <segment state="initial">
          <source xml:space="preserve">You must have such a class to support code-behind for a XAML page.</source>
          <target xml:space="preserve">You must have such a class to support code-behind for a XAML page.</target>
        </segment>
      </unit>
      <unit id="166">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209051)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Window.Content</pc>
						</pc> in the default Windows Runtime activation model.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">
							<pc dataRefEnd="id4" dataRefStart="id3" id="p2">Window.Content</pc>
						</pc> in the default Windows Runtime activation model.</target>
        </segment>
      </unit>
      <unit id="167">
        <segment state="initial">
          <source xml:space="preserve">x:Name</source>
          <target xml:space="preserve">x:Name</target>
        </segment>
      </unit>
      <unit id="168">
        <segment state="initial">
          <source xml:space="preserve">Specifies a run-time object name for the instance that exists in run-time code after an object element defined in XAML is processed.</source>
          <target xml:space="preserve">Specifies a run-time object name for the instance that exists in run-time code after an object element defined in XAML is processed.</target>
        </segment>
      </unit>
      <unit id="169">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can think of setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> in XAML as being like declaring a named variable in code.</source>
          <target xml:space="preserve">You can think of setting <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> in XAML as being like declaring a named variable in code.</target>
        </segment>
      </unit>
      <unit id="170">
        <segment state="initial">
          <source xml:space="preserve">As you'll learn later, that's exactly what happens when your XAML is loaded as a component of a Windows Runtime app.</source>
          <target xml:space="preserve">As you'll learn later, that's exactly what happens when your XAML is loaded as a component of a Windows Runtime app.</target>
        </segment>
      </unit>
      <unit id="171">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208735)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElement.Name</pc></pc> is a similar property in the framework but not all elements support it.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">FrameworkElement.Name</pc></pc> is a similar property in the framework but not all elements support it.</target>
        </segment>
      </unit>
      <unit id="172">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">So you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> for element identification, whenever <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Name</pc> is not supported on that element type.</source>
          <target xml:space="preserve">So you use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> for element identification, whenever <pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Name</pc> is not supported on that element type.</target>
        </segment>
      </unit>
      <unit id="173">
        <segment state="initial">
          <source xml:space="preserve">x:Uid</source>
          <target xml:space="preserve">x:Uid</target>
        </segment>
      </unit>
      <unit id="174">
        <segment state="initial">
          <source xml:space="preserve">Identifies elements that should use localized resources for some of their property values.</source>
          <target xml:space="preserve">Identifies elements that should use localized resources for some of their property values.</target>
        </segment>
      </unit>
      <unit id="175">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/xaml/hh965329)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on how to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Uid</pc>, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Quickstart: Translating UI resources</pc>.</source>
          <target xml:space="preserve">For more info on how to use <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Uid</pc>, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Quickstart: Translating UI resources</pc>.</target>
        </segment>
      </unit>
      <unit id="176">
        <segment state="initial">
          <source xml:space="preserve">XAML intrinsic data types</source>
          <target xml:space="preserve">XAML intrinsic data types</target>
        </segment>
      </unit>
      <unit id="177">
        <segment state="initial">
          <source xml:space="preserve">These types can specify values for simple value-types when that's required for an attribute or resource.</source>
          <target xml:space="preserve">These types can specify values for simple value-types when that's required for an attribute or resource.</target>
        </segment>
      </unit>
      <unit id="178">
        <segment state="initial">
          <source xml:space="preserve">These intrinsic types correspond to the simple value types that are typically defined as part of each programming language's intrinsic definitions.</source>
          <target xml:space="preserve">These intrinsic types correspond to the simple value types that are typically defined as part of each programming language's intrinsic definitions.</target>
        </segment>
      </unit>
      <unit id="179">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br210320)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, you might need an object representing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc> Boolean value to use in an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ObjectAnimationUsingKeyFrames</pc></pc> storyboarded visual state.</source>
          <target xml:space="preserve">For example, you might need an object representing a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">true</pc> Boolean value to use in an <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ObjectAnimationUsingKeyFrames</pc></pc> storyboarded visual state.</target>
        </segment>
      </unit>
      <unit id="180">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">&lt;code&gt;</data>
          <data id="id4">&amp;lt;x:Boolean&amp;gt;True&amp;lt;/x:Boolean&amp;gt;</data>
          <data id="id5">&lt;/code&gt;</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For that value in XAML, you'd use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Boolean</pc> intrinsic type as the object element, like this: <ph dataRef="id3" id="ph1" /><ph dataRef="id4" id="ph2" /><ph dataRef="id5" id="ph3" /></source>
          <target xml:space="preserve">For that value in XAML, you'd use the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Boolean</pc> intrinsic type as the object element, like this: <ph dataRef="id3" id="ph1" /><ph dataRef="id4" id="ph2" /><ph dataRef="id5" id="ph3" /></target>
        </segment>
      </unit>
      <unit id="181">
        <segment state="initial">
          <source xml:space="preserve">Other programming constructs in the XAML-language XAML namespace exist but are not as common.</source>
          <target xml:space="preserve">Other programming constructs in the XAML-language XAML namespace exist but are not as common.</target>
        </segment>
      </unit>
      <unit id="182">
        <segment state="initial">
          <source xml:space="preserve">Mapping custom types to XAML namespaces</source>
          <target xml:space="preserve">Mapping custom types to XAML namespaces</target>
        </segment>
      </unit>
      <unit id="183">
        <segment state="initial">
          <source xml:space="preserve">One of the most powerful aspects of XAML as a language is that it's easy to extend the XAML vocabulary for your Windows Runtime apps.</source>
          <target xml:space="preserve">One of the most powerful aspects of XAML as a language is that it's easy to extend the XAML vocabulary for your Windows Runtime apps.</target>
        </segment>
      </unit>
      <unit id="184">
        <segment state="initial">
          <source xml:space="preserve">You can define your own custom types in your app's programming language and then reference your custom types in XAML markup.</source>
          <target xml:space="preserve">You can define your own custom types in your app's programming language and then reference your custom types in XAML markup.</target>
        </segment>
      </unit>
      <unit id="185">
        <segment state="initial">
          <source xml:space="preserve">Support for extension through custom types is fundamentally built-in to how the XAML language works.</source>
          <target xml:space="preserve">Support for extension through custom types is fundamentally built-in to how the XAML language works.</target>
        </segment>
      </unit>
      <unit id="186">
        <segment state="initial">
          <source xml:space="preserve">Frameworks or app developers are responsible for creating the backing objects that XAML references.</source>
          <target xml:space="preserve">Frameworks or app developers are responsible for creating the backing objects that XAML references.</target>
        </segment>
      </unit>
      <unit id="187">
        <segment state="initial">
          <source xml:space="preserve">Neither frameworks nor the app developer are bound by specifications of what the objects in their vocabularies represent or do beyond the basic XAML syntax rules (there are some expectations of what the XAML-language XAML namespace types should do, but the Windows Runtime provides all the necessary support).</source>
          <target xml:space="preserve">Neither frameworks nor the app developer are bound by specifications of what the objects in their vocabularies represent or do beyond the basic XAML syntax rules (there are some expectations of what the XAML-language XAML namespace types should do, but the Windows Runtime provides all the necessary support).</target>
        </segment>
      </unit>
      <unit id="188">
        <segment state="initial">
          <source xml:space="preserve">If you use XAML for types that come from libraries other than the Windows Runtime core libraries and metadata, you must declare and map a XAML namespace with a prefix.</source>
          <target xml:space="preserve">If you use XAML for types that come from libraries other than the Windows Runtime core libraries and metadata, you must declare and map a XAML namespace with a prefix.</target>
        </segment>
      </unit>
      <unit id="189">
        <segment state="initial">
          <source xml:space="preserve">Use that prefix in element usages to reference the types that were defined in your library.</source>
          <target xml:space="preserve">Use that prefix in element usages to reference the types that were defined in your library.</target>
        </segment>
      </unit>
      <unit id="190">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You declare prefix mappings as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> attributes, typically in a root element along with the other XAML namespace definitions.</source>
          <target xml:space="preserve">You declare prefix mappings as <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns</pc> attributes, typically in a root element along with the other XAML namespace definitions.</target>
        </segment>
      </unit>
      <unit id="191">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To make your own namespace definition that references custom types, you first specify the keyword <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns:</pc>, then the prefix you want.</source>
          <target xml:space="preserve">To make your own namespace definition that references custom types, you first specify the keyword <pc dataRefEnd="id2" dataRefStart="id1" id="p1">xmlns:</pc>, then the prefix you want.</target>
        </segment>
      </unit>
      <unit id="192">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The value of that attribute must contain the keyword <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using:</pc> as the first part of the value.</source>
          <target xml:space="preserve">The value of that attribute must contain the keyword <pc dataRefEnd="id2" dataRefStart="id1" id="p1">using:</pc> as the first part of the value.</target>
        </segment>
      </unit>
      <unit id="193">
        <segment state="initial">
          <source xml:space="preserve">The remainder of the value is a string token that references the specific code-backing namespace that contains your custom types, by name.</source>
          <target xml:space="preserve">The remainder of the value is a string token that references the specific code-backing namespace that contains your custom types, by name.</target>
        </segment>
      </unit>
      <unit id="194">
        <segment state="initial">
          <source xml:space="preserve">The prefix defines the markup token that is used to refer to that XAML namespace in the remainder of the markup in that XAML file.</source>
          <target xml:space="preserve">The prefix defines the markup token that is used to refer to that XAML namespace in the remainder of the markup in that XAML file.</target>
        </segment>
      </unit>
      <unit id="195">
        <segment state="initial">
          <source xml:space="preserve">A colon character (:) goes between the prefix and the entity to be referenced within the XAML namespace.</source>
          <target xml:space="preserve">A colon character (:) goes between the prefix and the entity to be referenced within the XAML namespace.</target>
        </segment>
      </unit>
      <unit id="196">
        <originalData>
          <data id="id1">`myTypes`</data>
          <data id="id2">`myCompany.myTypes`</data>
          <data id="id3">`    xmlns:myTypes="using:myCompany.myTypes"`</data>
          <data id="id4">`&lt;myTypes:CustomButton/&gt;`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, the attribute syntax to map a prefix <ph dataRef="id1" id="ph1" /> to the namespace <ph dataRef="id2" id="ph2" /> is: <ph dataRef="id3" id="ph3" />, and a representative element usage is: <ph dataRef="id4" id="ph4" /></source>
          <target xml:space="preserve">For example, the attribute syntax to map a prefix <ph dataRef="id1" id="ph1" /> to the namespace <ph dataRef="id2" id="ph2" /> is: <ph dataRef="id3" id="ph3" />, and a representative element usage is: <ph dataRef="id4" id="ph4" /></target>
        </segment>
      </unit>
      <unit id="197">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](xaml-namespaces-and-namespace-mapping.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on mapping XAML namespaces for custom types, including special considerations for Visual C++ component extensions (C++/CX), see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namespaces and namespace mapping</pc>.</source>
          <target xml:space="preserve">For more info on mapping XAML namespaces for custom types, including special considerations for Visual C++ component extensions (C++/CX), see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namespaces and namespace mapping</pc>.</target>
        </segment>
      </unit>
      <unit id="198">
        <segment state="initial">
          <source xml:space="preserve">Other XAML namespaces</source>
          <target xml:space="preserve">Other XAML namespaces</target>
        </segment>
      </unit>
      <unit id="199">
        <segment state="initial">
          <source xml:space="preserve">You often see XAML files that define the prefixes "d" (for designer namespace) and "mc" (for markup compatibility).</source>
          <target xml:space="preserve">You often see XAML files that define the prefixes "d" (for designer namespace) and "mc" (for markup compatibility).</target>
        </segment>
      </unit>
      <unit id="200">
        <segment state="initial">
          <source xml:space="preserve">Generally these are for infrastructure support, or to enable scenarios in a design-time tool.</source>
          <target xml:space="preserve">Generally these are for infrastructure support, or to enable scenarios in a design-time tool.</target>
        </segment>
      </unit>
      <unit id="201">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](xaml-namespaces-and-namespace-mapping.md#other-XAML-namespaces)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">"Other XAML namespaces" section of the XAML namespaces topic</pc>.</source>
          <target xml:space="preserve">For more info, see the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">"Other XAML namespaces" section of the XAML namespaces topic</pc>.</target>
        </segment>
      </unit>
      <unit id="202">
        <segment state="initial">
          <source xml:space="preserve">Markup extensions</source>
          <target xml:space="preserve">Markup extensions</target>
        </segment>
      </unit>
      <unit id="203">
        <segment state="initial">
          <source xml:space="preserve">Markup extensions are a XAML language concept that is often used in the Windows Runtime XAML implementation.</source>
          <target xml:space="preserve">Markup extensions are a XAML language concept that is often used in the Windows Runtime XAML implementation.</target>
        </segment>
      </unit>
      <unit id="204">
        <segment state="initial">
          <source xml:space="preserve">Markup extensions often represent some kind of "shortcut" that enables a XAML file to access a value or behavior that isn't simply declaring elements based on backing types.</source>
          <target xml:space="preserve">Markup extensions often represent some kind of "shortcut" that enables a XAML file to access a value or behavior that isn't simply declaring elements based on backing types.</target>
        </segment>
      </unit>
      <unit id="205">
        <segment state="initial">
          <source xml:space="preserve">Some markup extensions can set properties with plain strings or with additionally nested elements, with the goal of streamlining the syntax or the factoring between different XAML files.</source>
          <target xml:space="preserve">Some markup extensions can set properties with plain strings or with additionally nested elements, with the goal of streamlining the syntax or the factoring between different XAML files.</target>
        </segment>
      </unit>
      <unit id="206">
        <segment state="initial">
          <source xml:space="preserve">In XAML attribute syntax, curly braces "{" and "}" indicate a XAML markup extension usage.</source>
          <target xml:space="preserve">In XAML attribute syntax, curly braces "{" and "}" indicate a XAML markup extension usage.</target>
        </segment>
      </unit>
      <unit id="207">
        <segment state="initial">
          <source xml:space="preserve">This usage directs the XAML processing to escape from the general treatment of treating attribute values as either a literal string or a directly string-convertible value.</source>
          <target xml:space="preserve">This usage directs the XAML processing to escape from the general treatment of treating attribute values as either a literal string or a directly string-convertible value.</target>
        </segment>
      </unit>
      <unit id="208">
        <segment state="initial">
          <source xml:space="preserve">Instead, a XAML parser calls code that provides behavior for that particular markup extension, and that code provides an alternate object or behavior result that the XAML parser needs.</source>
          <target xml:space="preserve">Instead, a XAML parser calls code that provides behavior for that particular markup extension, and that code provides an alternate object or behavior result that the XAML parser needs.</target>
        </segment>
      </unit>
      <unit id="209">
        <segment state="initial">
          <source xml:space="preserve">Markup extensions can have arguments, which follow the markup extension name and are also contained within the curly braces.</source>
          <target xml:space="preserve">Markup extensions can have arguments, which follow the markup extension name and are also contained within the curly braces.</target>
        </segment>
      </unit>
      <unit id="210">
        <segment state="initial">
          <source xml:space="preserve">Typically, an evaluated markup extension provides an object return value.</source>
          <target xml:space="preserve">Typically, an evaluated markup extension provides an object return value.</target>
        </segment>
      </unit>
      <unit id="211">
        <segment state="initial">
          <source xml:space="preserve">During parsing, that return value is inserted into the position in the object tree where the markup extension usage was in the source XAML.</source>
          <target xml:space="preserve">During parsing, that return value is inserted into the position in the object tree where the markup extension usage was in the source XAML.</target>
        </segment>
      </unit>
      <unit id="212">
        <segment state="initial">
          <source xml:space="preserve">Windows Runtime XAML supports these markup extensions that are defined under the default XAML namespace and are understood by the Windows Runtime XAML parser:</source>
          <target xml:space="preserve">Windows Runtime XAML supports these markup extensions that are defined under the default XAML namespace and are understood by the Windows Runtime XAML parser:</target>
        </segment>
      </unit>
      <unit id="213">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](x-bind-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{xBind}</pc>: supports data binding, which defers property evaluation until run-time by executing special-purpose code, which it generates at compile-time.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{xBind}</pc>: supports data binding, which defers property evaluation until run-time by executing special-purpose code, which it generates at compile-time.</target>
        </segment>
      </unit>
      <unit id="214">
        <segment state="initial">
          <source xml:space="preserve">This markup extension supports a wide range of arguments.</source>
          <target xml:space="preserve">This markup extension supports a wide range of arguments.</target>
        </segment>
      </unit>
      <unit id="215">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](binding-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc>: supports data binding, which defers property evaluation until run-time by executing general-purpose runtime object inspection.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{Binding}</pc>: supports data binding, which defers property evaluation until run-time by executing general-purpose runtime object inspection.</target>
        </segment>
      </unit>
      <unit id="216">
        <segment state="initial">
          <source xml:space="preserve">This markup extension supports a wide range of arguments.</source>
          <target xml:space="preserve">This markup extension supports a wide range of arguments.</target>
        </segment>
      </unit>
      <unit id="217">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](staticresource-markup-extension.md)</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{StaticResource}</pc>: supports referencing resource values that are defined in a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ResourceDictionary</pc></pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{StaticResource}</pc>: supports referencing resource values that are defined in a <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">ResourceDictionary</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="218">
        <segment state="initial">
          <source xml:space="preserve">These resources can be in a different XAML file but must ultimately be findable by the XAML parser at load time.</source>
          <target xml:space="preserve">These resources can be in a different XAML file but must ultimately be findable by the XAML parser at load time.</target>
        </segment>
      </unit>
      <unit id="219">
        <originalData>
          <data id="id1">`{StaticResource}`</data>
          <data id="id2">[</data>
          <data id="id3">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The argument of a <ph dataRef="id1" id="ph1" /> usage identifies the key (the name) for a keyed resource in a <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">ResourceDictionary</pc></pc>.</source>
          <target xml:space="preserve">The argument of a <ph dataRef="id1" id="ph1" /> usage identifies the key (the name) for a keyed resource in a <pc dataRefEnd="id3" dataRefStart="id2" id="p1"><pc dataRefEnd="id5" dataRefStart="id4" id="p2">ResourceDictionary</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="220">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](themeresource-markup-extension.md)</data>
          <data id="id3">[</data>
          <data id="id4">](staticresource-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{ThemeResource}</pc>: similar to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{StaticResource}</pc> but can respond to run-time theme changes.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{ThemeResource}</pc>: similar to <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{StaticResource}</pc> but can respond to run-time theme changes.</target>
        </segment>
      </unit>
      <unit id="221">
        <segment state="initial">
          <source xml:space="preserve">{ThemeResource} appears quite often in the Windows Runtime default XAML templates, because most of these templates are designed for compatibility with the user switching the theme while the app is running.</source>
          <target xml:space="preserve">{ThemeResource} appears quite often in the Windows Runtime default XAML templates, because most of these templates are designed for compatibility with the user switching the theme while the app is running.</target>
        </segment>
      </unit>
      <unit id="222">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](templatebinding-markup-extension.md)</data>
          <data id="id3">[</data>
          <data id="id4">](binding-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{TemplateBinding}</pc>: a special case of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> that supports control templates in XAML and their eventual usage at run time.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{TemplateBinding}</pc>: a special case of <pc dataRefEnd="id4" dataRefStart="id3" id="p2">{Binding}</pc> that supports control templates in XAML and their eventual usage at run time.</target>
        </segment>
      </unit>
      <unit id="223">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](relativesource-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{RelativeSource}</pc>: enables a particular form of template binding where values come from the templated parent.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{RelativeSource}</pc>: enables a particular form of template binding where values come from the templated parent.</target>
        </segment>
      </unit>
      <unit id="224">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](customresource-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{CustomResource}</pc>: for advanced resource lookup scenarios.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">{CustomResource}</pc>: for advanced resource lookup scenarios.</target>
        </segment>
      </unit>
      <unit id="225">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](x-null-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Windows Runtime also supports the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Null} markup extension</pc>.</source>
          <target xml:space="preserve">Windows Runtime also supports the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">{x:Null} markup extension</pc>.</target>
        </segment>
      </unit>
      <unit id="226">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](T:System.Nullable%601)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You use this to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Nullable</pc></pc> values to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> in XAML.</source>
          <target xml:space="preserve">You use this to set <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Nullable</pc></pc> values to <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> in XAML.</target>
        </segment>
      </unit>
      <unit id="227">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209316)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example you might use this in a control template for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CheckBox</pc></pc>, which interprets <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> as an indeterminate check state (triggering the "Indeterminate" visual state).</source>
          <target xml:space="preserve">For example you might use this in a control template for a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">CheckBox</pc></pc>, which interprets <pc dataRefEnd="id6" dataRefStart="id5" id="p3">null</pc> as an indeterminate check state (triggering the "Indeterminate" visual state).</target>
        </segment>
      </unit>
      <unit id="228">
        <segment state="initial">
          <source xml:space="preserve">A markup extension generally return an existing instance from some other part of the object graph for the app, or defers a value to run time.</source>
          <target xml:space="preserve">A markup extension generally return an existing instance from some other part of the object graph for the app, or defers a value to run time.</target>
        </segment>
      </unit>
      <unit id="229">
        <segment state="initial">
          <source xml:space="preserve">Because you can use a markup extension as an attribute value, and that's the typical usage, you often see markup extensions providing values for reference-type properties that might have otherwise required a property element syntax.</source>
          <target xml:space="preserve">Because you can use a markup extension as an attribute value, and that's the typical usage, you often see markup extensions providing values for reference-type properties that might have otherwise required a property element syntax.</target>
        </segment>
      </unit>
      <unit id="230">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">`&lt;Button Style="{StaticResource SearchButtonStyle}"/&gt;`</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For example, here's the syntax for referencing a reusable <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> from a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ResourceDictionary</pc></pc>: <ph dataRef="id9" id="ph1" />.</source>
          <target xml:space="preserve">For example, here's the syntax for referencing a reusable <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> from a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">ResourceDictionary</pc></pc>: <ph dataRef="id9" id="ph1" />.</target>
        </segment>
      </unit>
      <unit id="231">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">`{StaticResource}`</data>
          <data id="id6">`&lt;Button.Style&gt;`</data>
          <data id="id7">`&lt;Style&gt;`</data>
          <data id="id8">[</data>
          <data id="id9">](https://msdn.microsoft.com/library/windows/apps/br208743)</data>
          <data id="id10">**</data>
          <data id="id11">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> is a reference type, not a simple value, so without the <ph dataRef="id5" id="ph1" /> usage, you would've needed a <ph dataRef="id6" id="ph2" /> property element and a <ph dataRef="id7" id="ph3" /> definition within it to set the <pc dataRefEnd="id9" dataRefStart="id8" id="p3"><pc dataRefEnd="id11" dataRefStart="id10" id="p4">FrameworkElement.Style</pc></pc> property.</source>
          <target xml:space="preserve">A <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> is a reference type, not a simple value, so without the <ph dataRef="id5" id="ph1" /> usage, you would've needed a <ph dataRef="id6" id="ph2" /> property element and a <ph dataRef="id7" id="ph3" /> definition within it to set the <pc dataRefEnd="id9" dataRefStart="id8" id="p3"><pc dataRefEnd="id11" dataRefStart="id10" id="p4">FrameworkElement.Style</pc></pc> property.</target>
        </segment>
      </unit>
      <unit id="232">
        <segment state="initial">
          <source xml:space="preserve">By using markup extensions, every property that is settable in XAML is potentially settable in attribute syntax.</source>
          <target xml:space="preserve">By using markup extensions, every property that is settable in XAML is potentially settable in attribute syntax.</target>
        </segment>
      </unit>
      <unit id="233">
        <segment state="initial">
          <source xml:space="preserve">You can use attribute syntax to provide reference values for a property even if it doesn't otherwise support an attribute syntax for direct object instantiation.</source>
          <target xml:space="preserve">You can use attribute syntax to provide reference values for a property even if it doesn't otherwise support an attribute syntax for direct object instantiation.</target>
        </segment>
      </unit>
      <unit id="234">
        <segment state="initial">
          <source xml:space="preserve">Or you can enable specific behavior that defers the general requirement that XAML properties be filled by value types or by newly created reference types.</source>
          <target xml:space="preserve">Or you can enable specific behavior that defers the general requirement that XAML properties be filled by value types or by newly created reference types.</target>
        </segment>
      </unit>
      <unit id="235">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208743)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br209250)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">To illustrate, the next XAML example sets the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> property of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc></pc> by using attribute syntax.</source>
          <target xml:space="preserve">To illustrate, the next XAML example sets the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> property of a <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Border</pc></pc> by using attribute syntax.</target>
        </segment>
      </unit>
      <unit id="236">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208743)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br208849)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> property takes an instance of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Style</pc></pc> class, a reference type that by default could not be created using an attribute syntax string.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Style</pc></pc> property takes an instance of the <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Style</pc></pc> class, a reference type that by default could not be created using an attribute syntax string.</target>
        </segment>
      </unit>
      <unit id="237">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](staticresource-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But in this case, the attribute references a particular markup extension, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc>.</source>
          <target xml:space="preserve">But in this case, the attribute references a particular markup extension, <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc>.</target>
        </segment>
      </unit>
      <unit id="238">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When that markup extension is processed, it returns a reference to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Style</pc> element that was defined earlier as a keyed resource in a resource dictionary.</source>
          <target xml:space="preserve">When that markup extension is processed, it returns a reference to a <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Style</pc> element that was defined earlier as a keyed resource in a resource dictionary.</target>
        </segment>
      </unit>
      <unit id="239">
        <segment state="initial">
          <source xml:space="preserve">You can nest markup extensions.</source>
          <target xml:space="preserve">You can nest markup extensions.</target>
        </segment>
      </unit>
      <unit id="240">
        <segment state="initial">
          <source xml:space="preserve">The innermost markup extension is evaluated first.</source>
          <target xml:space="preserve">The innermost markup extension is evaluated first.</target>
        </segment>
      </unit>
      <unit id="241">
        <segment state="initial">
          <source xml:space="preserve">Because of markup extensions, you need special syntax for a literal "{" value in an attribute.</source>
          <target xml:space="preserve">Because of markup extensions, you need special syntax for a literal "{" value in an attribute.</target>
        </segment>
      </unit>
      <unit id="242">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](xaml-syntax-guide.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML syntax guide</pc>.</source>
          <target xml:space="preserve">For more info see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML syntax guide</pc>.</target>
        </segment>
      </unit>
      <unit id="243">
        <segment state="initial">
          <source xml:space="preserve">Events</source>
          <target xml:space="preserve">Events</target>
        </segment>
      </unit>
      <unit id="244">
        <segment state="initial">
          <source xml:space="preserve">XAML is a declarative language for objects and their properties, but it also includes a syntax for attaching event handlers to objects in the markup.</source>
          <target xml:space="preserve">XAML is a declarative language for objects and their properties, but it also includes a syntax for attaching event handlers to objects in the markup.</target>
        </segment>
      </unit>
      <unit id="245">
        <segment state="initial">
          <source xml:space="preserve">The XAML event syntax can then integrate the XAML-declared events through the Windows Runtime programming model.</source>
          <target xml:space="preserve">The XAML event syntax can then integrate the XAML-declared events through the Windows Runtime programming model.</target>
        </segment>
      </unit>
      <unit id="246">
        <segment state="initial">
          <source xml:space="preserve">You specify the name of the event as an attribute name on the object where the event is handled.</source>
          <target xml:space="preserve">You specify the name of the event as an attribute name on the object where the event is handled.</target>
        </segment>
      </unit>
      <unit id="247">
        <segment state="initial">
          <source xml:space="preserve">For the attribute value, you specify the name of an event-handler function that you define in code.</source>
          <target xml:space="preserve">For the attribute value, you specify the name of an event-handler function that you define in code.</target>
        </segment>
      </unit>
      <unit id="248">
        <segment state="initial">
          <source xml:space="preserve">The XAML processor uses this name to create a delegate representation in the loaded object tree, and adds the specified handler to an internal handler list.</source>
          <target xml:space="preserve">The XAML processor uses this name to create a delegate representation in the loaded object tree, and adds the specified handler to an internal handler list.</target>
        </segment>
      </unit>
      <unit id="249">
        <segment state="initial">
          <source xml:space="preserve">Nearly all Windows Runtime apps are defined by both markup and code-behind sources.</source>
          <target xml:space="preserve">Nearly all Windows Runtime apps are defined by both markup and code-behind sources.</target>
        </segment>
      </unit>
      <unit id="250">
        <segment state="initial">
          <source xml:space="preserve">Here's a simple example.</source>
          <target xml:space="preserve">Here's a simple example.</target>
        </segment>
      </unit>
      <unit id="251">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209265)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br227737)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> class supports an event named <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Click</pc></pc>.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc></pc> class supports an event named <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">Click</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="252">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">You can write a handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click</pc> that runs code that should be invoked after the user clicks the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc>.</source>
          <target xml:space="preserve">You can write a handler for <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click</pc> that runs code that should be invoked after the user clicks the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc>.</target>
        </segment>
      </unit>
      <unit id="253">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In XAML, you specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click</pc> as an attribute on the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc>.</source>
          <target xml:space="preserve">In XAML, you specify <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Click</pc> as an attribute on the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Button</pc>.</target>
        </segment>
      </unit>
      <unit id="254">
        <segment state="initial">
          <source xml:space="preserve">For the attribute value, provide a string that is the method name of your handler.</source>
          <target xml:space="preserve">For the attribute value, provide a string that is the method name of your handler.</target>
        </segment>
      </unit>
      <unit id="255">
        <originalData>
          <data id="id1">`showUpdatesButton-Click`</data>
          <data id="id2">[</data>
          <data id="id3">](x-class-attribute.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When you compile, the compiler now expects that there will be a method named <ph dataRef="id1" id="ph1" /> defined in the code-behind file, in the namespace declared in the XAML page's <pc dataRefEnd="id3" dataRefStart="id2" id="p1">x:Class</pc> value.</source>
          <target xml:space="preserve">When you compile, the compiler now expects that there will be a method named <ph dataRef="id1" id="ph1" /> defined in the code-behind file, in the namespace declared in the XAML page's <pc dataRefEnd="id3" dataRefStart="id2" id="p1">x:Class</pc> value.</target>
        </segment>
      </unit>
      <unit id="256">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br227737)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Also, that method must satisfy the delegate contract for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc></pc> event.</source>
          <target xml:space="preserve">Also, that method must satisfy the delegate contract for the <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Click</pc></pc> event.</target>
        </segment>
      </unit>
      <unit id="257">
        <segment state="initial">
          <source xml:space="preserve">For example:</source>
          <target xml:space="preserve">For example:</target>
        </segment>
      </unit>
      <unit id="258">
        <segment state="initial">
          <source xml:space="preserve">[!div class="tabbedCodeSnippets"]</source>
          <target xml:space="preserve">[!div class="tabbedCodeSnippets"]</target>
        </segment>
      </unit>
      <unit id="259">
        <segment state="initial">
          <source xml:space="preserve">Within a project, the XAML is written as a .xaml file, and you use the language you prefer (C#, Visual Basic, C++/CX) to write a code-behind file.</source>
          <target xml:space="preserve">Within a project, the XAML is written as a .xaml file, and you use the language you prefer (C#, Visual Basic, C++/CX) to write a code-behind file.</target>
        </segment>
      </unit>
      <unit id="260">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](x-class-attribute.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When a XAML file is markup-compiled as part of a build action for the project, the location of the XAML code-behind file for each XAML page is identified by specifying a namespace and class as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Class</pc> attribute of the root element of the XAML page.</source>
          <target xml:space="preserve">When a XAML file is markup-compiled as part of a build action for the project, the location of the XAML code-behind file for each XAML page is identified by specifying a namespace and class as the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Class</pc> attribute of the root element of the XAML page.</target>
        </segment>
      </unit>
      <unit id="261">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](events-and-routed-events-overview.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on how these mechanisms work in XAML and how they relate to the programming and application models, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Events and routed events overview</pc>.</source>
          <target xml:space="preserve">For more info on how these mechanisms work in XAML and how they relate to the programming and application models, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Events and routed events overview</pc>.</target>
        </segment>
      </unit>
      <unit id="262">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For C++/CX there are two code-behind files, one is a header (.xaml.h) and the other is implementation (.xaml.cpp).</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  For C++/CX there are two code-behind files, one is a header (.xaml.h) and the other is implementation (.xaml.cpp).</target>
        </segment>
      </unit>
      <unit id="263">
        <segment state="initial">
          <source xml:space="preserve">The implementation references the header, and it's technically the header that represents the entry point for the code-behind connection.</source>
          <target xml:space="preserve">The implementation references the header, and it's technically the header that represents the entry point for the code-behind connection.</target>
        </segment>
      </unit>
      <unit id="264">
        <segment state="initial">
          <source xml:space="preserve">Resource dictionaries</source>
          <target xml:space="preserve">Resource dictionaries</target>
        </segment>
      </unit>
      <unit id="265">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Creating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> is a common task that is usually accomplished by authoring a resource dictionary as an area of a XAML page or a separate XAML file.</source>
          <target xml:space="preserve">Creating a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> is a common task that is usually accomplished by authoring a resource dictionary as an area of a XAML page or a separate XAML file.</target>
        </segment>
      </unit>
      <unit id="266">
        <segment state="initial">
          <source xml:space="preserve">Resource dictionaries and how to use them is a larger conceptual area that is outside the scope of this topic.</source>
          <target xml:space="preserve">Resource dictionaries and how to use them is a larger conceptual area that is outside the scope of this topic.</target>
        </segment>
      </unit>
      <unit id="267">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187273)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc>.</source>
          <target xml:space="preserve">For more info see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc>.</target>
        </segment>
      </unit>
      <unit id="268">
        <segment state="initial">
          <source xml:space="preserve">XAML and XML</source>
          <target xml:space="preserve">XAML and XML</target>
        </segment>
      </unit>
      <unit id="269">
        <segment state="initial">
          <source xml:space="preserve">The XAML language is fundamentally based on the XML language.</source>
          <target xml:space="preserve">The XAML language is fundamentally based on the XML language.</target>
        </segment>
      </unit>
      <unit id="270">
        <segment state="initial">
          <source xml:space="preserve">But XAML extends XML significantly.</source>
          <target xml:space="preserve">But XAML extends XML significantly.</target>
        </segment>
      </unit>
      <unit id="271">
        <segment state="initial">
          <source xml:space="preserve">In particular it treats the concept of schema quite differently because of its relationship to the backing type concept, and adds language elements such as attached members and markup extensions.</source>
          <target xml:space="preserve">In particular it treats the concept of schema quite differently because of its relationship to the backing type concept, and adds language elements such as attached members and markup extensions.</target>
        </segment>
      </unit>
      <unit id="272">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:lang</pc> is valid in XAML, but influences runtime rather than parse behavior, and is typically aliased to a framework-level property.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:lang</pc> is valid in XAML, but influences runtime rather than parse behavior, and is typically aliased to a framework-level property.</target>
        </segment>
      </unit>
      <unit id="273">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh702066)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Language</pc></pc>.</source>
          <target xml:space="preserve">For more info, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">FrameworkElement.Language</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="274">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:base</pc> is valid in markup but parsers ignore it.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:base</pc> is valid in markup but parsers ignore it.</target>
        </segment>
      </unit>
      <unit id="275">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](xaml-and-whitespace.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:space</pc> is valid, but is only relevant for scenarios described in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">XAML and whitespace</pc> topic.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">xml:space</pc> is valid, but is only relevant for scenarios described in the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">XAML and whitespace</pc> topic.</target>
        </segment>
      </unit>
      <unit id="276">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">encoding</pc> attribute is valid in XAML.</source>
          <target xml:space="preserve">The <pc dataRefEnd="id2" dataRefStart="id1" id="p1">encoding</pc> attribute is valid in XAML.</target>
        </segment>
      </unit>
      <unit id="277">
        <segment state="initial">
          <source xml:space="preserve">Only UTF-8 and UTF-16 encodings are supported.</source>
          <target xml:space="preserve">Only UTF-8 and UTF-16 encodings are supported.</target>
        </segment>
      </unit>
      <unit id="278">
        <segment state="initial">
          <source xml:space="preserve">UTF-32 encoding is not supported.</source>
          <target xml:space="preserve">UTF-32 encoding is not supported.</target>
        </segment>
      </unit>
      <unit id="279">
        <segment state="initial">
          <source xml:space="preserve">Case sensitivity in XAML</source>
          <target xml:space="preserve">Case sensitivity in XAML</target>
        </segment>
      </unit>
      <unit id="280">
        <segment state="initial">
          <source xml:space="preserve">XAML is case-sensitive.</source>
          <target xml:space="preserve">XAML is case-sensitive.</target>
        </segment>
      </unit>
      <unit id="281">
        <segment state="initial">
          <source xml:space="preserve">This is another consequence of XAML being based on XML, which is case-sensitive.</source>
          <target xml:space="preserve">This is another consequence of XAML being based on XML, which is case-sensitive.</target>
        </segment>
      </unit>
      <unit id="282">
        <segment state="initial">
          <source xml:space="preserve">The names of XAML elements and attributes are case-sensitive.</source>
          <target xml:space="preserve">The names of XAML elements and attributes are case-sensitive.</target>
        </segment>
      </unit>
      <unit id="283">
        <segment state="initial">
          <source xml:space="preserve">The value of an attribute is potentially case-sensitive; this depends on how the attribute value is handled for particular properties.</source>
          <target xml:space="preserve">The value of an attribute is potentially case-sensitive; this depends on how the attribute value is handled for particular properties.</target>
        </segment>
      </unit>
      <unit id="284">
        <segment state="initial">
          <source xml:space="preserve">For example, if the attribute value declares a member name of an enumeration, the built-in behavior that type-converts a member name string to return the enumeration member value is not case-sensitive.</source>
          <target xml:space="preserve">For example, if the attribute value declares a member name of an enumeration, the built-in behavior that type-converts a member name string to return the enumeration member value is not case-sensitive.</target>
        </segment>
      </unit>
      <unit id="285">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">In contrast, the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> property, and utility methods for working with objects based on the name that the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc> property declares, treat the name string as case-sensitive.</source>
          <target xml:space="preserve">In contrast, the value of the <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Name</pc> property, and utility methods for working with objects based on the name that the <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc> property declares, treat the name string as case-sensitive.</target>
        </segment>
      </unit>
      <unit id="286">
        <segment state="initial">
          <source xml:space="preserve">XAML namescopes</source>
          <target xml:space="preserve">XAML namescopes</target>
        </segment>
      </unit>
      <unit id="287">
        <segment state="initial">
          <source xml:space="preserve">The XAML language defines a concept of a XAML namescope.</source>
          <target xml:space="preserve">The XAML language defines a concept of a XAML namescope.</target>
        </segment>
      </unit>
      <unit id="288">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">The XAML namescope concept influences how XAML processors should treat the value of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc> applied to XAML elements, particularly the scopes in which names should be relied upon to be unique identifiers.</source>
          <target xml:space="preserve">The XAML namescope concept influences how XAML processors should treat the value of <pc dataRefEnd="id2" dataRefStart="id1" id="p1">x:Name</pc> or <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Name</pc> applied to XAML elements, particularly the scopes in which names should be relied upon to be unique identifiers.</target>
        </segment>
      </unit>
      <unit id="289">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](xaml-namescopes.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">XAML namescopes are covered in more detail in a separate topic; see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namescopes</pc>.</source>
          <target xml:space="preserve">XAML namescopes are covered in more detail in a separate topic; see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XAML namescopes</pc>.</target>
        </segment>
      </unit>
      <unit id="290">
        <segment state="initial">
          <source xml:space="preserve">The role of XAML in the development process</source>
          <target xml:space="preserve">The role of XAML in the development process</target>
        </segment>
      </unit>
      <unit id="291">
        <segment state="initial">
          <source xml:space="preserve">XAML plays several important roles in the app development process.</source>
          <target xml:space="preserve">XAML plays several important roles in the app development process.</target>
        </segment>
      </unit>
      <unit id="292">
        <segment state="initial">
          <source xml:space="preserve">XAML is the primary format for declaring an app's UI and elements in that UI, if you are programming using C#, Visual Basic or C++/CX.</source>
          <target xml:space="preserve">XAML is the primary format for declaring an app's UI and elements in that UI, if you are programming using C#, Visual Basic or C++/CX.</target>
        </segment>
      </unit>
      <unit id="293">
        <segment state="initial">
          <source xml:space="preserve">Typically at least one XAML file in your project represents a page metaphor in your app for the initially displayed UI.</source>
          <target xml:space="preserve">Typically at least one XAML file in your project represents a page metaphor in your app for the initially displayed UI.</target>
        </segment>
      </unit>
      <unit id="294">
        <segment state="initial">
          <source xml:space="preserve">Additional XAML files might declare additional pages for navigation UI.</source>
          <target xml:space="preserve">Additional XAML files might declare additional pages for navigation UI.</target>
        </segment>
      </unit>
      <unit id="295">
        <segment state="initial">
          <source xml:space="preserve">Other XAML files can declare resources, such as templates or styles.</source>
          <target xml:space="preserve">Other XAML files can declare resources, such as templates or styles.</target>
        </segment>
      </unit>
      <unit id="296">
        <segment state="initial">
          <source xml:space="preserve">You use the XAML format for declaring styles and templates applied to controls and UI for an app.</source>
          <target xml:space="preserve">You use the XAML format for declaring styles and templates applied to controls and UI for an app.</target>
        </segment>
      </unit>
      <unit id="297">
        <segment state="initial">
          <source xml:space="preserve">You might use styles and templates either for templating existing controls, or if you define a control that supplies a default template as part of a control package.</source>
          <target xml:space="preserve">You might use styles and templates either for templating existing controls, or if you define a control that supplies a default template as part of a control package.</target>
        </segment>
      </unit>
      <unit id="298">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208794)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">When you use it to define styles and templates, the relevant XAML is often declared as a discrete XAML file with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> root.</source>
          <target xml:space="preserve">When you use it to define styles and templates, the relevant XAML is often declared as a discrete XAML file with a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ResourceDictionary</pc></pc> root.</target>
        </segment>
      </unit>
      <unit id="299">
        <segment state="initial">
          <source xml:space="preserve">XAML is the common format for designer support of creating app UI and exchanging the UI design between different designer apps.</source>
          <target xml:space="preserve">XAML is the common format for designer support of creating app UI and exchanging the UI design between different designer apps.</target>
        </segment>
      </unit>
      <unit id="300">
        <segment state="initial">
          <source xml:space="preserve">Most notably, XAML for the app can be interchanged between different XAML design tools (or design windows within tools).</source>
          <target xml:space="preserve">Most notably, XAML for the app can be interchanged between different XAML design tools (or design windows within tools).</target>
        </segment>
      </unit>
      <unit id="301">
        <segment state="initial">
          <source xml:space="preserve">Several other technologies also define the basic UI in XAML.</source>
          <target xml:space="preserve">Several other technologies also define the basic UI in XAML.</target>
        </segment>
      </unit>
      <unit id="302">
        <segment state="initial">
          <source xml:space="preserve">In relationship to Windows Presentation Foundation (WPF) XAML and Microsoft Silverlight XAML, the XAML for Windows Runtime uses the same URI for its shared default XAML namespace.</source>
          <target xml:space="preserve">In relationship to Windows Presentation Foundation (WPF) XAML and Microsoft Silverlight XAML, the XAML for Windows Runtime uses the same URI for its shared default XAML namespace.</target>
        </segment>
      </unit>
      <unit id="303">
        <segment state="initial">
          <source xml:space="preserve">The XAML vocabulary for Windows Runtime overlaps significantly with the XAML-for-UI vocabulary also used by Silverlight and to a slightly lesser extent by WPF.</source>
          <target xml:space="preserve">The XAML vocabulary for Windows Runtime overlaps significantly with the XAML-for-UI vocabulary also used by Silverlight and to a slightly lesser extent by WPF.</target>
        </segment>
      </unit>
      <unit id="304">
        <segment state="initial">
          <source xml:space="preserve">Thus, XAML promotes an efficient migration pathway for UI originally defined for precursor technologies that also used XAML.</source>
          <target xml:space="preserve">Thus, XAML promotes an efficient migration pathway for UI originally defined for precursor technologies that also used XAML.</target>
        </segment>
      </unit>
      <unit id="305">
        <segment state="initial">
          <source xml:space="preserve">XAML defines the visual appearance of a UI, and an associated code-behind file defines the logic.</source>
          <target xml:space="preserve">XAML defines the visual appearance of a UI, and an associated code-behind file defines the logic.</target>
        </segment>
      </unit>
      <unit id="306">
        <segment state="initial">
          <source xml:space="preserve">You can adjust the UI design without making changes to the logic in code-behind.</source>
          <target xml:space="preserve">You can adjust the UI design without making changes to the logic in code-behind.</target>
        </segment>
      </unit>
      <unit id="307">
        <segment state="initial">
          <source xml:space="preserve">XAML simplifies the workflow between designers and developers.</source>
          <target xml:space="preserve">XAML simplifies the workflow between designers and developers.</target>
        </segment>
      </unit>
      <unit id="308">
        <segment state="initial">
          <source xml:space="preserve">Because of the richness of the visual designer and design surface support for the XAML language, XAML supports rapid UI prototyping in the early development phases.</source>
          <target xml:space="preserve">Because of the richness of the visual designer and design surface support for the XAML language, XAML supports rapid UI prototyping in the early development phases.</target>
        </segment>
      </unit>
      <unit id="309">
        <segment state="initial">
          <source xml:space="preserve">Depending on your own role in the development process, you might not interact with XAML much.</source>
          <target xml:space="preserve">Depending on your own role in the development process, you might not interact with XAML much.</target>
        </segment>
      </unit>
      <unit id="310">
        <segment state="initial">
          <source xml:space="preserve">The degree to which you do interact with XAML files also depends on which development environment you are using, whether you use interactive design environment features such as toolboxes and property editors, and the scope and purpose of your Windows Runtime app.</source>
          <target xml:space="preserve">The degree to which you do interact with XAML files also depends on which development environment you are using, whether you use interactive design environment features such as toolboxes and property editors, and the scope and purpose of your Windows Runtime app.</target>
        </segment>
      </unit>
      <unit id="311">
        <segment state="initial">
          <source xml:space="preserve">Nevertheless, it is likely that during development of the app, you will be editing a XAML file at the element level using a text or XML editor.</source>
          <target xml:space="preserve">Nevertheless, it is likely that during development of the app, you will be editing a XAML file at the element level using a text or XML editor.</target>
        </segment>
      </unit>
      <unit id="312">
        <segment state="initial">
          <source xml:space="preserve">Using this info, you can confidently edit XAML in a text or XML representation and maintain the validity of that XAML file's declarations and purpose when it is consumed by tools, markup compile operations, or the run-time phase of your Windows Runtime app.</source>
          <target xml:space="preserve">Using this info, you can confidently edit XAML in a text or XML representation and maintain the validity of that XAML file's declarations and purpose when it is consumed by tools, markup compile operations, or the run-time phase of your Windows Runtime app.</target>
        </segment>
      </unit>
      <unit id="313">
        <segment state="initial">
          <source xml:space="preserve">Optimize your XAML for load performance</source>
          <target xml:space="preserve">Optimize your XAML for load performance</target>
        </segment>
      </unit>
      <unit id="314">
        <segment state="initial">
          <source xml:space="preserve">Here are some tips for defining UI elements in XAML using best practices for performance.</source>
          <target xml:space="preserve">Here are some tips for defining UI elements in XAML using best practices for performance.</target>
        </segment>
      </unit>
      <unit id="315">
        <segment state="initial">
          <source xml:space="preserve">Many of these tips relate to using XAML resources, but are listed here in the general XAML overview for convenience.</source>
          <target xml:space="preserve">Many of these tips relate to using XAML resources, but are listed here in the general XAML overview for convenience.</target>
        </segment>
      </unit>
      <unit id="316">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt187273)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info about XAML resources see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc>.</source>
          <target xml:space="preserve">For more info about XAML resources see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">ResourceDictionary and XAML resource references</pc>.</target>
        </segment>
      </unit>
      <unit id="317">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/mt204779)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For some more tips on performance, including XAML that purposely demonstrates some of the poor performance practices that you should avoid in your XAML, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimize your XAML markup</pc>.</source>
          <target xml:space="preserve">For some more tips on performance, including XAML that purposely demonstrates some of the poor performance practices that you should avoid in your XAML, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Optimize your XAML markup</pc>.</target>
        </segment>
      </unit>
      <unit id="318">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242962)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you use the same color brush often in your XAML, define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SolidColorBrush</pc></pc> as a resource rather than using a named color as an attribute value each time.</source>
          <target xml:space="preserve">If you use the same color brush often in your XAML, define a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">SolidColorBrush</pc></pc> as a resource rather than using a named color as an attribute value each time.</target>
        </segment>
      </unit>
      <unit id="319">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242338)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you use the same resource on more than one UI page, consider defining it in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application.Resources</pc></pc> rather than on each page.</source>
          <target xml:space="preserve">If you use the same resource on more than one UI page, consider defining it in <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Application.Resources</pc></pc> rather than on each page.</target>
        </segment>
      </unit>
      <unit id="320">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Conversely, if only one page uses a resource, don't define it in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Application.Resources</pc> and instead define it only for the page that needs it.</source>
          <target xml:space="preserve">Conversely, if only one page uses a resource, don't define it in <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Application.Resources</pc> and instead define it only for the page that needs it.</target>
        </segment>
      </unit>
      <unit id="321">
        <segment state="initial">
          <source xml:space="preserve">This is good both for XAML factoring while designing your app and for performance during XAML parsing.</source>
          <target xml:space="preserve">This is good both for XAML factoring while designing your app and for performance during XAML parsing.</target>
        </segment>
      </unit>
      <unit id="322">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](staticresource-markup-extension.md)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For resources that your app packages, check for unused resources (a resource that has a key, but there's no <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc> reference in your app that uses it).</source>
          <target xml:space="preserve">For resources that your app packages, check for unused resources (a resource that has a key, but there's no <pc dataRefEnd="id2" dataRefStart="id1" id="p1">StaticResource</pc> reference in your app that uses it).</target>
        </segment>
      </unit>
      <unit id="323">
        <segment state="initial">
          <source xml:space="preserve">Remove these from your XAML before you release your app.</source>
          <target xml:space="preserve">Remove these from your XAML before you release your app.</target>
        </segment>
      </unit>
      <unit id="324">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br208801)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">If you're using separate XAML files that provides design resources (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc>), consider commenting or removing unused resources from these files.</source>
          <target xml:space="preserve">If you're using separate XAML files that provides design resources (<pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">MergedDictionaries</pc></pc>), consider commenting or removing unused resources from these files.</target>
        </segment>
      </unit>
      <unit id="325">
        <segment state="initial">
          <source xml:space="preserve">Even if you have a shared XAML starting point that you're using in more than one app or that provides common resources for all your app, it's still your app that packages the XAML resources each time, and potentially has to load them.</source>
          <target xml:space="preserve">Even if you have a shared XAML starting point that you're using in more than one app or that provides common resources for all your app, it's still your app that packages the XAML resources each time, and potentially has to load them.</target>
        </segment>
      </unit>
      <unit id="326">
        <segment state="initial">
          <source xml:space="preserve">Don't define UI elements you don't need for composition, and use the default control templates whenever possible (these templates have already been tested and verified for load performance).</source>
          <target xml:space="preserve">Don't define UI elements you don't need for composition, and use the default control templates whenever possible (these templates have already been tested and verified for load performance).</target>
        </segment>
      </unit>
      <unit id="327">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br209250)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Use containers such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Border</pc></pc> rather than deliberate overdraws of UI elements.</source>
          <target xml:space="preserve">Use containers such as <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">Border</pc></pc> rather than deliberate overdraws of UI elements.</target>
        </segment>
      </unit>
      <unit id="328">
        <segment state="initial">
          <source xml:space="preserve">Basically, don't draw the same pixel multiple times.</source>
          <target xml:space="preserve">Basically, don't draw the same pixel multiple times.</target>
        </segment>
      </unit>
      <unit id="329">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh701823)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on overdraw and how to test for it, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DebugSettings.IsOverdrawHeatMapEnabled</pc></pc>.</source>
          <target xml:space="preserve">For more info on overdraw and how to test for it, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">DebugSettings.IsOverdrawHeatMapEnabled</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="330">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/br242878)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
          <data id="id5">[</data>
          <data id="id6">](https://msdn.microsoft.com/library/windows/apps/br242705)</data>
          <data id="id7">**</data>
          <data id="id8">**</data>
          <data id="id9">**</data>
          <data id="id10">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Use the default items templates for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc>; these have special <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Presenter</pc> logic that solves performance issues when building the visual tree for large numbers of list items.</source>
          <target xml:space="preserve">Use the default items templates for <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">ListView</pc></pc> or <pc dataRefEnd="id6" dataRefStart="id5" id="p3"><pc dataRefEnd="id8" dataRefStart="id7" id="p4">GridView</pc></pc>; these have special <pc dataRefEnd="id10" dataRefStart="id9" id="p5">Presenter</pc> logic that solves performance issues when building the visual tree for large numbers of list items.</target>
        </segment>
      </unit>
      <unit id="331">
        <segment state="initial">
          <source xml:space="preserve">Debugging XAML</source>
          <target xml:space="preserve">Debugging XAML</target>
        </segment>
      </unit>
      <unit id="332">
        <segment state="initial">
          <source xml:space="preserve">Because XAML is a markup language, some of the typical strategies for debugging within Microsoft Visual Studio are not available.</source>
          <target xml:space="preserve">Because XAML is a markup language, some of the typical strategies for debugging within Microsoft Visual Studio are not available.</target>
        </segment>
      </unit>
      <unit id="333">
        <segment state="initial">
          <source xml:space="preserve">For example, there is no way to set a breakpoint within a XAML file.</source>
          <target xml:space="preserve">For example, there is no way to set a breakpoint within a XAML file.</target>
        </segment>
      </unit>
      <unit id="334">
        <segment state="initial">
          <source xml:space="preserve">However, there are other techniques that can help you debug issues with UI definitions or other XAML markup while you're still developing your app.</source>
          <target xml:space="preserve">However, there are other techniques that can help you debug issues with UI definitions or other XAML markup while you're still developing your app.</target>
        </segment>
      </unit>
      <unit id="335">
        <segment state="initial">
          <source xml:space="preserve">When there are problems with a XAML file, the most typical result is that some system or your app will throw a XAML parse exception.</source>
          <target xml:space="preserve">When there are problems with a XAML file, the most typical result is that some system or your app will throw a XAML parse exception.</target>
        </segment>
      </unit>
      <unit id="336">
        <segment state="initial">
          <source xml:space="preserve">Whenever there is a XAML parse exception, the XAML loaded by the XAML parser failed to create a valid object tree.</source>
          <target xml:space="preserve">Whenever there is a XAML parse exception, the XAML loaded by the XAML parser failed to create a valid object tree.</target>
        </segment>
      </unit>
      <unit id="337">
        <segment state="initial">
          <source xml:space="preserve">In some cases, such as when the XAML represents the first "page" of your application that is loaded as the root visual, the XAML parse exception is not recoverable.</source>
          <target xml:space="preserve">In some cases, such as when the XAML represents the first "page" of your application that is loaded as the root visual, the XAML parse exception is not recoverable.</target>
        </segment>
      </unit>
      <unit id="338">
        <segment state="initial">
          <source xml:space="preserve">XAML is often edited within an IDE such as Visual Studio and one of its XAML design surfaces.</source>
          <target xml:space="preserve">XAML is often edited within an IDE such as Visual Studio and one of its XAML design surfaces.</target>
        </segment>
      </unit>
      <unit id="339">
        <segment state="initial">
          <source xml:space="preserve">Visual Studio can often provide design-time validation and error checking of a XAML source as you edit it.</source>
          <target xml:space="preserve">Visual Studio can often provide design-time validation and error checking of a XAML source as you edit it.</target>
        </segment>
      </unit>
      <unit id="340">
        <segment state="initial">
          <source xml:space="preserve">For example it might display "squiggles" in the XAML text editor as soon as you type a bad attribute value, and you won't even have to wait for a XAML compile pass to see that something's wrong with your UI definition.</source>
          <target xml:space="preserve">For example it might display "squiggles" in the XAML text editor as soon as you type a bad attribute value, and you won't even have to wait for a XAML compile pass to see that something's wrong with your UI definition.</target>
        </segment>
      </unit>
      <unit id="341">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/hh673774)</data>
          <data id="id3">**</data>
          <data id="id4">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Once the app actually runs, if any XAML parse errors have gone undetected at design time, these are reported by the common language runtime (CLR) as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlParseException</pc></pc>.</source>
          <target xml:space="preserve">Once the app actually runs, if any XAML parse errors have gone undetected at design time, these are reported by the common language runtime (CLR) as a <pc dataRefEnd="id2" dataRefStart="id1" id="p1"><pc dataRefEnd="id4" dataRefStart="id3" id="p2">XamlParseException</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="342">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/dn532194)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">For more info on what you might be able to do for a run-time <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlParseException</pc>, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Exception handling for Windows Runtime apps in C# or Visual Basic</pc>.</source>
          <target xml:space="preserve">For more info on what you might be able to do for a run-time <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlParseException</pc>, see <pc dataRefEnd="id4" dataRefStart="id3" id="p2">Exception handling for Windows Runtime apps in C# or Visual Basic</pc>.</target>
        </segment>
      </unit>
      <unit id="343">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
          <data id="id3">[</data>
          <data id="id4">](https://msdn.microsoft.com/library/windows/apps/hh673774)</data>
          <data id="id5">**</data>
          <data id="id6">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Apps that use C++/CX for code don't get the specific <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">XamlParseException</pc></pc>.</source>
          <target xml:space="preserve">
						<pc dataRefEnd="id2" dataRefStart="id1" id="p1">Note</pc>  Apps that use C++/CX for code don't get the specific <pc dataRefEnd="id4" dataRefStart="id3" id="p2"><pc dataRefEnd="id6" dataRefStart="id5" id="p3">XamlParseException</pc></pc>.</target>
        </segment>
      </unit>
      <unit id="344">
        <originalData>
          <data id="id1">**</data>
          <data id="id2">**</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">But the message in the exception clarifies that the source of the error is XAML-related, and includes context info such as line numbers in a XAML file, just like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlParseException</pc> does.</source>
          <target xml:space="preserve">But the message in the exception clarifies that the source of the error is XAML-related, and includes context info such as line numbers in a XAML file, just like <pc dataRefEnd="id2" dataRefStart="id1" id="p1">XamlParseException</pc> does.</target>
        </segment>
      </unit>
      <unit id="345">
        <originalData>
          <data id="id1">[</data>
          <data id="id2">](https://msdn.microsoft.com/library/windows/apps/xaml/hh781607.aspx)</data>
        </originalData>
        <segment state="initial">
          <source xml:space="preserve">Fore more info on debugging a Windows Runtime app, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Start a debug session</pc>.</source>
          <target xml:space="preserve">Fore more info on debugging a Windows Runtime app, see <pc dataRefEnd="id2" dataRefStart="id1" id="p1">Start a debug session</pc>.</target>
        </segment>
      </unit>
    </group>
  </file>
</xliff>