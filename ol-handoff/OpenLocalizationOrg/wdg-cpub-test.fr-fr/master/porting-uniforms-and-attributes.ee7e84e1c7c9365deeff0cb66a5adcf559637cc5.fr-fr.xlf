<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">42cc98cf95cee16f889c79b869f28effc66b69b1</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\porting-uniforms-and-attributes.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Compare OpenGL ES 2.0 buffers, uniforms, and vertex attributes to Direct3D</source>
          <target state="new">Compare OpenGL ES 2.0 buffers, uniforms, and vertex attributes to Direct3D</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>During the process of porting to Direct3D 11 from OpenGL ES 2.0, you must change the syntax and API behavior for passing data between the app and the shader programs.</source>
          <target state="new">During the process of porting to Direct3D 11 from OpenGL ES 2.0, you must change the syntax and API behavior for passing data between the app and the shader programs.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Compare OpenGL ES 2.0 buffers, uniforms, and vertex attributes to Direct3D</source>
          <target state="new">Compare OpenGL ES 2.0 buffers, uniforms, and vertex attributes to Direct3D</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Important APIs</source>
          <target state="new">Important APIs</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>ID3D11Device1::CreateBuffer</source>
          <target state="new">ID3D11Device1::CreateBuffer</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>ID3D11Device1::CreateInputLayout</source>
          <target state="new">ID3D11Device1::CreateInputLayout</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>ID3D11DeviceContext1::IASetInputLayout</source>
          <target state="new">ID3D11DeviceContext1::IASetInputLayout</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>During the process of porting to Direct3D 11 from OpenGL ES 2.0, you must change the syntax and API behavior for passing data between the app and the shader programs.</source>
          <target state="new">During the process of porting to Direct3D 11 from OpenGL ES 2.0, you must change the syntax and API behavior for passing data between the app and the shader programs.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>In OpenGL ES 2.0, data is passed to and from shader programs in four ways: as uniforms for constant data, as attributes for vertex data, as buffer objects for other resource data (such as textures).</source>
          <target state="new">In OpenGL ES 2.0, data is passed to and from shader programs in four ways: as uniforms for constant data, as attributes for vertex data, as buffer objects for other resource data (such as textures).</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>In Direct3D 11, these roughly map to constant buffers, vertex buffers, and subresources.</source>
          <target state="new">In Direct3D 11, these roughly map to constant buffers, vertex buffers, and subresources.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Despite the superficial commonality, they are handled quite different in usage.</source>
          <target state="new">Despite the superficial commonality, they are handled quite different in usage.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Here's the basic mapping.</source>
          <target state="new">Here's the basic mapping.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0</source>
          <target state="new">OpenGL ES 2.0</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Direct3D 11</source>
          <target state="new">Direct3D 11</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>uniform</source>
          <target state="new">uniform</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>constant buffer (<bpt id="p1">**</bpt>cbuffer<ept id="p1">**</ept>) field.</source>
          <target state="new">constant buffer (<bpt id="p1">**</bpt>cbuffer<ept id="p1">**</ept>) field.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>attribute</source>
          <target state="new">attribute</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>vertex buffer element field, designated by an input layout and marked with a specific HLSL semantic.</source>
          <target state="new">vertex buffer element field, designated by an input layout and marked with a specific HLSL semantic.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>buffer object</source>
          <target state="new">buffer object</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>buffer; See <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11\_BUFFER\_DESC<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> and for a general-use buffer definitions.</source>
          <target state="new">buffer; See <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11\_BUFFER\_DESC<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> and for a general-use buffer definitions.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>frame buffer object (FBO)</source>
          <target state="new">frame buffer object (FBO)</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>render target(s); See <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11RenderTargetView<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept> with <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11Texture2D<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept>.</source>
          <target state="new">render target(s); See <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11RenderTargetView<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept> with <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11Texture2D<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept>.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>back buffer</source>
          <target state="new">back buffer</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>swap chain with "back buffer" surface; See <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain1<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</ept> with attached <bpt id="p3">[</bpt><bpt id="p4">**</bpt>IDXGISurface1<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff471343)</ept>.</source>
          <target state="new">swap chain with "back buffer" surface; See <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IDXGISwapChain1<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh404631)</ept> with attached <bpt id="p3">[</bpt><bpt id="p4">**</bpt>IDXGISurface1<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff471343)</ept>.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Port buffers</source>
          <target state="new">Port buffers</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>In OpenGL ES 2.0, the process for creating and binding any kind of buffer generally follows this pattern</source>
          <target state="new">In OpenGL ES 2.0, the process for creating and binding any kind of buffer generally follows this pattern</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Call glGenBuffers to generate one or more buffers and return the handles to them.</source>
          <target state="new">Call glGenBuffers to generate one or more buffers and return the handles to them.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Call glBindBuffer to define the layout of a buffer, such as GL\_ELEMENT\_ARRAY\_BUFFER.</source>
          <target state="new">Call glBindBuffer to define the layout of a buffer, such as GL\_ELEMENT\_ARRAY\_BUFFER.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Call glBufferData to populate the buffer with specific data (such as vertex structures, index data, or color data) in a specific layout.</source>
          <target state="new">Call glBufferData to populate the buffer with specific data (such as vertex structures, index data, or color data) in a specific layout.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The most common kind of buffer is the vertex buffer, which minimally contains the positions of the vertices in some coordinate system.</source>
          <target state="new">The most common kind of buffer is the vertex buffer, which minimally contains the positions of the vertices in some coordinate system.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>In typical use, a vertex is represented by a structure that contains the position coordinates, a normal vector to the vertex position, a tangent vector to the vertex position, and texture lookup (uv) coordinates.</source>
          <target state="new">In typical use, a vertex is represented by a structure that contains the position coordinates, a normal vector to the vertex position, a tangent vector to the vertex position, and texture lookup (uv) coordinates.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The buffer contains a contiguous list of these vertices, in some order (like a triangle list, or strip, or fan), and which collectively represent the visible polygons in your scene.</source>
          <target state="new">The buffer contains a contiguous list of these vertices, in some order (like a triangle list, or strip, or fan), and which collectively represent the visible polygons in your scene.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>(In Direct3D 11 as well as OpenGL ES 2.0 it is inefficient to have multiple vertex buffers per draw call.)</source>
          <target state="new">(In Direct3D 11 as well as OpenGL ES 2.0 it is inefficient to have multiple vertex buffers per draw call.)</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Here's an example a vertex buffer and an index buffer created with OpenGL ES 2.0:</source>
          <target state="new">Here's an example a vertex buffer and an index buffer created with OpenGL ES 2.0:</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Creating and populating a vertex buffer and an index buffer.</source>
          <target state="new">OpenGL ES 2.0: Creating and populating a vertex buffer and an index buffer.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Other buffers include pixel buffers and maps, like textures.</source>
          <target state="new">Other buffers include pixel buffers and maps, like textures.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The shader pipeline can render into texture buffers (pixmaps) or render buffer objects and use those buffers in future shader passes.</source>
          <target state="new">The shader pipeline can render into texture buffers (pixmaps) or render buffer objects and use those buffers in future shader passes.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In the simplest case, the call flow is:</source>
          <target state="new">In the simplest case, the call flow is:</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Call glGenFramebuffers to generate a frame buffer object.</source>
          <target state="new">Call glGenFramebuffers to generate a frame buffer object.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Call glBindFramebuffer to bind the frame buffer object for writing.</source>
          <target state="new">Call glBindFramebuffer to bind the frame buffer object for writing.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Call glFramebufferTexture2D to draw into a specified texture map.</source>
          <target state="new">Call glFramebufferTexture2D to draw into a specified texture map.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>In Direct3D 11, buffer data elements are considered "subresources," and can range from individual vertex data elements to MIP-map textures.</source>
          <target state="new">In Direct3D 11, buffer data elements are considered "subresources," and can range from individual vertex data elements to MIP-map textures.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure with the configuration for a buffer data element.</source>
          <target state="new">Populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structure with the configuration for a buffer data element.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_BUFFER\_DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> structure with the size of the individual elements in the buffer as well as the buffer type.</source>
          <target state="new">Populate a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_BUFFER\_DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> structure with the size of the individual elements in the buffer as well as the buffer type.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device1::CreateBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> with these two structures.</source>
          <target state="new">Call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device1::CreateBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh404575)</ept> with these two structures.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Creating and populating a vertex buffer and an index buffer.</source>
          <target state="new">Direct3D 11: Creating and populating a vertex buffer and an index buffer.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Writable pixel buffers or maps, such as a frame buffer, can be created as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Texture2D<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept> objects.</source>
          <target state="new">Writable pixel buffers or maps, such as a frame buffer, can be created as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Texture2D<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476635)</ept> objects.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>These can be bound as resources to an <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11RenderTargetView<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11ShaderResourceView<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476628)</ept>, which, once drawn into, can be displayed with the associated swap chain or passed to a shader, respectively.</source>
          <target state="new">These can be bound as resources to an <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11RenderTargetView<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476582)</ept> or <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11ShaderResourceView<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476628)</ept>, which, once drawn into, can be displayed with the associated swap chain or passed to a shader, respectively.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Creating a frame buffer object.</source>
          <target state="new">Direct3D 11: Creating a frame buffer object.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Change uniforms and uniform buffer objects to Direct3D constant buffers</source>
          <target state="new">Change uniforms and uniform buffer objects to Direct3D constant buffers</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In Open GL ES 2.0, uniforms are the mechanism to supply constant data to individual shader programs.</source>
          <target state="new">In Open GL ES 2.0, uniforms are the mechanism to supply constant data to individual shader programs.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>This data cannot be altered by the shaders.</source>
          <target state="new">This data cannot be altered by the shaders.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Setting a uniform typically involves providing one of the glUniform\* methods with the upload location in the GPU along with a pointer to the data in app memory.</source>
          <target state="new">Setting a uniform typically involves providing one of the glUniform\* methods with the upload location in the GPU along with a pointer to the data in app memory.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>After ithe glUniform\* method executes, the uniform data is in the GPU memory and accessible by the shaders that have declared that uniform.</source>
          <target state="new">After ithe glUniform\* method executes, the uniform data is in the GPU memory and accessible by the shaders that have declared that uniform.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You are expected to ensure that the data is packed in such a way that the shader can interpret it based on the uniform declaration in the shader (by using compatible types).</source>
          <target state="new">You are expected to ensure that the data is packed in such a way that the shader can interpret it based on the uniform declaration in the shader (by using compatible types).</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0 Creating a uniform and uploading data to it</source>
          <target state="new">OpenGL ES 2.0 Creating a uniform and uploading data to it</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>In a shader's GLSL, the corresponding uniform declaration looks like this:</source>
          <target state="new">In a shader's GLSL, the corresponding uniform declaration looks like this:</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Open GL ES 2.0: GLSL uniform declaration</source>
          <target state="new">Open GL ES 2.0: GLSL uniform declaration</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Direct3D designates uniform data as "constant buffers," which, like uniforms, contain constant data provided to individual shaders.</source>
          <target state="new">Direct3D designates uniform data as "constant buffers," which, like uniforms, contain constant data provided to individual shaders.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>As with uniform buffers, it is important to pack the constant buffer data in memory identically to the way the shader expects to interpret it.</source>
          <target state="new">As with uniform buffers, it is important to pack the constant buffer data in memory identically to the way the shader expects to interpret it.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Using DirectXMath types (such as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XMFLOAT4<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ee419608)</ept>) instead of platform types (such as <bpt id="p3">**</bpt>float\*<ept id="p3">**</ept> or <bpt id="p4">**</bpt>float\[4\]<ept id="p4">**</ept>) guarantees proper data element alignment.</source>
          <target state="new">Using DirectXMath types (such as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>XMFLOAT4<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ee419608)</ept>) instead of platform types (such as <bpt id="p3">**</bpt>float\*<ept id="p3">**</ept> or <bpt id="p4">**</bpt>float\[4\]<ept id="p4">**</ept>) guarantees proper data element alignment.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Constant buffers must have an associated GPU register used to reference that data on the GPU.</source>
          <target state="new">Constant buffers must have an associated GPU register used to reference that data on the GPU.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The data is packed into the register location as indicated by the layout of the buffer.</source>
          <target state="new">The data is packed into the register location as indicated by the layout of the buffer.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Creating a constant buffer and uploading data to it</source>
          <target state="new">Direct3D 11: Creating a constant buffer and uploading data to it</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>In a shader's HLSL, the corresponding constant buffer declaration looks like this:</source>
          <target state="new">In a shader's HLSL, the corresponding constant buffer declaration looks like this:</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Constant buffer HLSL declaration</source>
          <target state="new">Direct3D 11: Constant buffer HLSL declaration</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Note that a register must be declared for each constant buffer.</source>
          <target state="new">Note that a register must be declared for each constant buffer.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Different Direct3D feature levels have different maximum available registers, so do not exceed the maximum number for the lowest feature level you are targeting.</source>
          <target state="new">Different Direct3D feature levels have different maximum available registers, so do not exceed the maximum number for the lowest feature level you are targeting.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Port vertex attributes to a Direct3D input layouts and HLSL semantics</source>
          <target state="new">Port vertex attributes to a Direct3D input layouts and HLSL semantics</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Since vertex data can be modified by the shader pipeline, OpenGL ES 2.0 requires that you specify them as "attributes" instead of "uniforms".</source>
          <target state="new">Since vertex data can be modified by the shader pipeline, OpenGL ES 2.0 requires that you specify them as "attributes" instead of "uniforms".</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>(This has changed in later versions of OpenGL and GLSL.) Vertex-specific data such the vertex position, normals, tangents, and color values are supplied to the shaders as attribute values.</source>
          <target state="new">(This has changed in later versions of OpenGL and GLSL.) Vertex-specific data such the vertex position, normals, tangents, and color values are supplied to the shaders as attribute values.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>These attribute values correspond to specific offsets for each element in the vertex data; for example, the first attribute could point to the position component of an individual vertex, and the second to the normal, and so on.</source>
          <target state="new">These attribute values correspond to specific offsets for each element in the vertex data; for example, the first attribute could point to the position component of an individual vertex, and the second to the normal, and so on.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The basic process for moving the vertex buffer data from main memory to the GPU looks like this:</source>
          <target state="new">The basic process for moving the vertex buffer data from main memory to the GPU looks like this:</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Upload the vertex data with glBindBuffer.</source>
          <target state="new">Upload the vertex data with glBindBuffer.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Get the location of the attributes on the GPU with glGetAttribLocation.</source>
          <target state="new">Get the location of the attributes on the GPU with glGetAttribLocation.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Call it for each attribute in the vertex data element.</source>
          <target state="new">Call it for each attribute in the vertex data element.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Call glVertexAttribPointer to provide set the correct attribute size and offset inside an individual vertex data element.</source>
          <target state="new">Call glVertexAttribPointer to provide set the correct attribute size and offset inside an individual vertex data element.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Do this for each attribute.</source>
          <target state="new">Do this for each attribute.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Enable the vertex data layout information with glEnableVertexAttribArray.</source>
          <target state="new">Enable the vertex data layout information with glEnableVertexAttribArray.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Uploading vertex buffer data to the shader attribute</source>
          <target state="new">OpenGL ES 2.0: Uploading vertex buffer data to the shader attribute</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Now, in your vertex shader, you declare attributes with the same names you defined in your call to glGetAttribLocation.</source>
          <target state="new">Now, in your vertex shader, you declare attributes with the same names you defined in your call to glGetAttribLocation.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0: Declaring an attribute in GLSL</source>
          <target state="new">OpenGL ES 2.0: Declaring an attribute in GLSL</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>In some ways, the same process holds for Direct3D.</source>
          <target state="new">In some ways, the same process holds for Direct3D.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Instead of a attributes, vertex data is provided in input buffers, which include vertex buffers and the corresponding index buffers.</source>
          <target state="new">Instead of a attributes, vertex data is provided in input buffers, which include vertex buffers and the corresponding index buffers.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>However, since Direct3D does not have the "attribute" declaration, you must specify an input layout which declares the individual component of the data elements in the vertex buffer and the HLSL semantics that indicate where and how those components are to be interpreted by the vertex shader.</source>
          <target state="new">However, since Direct3D does not have the "attribute" declaration, you must specify an input layout which declares the individual component of the data elements in the vertex buffer and the HLSL semantics that indicate where and how those components are to be interpreted by the vertex shader.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>HLSL semantics require that you define the usage of each component with a specific string that informs the shader engine as to its purpose.</source>
          <target state="new">HLSL semantics require that you define the usage of each component with a specific string that informs the shader engine as to its purpose.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For example, vertex position data is marked as POSITION, normal data is marked as NORMAL, and vertex color data is marked as COLOR.</source>
          <target state="new">For example, vertex position data is marked as POSITION, normal data is marked as NORMAL, and vertex color data is marked as COLOR.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>(Other shader stages also require specific semantics, and those semantics have different interpretations based on the shader stage.) For more info on HLSL semantics, read <bpt id="p1">[</bpt>Port your shader pipeline<ept id="p1">](change-your-shader-loading-code.md)</ept> and <bpt id="p2">[</bpt>HLSL Semantics<ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/bb205574)</ept>.</source>
          <target state="new">(Other shader stages also require specific semantics, and those semantics have different interpretations based on the shader stage.) For more info on HLSL semantics, read <bpt id="p1">[</bpt>Port your shader pipeline<ept id="p1">](change-your-shader-loading-code.md)</ept> and <bpt id="p2">[</bpt>HLSL Semantics<ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/bb205574)</ept>.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Collectively, the process of setting the vertex and index buffers, and setting the input layout is called the "Input Assembly" (IA) stage of the Direct3D graphics pipeline.</source>
          <target state="new">Collectively, the process of setting the vertex and index buffers, and setting the input layout is called the "Input Assembly" (IA) stage of the Direct3D graphics pipeline.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Configuring the input assembly stage</source>
          <target state="new">Direct3D 11: Configuring the input assembly stage</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>An input layout is declared and associated with a vertex shader by declaring the format of the vertex data element and the semantic used for each component.</source>
          <target state="new">An input layout is declared and associated with a vertex shader by declaring the format of the vertex data element and the semantic used for each component.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The vertex element data layout described in the D3D11\_INPUT\_ELEMENT\_DESC you create must correspond to the layout of the corresponding structure.</source>
          <target state="new">The vertex element data layout described in the D3D11\_INPUT\_ELEMENT\_DESC you create must correspond to the layout of the corresponding structure.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Here, you create a layout for vertex data that has two components:</source>
          <target state="new">Here, you create a layout for vertex data that has two components:</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>A vertex position coordinate, represented in main memory as an XMFLOAT3, which is an aligned array of 3 32-bit floating point values for the (x, y, z) coordinates.</source>
          <target state="new">A vertex position coordinate, represented in main memory as an XMFLOAT3, which is an aligned array of 3 32-bit floating point values for the (x, y, z) coordinates.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A vertex color value, represented as an XMFLOAT4, which is an aligned array of 4 32-bit floating point values for the color (RGBA).</source>
          <target state="new">A vertex color value, represented as an XMFLOAT4, which is an aligned array of 4 32-bit floating point values for the color (RGBA).</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>You assign a semantic for each one, as well as a format type.</source>
          <target state="new">You assign a semantic for each one, as well as a format type.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>You then pass the description to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device1::CreateInputLayout<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476512)</ept>.</source>
          <target state="new">You then pass the description to <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device1::CreateInputLayout<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476512)</ept>.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>The input layout is used when we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext1::IASetInputLayout<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</ept> when you set up the input assembly during our render method.</source>
          <target state="new">The input layout is used when we call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext1::IASetInputLayout<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476454)</ept> when you set up the input assembly during our render method.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Describing an input layout with specific semantics</source>
          <target state="new">Direct3D 11: Describing an input layout with specific semantics</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Finally, you make sure that the shader can understand the input data by declaring the input.</source>
          <target state="new">Finally, you make sure that the shader can understand the input data by declaring the input.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>The semantics you assigned in the layout are used to select the correct locations in GPU memory.</source>
          <target state="new">The semantics you assigned in the layout are used to select the correct locations in GPU memory.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>Direct3D 11: Declaring shader input data with HLSL semantics</source>
          <target state="new">Direct3D 11: Declaring shader input data with HLSL semantics</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>