<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a881a1a8fcfb22a48bae33d10654fb1b2096f76a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\tutorial--assembling-the-rendering-pipeline.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Assemble the rendering framework</source>
          <target state="new">Assemble the rendering framework</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Now, it's time to look at how the sample game uses that structure and state to display its graphics.</source>
          <target state="new">Now, it's time to look at how the sample game uses that structure and state to display its graphics.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Assemble the rendering framework</source>
          <target state="new">Assemble the rendering framework</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>By now, you've seen how to structure a Universal Windows Platform (UWP) game to work with the Windows Runtime, and how to define a state machine to handle the flow of the game.</source>
          <target state="new">By now, you've seen how to structure a Universal Windows Platform (UWP) game to work with the Windows Runtime, and how to define a state machine to handle the flow of the game.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Now, it's time to look at how the sample game uses that structure and state to display its graphics.</source>
          <target state="new">Now, it's time to look at how the sample game uses that structure and state to display its graphics.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Here, we look at how to implement a rendering framework, starting from the initialization of the graphics device through the presentation of the graphics objects for display.</source>
          <target state="new">Here, we look at how to implement a rendering framework, starting from the initialization of the graphics device through the presentation of the graphics objects for display.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Objective</source>
          <target state="new">Objective</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>To understand how to set up a basic rendering framework to display the graphics output for a UWP DirectX game.</source>
          <target state="new">To understand how to set up a basic rendering framework to display the graphics output for a UWP DirectX game.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   The following code files are not discussed here, but provide classes and methods referred to in this topic and are <bpt id="p2">[</bpt>provided as code at the end of this topic<ept id="p2">](#code_sample)</ept>:</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   The following code files are not discussed here, but provide classes and methods referred to in this topic and are <bpt id="p2">[</bpt>provided as code at the end of this topic<ept id="p2">](#code_sample)</ept>:</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Animate.h/.cpp<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Animate.h/.cpp<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>BasicLoader.h/.cpp<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>BasicLoader.h/.cpp<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Provides methods for loading meshes, shaders and textures, both synchronously and asynchronously.</source>
          <target state="new">Provides methods for loading meshes, shaders and textures, both synchronously and asynchronously.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Very useful!</source>
          <target state="new">Very useful!</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MeshObject.h/.cpp<ept id="p1">**</ept>, <bpt id="p2">**</bpt>SphereMesh.h/.cpp<ept id="p2">**</ept>, <bpt id="p3">**</bpt>CylinderMesh.h/.cpp<ept id="p3">**</ept>, <bpt id="p4">**</bpt>FaceMesh.h/.cpp<ept id="p4">**</ept>, and <bpt id="p5">**</bpt>WorldMesh.h/.cpp<ept id="p5">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>MeshObject.h/.cpp<ept id="p1">**</ept>, <bpt id="p2">**</bpt>SphereMesh.h/.cpp<ept id="p2">**</ept>, <bpt id="p3">**</bpt>CylinderMesh.h/.cpp<ept id="p3">**</ept>, <bpt id="p4">**</bpt>FaceMesh.h/.cpp<ept id="p4">**</ept>, and <bpt id="p5">**</bpt>WorldMesh.h/.cpp<ept id="p5">**</ept>.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Contains the definitions of the object primitives used in the game, such as the ammo spheres, the cylinder and cone obstacles, and the walls of the shooting gallery.</source>
          <target state="new">Contains the definitions of the object primitives used in the game, such as the ammo spheres, the cylinder and cone obstacles, and the walls of the shooting gallery.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>(<bpt id="p1">**</bpt>GameObject.cpp<ept id="p1">**</ept>, briefly discussed in this topic, contains the method for rendering these primitives.)</source>
          <target state="new">(<bpt id="p1">**</bpt>GameObject.cpp<ept id="p1">**</ept>, briefly discussed in this topic, contains the method for rendering these primitives.)</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Level.h/.cpp<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Level\[1-6\].h/.cpp<ept id="p2">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Level.h/.cpp<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Level\[1-6\].h/.cpp<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Contains the configuration for each of the games six levels, including the success criteria and the number and position of the targets and obstacles.</source>
          <target state="new">Contains the configuration for each of the games six levels, including the success criteria and the number and position of the targets and obstacles.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>TargetTexture.h/.cpp<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>TargetTexture.h/.cpp<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Contains a set of methods for drawing the bitmaps used as the textures on the targets.</source>
          <target state="new">Contains a set of methods for drawing the bitmaps used as the textures on the targets.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>These files contain code that is not specific to UWP DirectX games.</source>
          <target state="new">These files contain code that is not specific to UWP DirectX games.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>But you can review them separately if you'd like more implementation details.</source>
          <target state="new">But you can review them separately if you'd like more implementation details.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This section covers three key files from the game sample (<bpt id="p1">[</bpt>provided as code at the end of this topic<ept id="p1">](#code_sample)</ept>):</source>
          <target state="new">This section covers three key files from the game sample (<bpt id="p1">[</bpt>provided as code at the end of this topic<ept id="p1">](#code_sample)</ept>):</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Camera.h/.cpp</source>
          <target state="new">Camera.h/.cpp</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>GameRenderer.h/.cpp</source>
          <target state="new">GameRenderer.h/.cpp</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>PrimObject.h/.cpp</source>
          <target state="new">PrimObject.h/.cpp</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Again, we assume that you understand basic 3D programming concepts like meshes, vertices, and textures.</source>
          <target state="new">Again, we assume that you understand basic 3D programming concepts like meshes, vertices, and textures.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For more info about Direct3D 11 programming in general, see <bpt id="p1">[</bpt>Programming Guide for Direct3D 11<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476345)</ept>.</source>
          <target state="new">For more info about Direct3D 11 programming in general, see <bpt id="p1">[</bpt>Programming Guide for Direct3D 11<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476345)</ept>.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>With that said, let's look at the work that must be done to put our game on the screen.</source>
          <target state="new">With that said, let's look at the work that must be done to put our game on the screen.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>An overview of the Windows Runtime and DirectX</source>
          <target state="new">An overview of the Windows Runtime and DirectX</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>DirectX is a fundamental part of the Windows Runtime and of the Windows 10 experience.</source>
          <target state="new">DirectX is a fundamental part of the Windows Runtime and of the Windows 10 experience.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>All of Windows 10's visuals are built on top of DirectX, and you have the same direct line to the same low-level graphics interface, <bpt id="p1">[</bpt>DXGI<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh404534)</ept>, which provides an abstraction layer for the graphics hardware and its drivers.</source>
          <target state="new">All of Windows 10's visuals are built on top of DirectX, and you have the same direct line to the same low-level graphics interface, <bpt id="p1">[</bpt>DXGI<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/hh404534)</ept>, which provides an abstraction layer for the graphics hardware and its drivers.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>All the Direct3D 11 APIs are available for you to talk to DXGI directly.</source>
          <target state="new">All the Direct3D 11 APIs are available for you to talk to DXGI directly.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The result is fast, high performing graphics in your games that give you access to all the latest graphics hardware features.</source>
          <target state="new">The result is fast, high performing graphics in your games that give you access to all the latest graphics hardware features.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>To add DirectX support to a UWP app, you create a view provider for DirectX resources by implementing the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IFrameworkViewSource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh700482)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>IFrameworkView<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh700478)</ept> interfaces.</source>
          <target state="new">To add DirectX support to a UWP app, you create a view provider for DirectX resources by implementing the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>IFrameworkViewSource<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh700482)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>IFrameworkView<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh700478)</ept> interfaces.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>These provide a factory pattern for your view provider type and the implementation of your DirectX view provider, respectively.</source>
          <target state="new">These provide a factory pattern for your view provider type and the implementation of your DirectX view provider, respectively.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>The UWP singleton, represented by the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreApplication<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225016)</ept> object, runs this implementation.</source>
          <target state="new">The UWP singleton, represented by the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreApplication<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br225016)</ept> object, runs this implementation.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>In <bpt id="p1">[</bpt>Defining the game's UWP framework<ept id="p1">](tutorial--building-the-games-metro-style-app-framework.md)</ept>, we looked at how the renderer fit into the game sample's app framework.</source>
          <target state="new">In <bpt id="p1">[</bpt>Defining the game's UWP framework<ept id="p1">](tutorial--building-the-games-metro-style-app-framework.md)</ept>, we looked at how the renderer fit into the game sample's app framework.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Now, let's look at how the game renderer connects to the view and builds the graphics that define the look of the game.</source>
          <target state="new">Now, let's look at how the game renderer connects to the view and builds the graphics that define the look of the game.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Defining the renderer</source>
          <target state="new">Defining the renderer</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>GameRenderer<ept id="p1">**</ept> abstract type inherits from the <bpt id="p2">**</bpt>DirectXBase<ept id="p2">**</ept> renderer type, adds support for stereo 3-D, and declares constant buffers and resources for the shaders that create and define our graphic primitives.</source>
          <target state="new">The <bpt id="p1">**</bpt>GameRenderer<ept id="p1">**</ept> abstract type inherits from the <bpt id="p2">**</bpt>DirectXBase<ept id="p2">**</ept> renderer type, adds support for stereo 3-D, and declares constant buffers and resources for the shaders that create and define our graphic primitives.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Here's the definition of <bpt id="p1">**</bpt>GameRenderer<ept id="p1">**</ept>.</source>
          <target state="new">Here's the definition of <bpt id="p1">**</bpt>GameRenderer<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Because the Direct3D 11 APIs are defined as COM APIs, you must provide <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ComPtr<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br244983)</ept> references to the objects defined by these APIs.</source>
          <target state="new">Because the Direct3D 11 APIs are defined as COM APIs, you must provide <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ComPtr<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br244983)</ept> references to the objects defined by these APIs.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>These objects are automatically freed when their last reference goes out of scope when the app terminates.</source>
          <target state="new">These objects are automatically freed when their last reference goes out of scope when the app terminates.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>The game sample declares 4 specific constant buffers:</source>
          <target state="new">The game sample declares 4 specific constant buffers:</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_constantBufferNeverChanges<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_constantBufferNeverChanges<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This constant buffer contains the lighting parameters.</source>
          <target state="new">This constant buffer contains the lighting parameters.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>It's set one time and never changes again.</source>
          <target state="new">It's set one time and never changes again.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_constantBufferChangeOnResize<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_constantBufferChangeOnResize<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>This constant buffer contains the projection matrix.</source>
          <target state="new">This constant buffer contains the projection matrix.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>The projection matrix is dependent on the size and aspect ratio of the window.</source>
          <target state="new">The projection matrix is dependent on the size and aspect ratio of the window.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>It's updated only when the window size changes.</source>
          <target state="new">It's updated only when the window size changes.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_constantBufferChangesEveryFrame<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_constantBufferChangesEveryFrame<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>This constant buffer contains the view matrix.</source>
          <target state="new">This constant buffer contains the view matrix.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>This matrix is dependent on the camera position and look direction (the normal to the projection) and changes only one time per frame.</source>
          <target state="new">This matrix is dependent on the camera position and look direction (the normal to the projection) and changes only one time per frame.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_constantBufferChangesEveryPrim<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_constantBufferChangesEveryPrim<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This constant buffer contains the model matrix and material properties of each primitive.</source>
          <target state="new">This constant buffer contains the model matrix and material properties of each primitive.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The model matrix transforms vertices from local coordinates into world coordinates.</source>
          <target state="new">The model matrix transforms vertices from local coordinates into world coordinates.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>These constants are specific to each primitive and are updated for every draw call.</source>
          <target state="new">These constants are specific to each primitive and are updated for every draw call.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The whole idea of multiple constant buffers with different frequencies is to reduce the amount of data that must be sent to the GPU per frame.</source>
          <target state="new">The whole idea of multiple constant buffers with different frequencies is to reduce the amount of data that must be sent to the GPU per frame.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Therefore, the sample separates constants into different buffers based on the frequency that they must be updated.</source>
          <target state="new">Therefore, the sample separates constants into different buffers based on the frequency that they must be updated.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>This is a best practice for Direct3D programming.</source>
          <target state="new">This is a best practice for Direct3D programming.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>The renderer contains the shader objects that compute our primitives and textures: <bpt id="p1">**</bpt>m\_vertexShader<ept id="p1">**</ept> and <bpt id="p2">**</bpt>m\_pixelShader<ept id="p2">**</ept>.</source>
          <target state="new">The renderer contains the shader objects that compute our primitives and textures: <bpt id="p1">**</bpt>m\_vertexShader<ept id="p1">**</ept> and <bpt id="p2">**</bpt>m\_pixelShader<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The vertex shader processes the primitives and the basic lighting, and the pixel shader (sometimes called a fragment shader) processes the textures and any per-pixel effects.</source>
          <target state="new">The vertex shader processes the primitives and the basic lighting, and the pixel shader (sometimes called a fragment shader) processes the textures and any per-pixel effects.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>There are two versions of these shaders (regular and flat) for rendering different primitives.</source>
          <target state="new">There are two versions of these shaders (regular and flat) for rendering different primitives.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The flat versions are much simpler and don't do specular highlights or any per pixel lighting effects.</source>
          <target state="new">The flat versions are much simpler and don't do specular highlights or any per pixel lighting effects.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>These are used for the walls and make rendering faster on lower powered devices.</source>
          <target state="new">These are used for the walls and make rendering faster on lower powered devices.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The renderer class contains the <bpt id="p1">[</bpt>DirectWrite and Direct2D<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff729481)</ept> resources used for the overlay and the Heads Up Display (the <bpt id="p2">**</bpt>GameHud<ept id="p2">**</ept> object).</source>
          <target state="new">The renderer class contains the <bpt id="p1">[</bpt>DirectWrite and Direct2D<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff729481)</ept> resources used for the overlay and the Heads Up Display (the <bpt id="p2">**</bpt>GameHud<ept id="p2">**</ept> object).</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>The overlay and HUD are drawn on top of the render target when projection is complete in the graphics pipeline.</source>
          <target state="new">The overlay and HUD are drawn on top of the render target when projection is complete in the graphics pipeline.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>The renderer also defines the shader resource objects that hold the textures for the primitives.</source>
          <target state="new">The renderer also defines the shader resource objects that hold the textures for the primitives.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Some of these textures are pre-defined (DDS textures for the walls and floor of the world as well as the ammo spheres).</source>
          <target state="new">Some of these textures are pre-defined (DDS textures for the walls and floor of the world as well as the ammo spheres).</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Now, it's time to see how this object is created!</source>
          <target state="new">Now, it's time to see how this object is created!</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Initializing the renderer</source>
          <target state="new">Initializing the renderer</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The sample game calls this <bpt id="p1">**</bpt>Initialize<ept id="p1">**</ept> method as part of the CoreApplication initialization sequence in <bpt id="p2">**</bpt>App::SetWindow<ept id="p2">**</ept>.</source>
          <target state="new">The sample game calls this <bpt id="p1">**</bpt>Initialize<ept id="p1">**</ept> method as part of the CoreApplication initialization sequence in <bpt id="p2">**</bpt>App::SetWindow<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>This is a pretty straightforward method.</source>
          <target state="new">This is a pretty straightforward method.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>It checks to see if the renderer had been previously initialized, and if it hasn't, it instantiates the <bpt id="p1">**</bpt>GameHud<ept id="p1">**</ept> and <bpt id="p2">**</bpt>GameInfoOverlay<ept id="p2">**</ept> objects.</source>
          <target state="new">It checks to see if the renderer had been previously initialized, and if it hasn't, it instantiates the <bpt id="p1">**</bpt>GameHud<ept id="p1">**</ept> and <bpt id="p2">**</bpt>GameInfoOverlay<ept id="p2">**</ept> objects.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>After that, the renderer initialization process runs the base implementation of <bpt id="p1">**</bpt>Initialize<ept id="p1">**</ept> provided on the <bpt id="p2">**</bpt>DirectXBase<ept id="p2">**</ept> class it inherited from.</source>
          <target state="new">After that, the renderer initialization process runs the base implementation of <bpt id="p1">**</bpt>Initialize<ept id="p1">**</ept> provided on the <bpt id="p2">**</bpt>DirectXBase<ept id="p2">**</ept> class it inherited from.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>When the DirectXBase initialization completes, the <bpt id="p1">**</bpt>GameInfoOverlay<ept id="p1">**</ept> object is initialized.</source>
          <target state="new">When the DirectXBase initialization completes, the <bpt id="p1">**</bpt>GameInfoOverlay<ept id="p1">**</ept> object is initialized.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>After initialization is complete, it's time to look at the methods for creating and loading the graphics resources for the game.</source>
          <target state="new">After initialization is complete, it's time to look at the methods for creating and loading the graphics resources for the game.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Creating and loading DirectX graphics resources</source>
          <target state="new">Creating and loading DirectX graphics resources</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>The first order of business in any game is to establish a connection to our graphics interface, create the resources we need to draw the graphics, and then set up a render target into which we can draw those graphics.</source>
          <target state="new">The first order of business in any game is to establish a connection to our graphics interface, create the resources we need to draw the graphics, and then set up a render target into which we can draw those graphics.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In the game sample (and in the Microsoft Visual Studio<bpt id="p1">**</bpt>DirectX 11 App (Universal Windows)<ept id="p1">**</ept> template), this process is implemented with three methods:</source>
          <target state="new">In the game sample (and in the Microsoft Visual Studio<bpt id="p1">**</bpt>DirectX 11 App (Universal Windows)<ept id="p1">**</ept> template), this process is implemented with three methods:</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>CreateDeviceIndependentResources</source>
          <target state="new">CreateDeviceIndependentResources</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>CreateDeviceResources</source>
          <target state="new">CreateDeviceResources</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>CreateWindowSizeDependentResources</source>
          <target state="new">CreateWindowSizeDependentResources</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>Now, in the game sample, we override two of these methods (<bpt id="p1">**</bpt>CreateDeviceIndependentResources<ept id="p1">**</ept> and <bpt id="p2">**</bpt>CreateDeviceResources<ept id="p2">**</ept>) provided on the <bpt id="p3">**</bpt>DirectXBase<ept id="p3">**</ept> class implemented in the <bpt id="p4">**</bpt>DirectX 11 App (Universal Windows)<ept id="p4">**</ept> template.</source>
          <target state="new">Now, in the game sample, we override two of these methods (<bpt id="p1">**</bpt>CreateDeviceIndependentResources<ept id="p1">**</ept> and <bpt id="p2">**</bpt>CreateDeviceResources<ept id="p2">**</ept>) provided on the <bpt id="p3">**</bpt>DirectXBase<ept id="p3">**</ept> class implemented in the <bpt id="p4">**</bpt>DirectX 11 App (Universal Windows)<ept id="p4">**</ept> template.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>For each of these override methods, we first call the <bpt id="p1">**</bpt>DirectXBase<ept id="p1">**</ept> implementations they override, and then add more implementation details specific to the game sample.</source>
          <target state="new">For each of these override methods, we first call the <bpt id="p1">**</bpt>DirectXBase<ept id="p1">**</ept> implementations they override, and then add more implementation details specific to the game sample.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Be aware that the <bpt id="p1">**</bpt>DirectXBase<ept id="p1">**</ept> class implementation included with the game sample has been modified from the version provided in the Visual Studio template to include stereoscopic view support and includes pre-rotation of the <bpt id="p2">**</bpt>SwapBuffer<ept id="p2">**</ept> object.</source>
          <target state="new">Be aware that the <bpt id="p1">**</bpt>DirectXBase<ept id="p1">**</ept> class implementation included with the game sample has been modified from the version provided in the Visual Studio template to include stereoscopic view support and includes pre-rotation of the <bpt id="p2">**</bpt>SwapBuffer<ept id="p2">**</ept> object.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CreateWindowSizeDependentResources<ept id="p1">**</ept> is not overridden by the <bpt id="p2">**</bpt>GameRenderer<ept id="p2">**</ept> object.</source>
          <target state="new"><bpt id="p1">**</bpt>CreateWindowSizeDependentResources<ept id="p1">**</ept> is not overridden by the <bpt id="p2">**</bpt>GameRenderer<ept id="p2">**</ept> object.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>We use the implementation of it provided in the <bpt id="p1">**</bpt>DirectXBase<ept id="p1">**</ept> class.</source>
          <target state="new">We use the implementation of it provided in the <bpt id="p1">**</bpt>DirectXBase<ept id="p1">**</ept> class.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>For more info about the <bpt id="p1">**</bpt>DirectXBase<ept id="p1">**</ept> base implementations of these methods, see <bpt id="p2">[</bpt>How to set up your UWP DirectX app to display a view<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/hh465077)</ept>.</source>
          <target state="new">For more info about the <bpt id="p1">**</bpt>DirectXBase<ept id="p1">**</ept> base implementations of these methods, see <bpt id="p2">[</bpt>How to set up your UWP DirectX app to display a view<ept id="p2">](https://msdn.microsoft.com/library/windows/apps/hh465077)</ept>.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The first of these overridden methods, <bpt id="p1">**</bpt>CreateDeviceIndependentResources<ept id="p1">**</ept>, calls the <bpt id="p2">**</bpt>GameHud::CreateDeviceIndependentResources<ept id="p2">**</ept> method to create the <bpt id="p3">[</bpt>DirectWrite<ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/dd368038)</ept> text resources that use the Segoe UI font, which is the font used by most UWP apps.</source>
          <target state="new">The first of these overridden methods, <bpt id="p1">**</bpt>CreateDeviceIndependentResources<ept id="p1">**</ept>, calls the <bpt id="p2">**</bpt>GameHud::CreateDeviceIndependentResources<ept id="p2">**</ept> method to create the <bpt id="p3">[</bpt>DirectWrite<ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/dd368038)</ept> text resources that use the Segoe UI font, which is the font used by most UWP apps.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>CreateDeviceIndependentResources</source>
          <target state="new">CreateDeviceIndependentResources</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The sample uses four text formatters: two for title header and title body text, and two for body text.</source>
          <target state="new">The sample uses four text formatters: two for title header and title body text, and two for body text.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>This is used in much of the overlay text.</source>
          <target state="new">This is used in much of the overlay text.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The second method, <bpt id="p1">**</bpt>CreateDeviceResources<ept id="p1">**</ept>, loads the specific resources for the game that will be computed on the graphics device.</source>
          <target state="new">The second method, <bpt id="p1">**</bpt>CreateDeviceResources<ept id="p1">**</ept>, loads the specific resources for the game that will be computed on the graphics device.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Let's look at the code for this method.</source>
          <target state="new">Let's look at the code for this method.</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>CreateDeviceResources</source>
          <target state="new">CreateDeviceResources</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>In this example, in normal execution, the <bpt id="p1">**</bpt>CreateDeviceResources<ept id="p1">**</ept> method just calls the base class method and then calls the <bpt id="p2">**</bpt>GameHud::CreateDeviceResources<ept id="p2">**</ept> method (also listed previously).</source>
          <target state="new">In this example, in normal execution, the <bpt id="p1">**</bpt>CreateDeviceResources<ept id="p1">**</ept> method just calls the base class method and then calls the <bpt id="p2">**</bpt>GameHud::CreateDeviceResources<ept id="p2">**</ept> method (also listed previously).</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>If there's a problem later with the underlying graphics device, it might have to be re-initialized.</source>
          <target state="new">If there's a problem later with the underlying graphics device, it might have to be re-initialized.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In this case, the <bpt id="p1">**</bpt>CreateDeviceResources<ept id="p1">**</ept> method initiates a set of async tasks to create the game device resources.</source>
          <target state="new">In this case, the <bpt id="p1">**</bpt>CreateDeviceResources<ept id="p1">**</ept> method initiates a set of async tasks to create the game device resources.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>This is done through a sequence of two methods: a call to <bpt id="p1">**</bpt>CreateDeviceResourcesAsync<ept id="p1">**</ept>, and then, when it completes, <bpt id="p2">**</bpt>FinalizeCreateGameDeviceResources<ept id="p2">**</ept>.</source>
          <target state="new">This is done through a sequence of two methods: a call to <bpt id="p1">**</bpt>CreateDeviceResourcesAsync<ept id="p1">**</ept>, and then, when it completes, <bpt id="p2">**</bpt>FinalizeCreateGameDeviceResources<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>CreateGameDeviceResourcesAsync and FinalizeCreateGameDeviceResources</source>
          <target state="new">CreateGameDeviceResourcesAsync and FinalizeCreateGameDeviceResources</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CreateDeviceResourcesAsync<ept id="p1">**</ept> is a method that runs as a separate set of async tasks to load the game resources.</source>
          <target state="new"><bpt id="p1">**</bpt>CreateDeviceResourcesAsync<ept id="p1">**</ept> is a method that runs as a separate set of async tasks to load the game resources.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Because it's expected to run on a separate thread, it only has access to the Direct3D 11 device methods (those defined on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</ept>) and not the device context methods (the methods defined on <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>), so it has the option to not perform any rendering.</source>
          <target state="new">Because it's expected to run on a separate thread, it only has access to the Direct3D 11 device methods (those defined on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476379)</ept>) and not the device context methods (the methods defined on <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476385)</ept>), so it has the option to not perform any rendering.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>FinalizeCreateGameDeviceResources<ept id="p1">**</ept> method runs on the main thread and does have access to the Direct3D 11 device context methods.</source>
          <target state="new">The <bpt id="p1">**</bpt>FinalizeCreateGameDeviceResources<ept id="p1">**</ept> method runs on the main thread and does have access to the Direct3D 11 device context methods.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>The sequence of events for loading the game devices resources proceeds as follows.</source>
          <target state="new">The sequence of events for loading the game devices resources proceeds as follows.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>CreateDeviceResourcesAsync<ept id="p1">**</ept> first initializes constant buffers for the primitives.</source>
          <target state="new"><bpt id="p1">**</bpt>CreateDeviceResourcesAsync<ept id="p1">**</ept> first initializes constant buffers for the primitives.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>Constant buffers are low-latency, fixed-width buffers that hold the data that a shader uses during shader execution.</source>
          <target state="new">Constant buffers are low-latency, fixed-width buffers that hold the data that a shader uses during shader execution.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>(Think of these buffers as passing data to the shader that is constant over the execution of the particular draw call.) In this sample, the buffers contain the data that the shaders will use to:</source>
          <target state="new">(Think of these buffers as passing data to the shader that is constant over the execution of the particular draw call.) In this sample, the buffers contain the data that the shaders will use to:</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Place the light sources and set their color when the renderer initializes</source>
          <target state="new">Place the light sources and set their color when the renderer initializes</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Compute the view matrix whenever the window is resized</source>
          <target state="new">Compute the view matrix whenever the window is resized</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Compute the projection matrix for every frame update</source>
          <target state="new">Compute the projection matrix for every frame update</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Compute the transformations of the primitives on every render update</source>
          <target state="new">Compute the transformations of the primitives on every render update</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The constants receive the source information (vertices) and transform the vertex coordinates and data from model space into the device space.</source>
          <target state="new">The constants receive the source information (vertices) and transform the vertex coordinates and data from model space into the device space.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>Ultimately, this data results in texel coordinates and pixels in the render target.</source>
          <target state="new">Ultimately, this data results in texel coordinates and pixels in the render target.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Next, the game renderer object creates a loader for the shaders that will perform the computation.</source>
          <target state="new">Next, the game renderer object creates a loader for the shaders that will perform the computation.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>(See <bpt id="p1">**</bpt>BasicLoader.cpp<ept id="p1">**</ept> in the sample for the specific implementation.)</source>
          <target state="new">(See <bpt id="p1">**</bpt>BasicLoader.cpp<ept id="p1">**</ept> in the sample for the specific implementation.)</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>Then, <bpt id="p1">**</bpt>CreateDeviceResourcesAsync<ept id="p1">**</ept> initiates async tasks for loading all the texture resources into <bpt id="p2">**</bpt>ShaderResourceViews<ept id="p2">**</ept>.</source>
          <target state="new">Then, <bpt id="p1">**</bpt>CreateDeviceResourcesAsync<ept id="p1">**</ept> initiates async tasks for loading all the texture resources into <bpt id="p2">**</bpt>ShaderResourceViews<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>These texture resources are stored in the DirectDraw Surface (DDS) textures that came with the sample.</source>
          <target state="new">These texture resources are stored in the DirectDraw Surface (DDS) textures that came with the sample.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>DDS textures are a lossy texture format that work with DirectX Texture Compression (DXTC).</source>
          <target state="new">DDS textures are a lossy texture format that work with DirectX Texture Compression (DXTC).</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>We use these textures on the walls, ceiling and floor of the world, and on the ammo spheres and pillar obstacles.</source>
          <target state="new">We use these textures on the walls, ceiling and floor of the world, and on the ammo spheres and pillar obstacles.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Finally, it returns a task group that contains all the async tasks created by the method.</source>
          <target state="new">Finally, it returns a task group that contains all the async tasks created by the method.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The calling function waits for the completion of all these async tasks, and then calls <bpt id="p1">**</bpt>FinalizeCreateGameDeviceResources<ept id="p1">**</ept>.</source>
          <target state="new">The calling function waits for the completion of all these async tasks, and then calls <bpt id="p1">**</bpt>FinalizeCreateGameDeviceResources<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>FinalizeCreateGameDeviceResources<ept id="p1">**</ept> loads the initial data into the constant buffers with a device context method call to <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ID3D11DeviceContext::UpdateSubresource<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</ept>: <ph id="ph1">`m_deviceContext-&gt;UpdateSubresource`</ph>.</source>
          <target state="new"><bpt id="p1">**</bpt>FinalizeCreateGameDeviceResources<ept id="p1">**</ept> loads the initial data into the constant buffers with a device context method call to <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ID3D11DeviceContext::UpdateSubresource<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/desktop/ff476486)</ept>: <ph id="ph1">`m_deviceContext-&gt;UpdateSubresource`</ph>.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>This method creates the mesh objects for the sphere, cylinder, face, and world game objects and the associated materials.</source>
          <target state="new">This method creates the mesh objects for the sphere, cylinder, face, and world game objects and the associated materials.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>It then walks the game object list associating the appropriate device resources with each object.</source>
          <target state="new">It then walks the game object list associating the appropriate device resources with each object.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The textures for the ringed and numbered target objects are procedurally generated using the code in <bpt id="p1">**</bpt>TargetTexture.cpp<ept id="p1">**</ept>.</source>
          <target state="new">The textures for the ringed and numbered target objects are procedurally generated using the code in <bpt id="p1">**</bpt>TargetTexture.cpp<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The renderer creates an instance of the <bpt id="p1">**</bpt>TargetTexture<ept id="p1">**</ept> type, which creates the bitmap texture for the target objects in the game when we call the <bpt id="p2">**</bpt>TargetTexture::CreateTextureResourceView<ept id="p2">**</ept> method.</source>
          <target state="new">The renderer creates an instance of the <bpt id="p1">**</bpt>TargetTexture<ept id="p1">**</ept> type, which creates the bitmap texture for the target objects in the game when we call the <bpt id="p2">**</bpt>TargetTexture::CreateTextureResourceView<ept id="p2">**</ept> method.</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The resulting texture is composed of concentric colored rings, with a numeric value on the top.</source>
          <target state="new">The resulting texture is composed of concentric colored rings, with a numeric value on the top.</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>These generated resources are associated with the appropriate target game objects.</source>
          <target state="new">These generated resources are associated with the appropriate target game objects.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Lastly, <bpt id="p1">**</bpt>FinalizeCreateGameDeviceResources<ept id="p1">**</ept> set the <ph id="ph1">`m_gameResourcesLoaded`</ph> Boolean global variable to indicate that all resources are now loaded.</source>
          <target state="new">Lastly, <bpt id="p1">**</bpt>FinalizeCreateGameDeviceResources<ept id="p1">**</ept> set the <ph id="ph1">`m_gameResourcesLoaded`</ph> Boolean global variable to indicate that all resources are now loaded.</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>The game has the resources to display the graphics in the current window, and it can recreate those resources as the window changes.</source>
          <target state="new">The game has the resources to display the graphics in the current window, and it can recreate those resources as the window changes.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Now, let's look at the camera used to define the player's view of the scene in that window.</source>
          <target state="new">Now, let's look at the camera used to define the player's view of the scene in that window.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Implementing the camera object</source>
          <target state="new">Implementing the camera object</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The game has the code in place to update the world in its own coordinate system (sometimes called the world space or scene space).</source>
          <target state="new">The game has the code in place to update the world in its own coordinate system (sometimes called the world space or scene space).</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>All objects, including the camera, are positioned and oriented in this space.</source>
          <target state="new">All objects, including the camera, are positioned and oriented in this space.</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>In the sample game, the camera's position along with the look vectors (the "look at" vector that points directly into the scene from the camera, and the "look up" vector that is upwards perpendicular to it) define the camera space.</source>
          <target state="new">In the sample game, the camera's position along with the look vectors (the "look at" vector that points directly into the scene from the camera, and the "look up" vector that is upwards perpendicular to it) define the camera space.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The projection parameters determine how much of that space is actually visible in the final scene; and the Field of View (FoV), aspect ratio, and clipping planes define the projection transformation.</source>
          <target state="new">The projection parameters determine how much of that space is actually visible in the final scene; and the Field of View (FoV), aspect ratio, and clipping planes define the projection transformation.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>A vertex shader does the heavy lifting of converting from the model coordinates to device coordinates with the following algorithm (where V is a vector and M is a matrix):</source>
          <target state="new">A vertex shader does the heavy lifting of converting from the model coordinates to device coordinates with the following algorithm (where V is a vector and M is a matrix):</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="new">.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>is a transformation matrix for model coordinates to world coordinates.</source>
          <target state="new">is a transformation matrix for model coordinates to world coordinates.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>This is provided by the primitive.</source>
          <target state="new">This is provided by the primitive.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>(We'll review this in the section on primitives, here.)</source>
          <target state="new">(We'll review this in the section on primitives, here.)</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>is a transformation matrix for world coordinates to view coordinates.</source>
          <target state="new">is a transformation matrix for world coordinates to view coordinates.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>This is provided by the view matrix of the camera.</source>
          <target state="new">This is provided by the view matrix of the camera.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>is a transformation matrix for view coordinates to device coordinates.</source>
          <target state="new">is a transformation matrix for view coordinates to device coordinates.</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>This is provided by the projection of the camera.</source>
          <target state="new">This is provided by the projection of the camera.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The shader code in <bpt id="p1">**</bpt>VertexShader.hlsl<ept id="p1">**</ept> is loaded with these vectors and matrices from the constant buffers, and performs this transformation for every vertex.</source>
          <target state="new">The shader code in <bpt id="p1">**</bpt>VertexShader.hlsl<ept id="p1">**</ept> is loaded with these vectors and matrices from the constant buffers, and performs this transformation for every vertex.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>Camera<ept id="p1">**</ept> object defines the view and projection matrices.</source>
          <target state="new">The <bpt id="p1">**</bpt>Camera<ept id="p1">**</ept> object defines the view and projection matrices.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Let's look at how the sample game declares it.</source>
          <target state="new">Let's look at how the sample game declares it.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>There are two 4x4 matrices that define the transformations to the view and projection coordinates, <bpt id="p1">**</bpt>m\_viewMatrix<ept id="p1">**</ept> and <bpt id="p2">**</bpt>m\_projectionMatrix<ept id="p2">**</ept>.</source>
          <target state="new">There are two 4x4 matrices that define the transformations to the view and projection coordinates, <bpt id="p1">**</bpt>m\_viewMatrix<ept id="p1">**</ept> and <bpt id="p2">**</bpt>m\_projectionMatrix<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>(For stereo projection, you use two projection matrices: one for each eye's view.) They are calculated with these two methods, respectively:</source>
          <target state="new">(For stereo projection, you use two projection matrices: one for each eye's view.) They are calculated with these two methods, respectively:</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>SetViewParams</source>
          <target state="new">SetViewParams</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>SetProjParams</source>
          <target state="new">SetProjParams</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>The code for these two methods looks like this:</source>
          <target state="new">The code for these two methods looks like this:</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>We get the resulting view and projection data by calling the <bpt id="p1">**</bpt>View<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Projection<ept id="p2">**</ept> methods, respectively, on the <bpt id="p3">**</bpt>Camera<ept id="p3">**</ept> object.</source>
          <target state="new">We get the resulting view and projection data by calling the <bpt id="p1">**</bpt>View<ept id="p1">**</ept> and <bpt id="p2">**</bpt>Projection<ept id="p2">**</ept> methods, respectively, on the <bpt id="p3">**</bpt>Camera<ept id="p3">**</ept> object.</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>These calls occur in the next step we review, the <bpt id="p1">**</bpt>GameRenderer::Render<ept id="p1">**</ept> method called in the game loop.</source>
          <target state="new">These calls occur in the next step we review, the <bpt id="p1">**</bpt>GameRenderer::Render<ept id="p1">**</ept> method called in the game loop.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Now, let's look at how the game creates the framework to draw our game graphics using the camera.</source>
          <target state="new">Now, let's look at how the game creates the framework to draw our game graphics using the camera.</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>This includes defining the primitives that comprise the game world and its elements.</source>
          <target state="new">This includes defining the primitives that comprise the game world and its elements.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>Defining the primitives</source>
          <target state="new">Defining the primitives</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>In the game sample code, we define and implement the primitives in two base classes and the corresponding specializations for each primitive type.</source>
          <target state="new">In the game sample code, we define and implement the primitives in two base classes and the corresponding specializations for each primitive type.</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>MeshObject.h/.cpp<ept id="p1">**</ept> defines the base class for all mesh objects.</source>
          <target state="new"><bpt id="p1">**</bpt>MeshObject.h/.cpp<ept id="p1">**</ept> defines the base class for all mesh objects.</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>SphereMesh.h/.cpp<ept id="p1">**</ept>, <bpt id="p2">**</bpt>CylinderMesh.h/.cpp<ept id="p2">**</ept>, <bpt id="p3">**</bpt>FaceMesh.h/.cpp<ept id="p3">**</ept>, and <bpt id="p4">**</bpt>WorldMesh.h/.cpp<ept id="p4">**</ept> files contain the code that populates the constant buffers for each primitive with the vertex and vertex normal data that defines the primitive's geometry.</source>
          <target state="new">The <bpt id="p1">**</bpt>SphereMesh.h/.cpp<ept id="p1">**</ept>, <bpt id="p2">**</bpt>CylinderMesh.h/.cpp<ept id="p2">**</ept>, <bpt id="p3">**</bpt>FaceMesh.h/.cpp<ept id="p3">**</ept>, and <bpt id="p4">**</bpt>WorldMesh.h/.cpp<ept id="p4">**</ept> files contain the code that populates the constant buffers for each primitive with the vertex and vertex normal data that defines the primitive's geometry.</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>These code files are a good place to start if you're looking to understand how to create Direct3D primitives in your own game app, but we won't cover them here as it's too specific to this game's implementation.</source>
          <target state="new">These code files are a good place to start if you're looking to understand how to create Direct3D primitives in your own game app, but we won't cover them here as it's too specific to this game's implementation.</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>For now, we assume that the vertex buffers for each primitive have been populated, and look at how the game sample handles those buffers to update the game itself.</source>
          <target state="new">For now, we assume that the vertex buffers for each primitive have been populated, and look at how the game sample handles those buffers to update the game itself.</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The base class for objects that represent the primitives from the perspective of the game is defined in <bpt id="p1">**</bpt>GameObject.h./.cpp.<ept id="p1">**</ept></source>
          <target state="new">The base class for objects that represent the primitives from the perspective of the game is defined in <bpt id="p1">**</bpt>GameObject.h./.cpp.<ept id="p1">**</ept></target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>This class, <bpt id="p1">**</bpt>GameObject<ept id="p1">**</ept>, defines the fields and methods for the common behaviors across all primitives.</source>
          <target state="new">This class, <bpt id="p1">**</bpt>GameObject<ept id="p1">**</ept>, defines the fields and methods for the common behaviors across all primitives.</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Each primitive object type derives from it.</source>
          <target state="new">Each primitive object type derives from it.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Let's look at how it's defined:</source>
          <target state="new">Let's look at how it's defined:</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>Most of the fields contain data about the state, visual properties, or position of the primitive in the game world.</source>
          <target state="new">Most of the fields contain data about the state, visual properties, or position of the primitive in the game world.</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>There are a few methods in particular that are necessary in most games:</source>
          <target state="new">There are a few methods in particular that are necessary in most games:</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Mesh<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Mesh<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Gets the mesh geometry for the primitive, which is stored in <bpt id="p1">**</bpt>m\_mesh<ept id="p1">**</ept>.</source>
          <target state="new">Gets the mesh geometry for the primitive, which is stored in <bpt id="p1">**</bpt>m\_mesh<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>This geometry is defined in <bpt id="p1">**</bpt>MeshObject.h/.cpp<ept id="p1">**</ept>.</source>
          <target state="new">This geometry is defined in <bpt id="p1">**</bpt>MeshObject.h/.cpp<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>IsTouching<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>IsTouching<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>This method determines if the primitive is within a specific distance of a point, and returns the point on the surface closest to the point and the normal to the surface of the object at that point.</source>
          <target state="new">This method determines if the primitive is within a specific distance of a point, and returns the point on the surface closest to the point and the normal to the surface of the object at that point.</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Because the sample is only concerned with ammo-primitive collisions, this is enough for the game's dynamics.</source>
          <target state="new">Because the sample is only concerned with ammo-primitive collisions, this is enough for the game's dynamics.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>It is not a general purpose primitive-primitive intersection function, although it could be used as the basis for one.</source>
          <target state="new">It is not a general purpose primitive-primitive intersection function, although it could be used as the basis for one.</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>AnimatePosition<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>AnimatePosition<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Updates the movement and animation for the primitive.</source>
          <target state="new">Updates the movement and animation for the primitive.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>UpdatePosition<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>UpdatePosition<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Updates the position of the object in the world coordinate space.</source>
          <target state="new">Updates the position of the object in the world coordinate space.</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Render<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Render<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Puts the material properties of the primitive into the primitive constant buffer and then renders (draws) the primitive geometry using the device context.</source>
          <target state="new">Puts the material properties of the primitive into the primitive constant buffer and then renders (draws) the primitive geometry using the device context.</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>It's a good practice to create a base object type that defines the minimum set of methods for a primitive because most games have a very large number of primitives, and the code can quickly become difficult to manage.</source>
          <target state="new">It's a good practice to create a base object type that defines the minimum set of methods for a primitive because most games have a very large number of primitives, and the code can quickly become difficult to manage.</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>It also simplifies game code when the update loop can treat the primitives polymorphically, letting the objects themselves define their own update and rendering behaviors.</source>
          <target state="new">It also simplifies game code when the update loop can treat the primitives polymorphically, letting the objects themselves define their own update and rendering behaviors.</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Let's look at the basic rendering of a primitive in the game sample.</source>
          <target state="new">Let's look at the basic rendering of a primitive in the game sample.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source>Rendering the primitives</source>
          <target state="new">Rendering the primitives</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>The primitives in the game sample use the base <bpt id="p1">**</bpt>Render<ept id="p1">**</ept> method implemented on the parent <bpt id="p2">**</bpt>GameObject<ept id="p2">**</ept> class, as here:</source>
          <target state="new">The primitives in the game sample use the base <bpt id="p1">**</bpt>Render<ept id="p1">**</ept> method implemented on the parent <bpt id="p2">**</bpt>GameObject<ept id="p2">**</ept> class, as here:</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>GameObject::Render<ept id="p1">**</ept> method updates the primitive constant buffer with the data specific to a given primitive.</source>
          <target state="new">The <bpt id="p1">**</bpt>GameObject::Render<ept id="p1">**</ept> method updates the primitive constant buffer with the data specific to a given primitive.</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The game uses multiple constant buffers, but only needs to update these buffers one time per primitive.</source>
          <target state="new">The game uses multiple constant buffers, but only needs to update these buffers one time per primitive.</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Think of the constant buffers as input to the shaders that run for each primitive.</source>
          <target state="new">Think of the constant buffers as input to the shaders that run for each primitive.</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>Some data is static (<bpt id="p1">**</bpt>m\_constantBufferNeverChanges<ept id="p1">**</ept>); some data is constant over the frame (<bpt id="p2">**</bpt>m\_constantBufferChangesEveryFrame)<ept id="p2">**</ept>, like the position of the camera; and some data is specific to the primitive, like its color and textures (<bpt id="p3">**</bpt>m\_constantBufferChangesEveryPrim<ept id="p3">**</ept>).</source>
          <target state="new">Some data is static (<bpt id="p1">**</bpt>m\_constantBufferNeverChanges<ept id="p1">**</ept>); some data is constant over the frame (<bpt id="p2">**</bpt>m\_constantBufferChangesEveryFrame)<ept id="p2">**</ept>, like the position of the camera; and some data is specific to the primitive, like its color and textures (<bpt id="p3">**</bpt>m\_constantBufferChangesEveryPrim<ept id="p3">**</ept>).</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The game renderer separates these inputs into different constant buffers to optimize the memory bandwidth that the CPU and GPU use.</source>
          <target state="new">The game renderer separates these inputs into different constant buffers to optimize the memory bandwidth that the CPU and GPU use.</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>This approach also helps to minimize the amount of data the GPU needs to keep track of.</source>
          <target state="new">This approach also helps to minimize the amount of data the GPU needs to keep track of.</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Remember, the GPU has a big queue of commands, and each time the game calls <bpt id="p1">**</bpt>Draw<ept id="p1">**</ept>, that command is queued along with the data associated with it.</source>
          <target state="new">Remember, the GPU has a big queue of commands, and each time the game calls <bpt id="p1">**</bpt>Draw<ept id="p1">**</ept>, that command is queued along with the data associated with it.</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>When the game updates the primitive constant buffer and issues the next <bpt id="p1">**</bpt>Draw<ept id="p1">**</ept> command, the graphics driver adds this next command and the associated data to the queue.</source>
          <target state="new">When the game updates the primitive constant buffer and issues the next <bpt id="p1">**</bpt>Draw<ept id="p1">**</ept> command, the graphics driver adds this next command and the associated data to the queue.</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>If the game draws 100 primitives, it could potentially have 100 copies of the constant buffer data in the queue.</source>
          <target state="new">If the game draws 100 primitives, it could potentially have 100 copies of the constant buffer data in the queue.</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>We want to minimize the amount of data the game is sending to the GPU, so the game uses a separate primitive constant buffer that only contains the updates for each primitive.</source>
          <target state="new">We want to minimize the amount of data the game is sending to the GPU, so the game uses a separate primitive constant buffer that only contains the updates for each primitive.</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>If a collision (a hit) is detected, <bpt id="p1">**</bpt>GameObject::Render<ept id="p1">**</ept> checks the current context, which indicates whether the target has been hit by an ammo sphere.</source>
          <target state="new">If a collision (a hit) is detected, <bpt id="p1">**</bpt>GameObject::Render<ept id="p1">**</ept> checks the current context, which indicates whether the target has been hit by an ammo sphere.</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>If the target has been hit, this method applies a hit material, which reverses the colors of the rings of the target to indicate a successful hit to the player.</source>
          <target state="new">If the target has been hit, this method applies a hit material, which reverses the colors of the rings of the target to indicate a successful hit to the player.</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Otherwise, it applies the default material with the same method.</source>
          <target state="new">Otherwise, it applies the default material with the same method.</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>In both cases, it sets the material by calling <bpt id="p1">**</bpt>Material::RenderSetup<ept id="p1">**</ept>, which sets the appropriate constants into the constant buffer.</source>
          <target state="new">In both cases, it sets the material by calling <bpt id="p1">**</bpt>Material::RenderSetup<ept id="p1">**</ept>, which sets the appropriate constants into the constant buffer.</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Then, it calls <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::PSSetShaderResources<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476473)</ept> to set the corresponding texture resource for the pixel shader, and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::VSSetShader<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>ID3D11DeviceContext::PSSetShader<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> to set the vertex shader and pixel shader objects themselves, respectively.</source>
          <target state="new">Then, it calls <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::PSSetShaderResources<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476473)</ept> to set the corresponding texture resource for the pixel shader, and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::VSSetShader<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476493)</ept> and <bpt id="p5">[</bpt><bpt id="p6">**</bpt>ID3D11DeviceContext::PSSetShader<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/desktop/ff476472)</ept> to set the vertex shader and pixel shader objects themselves, respectively.</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Here's how <bpt id="p1">**</bpt>Material::RenderSetup<ept id="p1">**</ept> configures the constant buffers and assigns the shader resources.</source>
          <target state="new">Here's how <bpt id="p1">**</bpt>Material::RenderSetup<ept id="p1">**</ept> configures the constant buffers and assigns the shader resources.</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source>Again, note that the constant buffer is the one used for updating changes to primitives, specifically.</source>
          <target state="new">Again, note that the constant buffer is the one used for updating changes to primitives, specifically.</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   The <bpt id="p2">**</bpt>Material<ept id="p2">**</ept> class is defined in <bpt id="p3">**</bpt>Material.h/.cpp<ept id="p3">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   The <bpt id="p2">**</bpt>Material<ept id="p2">**</ept> class is defined in <bpt id="p3">**</bpt>Material.h/.cpp<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Finally, the <bpt id="p1">**</bpt>PrimObject::Render<ept id="p1">**</ept> calls the <bpt id="p2">**</bpt>Render<ept id="p2">**</ept> method for the underlying <bpt id="p3">**</bpt>MeshObject<ept id="p3">**</ept> object.</source>
          <target state="new">Finally, the <bpt id="p1">**</bpt>PrimObject::Render<ept id="p1">**</ept> calls the <bpt id="p2">**</bpt>Render<ept id="p2">**</ept> method for the underlying <bpt id="p3">**</bpt>MeshObject<ept id="p3">**</ept> object.</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>Now, the game samples <bpt id="p1">**</bpt>MeshObject::Render<ept id="p1">**</ept> method queues the drawing command to execute the shaders on the GPU using the current scene state.</source>
          <target state="new">Now, the game samples <bpt id="p1">**</bpt>MeshObject::Render<ept id="p1">**</ept> method queues the drawing command to execute the shaders on the GPU using the current scene state.</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The vertex shader converts the geometry (vertices) from model coordinates into device (world) coordinates, taking into account where the camera is and the perspective transformation.</source>
          <target state="new">The vertex shader converts the geometry (vertices) from model coordinates into device (world) coordinates, taking into account where the camera is and the perspective transformation.</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>Lastly, the pixel shaders render the transformed triangles into the back buffer using the texture set above.</source>
          <target state="new">Lastly, the pixel shaders render the transformed triangles into the back buffer using the texture set above.</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>This happens on the actual rendering process!</source>
          <target state="new">This happens on the actual rendering process!</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Creating the vertex and pixel shaders</source>
          <target state="new">Creating the vertex and pixel shaders</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>At this point, the game sample has defined the primitives to draw and the constant buffers that define their rendering.</source>
          <target state="new">At this point, the game sample has defined the primitives to draw and the constant buffers that define their rendering.</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>These constant buffers serve as the sets of parameters to the shaders that run on the graphics device.</source>
          <target state="new">These constant buffers serve as the sets of parameters to the shaders that run on the graphics device.</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>These shader programs come in two types:</source>
          <target state="new">These shader programs come in two types:</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Vertex shaders perform per-vertex operations, such as vertex transformations and lighting.</source>
          <target state="new">Vertex shaders perform per-vertex operations, such as vertex transformations and lighting.</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>Pixel (or fragment) shaders perform per-pixel operations, such as texturing and per-pixel lighting.</source>
          <target state="new">Pixel (or fragment) shaders perform per-pixel operations, such as texturing and per-pixel lighting.</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>They can also be used to perform post-processing effects on bitmaps, such as the final render target.</source>
          <target state="new">They can also be used to perform post-processing effects on bitmaps, such as the final render target.</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>The shader code is defined using High-Level Shader Language (HLSL), which, in Direct3D 11, is compiled from a program created with a C-like syntax.</source>
          <target state="new">The shader code is defined using High-Level Shader Language (HLSL), which, in Direct3D 11, is compiled from a program created with a C-like syntax.</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>(The complete syntax can be found <bpt id="p1">[</bpt>here<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509635)</ept>.) The two principal shaders for the sample game are defined in <bpt id="p2">**</bpt>PixelShader.hlsl<ept id="p2">**</ept> and <bpt id="p3">**</bpt>VertexShader.hlsl<ept id="p3">**</ept>.</source>
          <target state="new">(The complete syntax can be found <bpt id="p1">[</bpt>here<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509635)</ept>.) The two principal shaders for the sample game are defined in <bpt id="p2">**</bpt>PixelShader.hlsl<ept id="p2">**</ept> and <bpt id="p3">**</bpt>VertexShader.hlsl<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>(There are also two "low power" shaders defined for low power devices: <bpt id="p1">**</bpt>PixelShaderFlat.hlsl<ept id="p1">**</ept> and <bpt id="p2">**</bpt>VertexShaderFlat.hlsl<ept id="p2">**</ept>.</source>
          <target state="new">(There are also two "low power" shaders defined for low power devices: <bpt id="p1">**</bpt>PixelShaderFlat.hlsl<ept id="p1">**</ept> and <bpt id="p2">**</bpt>VertexShaderFlat.hlsl<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>These two shaders provide reduced effects, such as a lack of specular highlights on textures surfaces.) FInally, there is an .hlsli file that contains the format of the constant buffers, <bpt id="p1">**</bpt>ConstantBuffers.hlsli<ept id="p1">**</ept>.</source>
          <target state="new">These two shaders provide reduced effects, such as a lack of specular highlights on textures surfaces.) FInally, there is an .hlsli file that contains the format of the constant buffers, <bpt id="p1">**</bpt>ConstantBuffers.hlsli<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>ConstantBuffers.hlsli<ept id="p1">**</ept> is defined like this:</source>
          <target state="new"><bpt id="p1">**</bpt>ConstantBuffers.hlsli<ept id="p1">**</ept> is defined like this:</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>VertexShader.hlsl<ept id="p1">**</ept> is defined like this:</source>
          <target state="new"><bpt id="p1">**</bpt>VertexShader.hlsl<ept id="p1">**</ept> is defined like this:</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>VertexShader.hlsl</source>
          <target state="new">VertexShader.hlsl</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>main<ept id="p1">**</ept> function in <bpt id="p2">**</bpt>VertexShader.hlsl<ept id="p2">**</ept> performs the vertex transformation sequence we discussed in the camera section.</source>
          <target state="new">The <bpt id="p1">**</bpt>main<ept id="p1">**</ept> function in <bpt id="p2">**</bpt>VertexShader.hlsl<ept id="p2">**</ept> performs the vertex transformation sequence we discussed in the camera section.</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>It's run one time per vertex.</source>
          <target state="new">It's run one time per vertex.</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>The resultant outputs are passed to the pixel shader code for texturing and material effects.</source>
          <target state="new">The resultant outputs are passed to the pixel shader code for texturing and material effects.</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>PixelShader.hlsl</source>
          <target state="new">PixelShader.hlsl</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>main<ept id="p1">**</ept> function in <bpt id="p2">**</bpt>PixelShader.hlsl<ept id="p2">**</ept> takes the 2-D projections of the triangle surfaces for each primitive in the scene, and computes the color value for each pixel of the visible surfaces based on the textures and effects (in this case, specular lighting) applied to them.</source>
          <target state="new">The <bpt id="p1">**</bpt>main<ept id="p1">**</ept> function in <bpt id="p2">**</bpt>PixelShader.hlsl<ept id="p2">**</ept> takes the 2-D projections of the triangle surfaces for each primitive in the scene, and computes the color value for each pixel of the visible surfaces based on the textures and effects (in this case, specular lighting) applied to them.</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>Now, let's bring all these ideas (primitives, camera, and shaders) together, and see how the sample game builds the complete rendering process.</source>
          <target state="new">Now, let's bring all these ideas (primitives, camera, and shaders) together, and see how the sample game builds the complete rendering process.</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Rendering the frame for output</source>
          <target state="new">Rendering the frame for output</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>We briefly discussed this method in <bpt id="p1">[</bpt>Defining the main game object<ept id="p1">](tutorial--defining-the-main-game-loop.md)</ept>.</source>
          <target state="new">We briefly discussed this method in <bpt id="p1">[</bpt>Defining the main game object<ept id="p1">](tutorial--defining-the-main-game-loop.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>Now, let's look at it in a little more detail.</source>
          <target state="new">Now, let's look at it in a little more detail.</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The game has all the pieces to assemble a view for output: primitives and the rules for their behavior, a camera object to provide the player's view of the game world, and the graphics resources for drawing.</source>
          <target state="new">The game has all the pieces to assemble a view for output: primitives and the rules for their behavior, a camera object to provide the player's view of the game world, and the graphics resources for drawing.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>Now, let's look at the process that brings it all together.</source>
          <target state="new">Now, let's look at the process that brings it all together.</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>If stereo 3D is enabled, set the following rendering process to run two times, one time for each eye.</source>
          <target state="new">If stereo 3D is enabled, set the following rendering process to run two times, one time for each eye.</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>The whole scene is enclosed in a bounding world volume, so draw every pixel (even those we dont need) to clear the color planes of the render target.</source>
          <target state="new">The whole scene is enclosed in a bounding world volume, so draw every pixel (even those we dont need) to clear the color planes of the render target.</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>Set the depth stencil buffer to the default value.</source>
          <target state="new">Set the depth stencil buffer to the default value.</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>Update the constant buffer for frame update data by using the camera's view matrix and data.</source>
          <target state="new">Update the constant buffer for frame update data by using the camera's view matrix and data.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>Set up the Direct3D context to use the four content buffers that were defined earlier.</source>
          <target state="new">Set up the Direct3D context to use the four content buffers that were defined earlier.</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">**</bpt>Render<ept id="p1">**</ept> method on each primitive object.</source>
          <target state="new">Call the <bpt id="p1">**</bpt>Render<ept id="p1">**</ept> method on each primitive object.</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>This results in a <bpt id="p1">**</bpt>Draw<ept id="p1">**</ept> or <bpt id="p2">**</bpt>DrawIndexed<ept id="p2">**</ept> call on the context to draw the geometry of that each primitive.</source>
          <target state="new">This results in a <bpt id="p1">**</bpt>Draw<ept id="p1">**</ept> or <bpt id="p2">**</bpt>DrawIndexed<ept id="p2">**</ept> call on the context to draw the geometry of that each primitive.</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Specifically, this <bpt id="p1">**</bpt>Draw<ept id="p1">**</ept> call queues commands and data to the GPU, as parameterized by the constant buffer data.</source>
          <target state="new">Specifically, this <bpt id="p1">**</bpt>Draw<ept id="p1">**</ept> call queues commands and data to the GPU, as parameterized by the constant buffer data.</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>Each draw call executes the vertex shader one time per vertex, and then the pixel shader one time for every pixel of each triangle in the primitive.</source>
          <target state="new">Each draw call executes the vertex shader one time per vertex, and then the pixel shader one time for every pixel of each triangle in the primitive.</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>The textures are part of the state that the pixel shader uses to do the rendering.</source>
          <target state="new">The textures are part of the state that the pixel shader uses to do the rendering.</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source>Draw the HUD and the overlay using the Direct2D context.</source>
          <target state="new">Draw the HUD and the overlay using the Direct2D context.</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source>Call <bpt id="p1">**</bpt>DirectXBase::Present<ept id="p1">**</ept>.</source>
          <target state="new">Call <bpt id="p1">**</bpt>DirectXBase::Present<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>And the game has updated the display!</source>
          <target state="new">And the game has updated the display!</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>Altogether, this is the basic process for implementing the graphics framework of a game.</source>
          <target state="new">Altogether, this is the basic process for implementing the graphics framework of a game.</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>Of course, the larger your game, the more abstractions you must put in place to handle that complexity, such as entire hierarchies of object types and animation behaviors, and more complex methods for loading and managing assets such as meshes and textures.</source>
          <target state="new">Of course, the larger your game, the more abstractions you must put in place to handle that complexity, such as entire hierarchies of object types and animation behaviors, and more complex methods for loading and managing assets such as meshes and textures.</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="new">Next steps</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Moving forward, let's look at a few important parts of the game sample that we've only discussed in passing: <bpt id="p1">[</bpt>the user interface overlay<ept id="p1">](tutorial--adding-a-user-interface.md)</ept>, <bpt id="p2">[</bpt>the input controls<ept id="p2">](tutorial--adding-controls.md)</ept>, and <bpt id="p3">[</bpt>the sound<ept id="p3">](tutorial--adding-sound.md)</ept>.</source>
          <target state="new">Moving forward, let's look at a few important parts of the game sample that we've only discussed in passing: <bpt id="p1">[</bpt>the user interface overlay<ept id="p1">](tutorial--adding-a-user-interface.md)</ept>, <bpt id="p2">[</bpt>the input controls<ept id="p2">](tutorial--adding-controls.md)</ept>, and <bpt id="p3">[</bpt>the sound<ept id="p3">](tutorial--adding-sound.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>Complete sample code for this section</source>
          <target state="new">Complete sample code for this section</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>Camera.h</source>
          <target state="new">Camera.h</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source>Camera.cpp</source>
          <target state="new">Camera.cpp</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>GameRenderer.h</source>
          <target state="new">GameRenderer.h</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>GameRenderer.cpp</source>
          <target state="new">GameRenderer.cpp</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>GameObject.h</source>
          <target state="new">GameObject.h</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>GameObject.cpp</source>
          <target state="new">GameObject.cpp</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>Animate.h</source>
          <target state="new">Animate.h</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>Animate.cpp</source>
          <target state="new">Animate.cpp</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>BasicLoader.h</source>
          <target state="new">BasicLoader.h</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>BasicLoader.cpp</source>
          <target state="new">BasicLoader.cpp</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>MeshObject.h</source>
          <target state="new">MeshObject.h</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>MeshObject.cpp</source>
          <target state="new">MeshObject.cpp</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>SphereMesh.h</source>
          <target state="new">SphereMesh.h</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>SphereMesh.cpp</source>
          <target state="new">SphereMesh.cpp</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>CylinderMesh.h</source>
          <target state="new">CylinderMesh.h</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>CylinderMesh.cpp</source>
          <target state="new">CylinderMesh.cpp</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>FaceMesh.h</source>
          <target state="new">FaceMesh.h</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>FaceMesh.cpp</source>
          <target state="new">FaceMesh.cpp</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>WorldMesh.h</source>
          <target state="new">WorldMesh.h</target>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>WorldMesh.cpp</source>
          <target state="new">WorldMesh.cpp</target>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>Level.h</source>
          <target state="new">Level.h</target>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>Level.cpp</source>
          <target state="new">Level.cpp</target>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>Level1.h</source>
          <target state="new">Level1.h</target>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>Level1.cpp</source>
          <target state="new">Level1.cpp</target>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>Level2.h</source>
          <target state="new">Level2.h</target>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Level2.cpp</source>
          <target state="new">Level2.cpp</target>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>Level3.h</source>
          <target state="new">Level3.h</target>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>Level3.cpp</source>
          <target state="new">Level3.cpp</target>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>Level4.h</source>
          <target state="new">Level4.h</target>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>Level4.cpp</source>
          <target state="new">Level4.cpp</target>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Level5.h</source>
          <target state="new">Level5.h</target>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve">
          <source>Level5.cpp</source>
          <target state="new">Level5.cpp</target>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve">
          <source>Level6.h</source>
          <target state="new">Level6.h</target>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>Level6.cpp</source>
          <target state="new">Level6.cpp</target>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>TargetTexture.h</source>
          <target state="new">TargetTexture.h</target>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source>TargetTexture.cpp</source>
          <target state="new">TargetTexture.cpp</target>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Material.h</source>
          <target state="new">Material.h</target>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source>Material.cpp</source>
          <target state="new">Material.cpp</target>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="new">Note</target>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve">
          <source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
          <target state="new">This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</target>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve">
          <source>If youre developing for Windows 8.x or Windows Phone 8.x, see the <bpt id="p1">[</bpt>archived documentation<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.</source>
          <target state="new">If youre developing for Windows 8.x or Windows Phone 8.x, see the <bpt id="p1">[</bpt>archived documentation<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.</target>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>Create a simple UWP game with DirectX</source>
          <target state="new">Create a simple UWP game with DirectX</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>