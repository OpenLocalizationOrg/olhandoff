<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8e8f3476454b0c0d3173ca807bb21f20e5a429a5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\create-a-basic-mesh.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Create and display a basic mesh</source>
          <target state="new">Create and display a basic mesh</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>3-D Universal Windows Platform (UWP) games typically use polygons to represent objects and surfaces in the game.</source>
          <target state="new">3-D Universal Windows Platform (UWP) games typically use polygons to represent objects and surfaces in the game.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Create and display a basic mesh</source>
          <target state="new">Create and display a basic mesh</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>3-D Universal Windows Platform (UWP) games typically use polygons to represent objects and surfaces in the game.</source>
          <target state="new">3-D Universal Windows Platform (UWP) games typically use polygons to represent objects and surfaces in the game.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>The lists of vertices that comprise the structure of these polygonal objects and surfaces are called meshes.</source>
          <target state="new">The lists of vertices that comprise the structure of these polygonal objects and surfaces are called meshes.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Here, we create a basic mesh for a cube object and provide it to the shader pipeline for rendering and display.</source>
          <target state="new">Here, we create a basic mesh for a cube object and provide it to the shader pipeline for rendering and display.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>   The example code included here uses types (such as DirectX::XMFLOAT3 and DirectX::XMFLOAT4X4) and inline methods declared in DirectXMath.h.</source>
          <target state="new"><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>   The example code included here uses types (such as DirectX::XMFLOAT3 and DirectX::XMFLOAT4X4) and inline methods declared in DirectXMath.h.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>If you're cutting and pasting this code, \#include <ph id="ph1">&amp;lt;</ph>DirectXMath.h<ph id="ph2">&amp;gt;</ph> in your project.</source>
          <target state="new">If you're cutting and pasting this code, \#include <ph id="ph1">&amp;lt;</ph>DirectXMath.h<ph id="ph2">&amp;gt;</ph> in your project.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>What you need to know</source>
          <target state="new">What you need to know</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Technologies</source>
          <target state="new">Technologies</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Direct3D</source>
          <target state="new">Direct3D</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="new">Prerequisites</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Basic knowledge of linear algebra and 3-D coordinate systems</source>
          <target state="new">Basic knowledge of linear algebra and 3-D coordinate systems</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>A Visual Studio 2015 Direct3D template</source>
          <target state="new">A Visual Studio 2015 Direct3D template</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="new">Instructions</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Step 1: Construct the mesh for the model</source>
          <target state="new">Step 1: Construct the mesh for the model</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>In most games, the mesh for a game object is loaded from a file that contains the specific vertex data.</source>
          <target state="new">In most games, the mesh for a game object is loaded from a file that contains the specific vertex data.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The ordering of these vertices is app-dependent, but they are usually serialized as strips or fans.</source>
          <target state="new">The ordering of these vertices is app-dependent, but they are usually serialized as strips or fans.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Vertex data can come from any software source, or it can be created manually.</source>
          <target state="new">Vertex data can come from any software source, or it can be created manually.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>It's up to your game to interpret the data in a way that the vertex shader can effectively process it.</source>
          <target state="new">It's up to your game to interpret the data in a way that the vertex shader can effectively process it.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In our example, we use a simple mesh for a cube.</source>
          <target state="new">In our example, we use a simple mesh for a cube.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The cube, like any object mesh at this stage in the pipeline, is represented using its own coordinate system.</source>
          <target state="new">The cube, like any object mesh at this stage in the pipeline, is represented using its own coordinate system.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The vertex shader takes its coordinates and, by applying the transformation matrices you provide, returns the final 2-D view projection in a homogeneous coordinate system.</source>
          <target state="new">The vertex shader takes its coordinates and, by applying the transformation matrices you provide, returns the final 2-D view projection in a homogeneous coordinate system.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Define the mesh for a cube.</source>
          <target state="new">Define the mesh for a cube.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>(Or load it from a file.</source>
          <target state="new">(Or load it from a file.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>It's your call!)</source>
          <target state="new">It's your call!)</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>The cube's coordinate system places the center of the cube at the origin, with the y-axis running top to bottom using a left-handed coordinate system.</source>
          <target state="new">The cube's coordinate system places the center of the cube at the origin, with the y-axis running top to bottom using a left-handed coordinate system.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Coordinate values are expressed as 32-bit floating values between -1 and 1.</source>
          <target state="new">Coordinate values are expressed as 32-bit floating values between -1 and 1.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>In each bracketed pairing, the second DirectX::XMFLOAT3 value group specifies the color associated with the vertex as an RGB value.</source>
          <target state="new">In each bracketed pairing, the second DirectX::XMFLOAT3 value group specifies the color associated with the vertex as an RGB value.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>For example, the first vertex at (-0.5, 0.5, -0.5) has a full green color (the G value is set to 1.0, and the "R" and "B" values are set to 0).</source>
          <target state="new">For example, the first vertex at (-0.5, 0.5, -0.5) has a full green color (the G value is set to 1.0, and the "R" and "B" values are set to 0).</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Therefore, you have 8 vertices, each with a specific color.</source>
          <target state="new">Therefore, you have 8 vertices, each with a specific color.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Each vertex/color pairing is the complete data for a vertex in our example.</source>
          <target state="new">Each vertex/color pairing is the complete data for a vertex in our example.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>When you specify our vertex buffer, you must keep this specific layout in mind.</source>
          <target state="new">When you specify our vertex buffer, you must keep this specific layout in mind.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>We provide this input layout to the vertex shader so it can understand your vertex data.</source>
          <target state="new">We provide this input layout to the vertex shader so it can understand your vertex data.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Step 2: Set up the input layout</source>
          <target state="new">Step 2: Set up the input layout</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Now, you have the vertices in memory.</source>
          <target state="new">Now, you have the vertices in memory.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>But, your graphics device has its own memory, and you use Direct3D to access it.</source>
          <target state="new">But, your graphics device has its own memory, and you use Direct3D to access it.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>To get your vertex data into the graphics device for processing, you need to clear the way, as it were: you must declare how the vertex data is laid out so that the graphics device can interpret it when it gets it from your game.</source>
          <target state="new">To get your vertex data into the graphics device for processing, you need to clear the way, as it were: you must declare how the vertex data is laid out so that the graphics device can interpret it when it gets it from your game.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>To do that, you use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11InputLayout<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476575)</ept>.</source>
          <target state="new">To do that, you use <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11InputLayout<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476575)</ept>.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>Declare and set the input layout for the vertex buffer.</source>
          <target state="new">Declare and set the input layout for the vertex buffer.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>In this code, you specify a layout for the vertices, specifically, what data each element in the vertex list contains.</source>
          <target state="new">In this code, you specify a layout for the vertices, specifically, what data each element in the vertex list contains.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>Here, in <bpt id="p1">**</bpt>basicVertexLayoutDesc<ept id="p1">**</ept>, you specify two data components:</source>
          <target state="new">Here, in <bpt id="p1">**</bpt>basicVertexLayoutDesc<ept id="p1">**</ept>, you specify two data components:</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>POSITION<ept id="p1">**</ept>: This is an HLSL semantic for position data provided to a shader.</source>
          <target state="new"><bpt id="p1">**</bpt>POSITION<ept id="p1">**</ept>: This is an HLSL semantic for position data provided to a shader.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In this code, it's a DirectX::XMFLOAT3, or more specifically, a structure with 3 32-bit floating point values that correspond to a 3D coordinate (x, y, z).</source>
          <target state="new">In this code, it's a DirectX::XMFLOAT3, or more specifically, a structure with 3 32-bit floating point values that correspond to a 3D coordinate (x, y, z).</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>You could also use a float4 if you are supplying the homogeneous "w" coordinate, and in that case, you specify DXGI\_FORMAT\_R32G32B32A32\_FLOAT.</source>
          <target state="new">You could also use a float4 if you are supplying the homogeneous "w" coordinate, and in that case, you specify DXGI\_FORMAT\_R32G32B32A32\_FLOAT.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Whether you use a DirectX::XMFLOAT3 or a float4 is up to the specific needs of your game.</source>
          <target state="new">Whether you use a DirectX::XMFLOAT3 or a float4 is up to the specific needs of your game.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Just make sure that the vertex data for your mesh corresponds correctly to the format you use!</source>
          <target state="new">Just make sure that the vertex data for your mesh corresponds correctly to the format you use!</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Each coordinate value is expressed as a floating point value between -1 and 1, in the object's coordinate space.</source>
          <target state="new">Each coordinate value is expressed as a floating point value between -1 and 1, in the object's coordinate space.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>When the vertex shader completes, the transformed vertex is in the homogeneous (perspective corrected) view projection space.</source>
          <target state="new">When the vertex shader completes, the transformed vertex is in the homogeneous (perspective corrected) view projection space.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>"But the enumeration value indicates RGB, not XYZ!"</source>
          <target state="new">"But the enumeration value indicates RGB, not XYZ!"</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>you smartly note.</source>
          <target state="new">you smartly note.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Good eye!</source>
          <target state="new">Good eye!</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>In both the cases of color data and coordinate data, you typically use 3 or 4 component values, so why not use the same format for both?</source>
          <target state="new">In both the cases of color data and coordinate data, you typically use 3 or 4 component values, so why not use the same format for both?</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>The HLSL semantic, not the format name, indicates how the shader treats the data.</source>
          <target state="new">The HLSL semantic, not the format name, indicates how the shader treats the data.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>COLOR<ept id="p1">**</ept>: This is an HLSL semantic for color data.</source>
          <target state="new"><bpt id="p1">**</bpt>COLOR<ept id="p1">**</ept>: This is an HLSL semantic for color data.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>Like <bpt id="p1">**</bpt>POSITION<ept id="p1">**</ept>, it consists of 3 32-bit floating point values (DirectX::XMFLOAT3).</source>
          <target state="new">Like <bpt id="p1">**</bpt>POSITION<ept id="p1">**</ept>, it consists of 3 32-bit floating point values (DirectX::XMFLOAT3).</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>Each value contains a color component: red (r), blue (b), or green (g), expressed as a floating number between 0 and 1.</source>
          <target state="new">Each value contains a color component: red (r), blue (b), or green (g), expressed as a floating number between 0 and 1.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>COLOR<ept id="p1">**</ept> values are typically returned as a 4-component RGBA value at the end of the shader pipeline.</source>
          <target state="new"><bpt id="p1">**</bpt>COLOR<ept id="p1">**</ept> values are typically returned as a 4-component RGBA value at the end of the shader pipeline.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For this example, you will be setting the "A" alpha value to 1.0 (maximum opacity) in the shader pipeline for all pixels.</source>
          <target state="new">For this example, you will be setting the "A" alpha value to 1.0 (maximum opacity) in the shader pipeline for all pixels.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>For a complete list of formats, see <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DXGI\_FORMAT<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</ept>.</source>
          <target state="new">For a complete list of formats, see <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DXGI\_FORMAT<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb173059)</ept>.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>For a complete list of HLSL semantics, see <bpt id="p1">[</bpt>Semantics<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</ept>.</source>
          <target state="new">For a complete list of HLSL semantics, see <bpt id="p1">[</bpt>Semantics<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb509647)</ept>.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateInputLayout<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476512)</ept> and create the input layout on the Direct3D device.</source>
          <target state="new">Call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateInputLayout<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476512)</ept> and create the input layout on the Direct3D device.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Now, you need to create a buffer that can actually hold the data!</source>
          <target state="new">Now, you need to create a buffer that can actually hold the data!</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Step 3: Populate the vertex buffers</source>
          <target state="new">Step 3: Populate the vertex buffers</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>Vertex buffers contain the list of vertices for each triangle in the mesh.</source>
          <target state="new">Vertex buffers contain the list of vertices for each triangle in the mesh.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Every vertex must be unique in this list.</source>
          <target state="new">Every vertex must be unique in this list.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>In our example, you have 8 vertices for the cube.</source>
          <target state="new">In our example, you have 8 vertices for the cube.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>The vertex shader runs on the graphics device and reads from the vertex buffer, and it interprets the data based on the input layout you specified in the previous step.</source>
          <target state="new">The vertex shader runs on the graphics device and reads from the vertex buffer, and it interprets the data based on the input layout you specified in the previous step.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>In the next example, you provide a description and a subresource for the buffer, which tell Direct3D a number of things about the physical mapping of the vertex data and how to treat it in memory on the graphics device.</source>
          <target state="new">In the next example, you provide a description and a subresource for the buffer, which tell Direct3D a number of things about the physical mapping of the vertex data and how to treat it in memory on the graphics device.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>This is necessary because you use a generic <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Buffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476351)</ept>, which could contain anything!</source>
          <target state="new">This is necessary because you use a generic <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Buffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476351)</ept>, which could contain anything!</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_BUFFER\_DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structures are supplied to ensure that Direct3D understands the physical memory layout of the buffer, including the size of each vertex element in the buffer as well as the maximum size of the vertex list.</source>
          <target state="new">The <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_BUFFER\_DESC<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476092)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>D3D11\_SUBRESOURCE\_DATA<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476220)</ept> structures are supplied to ensure that Direct3D understands the physical memory layout of the buffer, including the size of each vertex element in the buffer as well as the maximum size of the vertex list.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>You can also control access to the buffer memory here and how it is traversed, but that's a bit beyond the scope of this tutorial.</source>
          <target state="new">You can also control access to the buffer memory here and how it is traversed, but that's a bit beyond the scope of this tutorial.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>After you configure the buffer, you call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> to actually create it.</source>
          <target state="new">After you configure the buffer, you call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11Device::CreateBuffer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476501)</ept> to actually create it.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>Obviously, if you have more than one object, create buffers for each unique model.</source>
          <target state="new">Obviously, if you have more than one object, create buffers for each unique model.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Declare and create the vertex buffer.</source>
          <target state="new">Declare and create the vertex buffer.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Vertices loaded.</source>
          <target state="new">Vertices loaded.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>But what's the order of processing these vertices?</source>
          <target state="new">But what's the order of processing these vertices?</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>That's handled when you provide a list of indices to the vertices—the ordering of these indices is the order in which the vertex shader processes them.</source>
          <target state="new">That's handled when you provide a list of indices to the vertices—the ordering of these indices is the order in which the vertex shader processes them.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Step 4: Populate the index buffers</source>
          <target state="new">Step 4: Populate the index buffers</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Now, you provide a list of the indices for each of the vertices.</source>
          <target state="new">Now, you provide a list of the indices for each of the vertices.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>These indices correspond to the position of the vertex in the vertex buffer, starting with 0.</source>
          <target state="new">These indices correspond to the position of the vertex in the vertex buffer, starting with 0.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>To help you visualize this, consider that each unique vertex in your mesh has a unique number assigned to it, like an ID.</source>
          <target state="new">To help you visualize this, consider that each unique vertex in your mesh has a unique number assigned to it, like an ID.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>This ID is the integer position of the vertex in the vertex buffer.</source>
          <target state="new">This ID is the integer position of the vertex in the vertex buffer.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>a cube with eight numbered vertices</source>
          <target state="new">a cube with eight numbered vertices</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>In our example cube, you have 8 vertices, which create 6 quads for the sides.</source>
          <target state="new">In our example cube, you have 8 vertices, which create 6 quads for the sides.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>You split the quads into triangles, for a total of 12 triangles that use our 8 vertices.</source>
          <target state="new">You split the quads into triangles, for a total of 12 triangles that use our 8 vertices.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>At 3 vertices per triangle, you have 36 entries in our index buffer.</source>
          <target state="new">At 3 vertices per triangle, you have 36 entries in our index buffer.</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>In our example, this index pattern is known as a triangle list, and you indicate it to Direct3D as a <bpt id="p1">**</bpt>D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST<ept id="p1">**</ept> when you set the primitive topology.</source>
          <target state="new">In our example, this index pattern is known as a triangle list, and you indicate it to Direct3D as a <bpt id="p1">**</bpt>D3D11\_PRIMITIVE\_TOPOLOGY\_TRIANGLELIST<ept id="p1">**</ept> when you set the primitive topology.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>This is probably the most inefficient way to list indices, as there are many redundancies when triangles share points and sides.</source>
          <target state="new">This is probably the most inefficient way to list indices, as there are many redundancies when triangles share points and sides.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>For example, when a triangle shares a side in a rhombus shape, you list 6 indices for the four vertices, like this:</source>
          <target state="new">For example, when a triangle shares a side in a rhombus shape, you list 6 indices for the four vertices, like this:</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>order of indices when constructing a rhombus</source>
          <target state="new">order of indices when constructing a rhombus</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>Triangle 1: \[0, 1, 2\]</source>
          <target state="new">Triangle 1: \[0, 1, 2\]</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>Triangle 2: \[0, 2, 3\]</source>
          <target state="new">Triangle 2: \[0, 2, 3\]</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>In a strip or fan topology, you order the vertices in a way that eliminates many redundant sides during traversal (such as the side from index 0 to index 2 in the image.) For large meshes, this dramatically reduces the number of times the vertex shader is run, and improves performance significantly.</source>
          <target state="new">In a strip or fan topology, you order the vertices in a way that eliminates many redundant sides during traversal (such as the side from index 0 to index 2 in the image.) For large meshes, this dramatically reduces the number of times the vertex shader is run, and improves performance significantly.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>However, we'll keep it simple and stick with the triangle list.</source>
          <target state="new">However, we'll keep it simple and stick with the triangle list.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Declare the indices for the vertex buffer as a simple triangle list topology.</source>
          <target state="new">Declare the indices for the vertex buffer as a simple triangle list topology.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Thirty six index elements in the buffer is very redundant when you only have 8 vertices!</source>
          <target state="new">Thirty six index elements in the buffer is very redundant when you only have 8 vertices!</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>If you choose to eliminate some of the redundancies and use a different vertex list type, such as a strip or a fan, you must specify that type when you provide a specific <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_PRIMITIVE\_TOPOLOGY<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476189)</ept> value to the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::IASetPrimitiveTopology<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476455)</ept> method.</source>
          <target state="new">If you choose to eliminate some of the redundancies and use a different vertex list type, such as a strip or a fan, you must specify that type when you provide a specific <bpt id="p1">[</bpt><bpt id="p2">**</bpt>D3D11\_PRIMITIVE\_TOPOLOGY<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476189)</ept> value to the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>ID3D11DeviceContext::IASetPrimitiveTopology<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/desktop/ff476455)</ept> method.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>For more information about different index list techniques, see <bpt id="p1">[</bpt>Primitive Topologies<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb205124)</ept>.</source>
          <target state="new">For more information about different index list techniques, see <bpt id="p1">[</bpt>Primitive Topologies<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb205124)</ept>.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>Step 5: Create a constant buffer for your transformation matrices</source>
          <target state="new">Step 5: Create a constant buffer for your transformation matrices</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>Before you can start processing vertices, you need to provide the transformation matrices that will be applied (multiplied) to each vertex when it runs.</source>
          <target state="new">Before you can start processing vertices, you need to provide the transformation matrices that will be applied (multiplied) to each vertex when it runs.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>For most 3-D games, there are three of them:</source>
          <target state="new">For most 3-D games, there are three of them:</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The 4x4 matrix that transforms from the object (model) coordinate system to the overall world coordinate system.</source>
          <target state="new">The 4x4 matrix that transforms from the object (model) coordinate system to the overall world coordinate system.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The 4x4 matrix that transforms from the world coordinate system to the camera (view) coordinate system.</source>
          <target state="new">The 4x4 matrix that transforms from the world coordinate system to the camera (view) coordinate system.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>The 4x4 matrix that transforms from the camera coordinate system to the 2-D view projection coordinate system.</source>
          <target state="new">The 4x4 matrix that transforms from the camera coordinate system to the 2-D view projection coordinate system.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>These matrices are passed to the shader in a <bpt id="p1">*</bpt>constant buffer<ept id="p1">*</ept>.</source>
          <target state="new">These matrices are passed to the shader in a <bpt id="p1">*</bpt>constant buffer<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>A constant buffer is a region of memory that remains constant throughout the execution of the next pass of the shader pipeline, and which can be directly accessed by the shaders from your HLSL code.</source>
          <target state="new">A constant buffer is a region of memory that remains constant throughout the execution of the next pass of the shader pipeline, and which can be directly accessed by the shaders from your HLSL code.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>You define each constant buffer two times: first in your game's C++ code, and (at least) one time in the C-like HLSL syntax for your shader code.</source>
          <target state="new">You define each constant buffer two times: first in your game's C++ code, and (at least) one time in the C-like HLSL syntax for your shader code.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>The two declarations must directly correspond in terms of types and data alignment.</source>
          <target state="new">The two declarations must directly correspond in terms of types and data alignment.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>It's easy to introduce hard to find errors when the shader uses the HLSL declaration to interpret data declared in C++, and the types don't match or the alignment of data is off!</source>
          <target state="new">It's easy to introduce hard to find errors when the shader uses the HLSL declaration to interpret data declared in C++, and the types don't match or the alignment of data is off!</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>Constant buffers don't get changed by the HLSL.</source>
          <target state="new">Constant buffers don't get changed by the HLSL.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>You can change them when your game updates specific data.</source>
          <target state="new">You can change them when your game updates specific data.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Often, game devs create 4 classes of constant buffers: one type for updates per frame; one type for updates per model/object; one type for updates per game state refresh; and one type for data that never changes through the lifetime of the game.</source>
          <target state="new">Often, game devs create 4 classes of constant buffers: one type for updates per frame; one type for updates per model/object; one type for updates per game state refresh; and one type for data that never changes through the lifetime of the game.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>In this example, we just have one that never changes: the DirectX::XMFLOAT4X4 data for the three matrices.</source>
          <target state="new">In this example, we just have one that never changes: the DirectX::XMFLOAT4X4 data for the three matrices.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   The example code presented here uses column-major matrices.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>   The example code presented here uses column-major matrices.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>You can use row-major matrices instead by using the <bpt id="p1">**</bpt>row\_major<ept id="p1">**</ept> keyword in HLSL, and ensuring your source matrix data is also row-major.</source>
          <target state="new">You can use row-major matrices instead by using the <bpt id="p1">**</bpt>row\_major<ept id="p1">**</ept> keyword in HLSL, and ensuring your source matrix data is also row-major.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>DirectXMath uses row-major matrices and can be used directly with HLSL matrices defined with the <bpt id="p1">**</bpt>row\_major<ept id="p1">**</ept> keyword.</source>
          <target state="new">DirectXMath uses row-major matrices and can be used directly with HLSL matrices defined with the <bpt id="p1">**</bpt>row\_major<ept id="p1">**</ept> keyword.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>Declare and create a constant buffer for the three matrices you use to transform each vertex.</source>
          <target state="new">Declare and create a constant buffer for the three matrices you use to transform each vertex.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  You usually declare the projection matrix when you set up device specific resources, because the results of multiplication with it must match the current 2-D viewport size parameters (which often correspond with the pixel height and width of the display).</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  You usually declare the projection matrix when you set up device specific resources, because the results of multiplication with it must match the current 2-D viewport size parameters (which often correspond with the pixel height and width of the display).</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>If those change, you must scale the x- and y-coordinate values accordingly.</source>
          <target state="new">If those change, you must scale the x- and y-coordinate values accordingly.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>While you're here, set the vertex and index buffers on the<bpt id="p1">[</bpt>ID3D11DeviceContext<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476149)</ept>, plus the topology you're using.</source>
          <target state="new">While you're here, set the vertex and index buffers on the<bpt id="p1">[</bpt>ID3D11DeviceContext<ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/ff476149)</ept>, plus the topology you're using.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>All right!</source>
          <target state="new">All right!</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>Input assembly complete.</source>
          <target state="new">Input assembly complete.</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Everything's in place for rendering.</source>
          <target state="new">Everything's in place for rendering.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Let's get that vertex shader going.</source>
          <target state="new">Let's get that vertex shader going.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Step 6: Process the mesh with the vertex shader</source>
          <target state="new">Step 6: Process the mesh with the vertex shader</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>Now that you have a vertex buffer with the vertices that define your mesh, and the index buffer that defines the order in which the vertices are processed, you send them to the vertex shader.</source>
          <target state="new">Now that you have a vertex buffer with the vertices that define your mesh, and the index buffer that defines the order in which the vertices are processed, you send them to the vertex shader.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The vertex shader code, expressed as compiled high-level shader language, runs one time for each vertex in the vertex buffer, allowing you to perform your per-vertex transforms.</source>
          <target state="new">The vertex shader code, expressed as compiled high-level shader language, runs one time for each vertex in the vertex buffer, allowing you to perform your per-vertex transforms.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The final result is typically a 2-D projection.</source>
          <target state="new">The final result is typically a 2-D projection.</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>(Did you load your vertex shader?</source>
          <target state="new">(Did you load your vertex shader?</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>If not, review <bpt id="p1">[</bpt>How to load resources in your DirectX game<ept id="p1">](load-a-game-asset.md)</ept>.)</source>
          <target state="new">If not, review <bpt id="p1">[</bpt>How to load resources in your DirectX game<ept id="p1">](load-a-game-asset.md)</ept>.)</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Here, you create the vertex shader...</source>
          <target state="new">Here, you create the vertex shader...</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>...and set the constant buffers.</source>
          <target state="new">...and set the constant buffers.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Here's the vertex shader code that handles the transformation from object coordinates to world coordinates and then to the 2-D view projection coordinate system.</source>
          <target state="new">Here's the vertex shader code that handles the transformation from object coordinates to world coordinates and then to the 2-D view projection coordinate system.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>You also apply some simple per-vertex lighting to make things pretty.</source>
          <target state="new">You also apply some simple per-vertex lighting to make things pretty.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>This goes in your vertex shader's HLSL file (SimplerVertexShader.hlsl, in this example).</source>
          <target state="new">This goes in your vertex shader's HLSL file (SimplerVertexShader.hlsl, in this example).</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>See that <bpt id="p1">**</bpt>cbuffer<ept id="p1">**</ept> at the top?</source>
          <target state="new">See that <bpt id="p1">**</bpt>cbuffer<ept id="p1">**</ept> at the top?</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>That's the HLSL analogue to the same constant buffer we declared in our C++ code previously.</source>
          <target state="new">That's the HLSL analogue to the same constant buffer we declared in our C++ code previously.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>And the <bpt id="p1">**</bpt>VertexShaderInputstruct<ept id="p1">**</ept>?</source>
          <target state="new">And the <bpt id="p1">**</bpt>VertexShaderInputstruct<ept id="p1">**</ept>?</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Why, that looks just like your input layout and vertex data declaration!</source>
          <target state="new">Why, that looks just like your input layout and vertex data declaration!</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>It's important that the constant buffer and vertex data declarations in your C++ code match the declarations in your HLSL code—and that includes signs, types, and data alignment.</source>
          <target state="new">It's important that the constant buffer and vertex data declarations in your C++ code match the declarations in your HLSL code—and that includes signs, types, and data alignment.</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>PixelShaderInput<ept id="p1">**</ept> specifies the layout of the data that is returned by the vertex shader's main function.</source>
          <target state="new"><bpt id="p1">**</bpt>PixelShaderInput<ept id="p1">**</ept> specifies the layout of the data that is returned by the vertex shader's main function.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>When you finish processing a vertex, you'll return a vertex position in the 2-D projection space and a color used for per-vertex lighting.</source>
          <target state="new">When you finish processing a vertex, you'll return a vertex position in the 2-D projection space and a color used for per-vertex lighting.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>The graphics card uses data output by the shader to calculate the "fragments" (possible pixels) that must be colored when the pixel shader is run in the next stage of the pipeline.</source>
          <target state="new">The graphics card uses data output by the shader to calculate the "fragments" (possible pixels) that must be colored when the pixel shader is run in the next stage of the pipeline.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Step 7: Passing the mesh through the pixel shader</source>
          <target state="new">Step 7: Passing the mesh through the pixel shader</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Typically, at this stage in the graphics pipeline, you perform per-pixel operations on the visible projected surfaces of your objects.</source>
          <target state="new">Typically, at this stage in the graphics pipeline, you perform per-pixel operations on the visible projected surfaces of your objects.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>(People like textures.) For the purposes of sample, though, you simply pass it through this stage.</source>
          <target state="new">(People like textures.) For the purposes of sample, though, you simply pass it through this stage.</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>First, let's create an instance of the pixel shader.</source>
          <target state="new">First, let's create an instance of the pixel shader.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>The pixel shader runs for every pixel in the 2-D projection of your scene, assigning a color to that pixel.</source>
          <target state="new">The pixel shader runs for every pixel in the 2-D projection of your scene, assigning a color to that pixel.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>In this case, we pass the color for the pixel returned by the vertex shader straight through.</source>
          <target state="new">In this case, we pass the color for the pixel returned by the vertex shader straight through.</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>Set the pixel shader.</source>
          <target state="new">Set the pixel shader.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Define a passthrough pixel shader in HLSL.</source>
          <target state="new">Define a passthrough pixel shader in HLSL.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>Put this code in an HLSL file separate from the vertex shader HLSL (such as SimplePixelShader.hlsl).</source>
          <target state="new">Put this code in an HLSL file separate from the vertex shader HLSL (such as SimplePixelShader.hlsl).</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>This code is run one time for every visible pixel in your viewport (an in-memory representation of the portion of the screen you are drawing to), which, in this case, maps to the entire screen.</source>
          <target state="new">This code is run one time for every visible pixel in your viewport (an in-memory representation of the portion of the screen you are drawing to), which, in this case, maps to the entire screen.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Now, your graphics pipeline is completely defined!</source>
          <target state="new">Now, your graphics pipeline is completely defined!</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Step 8: Rasterizing and displaying the mesh</source>
          <target state="new">Step 8: Rasterizing and displaying the mesh</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>Let's run the pipeline.</source>
          <target state="new">Let's run the pipeline.</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>This is easy: call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb173565)</ept>.</source>
          <target state="new">This is easy: call <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ID3D11DeviceContext::DrawIndexed<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/desktop/bb173565)</ept>.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Draw that cube!</source>
          <target state="new">Draw that cube!</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>Inside the graphics card, each vertex is processed in the order specified in your index buffer.</source>
          <target state="new">Inside the graphics card, each vertex is processed in the order specified in your index buffer.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>After your code has executed the vertex shader and the 2-D fragments are defined, the pixel shader is invoked and the triangles colored.</source>
          <target state="new">After your code has executed the vertex shader and the 2-D fragments are defined, the pixel shader is invoked and the triangles colored.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>Now, put the cube on the screen.</source>
          <target state="new">Now, put the cube on the screen.</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Present that frame buffer to the display.</source>
          <target state="new">Present that frame buffer to the display.</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>And you're done!</source>
          <target state="new">And you're done!</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>For a scene full of models, use multiple vertex and index buffers, and you might even have different shaders for different model types.</source>
          <target state="new">For a scene full of models, use multiple vertex and index buffers, and you might even have different shaders for different model types.</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Remember that each model has its own coordinate system, and you need to transform them to the shared world coordinate system using the matrices you defined in the constant buffer.</source>
          <target state="new">Remember that each model has its own coordinate system, and you need to transform them to the shared world coordinate system using the matrices you defined in the constant buffer.</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="new">Remarks</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>This topic covers creating and displaying simple geometry that you create yourself.</source>
          <target state="new">This topic covers creating and displaying simple geometry that you create yourself.</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>For more info about loading more complex geometry from a file and converting it to the sample-specific vertex buffer object (.vbo) format, see <bpt id="p1">[</bpt>How to load resources in your DirectX game<ept id="p1">](load-a-game-asset.md)</ept>.</source>
          <target state="new">For more info about loading more complex geometry from a file and converting it to the sample-specific vertex buffer object (.vbo) format, see <bpt id="p1">[</bpt>How to load resources in your DirectX game<ept id="p1">](load-a-game-asset.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="new">Note</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
          <target state="new">This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id="p1">[</bpt>archived documentation<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.</source>
          <target state="new">If you’re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id="p1">[</bpt>archived documentation<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>How to load resources in your DirectX game</source>
          <target state="new">How to load resources in your DirectX game</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>