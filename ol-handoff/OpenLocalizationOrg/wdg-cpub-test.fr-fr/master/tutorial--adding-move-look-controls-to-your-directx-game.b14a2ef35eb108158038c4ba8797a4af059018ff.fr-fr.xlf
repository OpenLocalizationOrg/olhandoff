<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">2bd8b00353a2566a539ecb71e98c09882db49585</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\gaming\tutorial--adding-move-look-controls-to-your-directx-game.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Move-look controls for games</source>
          <target state="new">Move-look controls for games</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Learn how to add traditional mouse and keyboard move-look controls (also known as mouselook controls) to your DirectX game.</source>
          <target state="new">Learn how to add traditional mouse and keyboard move-look controls (also known as mouselook controls) to your DirectX game.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Move-look controls for games</source>
          <target state="new">Move-look controls for games</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Learn how to add traditional mouse and keyboard move-look controls (also known as mouselook controls) to your DirectX game.</source>
          <target state="new">Learn how to add traditional mouse and keyboard move-look controls (also known as mouselook controls) to your DirectX game.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>We also discuss move-look support for touch devices, with the move controller defined as the lower-left section of the screen that behaves like a directional input, and the look controller defined for the remainder of the screen, with the camera centering on the last place the player touched in that area.</source>
          <target state="new">We also discuss move-look support for touch devices, with the move controller defined as the lower-left section of the screen that behaves like a directional input, and the look controller defined for the remainder of the screen, with the camera centering on the last place the player touched in that area.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>If this is an unfamiliar control concept to you, think of it this way: the keyboard (or the touch-based directional input box) controls your legs in this 3D space, and behaves as if your legs were only capable of moving forward or backward, or strafing left and right.</source>
          <target state="new">If this is an unfamiliar control concept to you, think of it this way: the keyboard (or the touch-based directional input box) controls your legs in this 3D space, and behaves as if your legs were only capable of moving forward or backward, or strafing left and right.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The mouse (or touch pointer) controls your head.</source>
          <target state="new">The mouse (or touch pointer) controls your head.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>You use your head to look in a direction -- left or right, up or down, or somewhere in that plane.</source>
          <target state="new">You use your head to look in a direction -- left or right, up or down, or somewhere in that plane.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>If there is a target in your view, you would use the mouse to center your camera view on that target, and then press the forward key to move towards it, or back to move away from it.</source>
          <target state="new">If there is a target in your view, you would use the mouse to center your camera view on that target, and then press the forward key to move towards it, or back to move away from it.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>To circle the target, you would keep the camera view centered on the target, and move left or right at the same time.</source>
          <target state="new">To circle the target, you would keep the camera view centered on the target, and move left or right at the same time.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>You can see how this is a very effective control method for navigating 3D environments!</source>
          <target state="new">You can see how this is a very effective control method for navigating 3D environments!</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>These controls are commonly known as WASD controls in gaming, where the W, A, S, and D keys are used for x-z plane fixed camera movement, and the mouse is used to control camera rotation around the x and y axes.</source>
          <target state="new">These controls are commonly known as WASD controls in gaming, where the W, A, S, and D keys are used for x-z plane fixed camera movement, and the mouse is used to control camera rotation around the x and y axes.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Objectives</source>
          <target state="new">Objectives</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Add basic move-look controls to your DirectX game for both mouse and keyboard, and touch screens.</source>
          <target state="new">Add basic move-look controls to your DirectX game for both mouse and keyboard, and touch screens.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Implement a first-person camera used to navigate a 3D environment.</source>
          <target state="new">Implement a first-person camera used to navigate a 3D environment.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A note on touch control implementations</source>
          <target state="new">A note on touch control implementations</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>For touch controls, we implement two controllers: the move controller, which handles movement in the x-z plane relative to the camera's look point; and the look controller, which aims the camera's look point.</source>
          <target state="new">For touch controls, we implement two controllers: the move controller, which handles movement in the x-z plane relative to the camera's look point; and the look controller, which aims the camera's look point.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Our move controller maps to the keyboard WASD buttons, and the look controller maps to the mouse.</source>
          <target state="new">Our move controller maps to the keyboard WASD buttons, and the look controller maps to the mouse.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>But for touch controls, we need to define a region of the screen that serves as the directional inputs, or the virtual WASD buttons, with the remainder of the screen serving as the input space for the look controls.</source>
          <target state="new">But for touch controls, we need to define a region of the screen that serves as the directional inputs, or the virtual WASD buttons, with the remainder of the screen serving as the input space for the look controls.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Our screen looks like this.</source>
          <target state="new">Our screen looks like this.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>the move-look controller layout</source>
          <target state="new">the move-look controller layout</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>When you move the touch pointer (not the mouse!) in the lower left of the screen, any movement upwards will make the camera move forward.</source>
          <target state="new">When you move the touch pointer (not the mouse!) in the lower left of the screen, any movement upwards will make the camera move forward.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Any movement downwards will make the camera move backwards.</source>
          <target state="new">Any movement downwards will make the camera move backwards.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>The same holds for left and right movement inside the move controller's pointer space.</source>
          <target state="new">The same holds for left and right movement inside the move controller's pointer space.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Outside of that space, and it becomes a look controller -- you just touch or drag the camera to where you'd like it to face.</source>
          <target state="new">Outside of that space, and it becomes a look controller -- you just touch or drag the camera to where you'd like it to face.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Set up the basic input event infrastructure</source>
          <target state="new">Set up the basic input event infrastructure</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>First, we must create our control class that we use to handle input events from the mouse and keyboard, and update the camera perspective based on that input.</source>
          <target state="new">First, we must create our control class that we use to handle input events from the mouse and keyboard, and update the camera perspective based on that input.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>Because we're implementing move-look controls, we call it <bpt id="p1">**</bpt>MoveLookController<ept id="p1">**</ept>.</source>
          <target state="new">Because we're implementing move-look controls, we call it <bpt id="p1">**</bpt>MoveLookController<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Now, let's create a header that defines the state of the move-look controller and its first-person camera, plus the basic methods and event handlers that implement the controls and that update the state of the camera.</source>
          <target state="new">Now, let's create a header that defines the state of the move-look controller and its first-person camera, plus the basic methods and event handlers that implement the controls and that update the state of the camera.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Our code contains 4 groups of private fields.</source>
          <target state="new">Our code contains 4 groups of private fields.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Let's review the purpose of each one.</source>
          <target state="new">Let's review the purpose of each one.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>First, we define some useful fields that hold our updated info about our camera view.</source>
          <target state="new">First, we define some useful fields that hold our updated info about our camera view.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_position<ept id="p1">**</ept> is the position of the camera (and therefore the viewplane) in the 3D scene, using scene coordinates.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_position<ept id="p1">**</ept> is the position of the camera (and therefore the viewplane) in the 3D scene, using scene coordinates.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_pitch<ept id="p1">**</ept> is the pitch of the camera, or its up-down rotation around the viewplane's x-axis, in radians.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_pitch<ept id="p1">**</ept> is the pitch of the camera, or its up-down rotation around the viewplane's x-axis, in radians.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_yaw<ept id="p1">**</ept> is the yaw of the camera, or its left-right rotation around the viewplane's y-axis, in radians.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_yaw<ept id="p1">**</ept> is the yaw of the camera, or its left-right rotation around the viewplane's y-axis, in radians.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Now, let's define the fields that we use to store info about the status and position of our controllers.</source>
          <target state="new">Now, let's define the fields that we use to store info about the status and position of our controllers.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>First, we'll define the fields we need for our touch-based move controller.</source>
          <target state="new">First, we'll define the fields we need for our touch-based move controller.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>(There's nothing special needed for the keyboard implementation of the move controller.</source>
          <target state="new">(There's nothing special needed for the keyboard implementation of the move controller.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>We just read keyboard events with specific handlers.)</source>
          <target state="new">We just read keyboard events with specific handlers.)</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_moveInUse<ept id="p1">**</ept> indicates whether the move controller is in use.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_moveInUse<ept id="p1">**</ept> indicates whether the move controller is in use.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_movePointerID<ept id="p1">**</ept> is the unique ID for the current move pointer.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_movePointerID<ept id="p1">**</ept> is the unique ID for the current move pointer.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>We use it to differentiate between the look pointer and the move pointer when we check the pointer ID value.</source>
          <target state="new">We use it to differentiate between the look pointer and the move pointer when we check the pointer ID value.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_moveFirstDown<ept id="p1">**</ept> is the point on the screen where the player first touched the move controller pointer area.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_moveFirstDown<ept id="p1">**</ept> is the point on the screen where the player first touched the move controller pointer area.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>We use this value later to set a dead zone to keep tiny movements from jittering the view.</source>
          <target state="new">We use this value later to set a dead zone to keep tiny movements from jittering the view.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_movePointerPosition<ept id="p1">**</ept> is the point on the screen the player has currently moved the pointer to.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_movePointerPosition<ept id="p1">**</ept> is the point on the screen the player has currently moved the pointer to.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>We use it to determine what direction the player wanted to move by examining it relative to <bpt id="p1">**</bpt>m\_moveFirstDown<ept id="p1">**</ept>.</source>
          <target state="new">We use it to determine what direction the player wanted to move by examining it relative to <bpt id="p1">**</bpt>m\_moveFirstDown<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_moveCommand<ept id="p1">**</ept> is the final computed command for the move controller: up (forward), down (back), left, or right.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_moveCommand<ept id="p1">**</ept> is the final computed command for the move controller: up (forward), down (back), left, or right.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Now, we define the fields we use for our look controller, both the mouse and touch implementations.</source>
          <target state="new">Now, we define the fields we use for our look controller, both the mouse and touch implementations.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_lookInUse<ept id="p1">**</ept> indicates whether the look control is in use.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_lookInUse<ept id="p1">**</ept> indicates whether the look control is in use.</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_lookPointerID<ept id="p1">**</ept> is the unique ID for the current look pointer.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_lookPointerID<ept id="p1">**</ept> is the unique ID for the current look pointer.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>We use it to differentiate between the look pointer and the move pointer when we check the pointer ID value.</source>
          <target state="new">We use it to differentiate between the look pointer and the move pointer when we check the pointer ID value.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_lookLastPoint<ept id="p1">**</ept> is the last point, in scene coordinates, that was captured in the previous frame.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_lookLastPoint<ept id="p1">**</ept> is the last point, in scene coordinates, that was captured in the previous frame.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_lookLastDelta<ept id="p1">**</ept> is the computed difference between the current <bpt id="p2">**</bpt>m\_position<ept id="p2">**</ept> and <bpt id="p3">**</bpt>m\_lookLastPoint<ept id="p3">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_lookLastDelta<ept id="p1">**</ept> is the computed difference between the current <bpt id="p2">**</bpt>m\_position<ept id="p2">**</ept> and <bpt id="p3">**</bpt>m\_lookLastPoint<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>Finally, we define 6 Boolean values for the 6 degrees of movement, which we use to indicate the current state of each directional move action (on or off):</source>
          <target state="new">Finally, we define 6 Boolean values for the 6 degrees of movement, which we use to indicate the current state of each directional move action (on or off):</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>m\_forward<ept id="p1">**</ept>, <bpt id="p2">**</bpt>m\_back<ept id="p2">**</ept>, <bpt id="p3">**</bpt>m\_left<ept id="p3">**</ept>, <bpt id="p4">**</bpt>m\_right<ept id="p4">**</ept>, <bpt id="p5">**</bpt>m\_up<ept id="p5">**</ept> and <bpt id="p6">**</bpt>m\_down<ept id="p6">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>m\_forward<ept id="p1">**</ept>, <bpt id="p2">**</bpt>m\_back<ept id="p2">**</ept>, <bpt id="p3">**</bpt>m\_left<ept id="p3">**</ept>, <bpt id="p4">**</bpt>m\_right<ept id="p4">**</ept>, <bpt id="p5">**</bpt>m\_up<ept id="p5">**</ept> and <bpt id="p6">**</bpt>m\_down<ept id="p6">**</ept>.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>We use the 6 event handlers to capture the input data we use to update the state of our controllers:</source>
          <target state="new">We use the 6 event handlers to capture the input data we use to update the state of our controllers:</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>OnPointerPressed<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>OnPointerPressed<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The player pressed the left mouse button with the pointer in our game screen, or touched the screen.</source>
          <target state="new">The player pressed the left mouse button with the pointer in our game screen, or touched the screen.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>OnPointerMoved<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>OnPointerMoved<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The player moved the mouse with the pointer in our game screen, or dragged the touch pointer on the screen.</source>
          <target state="new">The player moved the mouse with the pointer in our game screen, or dragged the touch pointer on the screen.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>OnPointerReleased<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>OnPointerReleased<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>The player released the left mouse button with the pointer in our game screen, or stopped touching the screen.</source>
          <target state="new">The player released the left mouse button with the pointer in our game screen, or stopped touching the screen.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>OnKeyDown<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>OnKeyDown<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>The player pressed a key.</source>
          <target state="new">The player pressed a key.</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>OnKeyUp<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>OnKeyUp<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The player released a key.</source>
          <target state="new">The player released a key.</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>And finally, we use these methods and properties to initialize, access, and update the controllers' state info.</source>
          <target state="new">And finally, we use these methods and properties to initialize, access, and update the controllers' state info.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Initialize<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Initialize<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>Our app calls this event handler to initialize the controls and attach them to the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindow<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> object that describes our display window.</source>
          <target state="new">Our app calls this event handler to initialize the controls and attach them to the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindow<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> object that describes our display window.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SetPosition<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>SetPosition<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Our app calls this method to set the (x, y, and z) coordinates of our controls in the scene space.</source>
          <target state="new">Our app calls this method to set the (x, y, and z) coordinates of our controls in the scene space.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>SetOrientation<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>SetOrientation<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Our app calls this method to set the pitch and yaw of the camera.</source>
          <target state="new">Our app calls this method to set the pitch and yaw of the camera.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>get\_Position<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>get\_Position<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Our app accesses this property to get the current position of the camera in the scene space.</source>
          <target state="new">Our app accesses this property to get the current position of the camera in the scene space.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>You use this property as the method of communicating the current camera position to the app.</source>
          <target state="new">You use this property as the method of communicating the current camera position to the app.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>get\_LookPoint<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>get\_LookPoint<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Our app accesses this property to get the current point toward which the controller camera is facing.</source>
          <target state="new">Our app accesses this property to get the current point toward which the controller camera is facing.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Update<ept id="p1">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Update<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Reads the state of the move and look controllers and updates the camera position.</source>
          <target state="new">Reads the state of the move and look controllers and updates the camera position.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>You continually call this method from the app's main loop to refresh the camera controller data and the camera position in the scene space.</source>
          <target state="new">You continually call this method from the app's main loop to refresh the camera controller data and the camera position in the scene space.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Now, you have here all the components you need to implement your move-look controls.</source>
          <target state="new">Now, you have here all the components you need to implement your move-look controls.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>So, let's connect these pieces together.</source>
          <target state="new">So, let's connect these pieces together.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>Create the basic input events</source>
          <target state="new">Create the basic input events</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>The Windows Runtime event dispatcher provides 5 events we want instances of the <bpt id="p1">**</bpt>MoveLookController<ept id="p1">**</ept> class to handle:</source>
          <target state="new">The Windows Runtime event dispatcher provides 5 events we want instances of the <bpt id="p1">**</bpt>MoveLookController<ept id="p1">**</ept> class to handle:</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>PointerPressed</source>
          <target state="new">PointerPressed</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>PointerMoved</source>
          <target state="new">PointerMoved</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>PointerReleased</source>
          <target state="new">PointerReleased</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>KeyUp</source>
          <target state="new">KeyUp</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>KeyDown</source>
          <target state="new">KeyDown</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>These events are implemented on the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindow<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> type.</source>
          <target state="new">These events are implemented on the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CoreWindow<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> type.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>We assume that you have a <bpt id="p1">**</bpt>CoreWindow<ept id="p1">**</ept> object to work with.</source>
          <target state="new">We assume that you have a <bpt id="p1">**</bpt>CoreWindow<ept id="p1">**</ept> object to work with.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>If you don't know how to obtain one, see <bpt id="p1">[</bpt>How to set up your Universal Windows Platform (UWP) C++ app to display a DirectX view<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh465077)</ept>.</source>
          <target state="new">If you don't know how to obtain one, see <bpt id="p1">[</bpt>How to set up your Universal Windows Platform (UWP) C++ app to display a DirectX view<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh465077)</ept>.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>As these events fire while our app is running, the handlers update the controllers' state info defined in our private fields.</source>
          <target state="new">As these events fire while our app is running, the handlers update the controllers' state info defined in our private fields.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>First, let's populate the mouse and touch pointer event handlers.</source>
          <target state="new">First, let's populate the mouse and touch pointer event handlers.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>In the first event handler, <bpt id="p1">**</bpt>OnPointerPressed()<ept id="p1">**</ept>, we get the x-y coordinates of the pointer from the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>CoreWindow<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> that manages our display when the user clicks the mouse or touches the screen in the look controller region.</source>
          <target state="new">In the first event handler, <bpt id="p1">**</bpt>OnPointerPressed()<ept id="p1">**</ept>, we get the x-y coordinates of the pointer from the <bpt id="p2">[</bpt><bpt id="p3">**</bpt>CoreWindow<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> that manages our display when the user clicks the mouse or touches the screen in the look controller region.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>OnPointerPressed</source>
          <target state="new">OnPointerPressed</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>This event handler checks whether the pointer is not the mouse (for the purposes of this sample, which supports both mouse and touch) and if it is in the move controller area.</source>
          <target state="new">This event handler checks whether the pointer is not the mouse (for the purposes of this sample, which supports both mouse and touch) and if it is in the move controller area.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>If both criteria are true, it checks whether the pointer was just pressed, specifically, whether this click is unrelated to a previous move or look input, by testing if <bpt id="p1">**</bpt>m\_moveInUse<ept id="p1">**</ept> is false.</source>
          <target state="new">If both criteria are true, it checks whether the pointer was just pressed, specifically, whether this click is unrelated to a previous move or look input, by testing if <bpt id="p1">**</bpt>m\_moveInUse<ept id="p1">**</ept> is false.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>If so, the handler captures the point in the move controller area where the press happened and sets <bpt id="p1">**</bpt>m\_moveInUse<ept id="p1">**</ept> to true, so that when this handler is called again, it won't overwrite the start position of the move controller input interaction.</source>
          <target state="new">If so, the handler captures the point in the move controller area where the press happened and sets <bpt id="p1">**</bpt>m\_moveInUse<ept id="p1">**</ept> to true, so that when this handler is called again, it won't overwrite the start position of the move controller input interaction.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>It also updates the move controller pointer ID to the current pointer's ID.</source>
          <target state="new">It also updates the move controller pointer ID to the current pointer's ID.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>If the pointer is the mouse or if the touch pointer isn't in the move controller area, it must be in the look controller area.</source>
          <target state="new">If the pointer is the mouse or if the touch pointer isn't in the move controller area, it must be in the look controller area.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>It sets <bpt id="p1">**</bpt>m\_lookLastPoint<ept id="p1">**</ept> to the current position where the user pressed the mouse button or touched and pressed, resets the delta, and updates the look controller's pointer ID to the current pointer ID.</source>
          <target state="new">It sets <bpt id="p1">**</bpt>m\_lookLastPoint<ept id="p1">**</ept> to the current position where the user pressed the mouse button or touched and pressed, resets the delta, and updates the look controller's pointer ID to the current pointer ID.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>It also sets the state of the look controller to active.</source>
          <target state="new">It also sets the state of the look controller to active.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>OnPointerMoved</source>
          <target state="new">OnPointerMoved</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">**</bpt>OnPointerMoved<ept id="p1">**</ept> event handler fires whenever the pointer moves (in this case, if a touch screen pointer is being dragged, or if the mouse pointer is being moved while the left button is pressed).</source>
          <target state="new">The <bpt id="p1">**</bpt>OnPointerMoved<ept id="p1">**</ept> event handler fires whenever the pointer moves (in this case, if a touch screen pointer is being dragged, or if the mouse pointer is being moved while the left button is pressed).</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If the pointer ID is the same as the move controller pointer's ID, then it's the move pointer; otherwise, we check if it's the look controller that's the active pointer.</source>
          <target state="new">If the pointer ID is the same as the move controller pointer's ID, then it's the move pointer; otherwise, we check if it's the look controller that's the active pointer.</target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>If it's the move controller, we just update the pointer position.</source>
          <target state="new">If it's the move controller, we just update the pointer position.</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>We keep updating it as long the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>PointerMoved<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208276)</ept> event keeps firing, because we want to compare the final position with the first one we captured with the <bpt id="p3">**</bpt>OnPointerPressed<ept id="p3">**</ept> event handler.</source>
          <target state="new">We keep updating it as long the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>PointerMoved<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208276)</ept> event keeps firing, because we want to compare the final position with the first one we captured with the <bpt id="p3">**</bpt>OnPointerPressed<ept id="p3">**</ept> event handler.</target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>If it's the look controller, things are a little more complicated.</source>
          <target state="new">If it's the look controller, things are a little more complicated.</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>We need to calculate a new look point and center the camera on it, so we calculate the delta between the last look point and the current screen position, and then we multiply versus our scale factor, which we can tweak to make the look movements smaller or larger relative to the distance of the screen movement.</source>
          <target state="new">We need to calculate a new look point and center the camera on it, so we calculate the delta between the last look point and the current screen position, and then we multiply versus our scale factor, which we can tweak to make the look movements smaller or larger relative to the distance of the screen movement.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>Using that value, we calculate the pitch and the yaw.</source>
          <target state="new">Using that value, we calculate the pitch and the yaw.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Finally, we need to deactivate the move or look controller behaviors when the player stops moving the mouse or touching the screen.</source>
          <target state="new">Finally, we need to deactivate the move or look controller behaviors when the player stops moving the mouse or touching the screen.</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>We use <bpt id="p1">**</bpt>OnPointerReleased<ept id="p1">**</ept>, which we call when <bpt id="p2">[</bpt><bpt id="p3">**</bpt>PointerReleased<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208279)</ept> is fired, to set <bpt id="p4">**</bpt>m\_moveInUse<ept id="p4">**</ept> or <bpt id="p5">**</bpt>m\_lookInUse<ept id="p5">**</ept> to FALSE and turn off the camera pan movement, and to zero out the pointer ID.</source>
          <target state="new">We use <bpt id="p1">**</bpt>OnPointerReleased<ept id="p1">**</ept>, which we call when <bpt id="p2">[</bpt><bpt id="p3">**</bpt>PointerReleased<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208279)</ept> is fired, to set <bpt id="p4">**</bpt>m\_moveInUse<ept id="p4">**</ept> or <bpt id="p5">**</bpt>m\_lookInUse<ept id="p5">**</ept> to FALSE and turn off the camera pan movement, and to zero out the pointer ID.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>OnPointerReleased</source>
          <target state="new">OnPointerReleased</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>So far, we handled all the touch screen events.</source>
          <target state="new">So far, we handled all the touch screen events.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Now, let's handle the key input events for a keyboard-based move controller.</source>
          <target state="new">Now, let's handle the key input events for a keyboard-based move controller.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>OnKeyDown</source>
          <target state="new">OnKeyDown</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>As long as one of these keys is pressed, this event handler sets the corresponding directional move state to true.</source>
          <target state="new">As long as one of these keys is pressed, this event handler sets the corresponding directional move state to true.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>OnKeyUp</source>
          <target state="new">OnKeyUp</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>And when the key is released, this event handler sets it back to false.</source>
          <target state="new">And when the key is released, this event handler sets it back to false.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>When we call <bpt id="p1">**</bpt>Update<ept id="p1">**</ept>, it checks these directional move states, and move the camera accordingly.</source>
          <target state="new">When we call <bpt id="p1">**</bpt>Update<ept id="p1">**</ept>, it checks these directional move states, and move the camera accordingly.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>This is a bit simpler than the touch implementation!</source>
          <target state="new">This is a bit simpler than the touch implementation!</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Initialize the touch controls and the controller state</source>
          <target state="new">Initialize the touch controls and the controller state</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>Let's hook up the events now, and initialize all the controller state fields.</source>
          <target state="new">Let's hook up the events now, and initialize all the controller state fields.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Initialize</source>
          <target state="new">Initialize</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Initialize<ept id="p1">**</ept> takes a reference to the app's <bpt id="p2">[</bpt><bpt id="p3">**</bpt>CoreWindow<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> instance as a parameter and registers the event handlers we developed to the appropriate events on that <bpt id="p4">**</bpt>CoreWindow<ept id="p4">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Initialize<ept id="p1">**</ept> takes a reference to the app's <bpt id="p2">[</bpt><bpt id="p3">**</bpt>CoreWindow<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208225)</ept> instance as a parameter and registers the event handlers we developed to the appropriate events on that <bpt id="p4">**</bpt>CoreWindow<ept id="p4">**</ept>.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>It initializes the move and look pointer's IDs, sets the command vector for our touch screen move controller implementation to zero, and sets the camera looking straight ahead when the app starts.</source>
          <target state="new">It initializes the move and look pointer's IDs, sets the command vector for our touch screen move controller implementation to zero, and sets the camera looking straight ahead when the app starts.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>Getting and setting the position and orientation of the camera</source>
          <target state="new">Getting and setting the position and orientation of the camera</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>Let's define some methods to get and set the position of the camera with respect to the viewport.</source>
          <target state="new">Let's define some methods to get and set the position of the camera with respect to the viewport.</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>Updating the controller state info</source>
          <target state="new">Updating the controller state info</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Now, we perform our calculations that convert the pointer coordinate info tracked in <bpt id="p1">**</bpt>m\_movePointerPosition<ept id="p1">**</ept> into new coordinate information respective of our world coordinate system.</source>
          <target state="new">Now, we perform our calculations that convert the pointer coordinate info tracked in <bpt id="p1">**</bpt>m\_movePointerPosition<ept id="p1">**</ept> into new coordinate information respective of our world coordinate system.</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Our app calls this method every time we refresh the main app loop.</source>
          <target state="new">Our app calls this method every time we refresh the main app loop.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>So, it is here that we compute the new look point position info we want to pass to the app for updating the view matrix before projection into the viewport.</source>
          <target state="new">So, it is here that we compute the new look point position info we want to pass to the app for updating the view matrix before projection into the viewport.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>Because we don't want jittery movement when the player uses our touch-based move controller, we set a virtual dead zone around the pointer with a diameter of 32 pixels.</source>
          <target state="new">Because we don't want jittery movement when the player uses our touch-based move controller, we set a virtual dead zone around the pointer with a diameter of 32 pixels.</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>We also add velocity, which is the command value plus a movement gain rate.</source>
          <target state="new">We also add velocity, which is the command value plus a movement gain rate.</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>(You can adjust this behavior to your liking, to slow down or speed up the rate of movement based on the distance the pointer moves in the move controller area.)</source>
          <target state="new">(You can adjust this behavior to your liking, to slow down or speed up the rate of movement based on the distance the pointer moves in the move controller area.)</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>When we compute the velocity, we also translate the coordinates received from the move and look controllers into the movement of the actual look point we send to the method that computes our view matrix for the scene.</source>
          <target state="new">When we compute the velocity, we also translate the coordinates received from the move and look controllers into the movement of the actual look point we send to the method that computes our view matrix for the scene.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>First, we invert the x coordinate, because if we click-move or drag left or right with the look controller, the look point rotates in the opposite direction in the scene, as a camera might swing about its central axis.</source>
          <target state="new">First, we invert the x coordinate, because if we click-move or drag left or right with the look controller, the look point rotates in the opposite direction in the scene, as a camera might swing about its central axis.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>Then, we swap the y and z axes, because an up/down key press or touch drag motion (read as a y-axis behavior) on the move controller should translate into a camera action that moves the look point into or out of the screen (the z-axis).</source>
          <target state="new">Then, we swap the y and z axes, because an up/down key press or touch drag motion (read as a y-axis behavior) on the move controller should translate into a camera action that moves the look point into or out of the screen (the z-axis).</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>The final position of the look point for the player is the last position plus the calculated velocity, and this is what is read by the renderer when it calls the <bpt id="p1">**</bpt>get\_Position<ept id="p1">**</ept> method (most likely during the setup for each frame).</source>
          <target state="new">The final position of the look point for the player is the last position plus the calculated velocity, and this is what is read by the renderer when it calls the <bpt id="p1">**</bpt>get\_Position<ept id="p1">**</ept> method (most likely during the setup for each frame).</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>After that, we reset the move command to zero.</source>
          <target state="new">After that, we reset the move command to zero.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>Updating the view matrix with the new camera position</source>
          <target state="new">Updating the view matrix with the new camera position</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>We can obtain a scene space coordinate that our camera is focused on, and which is updated whenever you tell your app to do so (every 60 seconds in the main app loop, for example).</source>
          <target state="new">We can obtain a scene space coordinate that our camera is focused on, and which is updated whenever you tell your app to do so (every 60 seconds in the main app loop, for example).</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>This pseudocode suggests the calling behavior you can implement:</source>
          <target state="new">This pseudocode suggests the calling behavior you can implement:</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Congratulations!</source>
          <target state="new">Congratulations!</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>You've implemented basic move-look controls for both touch screens and keyboard/mouse input touch controls in your game!</source>
          <target state="new">You've implemented basic move-look controls for both touch screens and keyboard/mouse input touch controls in your game!</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="new">Note</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</source>
          <target state="new">This article is for Windows 10 developers writing Universal Windows Platform (UWP) apps.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>If you’re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id="p1">[</bpt>archived documentation<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.</source>
          <target state="new">If you’re developing for Windows 8.x or Windows Phone 8.x, see the <bpt id="p1">[</bpt>archived documentation<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept>.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>