<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">af817df780f291b6367a374e535cce22a84ba4c1</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci1\xaml-platform\xaml-syntax-guide.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>We explain XAML syntax rules and the terminology that describes the restrictions or choices available for XAML syntax.</source>
          <target state="new">We explain XAML syntax rules and the terminology that describes the restrictions or choices available for XAML syntax.</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>XAML syntax guide</source>
          <target state="new">XAML syntax guide</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>XAML syntax guide</source>
          <target state="new">XAML syntax guide</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>We explain XAML syntax rules and the terminology that describes the restrictions or choices available for XAML syntax.</source>
          <target state="new">We explain XAML syntax rules and the terminology that describes the restrictions or choices available for XAML syntax.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>You'll find this topic useful if you are new to using the XAML language, you want a refresher on the terminology or parts of syntax, or you are curious about how the XAML language works and want more background and context.</source>
          <target state="new">You'll find this topic useful if you are new to using the XAML language, you want a refresher on the terminology or parts of syntax, or you are curious about how the XAML language works and want more background and context.</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>XAML is XML</source>
          <target state="new">XAML is XML</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>Extensible Application Markup Language (XAML) has a basic syntax that builds on XML, and by definition valid XAML must be valid XML.</source>
          <target state="new">Extensible Application Markup Language (XAML) has a basic syntax that builds on XML, and by definition valid XAML must be valid XML.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>But XAML also has its own syntax concepts that extend XML.</source>
          <target state="new">But XAML also has its own syntax concepts that extend XML.</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>A given XML entity might be valid in plain XML, but that syntax might have a different and more complete meaning as XAML.</source>
          <target state="new">A given XML entity might be valid in plain XML, but that syntax might have a different and more complete meaning as XAML.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>This topic explains these XAML syntax concepts.</source>
          <target state="new">This topic explains these XAML syntax concepts.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>XAML vocabularies</source>
          <target state="new">XAML vocabularies</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>One area where XAML differs from most XML usages is that XAML is not typically enforced with a schema, such as an XSD file.</source>
          <target state="new">One area where XAML differs from most XML usages is that XAML is not typically enforced with a schema, such as an XSD file.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>That's because XAML is intended to be extensible, that's what the "X" in the acronym XAML means.</source>
          <target state="new">That's because XAML is intended to be extensible, that's what the "X" in the acronym XAML means.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Once XAML is parsed, the elements and attributes you reference in XAML are expected to exist in some backing code representation, either in the core types defined by the Windows Runtime, or in types that extend or are based off the Windows Runtime.</source>
          <target state="new">Once XAML is parsed, the elements and attributes you reference in XAML are expected to exist in some backing code representation, either in the core types defined by the Windows Runtime, or in types that extend or are based off the Windows Runtime.</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The SDK documentation sometimes refers to the types that are already built-in to the Windows Runtime and can be used in XAML as being the <bpt id="p1">*</bpt>XAML vocabulary<ept id="p1">*</ept> for the Windows Runtime.</source>
          <target state="new">The SDK documentation sometimes refers to the types that are already built-in to the Windows Runtime and can be used in XAML as being the <bpt id="p1">*</bpt>XAML vocabulary<ept id="p1">*</ept> for the Windows Runtime.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>Microsoft Visual Studio helps you to produce markup that's valid within this XAML vocabulary.</source>
          <target state="new">Microsoft Visual Studio helps you to produce markup that's valid within this XAML vocabulary.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>Visual Studio can also include your custom types for XAML usage so long as the source of those types is referenced correctly in the project.</source>
          <target state="new">Visual Studio can also include your custom types for XAML usage so long as the source of those types is referenced correctly in the project.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>For more info about XAML and custom types, see <bpt id="p1">[</bpt>XAML namespaces and namespace mapping<ept id="p1">](xaml-namespaces-and-namespace-mapping.md)</ept>.</source>
          <target state="new">For more info about XAML and custom types, see <bpt id="p1">[</bpt>XAML namespaces and namespace mapping<ept id="p1">](xaml-namespaces-and-namespace-mapping.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Declaring objects</source>
          <target state="new">Declaring objects</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>Programmers often think in terms of objects and members, whereas a markup language is conceptualized as elements and attributes.</source>
          <target state="new">Programmers often think in terms of objects and members, whereas a markup language is conceptualized as elements and attributes.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>In the most basic sense, an element that you declare in XAML markup becomes an object in a backing runtime object representation.</source>
          <target state="new">In the most basic sense, an element that you declare in XAML markup becomes an object in a backing runtime object representation.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>To create a run-time object for your app, you declare a XAML element in the XAML markup.</source>
          <target state="new">To create a run-time object for your app, you declare a XAML element in the XAML markup.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>The object is created when the Windows Runtime loads your XAML.</source>
          <target state="new">The object is created when the Windows Runtime loads your XAML.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>A XAML file always has exactly one element serving as its root, which declares an object that will be the conceptual root of some programming structure such as a page, or the object graph of the entire run-time definition of an application.</source>
          <target state="new">A XAML file always has exactly one element serving as its root, which declares an object that will be the conceptual root of some programming structure such as a page, or the object graph of the entire run-time definition of an application.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>In terms of XAML syntax, there are three ways to declare objects in XAML:</source>
          <target state="new">In terms of XAML syntax, there are three ways to declare objects in XAML:</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Directly, using object element syntax:<ept id="p1">**</ept> This uses opening and closing tags to instantiate an object as an XML-form element.</source>
          <target state="new"><bpt id="p1">**</bpt>Directly, using object element syntax:<ept id="p1">**</ept> This uses opening and closing tags to instantiate an object as an XML-form element.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>You can use this syntax to declare root objects or to create nested objects that set property values.</source>
          <target state="new">You can use this syntax to declare root objects or to create nested objects that set property values.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Indirectly, using attribute syntax:<ept id="p1">**</ept> This uses an inline string value that has instructions for how to create an object.</source>
          <target state="new"><bpt id="p1">**</bpt>Indirectly, using attribute syntax:<ept id="p1">**</ept> This uses an inline string value that has instructions for how to create an object.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>The XAML parser uses this string to set the value of a property to a newly created reference value.</source>
          <target state="new">The XAML parser uses this string to set the value of a property to a newly created reference value.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>Support for it is limited to certain common objects and properties.</source>
          <target state="new">Support for it is limited to certain common objects and properties.</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>Using a markup extension.</source>
          <target state="new">Using a markup extension.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>This does not mean that you always have the choice of any syntax for object creation in a XAML vocabulary.</source>
          <target state="new">This does not mean that you always have the choice of any syntax for object creation in a XAML vocabulary.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>Some objects can be created only by using object element syntax.</source>
          <target state="new">Some objects can be created only by using object element syntax.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Some objects can be created only by being initially set in an attribute.</source>
          <target state="new">Some objects can be created only by being initially set in an attribute.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>In fact, objects that can be created with either object element or attribute syntax are comparatively rare in XAML vocabularies.</source>
          <target state="new">In fact, objects that can be created with either object element or attribute syntax are comparatively rare in XAML vocabularies.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Even if both syntax forms are possible, one of the syntaxes will be more common as a matter of style.</source>
          <target state="new">Even if both syntax forms are possible, one of the syntaxes will be more common as a matter of style.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>There are also techniques you can use in XAML to reference existing objects rather than creating new values.</source>
          <target state="new">There are also techniques you can use in XAML to reference existing objects rather than creating new values.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The existing objects might be defined either in other areas of XAML, or might exist implicitly through some behavior of the platform and its application or programming models.</source>
          <target state="new">The existing objects might be defined either in other areas of XAML, or might exist implicitly through some behavior of the platform and its application or programming models.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Declaring an object by using object element syntax</source>
          <target state="new">Declaring an object by using object element syntax</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>To declare an object with object element syntax, you write tags like this: <ph id="ph1">`&lt;objectName&gt;  &lt;/objectName&gt;`</ph>, where <bpt id="p1">*</bpt>objectName<ept id="p1">*</ept> is the type name for the object you want to instantiate.</source>
          <target state="new">To declare an object with object element syntax, you write tags like this: <ph id="ph1">`&lt;objectName&gt;  &lt;/objectName&gt;`</ph>, where <bpt id="p1">*</bpt>objectName<ept id="p1">*</ept> is the type name for the object you want to instantiate.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Here's object element usage to declare a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> object:</source>
          <target state="new">Here's object element usage to declare a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept> object:</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>If the object does not contain other objects, you can declare the object element by using one self-closing tag instead of an opening/closing pair:</source>
          <target state="new">If the object does not contain other objects, you can declare the object element by using one self-closing tag instead of an opening/closing pair:</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Containers</source>
          <target state="new">Containers</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Many objects used as UI elements, such as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept>, can contain other objects.</source>
          <target state="new">Many objects used as UI elements, such as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept>, can contain other objects.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>These are sometimes referred to as containers.</source>
          <target state="new">These are sometimes referred to as containers.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>The following example shows a <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> container that contains one element, a <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Rectangle<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br243371)</ept>.</source>
          <target state="new">The following example shows a <bpt id="p1">**</bpt>Canvas<ept id="p1">**</ept> container that contains one element, a <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Rectangle<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br243371)</ept>.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>Declaring an object by using attribute syntax</source>
          <target state="new">Declaring an object by using attribute syntax</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Because this behavior is tied to property setting, we'll talk about this more in upcoming sections.</source>
          <target state="new">Because this behavior is tied to property setting, we'll talk about this more in upcoming sections.</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Initialization text</source>
          <target state="new">Initialization text</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>For some objects you can declare new values using inner text that's used as initialization values for construction.</source>
          <target state="new">For some objects you can declare new values using inner text that's used as initialization values for construction.</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>In XAML, this technique and syntax is called <bpt id="p1">*</bpt>initialization text<ept id="p1">*</ept>.</source>
          <target state="new">In XAML, this technique and syntax is called <bpt id="p1">*</bpt>initialization text<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>Conceptually, initialization text is similar to calling a constructor that has parameters.</source>
          <target state="new">Conceptually, initialization text is similar to calling a constructor that has parameters.</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Initialization text is useful for setting initial values of certain structures.</source>
          <target state="new">Initialization text is useful for setting initial values of certain structures.</target>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You often use an object element syntax with initialization text if you want a structure value with an <bpt id="p1">**</bpt>x:Key<ept id="p1">**</ept>, so it can exist in a <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ResourceDictionary<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208794)</ept>.</source>
          <target state="new">You often use an object element syntax with initialization text if you want a structure value with an <bpt id="p1">**</bpt>x:Key<ept id="p1">**</ept>, so it can exist in a <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ResourceDictionary<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br208794)</ept>.</target>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve">
          <source>You might do this if you share that structure value among multiple target properties.</source>
          <target state="new">You might do this if you share that structure value among multiple target properties.</target>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For some structures, you can't use attribute syntax to set the structure's values: initialization text is the only way to produce a useful and shareable <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CornerRadius<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242343)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Thickness<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208864)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>GridLength<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208754)</ept> or <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Color<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/hh673723)</ept> resource.</source>
          <target state="new">For some structures, you can't use attribute syntax to set the structure's values: initialization text is the only way to produce a useful and shareable <bpt id="p1">[</bpt><bpt id="p2">**</bpt>CornerRadius<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242343)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Thickness<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208864)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>GridLength<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208754)</ept> or <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Color<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/hh673723)</ept> resource.</target>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This abbreviated example uses initialization text to specify values for a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Thickness<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208864)</ept>, in this case specifying values that set both <bpt id="p3">**</bpt>Left<ept id="p3">**</ept> and <bpt id="p4">**</bpt>Right<ept id="p4">**</ept> to 20, and both <bpt id="p5">**</bpt>Top<ept id="p5">**</ept> and <bpt id="p6">**</bpt>Bottom<ept id="p6">**</ept> to 10.</source>
          <target state="new">This abbreviated example uses initialization text to specify values for a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Thickness<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208864)</ept>, in this case specifying values that set both <bpt id="p3">**</bpt>Left<ept id="p3">**</ept> and <bpt id="p4">**</bpt>Right<ept id="p4">**</ept> to 20, and both <bpt id="p5">**</bpt>Top<ept id="p5">**</ept> and <bpt id="p6">**</bpt>Bottom<ept id="p6">**</ept> to 10.</target>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>This example shows the <bpt id="p1">**</bpt>Thickness<ept id="p1">**</ept> created as a keyed resource, and then the reference to that resource.</source>
          <target state="new">This example shows the <bpt id="p1">**</bpt>Thickness<ept id="p1">**</ept> created as a keyed resource, and then the reference to that resource.</target>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source>For more info on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Thickness<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208864)</ept> initialization text, see <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Thickness<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208864)</ept>.</source>
          <target state="new">For more info on <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Thickness<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208864)</ept> initialization text, see <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Thickness<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208864)</ept>.</target>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Some structures can't be declared as object elements.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  Some structures can't be declared as object elements.</target>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Initialization text isn't supported and they can't be used as resources.</source>
          <target state="new">Initialization text isn't supported and they can't be used as resources.</target>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>You must use an attribute syntax in order to set properties to these values in XAML.</source>
          <target state="new">You must use an attribute syntax in order to set properties to these values in XAML.</target>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>These types are: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Duration<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242377)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>RepeatBehavior<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br210411)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Point<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br225870)</ept>, <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Rect<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/br225994)</ept> and <bpt id="p9">[</bpt><bpt id="p10">**</bpt>Size<ept id="p10">**</ept><ept id="p9">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept>.</source>
          <target state="new">These types are: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Duration<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242377)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>RepeatBehavior<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br210411)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Point<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br225870)</ept>, <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Rect<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/br225994)</ept> and <bpt id="p9">[</bpt><bpt id="p10">**</bpt>Size<ept id="p10">**</ept><ept id="p9">](https://msdn.microsoft.com/library/windows/apps/br225995)</ept>.</target>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve">
          <source>Setting properties</source>
          <target state="new">Setting properties</target>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>You can set properties on objects that you declared by using object element syntax.</source>
          <target state="new">You can set properties on objects that you declared by using object element syntax.</target>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>There are multiple ways to set properties in XAML:</source>
          <target state="new">There are multiple ways to set properties in XAML:</target>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>By using attribute syntax.</source>
          <target state="new">By using attribute syntax.</target>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>By using property element syntax.</source>
          <target state="new">By using property element syntax.</target>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>By using element syntax where the content (inner text or child elements) is setting the XAML content property of an object.</source>
          <target state="new">By using element syntax where the content (inner text or child elements) is setting the XAML content property of an object.</target>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source>By using a collection syntax (which is usually the implicit collection syntax).</source>
          <target state="new">By using a collection syntax (which is usually the implicit collection syntax).</target>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>As with object declaration, this list doesn't imply that any property could be set with each of the techniques.</source>
          <target state="new">As with object declaration, this list doesn't imply that any property could be set with each of the techniques.</target>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Some properties support only one of the techniques.</source>
          <target state="new">Some properties support only one of the techniques.</target>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>Some properties support more than one form; for example, there are properties that can use property element syntax, or attribute syntax.</source>
          <target state="new">Some properties support more than one form; for example, there are properties that can use property element syntax, or attribute syntax.</target>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>What's possible depends both on the property and on the object type that the property uses.</source>
          <target state="new">What's possible depends both on the property and on the object type that the property uses.</target>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>In the Windows Runtime API reference, you'll see the XAML usages you can use in the <bpt id="p1">**</bpt>Syntax<ept id="p1">**</ept> section.</source>
          <target state="new">In the Windows Runtime API reference, you'll see the XAML usages you can use in the <bpt id="p1">**</bpt>Syntax<ept id="p1">**</ept> section.</target>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Sometimes there is an alternative usage that would work but would be more verbose.</source>
          <target state="new">Sometimes there is an alternative usage that would work but would be more verbose.</target>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Those verbose usages aren't always shown because we are trying to show you the best practices or the real world scenarios for using that property in XAML.</source>
          <target state="new">Those verbose usages aren't always shown because we are trying to show you the best practices or the real world scenarios for using that property in XAML.</target>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve">
          <source>Guidance for XAML syntax is provided in the <bpt id="p1">**</bpt>XAML Usage<ept id="p1">**</ept> sections of reference pages for properties that can be set in XAML.</source>
          <target state="new">Guidance for XAML syntax is provided in the <bpt id="p1">**</bpt>XAML Usage<ept id="p1">**</ept> sections of reference pages for properties that can be set in XAML.</target>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Some properties on objects that cannot be set in XAML by any means, and can only be set using code.</source>
          <target state="new">Some properties on objects that cannot be set in XAML by any means, and can only be set using code.</target>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Usually these are properties that are more appropriate to work with in the code-behind, not in XAML.</source>
          <target state="new">Usually these are properties that are more appropriate to work with in the code-behind, not in XAML.</target>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>A read-only property cannot be set in XAML.</source>
          <target state="new">A read-only property cannot be set in XAML.</target>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve">
          <source>Even in code, the owning type would have to support some other way to set it, like a constructor overload, helper method, or calculated property support.</source>
          <target state="new">Even in code, the owning type would have to support some other way to set it, like a constructor overload, helper method, or calculated property support.</target>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve">
          <source>A calculated property relies on the values of other settable properties plus sometimes an event with built-in handling; these features are available in the dependency property system.</source>
          <target state="new">A calculated property relies on the values of other settable properties plus sometimes an event with built-in handling; these features are available in the dependency property system.</target>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve">
          <source>For more info on how dependency properties are useful for calculated property support, see <bpt id="p1">[</bpt>Dependency properties overview<ept id="p1">](dependency-properties-overview.md)</ept>.</source>
          <target state="new">For more info on how dependency properties are useful for calculated property support, see <bpt id="p1">[</bpt>Dependency properties overview<ept id="p1">](dependency-properties-overview.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Collection syntax in XAML gives an appearance that you are setting a read-only property, but in fact you are not.</source>
          <target state="new">Collection syntax in XAML gives an appearance that you are setting a read-only property, but in fact you are not.</target>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>See "Setting a Property by Using a Collection Syntax" section later in this topic.</source>
          <target state="new">See "Setting a Property by Using a Collection Syntax" section later in this topic.</target>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Setting a property by using attribute syntax</source>
          <target state="new">Setting a property by using attribute syntax</target>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve">
          <source>Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</source>
          <target state="new">Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</target>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>Setting XAML attributes is similar to how you set attribute values in XML.</source>
          <target state="new">Setting XAML attributes is similar to how you set attribute values in XML.</target>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>The attribute name is specified at any point within the tags following the element name, separated from element name by at least one whitespace.</source>
          <target state="new">The attribute name is specified at any point within the tags following the element name, separated from element name by at least one whitespace.</target>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve">
          <source>The attribute name is followed by an equals sign.</source>
          <target state="new">The attribute name is followed by an equals sign.</target>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve">
          <source>The attribute value is contained within a pair of quotes.</source>
          <target state="new">The attribute value is contained within a pair of quotes.</target>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve">
          <source>The quotes can be either double quotes or single quotes so long as they match and enclose the value.</source>
          <target state="new">The quotes can be either double quotes or single quotes so long as they match and enclose the value.</target>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The attribute value itself must be expressible as a string.</source>
          <target state="new">The attribute value itself must be expressible as a string.</target>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The string often contains numerals, but to XAML, all attribute values are string values until the XAML parser gets involved and does some basic value conversion.</source>
          <target state="new">The string often contains numerals, but to XAML, all attribute values are string values until the XAML parser gets involved and does some basic value conversion.</target>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>This example uses attribute syntax for four attributes to set the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Name<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208735)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Width<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Height<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208718)</ept>, and <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Fill<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/br243378)</ept> properties of a <bpt id="p9">[</bpt><bpt id="p10">**</bpt>Rectangle<ept id="p10">**</ept><ept id="p9">](https://msdn.microsoft.com/library/windows/apps/br243371)</ept> object.</source>
          <target state="new">This example uses attribute syntax for four attributes to set the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Name<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208735)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Width<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208751)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>Height<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br208718)</ept>, and <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Fill<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/br243378)</ept> properties of a <bpt id="p9">[</bpt><bpt id="p10">**</bpt>Rectangle<ept id="p10">**</ept><ept id="p9">](https://msdn.microsoft.com/library/windows/apps/br243371)</ept> object.</target>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>Setting a property by using property element syntax</source>
          <target state="new">Setting a property by using property element syntax</target>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Many properties of an object can be set by using property element syntax.</source>
          <target state="new">Many properties of an object can be set by using property element syntax.</target>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve">
          <source>A property element looks like this: <ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>object<ept id="p1">*</ept><ph id="ph2">`.`</ph><bpt id="p2">*</bpt>property<ept id="p2">*</ept><ph id="ph3">`&gt;`</ph>.</source>
          <target state="new">A property element looks like this: <ph id="ph1">`&lt;`</ph><bpt id="p1">*</bpt>object<ept id="p1">*</ept><ph id="ph2">`.`</ph><bpt id="p2">*</bpt>property<ept id="p2">*</ept><ph id="ph3">`&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve">
          <source>To use property element syntax, you create XAML property elements for the property that you want to set.</source>
          <target state="new">To use property element syntax, you create XAML property elements for the property that you want to set.</target>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve">
          <source>In standard XML, this element would just be considered an element that has a dot in its name.</source>
          <target state="new">In standard XML, this element would just be considered an element that has a dot in its name.</target>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve">
          <source>However, in XAML, the dot in the element name identifies the element as a property element, with <bpt id="p1">*</bpt>property<ept id="p1">*</ept> expected to a member of <bpt id="p2">*</bpt>object<ept id="p2">*</ept> in a backing object model implementation.</source>
          <target state="new">However, in XAML, the dot in the element name identifies the element as a property element, with <bpt id="p1">*</bpt>property<ept id="p1">*</ept> expected to a member of <bpt id="p2">*</bpt>object<ept id="p2">*</ept> in a backing object model implementation.</target>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>To use property element syntax, it must be possible to specify an object element in order to "fill" the property element tags.</source>
          <target state="new">To use property element syntax, it must be possible to specify an object element in order to "fill" the property element tags.</target>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>A property element will always have some content (single element, multiple elements, or inner text); there's no point in having a self-closing property element.</source>
          <target state="new">A property element will always have some content (single element, multiple elements, or inner text); there's no point in having a self-closing property element.</target>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>In the following grammar, <bpt id="p1">*</bpt>property<ept id="p1">*</ept> is the name of the property that you want to set and <bpt id="p2">*</bpt>propertyValueAsObjectElement<ept id="p2">*</ept> is a single object element, that's expected to satisfy the value type requirements of the property.</source>
          <target state="new">In the following grammar, <bpt id="p1">*</bpt>property<ept id="p1">*</ept> is the name of the property that you want to set and <bpt id="p2">*</bpt>propertyValueAsObjectElement<ept id="p2">*</ept> is a single object element, that's expected to satisfy the value type requirements of the property.</target>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="new">object</target>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>object<ept id="p1">*</ept><ph id="ph1">`.`</ph><bpt id="p2">*</bpt>property<ept id="p2">*</ept></source>
          <target state="new"><bpt id="p1">*</bpt>object<ept id="p1">*</ept><ph id="ph1">`.`</ph><bpt id="p2">*</bpt>property<ept id="p2">*</ept></target>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>propertyValueAsObjectElement</source>
          <target state="new">propertyValueAsObjectElement</target>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>object<ept id="p1">*</ept><ph id="ph1">`.`</ph><bpt id="p2">*</bpt>property<ept id="p2">*</ept></source>
          <target state="new"><bpt id="p1">*</bpt>object<ept id="p1">*</ept><ph id="ph1">`.`</ph><bpt id="p2">*</bpt>property<ept id="p2">*</ept></target>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>object</source>
          <target state="new">object</target>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>The following example uses property element syntax to set the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Fill<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br243378)</ept> of a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Rectangle<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br243371)</ept> with a <bpt id="p5">[</bpt><bpt id="p6">**</bpt>SolidColorBrush<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br242962)</ept> object element.</source>
          <target state="new">The following example uses property element syntax to set the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Fill<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br243378)</ept> of a <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Rectangle<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br243371)</ept> with a <bpt id="p5">[</bpt><bpt id="p6">**</bpt>SolidColorBrush<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br242962)</ept> object element.</target>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>(Within the <bpt id="p1">**</bpt>SolidColorBrush<ept id="p1">**</ept>, <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Color<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br242963)</ept> is set as an attribute.) The parsed result of this XAML is identical to the previous XAML example that set <bpt id="p4">**</bpt>Fill<ept id="p4">**</ept> using attribute syntax.</source>
          <target state="new">(Within the <bpt id="p1">**</bpt>SolidColorBrush<ept id="p1">**</ept>, <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Color<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br242963)</ept> is set as an attribute.) The parsed result of this XAML is identical to the previous XAML example that set <bpt id="p4">**</bpt>Fill<ept id="p4">**</ept> using attribute syntax.</target>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>XAML vocabularies and object-oriented programming</source>
          <target state="new">XAML vocabularies and object-oriented programming</target>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Properties and events as they appear as XAML members of a Windows Runtime XAML type are often inherited from base types.</source>
          <target state="new">Properties and events as they appear as XAML members of a Windows Runtime XAML type are often inherited from base types.</target>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>Consider this example: <ph id="ph1">`&lt;Button Background="Blue" .../&gt;`</ph>.</source>
          <target state="new">Consider this example: <ph id="ph1">`&lt;Button Background="Blue" .../&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Background<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209395)</ept> property is not an immediately declared property on the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Button<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> class.</source>
          <target state="new">The <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Background<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209395)</ept> property is not an immediately declared property on the <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Button<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209265)</ept> class.</target>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Instead, <bpt id="p1">**</bpt>Background<ept id="p1">**</ept> is inherited from the base <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Control<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br209390)</ept> class.</source>
          <target state="new">Instead, <bpt id="p1">**</bpt>Background<ept id="p1">**</ept> is inherited from the base <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Control<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br209390)</ept> class.</target>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>In fact, if you look at the reference topic for <bpt id="p1">**</bpt>Button<ept id="p1">**</ept> you'll see that the members lists contain at least one inherited member from each of a chain of successive base classes: <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ButtonBase<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br227736)</ept>, <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Control<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br209390)</ept>, <bpt id="p6">[</bpt><bpt id="p7">**</bpt>FrameworkElement<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept>, <bpt id="p8">[</bpt><bpt id="p9">**</bpt>UIElement<ept id="p9">**</ept><ept id="p8">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept>, <bpt id="p10">[</bpt><bpt id="p11">**</bpt>DependencyObject<ept id="p11">**</ept><ept id="p10">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>.</source>
          <target state="new">In fact, if you look at the reference topic for <bpt id="p1">**</bpt>Button<ept id="p1">**</ept> you'll see that the members lists contain at least one inherited member from each of a chain of successive base classes: <bpt id="p2">[</bpt><bpt id="p3">**</bpt>ButtonBase<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br227736)</ept>, <bpt id="p4">[</bpt><bpt id="p5">**</bpt>Control<ept id="p5">**</ept><ept id="p4">](https://msdn.microsoft.com/library/windows/apps/br209390)</ept>, <bpt id="p6">[</bpt><bpt id="p7">**</bpt>FrameworkElement<ept id="p7">**</ept><ept id="p6">](https://msdn.microsoft.com/library/windows/apps/br208706)</ept>, <bpt id="p8">[</bpt><bpt id="p9">**</bpt>UIElement<ept id="p9">**</ept><ept id="p8">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept>, <bpt id="p10">[</bpt><bpt id="p11">**</bpt>DependencyObject<ept id="p11">**</ept><ept id="p10">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>.</target>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> list, all the read-write properties and collection properties are inherited in a XAML vocabulary sense.</source>
          <target state="new">In the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> list, all the read-write properties and collection properties are inherited in a XAML vocabulary sense.</target>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Events (like the various <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElement<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> events) are inherited too.</source>
          <target state="new">Events (like the various <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElement<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> events) are inherited too.</target>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>If you use the Windows Runtime reference for XAML guidance, the element name that's shown in a syntax or even in example code is sometimes for the type that originally defines the property, because that reference topic is shared by all the possible types that inherit it from a base class.</source>
          <target state="new">If you use the Windows Runtime reference for XAML guidance, the element name that's shown in a syntax or even in example code is sometimes for the type that originally defines the property, because that reference topic is shared by all the possible types that inherit it from a base class.</target>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>If you use Visual Studio's IntelliSense for XAML in the XML editor, the IntelliSense and its drop-downs do a great job of coalescing the inheritance and providing an accurate list of attributes that are available for setting once you've started with an object element for a class instance.</source>
          <target state="new">If you use Visual Studio's IntelliSense for XAML in the XML editor, the IntelliSense and its drop-downs do a great job of coalescing the inheritance and providing an accurate list of attributes that are available for setting once you've started with an object element for a class instance.</target>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>XAML content properties</source>
          <target state="new">XAML content properties</target>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>Some types define one of their properties such that the property enables a XAML content syntax.</source>
          <target state="new">Some types define one of their properties such that the property enables a XAML content syntax.</target>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>For the XAML content property of a type, you can omit the property element for that property when specifying it in XAML.</source>
          <target state="new">For the XAML content property of a type, you can omit the property element for that property when specifying it in XAML.</target>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>Or, you can set the property to an inner text value by providing that inner text directly within the owning type's object element tags.</source>
          <target state="new">Or, you can set the property to an inner text value by providing that inner text directly within the owning type's object element tags.</target>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>XAML content properties support straightforward markup syntax for that property and makes the XAML more human-readable by reducing the nesting.</source>
          <target state="new">XAML content properties support straightforward markup syntax for that property and makes the XAML more human-readable by reducing the nesting.</target>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>If a XAML content syntax is available, that syntax will be shown in the "XAML" sections of <bpt id="p1">**</bpt>Syntax<ept id="p1">**</ept> for that property in the Windows Runtime reference documentation.</source>
          <target state="new">If a XAML content syntax is available, that syntax will be shown in the "XAML" sections of <bpt id="p1">**</bpt>Syntax<ept id="p1">**</ept> for that property in the Windows Runtime reference documentation.</target>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Child<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209258)</ept> property page for <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Border<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209250)</ept> shows XAML content syntax instead of property element syntax to set the single-object <bpt id="p5">**</bpt>Border.Child<ept id="p5">**</ept> value of a <bpt id="p6">**</bpt>Border<ept id="p6">**</ept>, like this:</source>
          <target state="new">For example, the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Child<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209258)</ept> property page for <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Border<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209250)</ept> shows XAML content syntax instead of property element syntax to set the single-object <bpt id="p5">**</bpt>Border.Child<ept id="p5">**</ept> value of a <bpt id="p6">**</bpt>Border<ept id="p6">**</ept>, like this:</target>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>If the property that is declared as the XAML content property is the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> type, or is type <bpt id="p2">**</bpt>String<ept id="p2">**</ept>, then the XAML content syntax supports what's basically inner text in the XML document model: a string between the opening and closing object tags.</source>
          <target state="new">If the property that is declared as the XAML content property is the <bpt id="p1">**</bpt>Object<ept id="p1">**</ept> type, or is type <bpt id="p2">**</bpt>String<ept id="p2">**</ept>, then the XAML content syntax supports what's basically inner text in the XML document model: a string between the opening and closing object tags.</target>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Text<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209676)</ept> property page for <bpt id="p3">[</bpt><bpt id="p4">**</bpt>TextBlock<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209652)</ept> shows XAML content syntax that has an inner text value to set <bpt id="p5">**</bpt>Text<ept id="p5">**</ept>, but the string "Text" never appears in the markup.</source>
          <target state="new">For example, the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Text<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209676)</ept> property page for <bpt id="p3">[</bpt><bpt id="p4">**</bpt>TextBlock<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209652)</ept> shows XAML content syntax that has an inner text value to set <bpt id="p5">**</bpt>Text<ept id="p5">**</ept>, but the string "Text" never appears in the markup.</target>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>Here's an example usage:</source>
          <target state="new">Here's an example usage:</target>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>If a XAML content property exists for a class, that's indicated in the reference topic for the class, in the "Attributes" section.</source>
          <target state="new">If a XAML content property exists for a class, that's indicated in the reference topic for the class, in the "Attributes" section.</target>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve">
          <source>Look for the value of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ContentPropertyAttribute<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228011)</ept>.</source>
          <target state="new">Look for the value of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ContentPropertyAttribute<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228011)</ept>.</target>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>This attribute uses a named field "Name".</source>
          <target state="new">This attribute uses a named field "Name".</target>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The value of "Name" is the name of the property of that class that is the XAML content property.</source>
          <target state="new">The value of "Name" is the name of the property of that class that is the XAML content property.</target>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>For example, on the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Border<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209250)</ept> reference page, you'll see this: ContentProperty("Name=Child").</source>
          <target state="new">For example, on the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Border<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209250)</ept> reference page, you'll see this: ContentProperty("Name=Child").</target>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>One important XAML syntax rule we should mention is that you can't intermix the XAML content property and other property elements you set on the element.</source>
          <target state="new">One important XAML syntax rule we should mention is that you can't intermix the XAML content property and other property elements you set on the element.</target>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The XAML content property must be set entirely before any property elements, or entirely after.</source>
          <target state="new">The XAML content property must be set entirely before any property elements, or entirely after.</target>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>For example this is invalid XAML:</source>
          <target state="new">For example this is invalid XAML:</target>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source>Collection syntax</source>
          <target state="new">Collection syntax</target>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>All of the syntaxes shown thus far are setting properties to single objects.</source>
          <target state="new">All of the syntaxes shown thus far are setting properties to single objects.</target>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source>But many UI scenarios require that a given parent element can have multiple child elements.</source>
          <target state="new">But many UI scenarios require that a given parent element can have multiple child elements.</target>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source>For example, a UI for an input form needs several text box elements, some labels, and perhaps a "Submit" button.</source>
          <target state="new">For example, a UI for an input form needs several text box elements, some labels, and perhaps a "Submit" button.</target>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>Still, if you were to use a programming object model to access these multiple elements, they would typically be items in a single collection property, rather than each item being the value of different properties.</source>
          <target state="new">Still, if you were to use a programming object model to access these multiple elements, they would typically be items in a single collection property, rather than each item being the value of different properties.</target>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>XAML supports multiple child elements as well as supporting a typical backing collection model by treating properties that use a collection type as implicit, and performing special handling for any child elements of a collection type.</source>
          <target state="new">XAML supports multiple child elements as well as supporting a typical backing collection model by treating properties that use a collection type as implicit, and performing special handling for any child elements of a collection type.</target>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>Many collection properties are also identified as the XAML content property for the class.</source>
          <target state="new">Many collection properties are also identified as the XAML content property for the class.</target>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>The combination of implicit collection processing and XAML content syntax is frequently seen in types used for control compositing, such as panels, views, or items controls.</source>
          <target state="new">The combination of implicit collection processing and XAML content syntax is frequently seen in types used for control compositing, such as panels, views, or items controls.</target>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>For example, the following examples show the simplest possible XAML for compositing two peer UI elements within a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>StackPanel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209635)</ept>.</source>
          <target state="new">For example, the following examples show the simplest possible XAML for compositing two peer UI elements within a <bpt id="p1">[</bpt><bpt id="p2">**</bpt>StackPanel<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209635)</ept>.</target>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>The mechanism of XAML collection syntax</source>
          <target state="new">The mechanism of XAML collection syntax</target>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>It might at first appear that XAML is enabling a "set" of the read-only collection property.</source>
          <target state="new">It might at first appear that XAML is enabling a "set" of the read-only collection property.</target>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>In reality, what XAML enables here is adding items to an existing collection.</source>
          <target state="new">In reality, what XAML enables here is adding items to an existing collection.</target>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The XAML language and XAML processors implementing XAML support rely on a convention in backing collection types to enable this syntax.</source>
          <target state="new">The XAML language and XAML processors implementing XAML support rely on a convention in backing collection types to enable this syntax.</target>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>Typically there is a backing property such as an indexer or <bpt id="p1">**</bpt>Items<ept id="p1">**</ept> property that refers to specific items of the collection.</source>
          <target state="new">Typically there is a backing property such as an indexer or <bpt id="p1">**</bpt>Items<ept id="p1">**</ept> property that refers to specific items of the collection.</target>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>Generally, that property is not explicit in the XAML syntax.</source>
          <target state="new">Generally, that property is not explicit in the XAML syntax.</target>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>For collections, the underlying mechanism for XAML parsing is not a property, but a method: specifically, the <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> method in most cases.</source>
          <target state="new">For collections, the underlying mechanism for XAML parsing is not a property, but a method: specifically, the <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> method in most cases.</target>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>When the XAML processor encounters one or more object elements within a XAML collection syntax, each such object is first created from an element, then each new object is added in order to the containing collection by calling the collection's <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> method.</source>
          <target state="new">When the XAML processor encounters one or more object elements within a XAML collection syntax, each such object is first created from an element, then each new object is added in order to the containing collection by calling the collection's <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> method.</target>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>When a XAML parser adds items to a collection, it is the logic of the <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> method that determines whether a given XAML element is a permissible item child of the collection object.</source>
          <target state="new">When a XAML parser adds items to a collection, it is the logic of the <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> method that determines whether a given XAML element is a permissible item child of the collection object.</target>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>Many collection types are strongly typed by the backing implementation, meaning that the input parameter of <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> expects that whatever is passed must be a type match with the <bpt id="p2">**</bpt>Add<ept id="p2">**</ept> parameter type.</source>
          <target state="new">Many collection types are strongly typed by the backing implementation, meaning that the input parameter of <bpt id="p1">**</bpt>Add<ept id="p1">**</ept> expects that whatever is passed must be a type match with the <bpt id="p2">**</bpt>Add<ept id="p2">**</ept> parameter type.</target>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>For collection properties, be careful about when you try to specify the collection explicitly as an object element.</source>
          <target state="new">For collection properties, be careful about when you try to specify the collection explicitly as an object element.</target>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>A XAML parser will create a new object whenever it encounters an object element.</source>
          <target state="new">A XAML parser will create a new object whenever it encounters an object element.</target>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>If the collection property you're trying to use is read-only, this can throw a XAML parse exception.</source>
          <target state="new">If the collection property you're trying to use is read-only, this can throw a XAML parse exception.</target>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Just use the implicit collection syntax, and you won't see that exception.</source>
          <target state="new">Just use the implicit collection syntax, and you won't see that exception.</target>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>When to use attribute or property element syntax</source>
          <target state="new">When to use attribute or property element syntax</target>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>All properties that support being set in XAML will support attribute or property element syntax for direct value setting, but potentially will not support either syntax interchangeably.</source>
          <target state="new">All properties that support being set in XAML will support attribute or property element syntax for direct value setting, but potentially will not support either syntax interchangeably.</target>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>Some properties do support either syntax, and some properties support additional syntax options like a XAML content property.</source>
          <target state="new">Some properties do support either syntax, and some properties support additional syntax options like a XAML content property.</target>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The type of XAML syntax supported by a property depends on the type of object that the property uses as its property type.</source>
          <target state="new">The type of XAML syntax supported by a property depends on the type of object that the property uses as its property type.</target>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>If the property type is a primitive type, such as a double (float or decimal), integer, Boolean, or string, the property always supports attribute syntax.</source>
          <target state="new">If the property type is a primitive type, such as a double (float or decimal), integer, Boolean, or string, the property always supports attribute syntax.</target>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>You can also use attribute syntax to set a property if the object type you use to set that property can be created by processing a string.</source>
          <target state="new">You can also use attribute syntax to set a property if the object type you use to set that property can be created by processing a string.</target>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>For primitives, this is always the case, the type conversion is built in to the parser.</source>
          <target state="new">For primitives, this is always the case, the type conversion is built in to the parser.</target>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>However, certain other object types can also be created by using a string specified as an attribute value, rather than an object element within a property element.</source>
          <target state="new">However, certain other object types can also be created by using a string specified as an attribute value, rather than an object element within a property element.</target>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>For this to work, there has to be an underlying type conversion, supported either by that particular property or supported generally for all values that use that property type.</source>
          <target state="new">For this to work, there has to be an underlying type conversion, supported either by that particular property or supported generally for all values that use that property type.</target>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>The string value of the attribute is used to set properties that are important for the initialization of the new object value.</source>
          <target state="new">The string value of the attribute is used to set properties that are important for the initialization of the new object value.</target>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>Potentially, a specific type converter can also create different subclasses of a common property type, depending on how it uniquely processes information in the string.</source>
          <target state="new">Potentially, a specific type converter can also create different subclasses of a common property type, depending on how it uniquely processes information in the string.</target>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>Object types that support this behavior will have a special grammar listed in the syntax section of the reference documentation.</source>
          <target state="new">Object types that support this behavior will have a special grammar listed in the syntax section of the reference documentation.</target>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>As an example, the XAML syntax for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Brush<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228076)</ept> shows how an attribute syntax can be used to create a new <bpt id="p3">[</bpt><bpt id="p4">**</bpt>SolidColorBrush<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br242962)</ept> value for any property of type <bpt id="p5">**</bpt>Brush<ept id="p5">**</ept> (and there are many <bpt id="p6">**</bpt>Brush<ept id="p6">**</ept> properties in Windows Runtime XAML).</source>
          <target state="new">As an example, the XAML syntax for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Brush<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br228076)</ept> shows how an attribute syntax can be used to create a new <bpt id="p3">[</bpt><bpt id="p4">**</bpt>SolidColorBrush<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br242962)</ept> value for any property of type <bpt id="p5">**</bpt>Brush<ept id="p5">**</ept> (and there are many <bpt id="p6">**</bpt>Brush<ept id="p6">**</ept> properties in Windows Runtime XAML).</target>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source>XAML parsing logic and rules</source>
          <target state="new">XAML parsing logic and rules</target>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Sometime's it's informative to read the XAML in a similar way to how a XAML parser must read it: as a set of string tokens encountered in a linear order.</source>
          <target state="new">Sometime's it's informative to read the XAML in a similar way to how a XAML parser must read it: as a set of string tokens encountered in a linear order.</target>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve">
          <source>A XAML parser must interpret these tokens under a set of rules that are part of the definition of how XAML works.</source>
          <target state="new">A XAML parser must interpret these tokens under a set of rules that are part of the definition of how XAML works.</target>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source>Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</source>
          <target state="new">Setting an attribute value is the typical means by which you set a property value in a markup language, for example in XML or HTML.</target>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>In the following syntax, <bpt id="p1">*</bpt>objectName<ept id="p1">*</ept> is the object you want to instantiate, <bpt id="p2">*</bpt>propertyName<ept id="p2">*</ept> is the name of the property that you want to set on that object, and <bpt id="p3">*</bpt>propertyValue<ept id="p3">*</ept> is the value to set.</source>
          <target state="new">In the following syntax, <bpt id="p1">*</bpt>objectName<ept id="p1">*</ept> is the object you want to instantiate, <bpt id="p2">*</bpt>propertyName<ept id="p2">*</ept> is the name of the property that you want to set on that object, and <bpt id="p3">*</bpt>propertyValue<ept id="p3">*</ept> is the value to set.</target>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>Either syntax enables you to declare an object and set a property on that object.</source>
          <target state="new">Either syntax enables you to declare an object and set a property on that object.</target>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>Although the first example is a single element in markup, there are actually discrete steps here with regard to how a XAML processor parses this markup.</source>
          <target state="new">Although the first example is a single element in markup, there are actually discrete steps here with regard to how a XAML processor parses this markup.</target>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>First, the presence of the object element indicates that a new <bpt id="p1">*</bpt>objectName<ept id="p1">*</ept> object must be instantiated.</source>
          <target state="new">First, the presence of the object element indicates that a new <bpt id="p1">*</bpt>objectName<ept id="p1">*</ept> object must be instantiated.</target>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source>Only after such an instance exists can the instance property <bpt id="p1">*</bpt>propertyName<ept id="p1">*</ept> can be set on it.</source>
          <target state="new">Only after such an instance exists can the instance property <bpt id="p1">*</bpt>propertyName<ept id="p1">*</ept> can be set on it.</target>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source>Another rule of XAML is that attributes of an element must be able to be set in any order.</source>
          <target state="new">Another rule of XAML is that attributes of an element must be able to be set in any order.</target>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>For example, there's no difference between <ph id="ph1">`&lt;Rectangle Height="50" Width="100" /&gt;`</ph> and <ph id="ph2">`&lt;Rectangle Width="100"  Height="50" /&gt;`</ph>.</source>
          <target state="new">For example, there's no difference between <ph id="ph1">`&lt;Rectangle Height="50" Width="100" /&gt;`</ph> and <ph id="ph2">`&lt;Rectangle Width="100"  Height="50" /&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Which order you use is a matter of style.</source>
          <target state="new">Which order you use is a matter of style.</target>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  XAML designers often promote ordering conventions if you use design surfaces other than the XML editor, but you can freely edit that XAML later, to reorder the attributes or introduce new ones.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  XAML designers often promote ordering conventions if you use design surfaces other than the XML editor, but you can freely edit that XAML later, to reorder the attributes or introduce new ones.</target>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source>Attached properties</source>
          <target state="new">Attached properties</target>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>XAML extends XML by adding a syntax element known as an <bpt id="p1">*</bpt>attached property<ept id="p1">*</ept>.</source>
          <target state="new">XAML extends XML by adding a syntax element known as an <bpt id="p1">*</bpt>attached property<ept id="p1">*</ept>.</target>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>Similar to the property element syntax, the attached property syntax contains a dot, and the dot holds special meaning to XAML parsing.</source>
          <target state="new">Similar to the property element syntax, the attached property syntax contains a dot, and the dot holds special meaning to XAML parsing.</target>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>Specifically, the dot separates the owner provider of the attached property, and the property name.</source>
          <target state="new">Specifically, the dot separates the owner provider of the attached property, and the property name.</target>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>In XAML, you set attached properties by using the syntax <bpt id="p1">*</bpt>AttachedPropertyProvider<ept id="p1">*</ept>.<bpt id="p2">*</bpt>PropertyName<ept id="p2">*</ept> Here is an example of how you can set the attached property <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Canvas.Left<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh759771)</ept> in XAML:</source>
          <target state="new">In XAML, you set attached properties by using the syntax <bpt id="p1">*</bpt>AttachedPropertyProvider<ept id="p1">*</ept>.<bpt id="p2">*</bpt>PropertyName<ept id="p2">*</ept> Here is an example of how you can set the attached property <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Canvas.Left<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/hh759771)</ept> in XAML:</target>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>You can set the attached property on elements that don't have a property of that name in the backing type, and in that way they function somewhat like a global property, or an attribute defined by a different XML namespace like the <bpt id="p1">**</bpt>xml:space<ept id="p1">**</ept> attribute.</source>
          <target state="new">You can set the attached property on elements that don't have a property of that name in the backing type, and in that way they function somewhat like a global property, or an attribute defined by a different XML namespace like the <bpt id="p1">**</bpt>xml:space<ept id="p1">**</ept> attribute.</target>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>In Windows Runtime XAML you'll see attached properties that support these scenarios:</source>
          <target state="new">In Windows Runtime XAML you'll see attached properties that support these scenarios:</target>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source>Child elements can inform parent container panels how they should behave in layout: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Grid<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br242704)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>VariableSizedWrapGrid<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br227651)</ept>.</source>
          <target state="new">Child elements can inform parent container panels how they should behave in layout: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Canvas<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209267)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Grid<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br242704)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>VariableSizedWrapGrid<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br227651)</ept>.</target>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source>Control usages can influence behavior of an important control part that comes from the control template: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ScrollViewer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209527)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>VirtualizingStackPanel<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227689)</ept>.</source>
          <target state="new">Control usages can influence behavior of an important control part that comes from the control template: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ScrollViewer<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209527)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>VirtualizingStackPanel<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227689)</ept>.</target>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Using a service that's available in a related class, where the service and the class that uses it don't share inheritance: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Typography<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh702143)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>VisualStateManager<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209021)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>AutomationProperties<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br209081)</ept>, <bpt id="p7">[</bpt><bpt id="p8">**</bpt>ToolTipService<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/br227609)</ept>.</source>
          <target state="new">Using a service that's available in a related class, where the service and the class that uses it don't share inheritance: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Typography<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/hh702143)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>VisualStateManager<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br209021)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>AutomationProperties<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br209081)</ept>, <bpt id="p7">[</bpt><bpt id="p8">**</bpt>ToolTipService<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/br227609)</ept>.</target>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source>Animation targeting: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Storyboard<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br210490)</ept>.</source>
          <target state="new">Animation targeting: <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Storyboard<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br210490)</ept>.</target>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>For more info, see <bpt id="p1">[</bpt>Attached properties overview<ept id="p1">](attached-properties-overview.md)</ept>.</source>
          <target state="new">For more info, see <bpt id="p1">[</bpt>Attached properties overview<ept id="p1">](attached-properties-overview.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source>Literal "{" values</source>
          <target state="new">Literal "{" values</target>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source>Because the opening brace symbol \{ is the opening of the markup extension sequence, you use an escape sequence to specify a literal string value that starts with "\{".</source>
          <target state="new">Because the opening brace symbol \{ is the opening of the markup extension sequence, you use an escape sequence to specify a literal string value that starts with "\{".</target>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>The escape sequence is "\{\}".</source>
          <target state="new">The escape sequence is "\{\}".</target>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>For example, to specify a string value that is a single opening brace, specify the attribute value as "\{\}\{".</source>
          <target state="new">For example, to specify a string value that is a single opening brace, specify the attribute value as "\{\}\{".</target>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>You can also use the alternative quotation marks (for example, a <bpt id="p1">**</bpt>'<ept id="p1">**</ept> within an attribute value delimited by <bpt id="p2">**</bpt>""<ept id="p2">**</ept>) to provide a "\{" value as a string.</source>
          <target state="new">You can also use the alternative quotation marks (for example, a <bpt id="p1">**</bpt>'<ept id="p1">**</ept> within an attribute value delimited by <bpt id="p2">**</bpt>""<ept id="p2">**</ept>) to provide a "\{" value as a string.</target>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  "\\}" also works if it's inside a quoted attribute.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  "\\}" also works if it's inside a quoted attribute.</target>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve">
          <source>Enumeration values</source>
          <target state="new">Enumeration values</target>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve">
          <source>Many properties in the Windows Runtime API use enumerations as values.</source>
          <target state="new">Many properties in the Windows Runtime API use enumerations as values.</target>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>If the member is a read-write property you can set such a property by providing an attribute value.</source>
          <target state="new">If the member is a read-write property you can set such a property by providing an attribute value.</target>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>You identify which enumeration value to use as the value of the property by using the unqualified name of the constant name .</source>
          <target state="new">You identify which enumeration value to use as the value of the property by using the unqualified name of the constant name .</target>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source>For example here's how to set <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElement.Visibility<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208992)</ept> in XAML: <ph id="ph1">`&lt;Button Visibility="Visible"/&gt;`</ph>.</source>
          <target state="new">For example here's how to set <bpt id="p1">[</bpt><bpt id="p2">**</bpt>UIElement.Visibility<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208992)</ept> in XAML: <ph id="ph1">`&lt;Button Visibility="Visible"/&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>Here the "Visible" as a string is directly mapped to a named constant of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Visibility<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209006)</ept> enumeration, <bpt id="p3">**</bpt>Visible<ept id="p3">**</ept>.</source>
          <target state="new">Here the "Visible" as a string is directly mapped to a named constant of the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Visibility<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br209006)</ept> enumeration, <bpt id="p3">**</bpt>Visible<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Don't use a qualified form, it won't work.</source>
          <target state="new">Don't use a qualified form, it won't work.</target>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve">
          <source>For example, this is invalid XAML: <ph id="ph1">`&lt;Button Visibility="Visibility.Visible"/&gt;`</ph>.</source>
          <target state="new">For example, this is invalid XAML: <ph id="ph1">`&lt;Button Visibility="Visibility.Visible"/&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve">
          <source>Don't use the value of the constant.</source>
          <target state="new">Don't use the value of the constant.</target>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>In other words, don't rely on the integer value of the enumeration that's there explicitly or implicitly depending on how the enumeration was defined.</source>
          <target state="new">In other words, don't rely on the integer value of the enumeration that's there explicitly or implicitly depending on how the enumeration was defined.</target>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve">
          <source>Although it might appear to work, it's a bad practice either in XAML or in code because you're relying on what could be a transient implementation detail.</source>
          <target state="new">Although it might appear to work, it's a bad practice either in XAML or in code because you're relying on what could be a transient implementation detail.</target>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve">
          <source>For example, don't do this: <ph id="ph1">`&lt;Button Visibility="1"/&gt;`</ph>.</source>
          <target state="new">For example, don't do this: <ph id="ph1">`&lt;Button Visibility="1"/&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  In reference topics for APIs that use XAML and use enumerations, click the link to the enumeration type in the <bpt id="p2">**</bpt>Property value<ept id="p2">**</ept> section of <bpt id="p3">**</bpt>Syntax<ept id="p3">**</ept>.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  In reference topics for APIs that use XAML and use enumerations, click the link to the enumeration type in the <bpt id="p2">**</bpt>Property value<ept id="p2">**</ept> section of <bpt id="p3">**</bpt>Syntax<ept id="p3">**</ept>.</target>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>This links to the enumeration page where you can discover the named constants for that enumeration.</source>
          <target state="new">This links to the enumeration page where you can discover the named constants for that enumeration.</target>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Enumerations can be flagwise, meaning that they are attributed with <bpt id="p1">**</bpt>FlagsAttribute<ept id="p1">**</ept>.</source>
          <target state="new">Enumerations can be flagwise, meaning that they are attributed with <bpt id="p1">**</bpt>FlagsAttribute<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve">
          <source>If you need to specify a combination of values for a flagwise enumeration as a XAML attribute value, use the name of each enumeration constant, with a comma (,) between each name, and no intervening space characters.</source>
          <target state="new">If you need to specify a combination of values for a flagwise enumeration as a XAML attribute value, use the name of each enumeration constant, with a comma (,) between each name, and no intervening space characters.</target>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve">
          <source>Flagwise attributes aren't common in the Windows Runtime XAML vocabulary, but <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ManipulationModes<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227934)</ept> is an example where setting a flagwise enumeration value in XAML is supported.</source>
          <target state="new">Flagwise attributes aren't common in the Windows Runtime XAML vocabulary, but <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ManipulationModes<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227934)</ept> is an example where setting a flagwise enumeration value in XAML is supported.</target>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>Interfaces in XAML</source>
          <target state="new">Interfaces in XAML</target>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source>In rare cases you'll see a XAML syntax where the type of a property is an interface.</source>
          <target state="new">In rare cases you'll see a XAML syntax where the type of a property is an interface.</target>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source>In the XAML type system, a type that implements that interface is acceptable as a value when parsed.</source>
          <target state="new">In the XAML type system, a type that implements that interface is acceptable as a value when parsed.</target>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>There must be a created instance of such a type available to serve as the value.</source>
          <target state="new">There must be a created instance of such a type available to serve as the value.</target>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve">
          <source>You'll see an interface used as a type in the XAML syntax for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Command<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227740)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>CommandParameter<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227741)</ept> properties of <bpt id="p5">[</bpt><bpt id="p6">**</bpt>ButtonBase<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br227736)</ept>.</source>
          <target state="new">You'll see an interface used as a type in the XAML syntax for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Command<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br227740)</ept> and <bpt id="p3">[</bpt><bpt id="p4">**</bpt>CommandParameter<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br227741)</ept> properties of <bpt id="p5">[</bpt><bpt id="p6">**</bpt>ButtonBase<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/br227736)</ept>.</target>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve">
          <source>These properties support Model-View-ViewModel (MVVM) design patterns where the <bpt id="p1">**</bpt>ICommand<ept id="p1">**</ept> interface is the contract for how the views and models interact.</source>
          <target state="new">These properties support Model-View-ViewModel (MVVM) design patterns where the <bpt id="p1">**</bpt>ICommand<ept id="p1">**</ept> interface is the contract for how the views and models interact.</target>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve">
          <source>XAML placeholder conventions in Windows Runtime reference</source>
          <target state="new">XAML placeholder conventions in Windows Runtime reference</target>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve">
          <source>If you've examined any of the <bpt id="p1">**</bpt>Syntax<ept id="p1">**</ept> section of reference topics for Windows Runtime APIs that can use XAML, you've probably seen that the syntax includes quite a few placeholders.</source>
          <target state="new">If you've examined any of the <bpt id="p1">**</bpt>Syntax<ept id="p1">**</ept> section of reference topics for Windows Runtime APIs that can use XAML, you've probably seen that the syntax includes quite a few placeholders.</target>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source>XAML syntax is different than the C#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) syntax because the XAML syntax is a usage syntax.</source>
          <target state="new">XAML syntax is different than the C#, Microsoft Visual Basic or Visual C++ component extensions (C++/CX) syntax because the XAML syntax is a usage syntax.</target>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>It's hinting at your eventual usage in your own XAML files, but without being over-prescriptive about the values you can use.</source>
          <target state="new">It's hinting at your eventual usage in your own XAML files, but without being over-prescriptive about the values you can use.</target>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve">
          <source>So usually the usage describes a type of grammar that mixes literals and placeholders, and defines some of the placeholders in the <bpt id="p1">**</bpt>XAML Values<ept id="p1">**</ept> section.</source>
          <target state="new">So usually the usage describes a type of grammar that mixes literals and placeholders, and defines some of the placeholders in the <bpt id="p1">**</bpt>XAML Values<ept id="p1">**</ept> section.</target>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>When you see type names / element names in a XAML syntax for a property, the name that's shown is for the type that originally defines the property.</source>
          <target state="new">When you see type names / element names in a XAML syntax for a property, the name that's shown is for the type that originally defines the property.</target>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>But Windows Runtime XAML supports a class inheritance model for the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DependencyObject<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>-based classes.</source>
          <target state="new">But Windows Runtime XAML supports a class inheritance model for the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>DependencyObject<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br242356)</ept>-based classes.</target>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source>So you can often use an attribute on a class that's not literally the defining class, but instead derives from a class that first defined the property/attribute.</source>
          <target state="new">So you can often use an attribute on a class that's not literally the defining class, but instead derives from a class that first defined the property/attribute.</target>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>For example, you can set <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Visibility<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208992)</ept> as an attribute on any <bpt id="p3">[</bpt><bpt id="p4">**</bpt>UIElement<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> derived class using a deep inheritance.</source>
          <target state="new">For example, you can set <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Visibility<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208992)</ept> as an attribute on any <bpt id="p3">[</bpt><bpt id="p4">**</bpt>UIElement<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/br208911)</ept> derived class using a deep inheritance.</target>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve">
          <source>For example: <ph id="ph1">`&lt;Button Visibility="Visible" /&gt;`</ph>.</source>
          <target state="new">For example: <ph id="ph1">`&lt;Button Visibility="Visible" /&gt;`</ph>.</target>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve">
          <source>So don't take the element name shown in any XAML usage syntax too literally; the syntax may be viable for elements representing that class, and also elements that represent a derived class.</source>
          <target state="new">So don't take the element name shown in any XAML usage syntax too literally; the syntax may be viable for elements representing that class, and also elements that represent a derived class.</target>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve">
          <source>In cases where it's rare or impossible for the type shown as the defining element to be in a real-world usage, that type name is deliberately lowercased in the syntax.</source>
          <target state="new">In cases where it's rare or impossible for the type shown as the defining element to be in a real-world usage, that type name is deliberately lowercased in the syntax.</target>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>For example, the syntax you see for <bpt id="p1">**</bpt>UIElement.Visibility<ept id="p1">**</ept> is :</source>
          <target state="new">For example, the syntax you see for <bpt id="p1">**</bpt>UIElement.Visibility<ept id="p1">**</ept> is :</target>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>Many XAML syntax sections include placeholders in the "Usage" that are then defined in a <bpt id="p1">**</bpt>XAML Values<ept id="p1">**</ept> section that's directly under the <bpt id="p2">**</bpt>Syntax<ept id="p2">**</ept> section.</source>
          <target state="new">Many XAML syntax sections include placeholders in the "Usage" that are then defined in a <bpt id="p1">**</bpt>XAML Values<ept id="p1">**</ept> section that's directly under the <bpt id="p2">**</bpt>Syntax<ept id="p2">**</ept> section.</target>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>XAML usage sections also use various generalized placeholders.</source>
          <target state="new">XAML usage sections also use various generalized placeholders.</target>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>These placeholders aren't redefined every time in <bpt id="p1">**</bpt>XAML Values<ept id="p1">**</ept>, because you'll guess or eventually learn what they represent.</source>
          <target state="new">These placeholders aren't redefined every time in <bpt id="p1">**</bpt>XAML Values<ept id="p1">**</ept>, because you'll guess or eventually learn what they represent.</target>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source>We think most readers would get tired of seeing them in <bpt id="p1">**</bpt>XAML Values<ept id="p1">**</ept> again and again so we left them out of the definitions.</source>
          <target state="new">We think most readers would get tired of seeing them in <bpt id="p1">**</bpt>XAML Values<ept id="p1">**</ept> again and again so we left them out of the definitions.</target>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>For reference, here's a list of some of these placeholders and what they mean in a general sense:</source>
          <target state="new">For reference, here's a list of some of these placeholders and what they mean in a general sense:</target>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>object<ept id="p1">*</ept>: theoretically any object value, but often practically limited to certain types of objects such as a string-or-object choice, and you should check the Remarks on the reference page for more info.</source>
          <target state="new"><bpt id="p1">*</bpt>object<ept id="p1">*</ept>: theoretically any object value, but often practically limited to certain types of objects such as a string-or-object choice, and you should check the Remarks on the reference page for more info.</target>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>object<ept id="p1">*</ept> <bpt id="p2">*</bpt>property<ept id="p2">*</ept>: <bpt id="p3">*</bpt>object<ept id="p3">*</ept> <bpt id="p4">*</bpt>property<ept id="p4">*</ept> in combination is used for cases where the syntax being shown is the syntax for a type that can be used as an attribute value for many properties.</source>
          <target state="new"><bpt id="p1">*</bpt>object<ept id="p1">*</ept> <bpt id="p2">*</bpt>property<ept id="p2">*</ept>: <bpt id="p3">*</bpt>object<ept id="p3">*</ept> <bpt id="p4">*</bpt>property<ept id="p4">*</ept> in combination is used for cases where the syntax being shown is the syntax for a type that can be used as an attribute value for many properties.</target>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve">
          <source>For example, the <bpt id="p1">**</bpt>Xaml Attribute Usage<ept id="p1">**</ept> shown for <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Brush<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br228076)</ept> includes: &lt;<bpt id="p4">*</bpt>object<ept id="p4">*</ept> <bpt id="p5">*</bpt>property<ept id="p5">*</ept>="<bpt id="p6">*</bpt>predefinedColorName<ept id="p6">*</ept>"/&gt;</source>
          <target state="new">For example, the <bpt id="p1">**</bpt>Xaml Attribute Usage<ept id="p1">**</ept> shown for <bpt id="p2">[</bpt><bpt id="p3">**</bpt>Brush<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br228076)</ept> includes: &lt;<bpt id="p4">*</bpt>object<ept id="p4">*</ept> <bpt id="p5">*</bpt>property<ept id="p5">*</ept>="<bpt id="p6">*</bpt>predefinedColorName<ept id="p6">*</ept>"/&gt;</target>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>eventhandler<ept id="p1">*</ept>: This appears as the attribute value for every XAML syntax shown for an event attribute.</source>
          <target state="new"><bpt id="p1">*</bpt>eventhandler<ept id="p1">*</ept>: This appears as the attribute value for every XAML syntax shown for an event attribute.</target>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>What you're supplying here is the function name for an event handler function.</source>
          <target state="new">What you're supplying here is the function name for an event handler function.</target>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>That function must be defined in the code-behind for the XAML page.</source>
          <target state="new">That function must be defined in the code-behind for the XAML page.</target>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>At the programming level, that function must match the delegate signature of the event that you're handling, or your app code won't compile.</source>
          <target state="new">At the programming level, that function must match the delegate signature of the event that you're handling, or your app code won't compile.</target>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve">
          <source>But that's really a programming consideration, not a XAML consideration, so we don't try to hint anything about the delegate type in the XAML syntax.</source>
          <target state="new">But that's really a programming consideration, not a XAML consideration, so we don't try to hint anything about the delegate type in the XAML syntax.</target>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve">
          <source>If you want to know which delegate you should be implementing for an event, that's in the <bpt id="p1">**</bpt>Event information<ept id="p1">**</ept> section of the reference topic for the event, in a table row that's labeled <bpt id="p2">**</bpt>Delegate<ept id="p2">**</ept>.</source>
          <target state="new">If you want to know which delegate you should be implementing for an event, that's in the <bpt id="p1">**</bpt>Event information<ept id="p1">**</ept> section of the reference topic for the event, in a table row that's labeled <bpt id="p2">**</bpt>Delegate<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>enumMemberName<ept id="p1">*</ept>: shown in attribute syntax for all enumerations.</source>
          <target state="new"><bpt id="p1">*</bpt>enumMemberName<ept id="p1">*</ept>: shown in attribute syntax for all enumerations.</target>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve">
          <source>There's a similar placeholder for properties that use an enumeration value, but it usually prefixes the placeholder with a hint of the enumeration's name.</source>
          <target state="new">There's a similar placeholder for properties that use an enumeration value, but it usually prefixes the placeholder with a hint of the enumeration's name.</target>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve">
          <source>For example, the syntax shown for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FrameworkElement.FlowDirection<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208716)</ept> is &lt;<bpt id="p3">*</bpt>frameworkElement<ept id="p3">*</ept><bpt id="p4">**</bpt>FlowDirection<ept id="p4">**</ept>="<bpt id="p5">*</bpt>flowDirectionMemberName<ept id="p5">*</ept>"/&gt;.</source>
          <target state="new">For example, the syntax shown for <bpt id="p1">[</bpt><bpt id="p2">**</bpt>FrameworkElement.FlowDirection<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208716)</ept> is &lt;<bpt id="p3">*</bpt>frameworkElement<ept id="p3">*</ept><bpt id="p4">**</bpt>FlowDirection<ept id="p4">**</ept>="<bpt id="p5">*</bpt>flowDirectionMemberName<ept id="p5">*</ept>"/&gt;.</target>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>If you're on one of those property reference pages, click the link to the enumeration type that appears in the <bpt id="p1">**</bpt>Property Value<ept id="p1">**</ept> section, next to the text <bpt id="p2">**</bpt>Type:<ept id="p2">**</ept>.</source>
          <target state="new">If you're on one of those property reference pages, click the link to the enumeration type that appears in the <bpt id="p1">**</bpt>Property Value<ept id="p1">**</ept> section, next to the text <bpt id="p2">**</bpt>Type:<ept id="p2">**</ept>.</target>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>For the attribute value of a property that uses that enumeration, you can use any string that is listed in the <bpt id="p1">**</bpt>Member<ept id="p1">**</ept> column of the <bpt id="p2">**</bpt>Members<ept id="p2">**</ept> list.</source>
          <target state="new">For the attribute value of a property that uses that enumeration, you can use any string that is listed in the <bpt id="p1">**</bpt>Member<ept id="p1">**</ept> column of the <bpt id="p2">**</bpt>Members<ept id="p2">**</ept> list.</target>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source><bpt id="p1">*</bpt>double<ept id="p1">*</ept>, <bpt id="p2">*</bpt>int<ept id="p2">*</ept>, <bpt id="p3">*</bpt>string<ept id="p3">*</ept>, <bpt id="p4">*</bpt>bool<ept id="p4">*</ept>: These are primitive types known to the XAML language.</source>
          <target state="new"><bpt id="p1">*</bpt>double<ept id="p1">*</ept>, <bpt id="p2">*</bpt>int<ept id="p2">*</ept>, <bpt id="p3">*</bpt>string<ept id="p3">*</ept>, <bpt id="p4">*</bpt>bool<ept id="p4">*</ept>: These are primitive types known to the XAML language.</target>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source>If you're programming using C# or Visual Basic, these types are projected to Microsoft .NET equivalent types such as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Double<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/system.double.aspx)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Int32<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/xaml/system.int32.aspx)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>String<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/xaml/system.string.aspx)</ept> and <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Boolean<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/xaml/system.boolean.aspx)</ept>, and you can use any members on those .NET types when you work with your XAML-defined values in .NET code-behind.</source>
          <target state="new">If you're programming using C# or Visual Basic, these types are projected to Microsoft .NET equivalent types such as <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Double<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/system.double.aspx)</ept>, <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Int32<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/xaml/system.int32.aspx)</ept>, <bpt id="p5">[</bpt><bpt id="p6">**</bpt>String<ept id="p6">**</ept><ept id="p5">](https://msdn.microsoft.com/library/windows/apps/xaml/system.string.aspx)</ept> and <bpt id="p7">[</bpt><bpt id="p8">**</bpt>Boolean<ept id="p8">**</ept><ept id="p7">](https://msdn.microsoft.com/library/windows/apps/xaml/system.boolean.aspx)</ept>, and you can use any members on those .NET types when you work with your XAML-defined values in .NET code-behind.</target>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source>If you're programming using C++/CX, you'll use the C++ primitive types but you can also consider these equivalent to types defined by the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Platform<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710417.aspx)</ept> namespace, for example <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Platform::String<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx)</ept>.</source>
          <target state="new">If you're programming using C++/CX, you'll use the C++ primitive types but you can also consider these equivalent to types defined by the <bpt id="p1">[</bpt><bpt id="p2">**</bpt>Platform<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/xaml/hh710417.aspx)</ept> namespace, for example <bpt id="p3">[</bpt><bpt id="p4">**</bpt>Platform::String<ept id="p4">**</ept><ept id="p3">](https://msdn.microsoft.com/library/windows/apps/xaml/hh755812.aspx)</ept>.</target>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>There will sometimes be additional value restrictions for particular properties.</source>
          <target state="new">There will sometimes be additional value restrictions for particular properties.</target>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve">
          <source>But you'll usually see these noted in a <bpt id="p1">**</bpt>Property value<ept id="p1">**</ept> section or Remarks section and not in a XAML section, because any such restrictions apply both to code usages and XAML usages.</source>
          <target state="new">But you'll usually see these noted in a <bpt id="p1">**</bpt>Property value<ept id="p1">**</ept> section or Remarks section and not in a XAML section, because any such restrictions apply both to code usages and XAML usages.</target>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve">
          <source>Tips and tricks, notes on style</source>
          <target state="new">Tips and tricks, notes on style</target>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve">
          <source>Markup extensions in general are described in the main <bpt id="p1">[</bpt>XAML overview<ept id="p1">](xaml-overview.md)</ept>.</source>
          <target state="new">Markup extensions in general are described in the main <bpt id="p1">[</bpt>XAML overview<ept id="p1">](xaml-overview.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve">
          <source>But the markup extension that most impacts the guidance given in this topic is the <bpt id="p1">[</bpt>StaticResource<ept id="p1">](staticresource-markup-extension.md)</ept> markup extension (and related <bpt id="p2">[</bpt>ThemeResource<ept id="p2">](themeresource-markup-extension.md)</ept>).</source>
          <target state="new">But the markup extension that most impacts the guidance given in this topic is the <bpt id="p1">[</bpt>StaticResource<ept id="p1">](staticresource-markup-extension.md)</ept> markup extension (and related <bpt id="p2">[</bpt>ThemeResource<ept id="p2">](themeresource-markup-extension.md)</ept>).</target>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve">
          <source>The function of the StaticResource markup extension is to enable factoring your XAML into reusable resources that come from a XAML <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ResourceDictionary<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208794)</ept>.</source>
          <target state="new">The function of the StaticResource markup extension is to enable factoring your XAML into reusable resources that come from a XAML <bpt id="p1">[</bpt><bpt id="p2">**</bpt>ResourceDictionary<ept id="p2">**</ept><ept id="p1">](https://msdn.microsoft.com/library/windows/apps/br208794)</ept>.</target>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>You almost always define control templates and related styles in a <bpt id="p1">**</bpt>ResourceDictionary<ept id="p1">**</ept>.</source>
          <target state="new">You almost always define control templates and related styles in a <bpt id="p1">**</bpt>ResourceDictionary<ept id="p1">**</ept>.</target>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>You often define the smaller parts of a control template definition or app-specific style in a <bpt id="p1">**</bpt>ResourceDictionary<ept id="p1">**</ept> too, for example a <bpt id="p2">[</bpt><bpt id="p3">**</bpt>SolidColorBrush<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br242962)</ept> for a color that your app uses more than once for different parts of UI.</source>
          <target state="new">You often define the smaller parts of a control template definition or app-specific style in a <bpt id="p1">**</bpt>ResourceDictionary<ept id="p1">**</ept> too, for example a <bpt id="p2">[</bpt><bpt id="p3">**</bpt>SolidColorBrush<ept id="p3">**</ept><ept id="p2">](https://msdn.microsoft.com/library/windows/apps/br242962)</ept> for a color that your app uses more than once for different parts of UI.</target>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>By using a StaticResource, any property that would otherwise require a property element usage to set can now be set in attribute syntax.</source>
          <target state="new">By using a StaticResource, any property that would otherwise require a property element usage to set can now be set in attribute syntax.</target>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>But the benefits of factoring XAML for reuse go beyond just simplifying the page-level syntax.</source>
          <target state="new">But the benefits of factoring XAML for reuse go beyond just simplifying the page-level syntax.</target>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source>For more info, see <bpt id="p1">[</bpt>ResourceDictionary and XAML resource references<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/mt187273)</ept>.</source>
          <target state="new">For more info, see <bpt id="p1">[</bpt>ResourceDictionary and XAML resource references<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/mt187273)</ept>.</target>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source>You'll see several different conventions for how white space and line feeds are applied in XAML examples.</source>
          <target state="new">You'll see several different conventions for how white space and line feeds are applied in XAML examples.</target>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>In particular, there are different conventions for how to break up object elements that have a lot of different attributes set.</source>
          <target state="new">In particular, there are different conventions for how to break up object elements that have a lot of different attributes set.</target>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source>That's just a matter of style.</source>
          <target state="new">That's just a matter of style.</target>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>The Visual Studio XML editor applies some default style rules when you edit XAML, but you can change these in the settings.</source>
          <target state="new">The Visual Studio XML editor applies some default style rules when you edit XAML, but you can change these in the settings.</target>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source>There are a small number of cases where the white space in a XAML file is considered significant; for more info see <bpt id="p1">[</bpt>XAML and whitespace<ept id="p1">](xaml-and-whitespace.md)</ept>.</source>
          <target state="new">There are a small number of cases where the white space in a XAML file is considered significant; for more info see <bpt id="p1">[</bpt>XAML and whitespace<ept id="p1">](xaml-and-whitespace.md)</ept>.</target>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve">
          <source>XAML overview</source>
          <target state="new">XAML overview</target>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve">
          <source>XAML namespaces and namespace mapping</source>
          <target state="new">XAML namespaces and namespace mapping</target>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve">
          <source>ResourceDictionary and XAML resource references</source>
          <target state="new">ResourceDictionary and XAML resource references</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>