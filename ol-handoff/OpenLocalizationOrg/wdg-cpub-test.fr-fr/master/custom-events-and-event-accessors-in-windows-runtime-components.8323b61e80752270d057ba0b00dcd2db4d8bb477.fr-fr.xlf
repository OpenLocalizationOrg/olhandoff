<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="fr-fr">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-48076a9" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e0a63e9e79cf385ac1fedc3943db0d3791a360b5</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">wdg-cpub-test\ndolci2\winrt-components\custom-events-and-event-accessors-in-windows-runtime-components.md</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">
      </xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Custom events and event accessors in Windows Runtime Components</source>
          <target state="new">Custom events and event accessors in Windows Runtime Components</target>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>.NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.</source>
          <target state="new">.NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.</target>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Custom events and event accessors in Windows Runtime Components</source>
          <target state="new">Custom events and event accessors in Windows Runtime Components</target>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>\[ Updated for UWP apps on Windows 10.</source>
          <target state="new">\[ Updated for UWP apps on Windows 10.</target>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve">
          <source>For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</source>
          <target state="new">For Windows 8.x articles, see the <bpt id="p1">[</bpt>archive<ept id="p1">](http://go.microsoft.com/fwlink/p/?linkid=619132)</ept> \]</target>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve">
          <source>\[Some information relates to pre-released product which may be substantially modified before it's commercially released.</source>
          <target state="new">\[Some information relates to pre-released product which may be substantially modified before it's commercially released.</target>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Microsoft makes no warranties, express or implied, with respect to the information provided here.\]</source>
          <target state="new">Microsoft makes no warranties, express or implied, with respect to the information provided here.\]</target>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>.NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.</source>
          <target state="new">.NET Framework support for Windows Runtime Components makes it easy to declare events components by hiding the differences between the Universal Windows Platform (UWP) event pattern and the .NET Framework event pattern.</target>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>However, when you declare custom event accessors in a Windows Runtime Component, you must follow the pattern used in the UWP.</source>
          <target state="new">However, when you declare custom event accessors in a Windows Runtime Component, you must follow the pattern used in the UWP.</target>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Registering events</source>
          <target state="new">Registering events</target>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>When you register to handle an event in the UWP, the add accessor returns a token.</source>
          <target state="new">When you register to handle an event in the UWP, the add accessor returns a token.</target>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>To unregister, you pass this token to the remove accessor.</source>
          <target state="new">To unregister, you pass this token to the remove accessor.</target>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>This means that the add and remove accessors for UWP events have different signatures from the accessors you're used to.</source>
          <target state="new">This means that the add and remove accessors for UWP events have different signatures from the accessors you're used to.</target>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Fortunately, the Visual Basic and C# compilers simplify this process: When you declare an event with custom accessors in a Windows Runtime Component, the compilers automatically use the UWP pattern.</source>
          <target state="new">Fortunately, the Visual Basic and C# compilers simplify this process: When you declare an event with custom accessors in a Windows Runtime Component, the compilers automatically use the UWP pattern.</target>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>For example, you get a compiler error if your add accessor doesn't return a token.</source>
          <target state="new">For example, you get a compiler error if your add accessor doesn't return a token.</target>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>The .NET Framework provides two types to support the implementation:</source>
          <target state="new">The .NET Framework provides two types to support the implementation:</target>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EventRegistrationToken<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.eventregistrationtoken.aspx)</ept> structure represents the token.</source>
          <target state="new">The <bpt id="p1">[</bpt>EventRegistrationToken<ept id="p1">](https://msdn.microsoft.com/library/windows/apps/windows.foundation.eventregistrationtoken.aspx)</ept> structure represents the token.</target>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>EventRegistrationTokenTable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/hh138412.aspx)</ept> class creates tokens and maintains a mapping between tokens and event handlers.</source>
          <target state="new">The <bpt id="p1">[</bpt>EventRegistrationTokenTable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph><ept id="p1">](https://msdn.microsoft.com/library/hh138412.aspx)</ept> class creates tokens and maintains a mapping between tokens and event handlers.</target>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>The generic type argument is the event argument type.</source>
          <target state="new">The generic type argument is the event argument type.</target>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>You create an instance of this class for each event, the first time an event handler is registered for that event.</source>
          <target state="new">You create an instance of this class for each event, the first time an event handler is registered for that event.</target>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The following code for the NumberChanged event shows the basic pattern for UWP events.</source>
          <target state="new">The following code for the NumberChanged event shows the basic pattern for UWP events.</target>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>In this example, the constructor for the event argument object, NumberChangedEventArgs, takes a single integer parameter that represents the changed numeric value.</source>
          <target state="new">In this example, the constructor for the event argument object, NumberChangedEventArgs, takes a single integer parameter that represents the changed numeric value.</target>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  This is the same pattern the compilers use for ordinary events that you declare in a Windows Runtime Component.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  This is the same pattern the compilers use for ordinary events that you declare in a Windows Runtime Component.</target>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The static (Shared in Visual Basic) GetOrCreateEventRegistrationTokenTable method creates the event’s instance of the EventRegistrationTokenTable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> object lazily.</source>
          <target state="new">The static (Shared in Visual Basic) GetOrCreateEventRegistrationTokenTable method creates the event’s instance of the EventRegistrationTokenTable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> object lazily.</target>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>Pass the class-level field that will hold the token table instance to this method.</source>
          <target state="new">Pass the class-level field that will hold the token table instance to this method.</target>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>If the field is empty, the method creates the table, stores a reference to the table in the field, and returns a reference to the table.</source>
          <target state="new">If the field is empty, the method creates the table, stores a reference to the table in the field, and returns a reference to the table.</target>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>If the field already contains a token table reference, the method just returns that reference.</source>
          <target state="new">If the field already contains a token table reference, the method just returns that reference.</target>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>  To ensure thread safety, the field that holds the event’s instance of EventRegistrationTokenTable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> must be a class-level field.</source>
          <target state="new"><bpt id="p1">**</bpt>Important<ept id="p1">**</ept>  To ensure thread safety, the field that holds the event’s instance of EventRegistrationTokenTable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> must be a class-level field.</target>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve">
          <source>If it is a class-level field, the GetOrCreateEventRegistrationTokenTable method ensures that when multiple threads try to create the token table, all threads get the same instance of the table.</source>
          <target state="new">If it is a class-level field, the GetOrCreateEventRegistrationTokenTable method ensures that when multiple threads try to create the token table, all threads get the same instance of the table.</target>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve">
          <source>For a given event, all calls to the GetOrCreateEventRegistrationTokenTable method must use the same class-level field.</source>
          <target state="new">For a given event, all calls to the GetOrCreateEventRegistrationTokenTable method must use the same class-level field.</target>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve">
          <source>Calling the GetOrCreateEventRegistrationTokenTable method in the remove accessor and in the <bpt id="p1">[</bpt>RaiseEvent<ept id="p1">](https://msdn.microsoft.com/library/fwd3bwed.aspx)</ept> method (the OnRaiseEvent method in C#) ensures that no exceptions occur if these methods are called before any event handler delegates have been added.</source>
          <target state="new">Calling the GetOrCreateEventRegistrationTokenTable method in the remove accessor and in the <bpt id="p1">[</bpt>RaiseEvent<ept id="p1">](https://msdn.microsoft.com/library/fwd3bwed.aspx)</ept> method (the OnRaiseEvent method in C#) ensures that no exceptions occur if these methods are called before any event handler delegates have been added.</target>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve">
          <source>The other members of the EventRegistrationTokenTable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> class that are used in the UWP event pattern include the following:</source>
          <target state="new">The other members of the EventRegistrationTokenTable<ph id="ph1">&amp;lt;</ph>T<ph id="ph2">&amp;gt;</ph> class that are used in the UWP event pattern include the following:</target>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>AddEventHandler<ept id="p1">](https://msdn.microsoft.com/library/hh138458.aspx)</ept> method generates a token for the event handler delegate, stores the delegate in the table, adds it to the invocation list, and returns the token.</source>
          <target state="new">The <bpt id="p1">[</bpt>AddEventHandler<ept id="p1">](https://msdn.microsoft.com/library/hh138458.aspx)</ept> method generates a token for the event handler delegate, stores the delegate in the table, adds it to the invocation list, and returns the token.</target>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>RemoveEventHandler(EventRegistrationToken)<ept id="p1">](https://msdn.microsoft.com/library/hh138425.aspx)</ept> method overload removes the delegate from the table and from the invocation list.</source>
          <target state="new">The <bpt id="p1">[</bpt>RemoveEventHandler(EventRegistrationToken)<ept id="p1">](https://msdn.microsoft.com/library/hh138425.aspx)</ept> method overload removes the delegate from the table and from the invocation list.</target>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  The AddEventHandler and RemoveEventHandler(EventRegistrationToken) methods lock the table to help ensure thread safety.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  The AddEventHandler and RemoveEventHandler(EventRegistrationToken) methods lock the table to help ensure thread safety.</target>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">[</bpt>InvocationList<ept id="p1">](https://msdn.microsoft.com/library/hh138465.aspx)</ept> property returns a delegate that includes all the event handlers that are currently registered to handle the event.</source>
          <target state="new">The <bpt id="p1">[</bpt>InvocationList<ept id="p1">](https://msdn.microsoft.com/library/hh138465.aspx)</ept> property returns a delegate that includes all the event handlers that are currently registered to handle the event.</target>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve">
          <source>Use this delegate to raise the event, or use the methods of the Delegate class to invoke the handlers individually.</source>
          <target state="new">Use this delegate to raise the event, or use the methods of the Delegate class to invoke the handlers individually.</target>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  We recommend that you follow the pattern shown in the example provided earlier in this article, and copy the delegate to a temporary variable before invoking it.</source>
          <target state="new"><bpt id="p1">**</bpt>Note<ept id="p1">**</ept>  We recommend that you follow the pattern shown in the example provided earlier in this article, and copy the delegate to a temporary variable before invoking it.</target>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve">
          <source>This avoids a race condition in which one thread removes the last handler, reducing the delegate to null just before another thread tries to invoke the delegate.</source>
          <target state="new">This avoids a race condition in which one thread removes the last handler, reducing the delegate to null just before another thread tries to invoke the delegate.</target>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>Delegates are immutable, so the copy is still valid.</source>
          <target state="new">Delegates are immutable, so the copy is still valid.</target>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Place your own code in the accessors as appropriate.</source>
          <target state="new">Place your own code in the accessors as appropriate.</target>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve">
          <source>If thread safety is an issue, you must provide your own locking for your code.</source>
          <target state="new">If thread safety is an issue, you must provide your own locking for your code.</target>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve">
          <source>C# users: When you write custom event accessors in the UWP event pattern, the compiler doesn't provide the usual syntactic shortcuts.</source>
          <target state="new">C# users: When you write custom event accessors in the UWP event pattern, the compiler doesn't provide the usual syntactic shortcuts.</target>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve">
          <source>It generates errors if you use the name of the event in your code.</source>
          <target state="new">It generates errors if you use the name of the event in your code.</target>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve">
          <source>Visual Basic users: In the .NET Framework, an event is just a multicast delegate that represents all the registered event handlers.</source>
          <target state="new">Visual Basic users: In the .NET Framework, an event is just a multicast delegate that represents all the registered event handlers.</target>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>Raising the event just means invoking the delegate.</source>
          <target state="new">Raising the event just means invoking the delegate.</target>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Visual Basic syntax generally hides the interactions with the delegate, and the compiler copies the delegate before invoking it, as described in the note about thread safety.</source>
          <target state="new">Visual Basic syntax generally hides the interactions with the delegate, and the compiler copies the delegate before invoking it, as described in the note about thread safety.</target>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>When you create a custom event in a Windows Runtime Component, you have to deal with the delegate directly.</source>
          <target state="new">When you create a custom event in a Windows Runtime Component, you have to deal with the delegate directly.</target>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This also means that you can, for example, use the <bpt id="p1">[</bpt>MulticastDelegate.GetInvocationList<ept id="p1">](https://msdn.microsoft.com/library/system.multicastdelegate.getinvocationlist.aspx)</ept> method to get an array that contains a separate delegate for each event handler, if you want to invoke the handlers separately.</source>
          <target state="new">This also means that you can, for example, use the <bpt id="p1">[</bpt>MulticastDelegate.GetInvocationList<ept id="p1">](https://msdn.microsoft.com/library/system.multicastdelegate.getinvocationlist.aspx)</ept> method to get an array that contains a separate delegate for each event handler, if you want to invoke the handlers separately.</target>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Related topics</source>
          <target state="new">Related topics</target>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>Events (Visual Basic)</source>
          <target state="new">Events (Visual Basic)</target>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Events (C# Programming Guide)</source>
          <target state="new">Events (C# Programming Guide)</target>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>.NET for Windows Store Apps Overview</source>
          <target state="new">.NET for Windows Store Apps Overview</target>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>.NET for UWP apps</source>
          <target state="new">.NET for UWP apps</target>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</source>
          <target state="new">Walkthrough: Creating a Simple Windows Runtime Component and calling it from JavaScript</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>